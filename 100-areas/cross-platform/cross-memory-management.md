---
title: "Cross-Platform: Memory Management — ARC vs GC"
created: 2026-01-11
modified: 2026-01-11
type: comparison
status: published
tags:
  - type/comparison
  - topic/memory
  - topic/arc
  - topic/gc
  - topic/swift
  - topic/kotlin
---

# Управление памятью: ARC vs GC

## TL;DR: Сравнительная таблица

| Характеристика | iOS (ARC) | Android (GC) | KMP |
|---------------|-----------|--------------|-----|
| **Механизм** | Automatic Reference Counting | Garbage Collection (G1/CMS) | ARC на iOS, GC на Android |
| **Когда освобождение** | При достижении refCount = 0 | При срабатывании GC цикла | Зависит от таргета |
| **Детерминизм** | Высокий (deinit предсказуем) | Низкий (finalize непредсказуем) | Гибридный |
| **Главная проблема** | Retain Cycles | GC Pauses (Stop-the-World) | Смешанные retain cycles |
| **Решение проблемы** | weak/unowned references | Object pooling, избегание аллокаций | WeakReference expect/actual |
| **Overhead** | Атомарные операции на каждый retain/release | Периодическое сканирование heap | Комбинированный |
| **Ответственность разработчика** | Явное управление владением | Минимальная (но понимание нужно) | Понимание обеих моделей |
| **Инструменты отладки** | Instruments (Leaks, Allocations) | Android Profiler, LeakCanary | Platform-specific |
| **Finalization** | deinit (детерминистичный) | finalize (deprecated, непредсказуем) | Platform-specific |
| **Циклические ссылки** | Ручное разрешение (weak) | Автоматическое обнаружение | Требует внимания на обоих |

---

## Почему платформы выбрали разные подходы?

### iOS: Наследие NeXT (1988)

Apple унаследовала модель памяти от NeXT Computer, компании Стива Джобса.
В 1988 году NeXTSTEP использовала Objective-C с ручным управлением памятью
через retain/release. Это было осознанным выбором:

```
┌─────────────────────────────────────────────────────────────────┐
│                    Эволюция ARC в iOS                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1988: NeXTSTEP                                                 │
│    └── Manual Retain/Release (MRR)                              │
│         └── Разработчик вручную вызывает retain/release        │
│                                                                 │
│  2001: Mac OS X                                                 │
│    └── MRR + autorelease pools                                  │
│         └── Добавлены автоматические пулы                       │
│                                                                 │
│  2011: iOS 5, Xcode 4.2                                         │
│    └── ARC (Automatic Reference Counting)                       │
│         └── Компилятор вставляет retain/release                 │
│                                                                 │
│  2014: Swift                                                    │
│    └── ARC by default                                           │
│         └── Нет выбора - только ARC                             │
│                                                                 │
│  2024+: Swift 6                                                 │
│    └── Strict Concurrency + ARC                                 │
│         └── Sendable, actors, isolation                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Причины выбора детерминистичной модели:**

1. **Ограниченные ресурсы устройств**: Первые iPhone имели 128MB RAM.
   Непредсказуемые паузы GC были неприемлемы для плавной анимации 60fps.

2. **Real-time требования**: Музыкальные и медиа-приложения требуют
   предсказуемой латентности. GC pause = пропуск аудио-фрейма.

3. **Батарея**: ARC работает инкрементально и не требует периодического
   сканирования всей памяти, что экономит батарею.

4. **Контроль**: Apple всегда предпочитала давать разработчикам больше
   контроля в обмен на ответственность.

### Android: Наследие Java

Android выбрал Java (позже Kotlin) и унаследовал философию JVM:

```
┌─────────────────────────────────────────────────────────────────┐
│                  Эволюция GC в Android                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  2008: Android 1.0                                              │
│    └── Dalvik VM + Mark-and-Sweep GC                            │
│         └── Stop-the-World паузы до 100ms                       │
│                                                                 │
│  2014: Android 5.0 (Lollipop)                                   │
│    └── ART (Android Runtime)                                    │
│         └── Ahead-of-Time compilation                           │
│         └── Concurrent GC, паузы ~5ms                           │
│                                                                 │
│  2017: Android 8.0 (Oreo)                                       │
│    └── Concurrent Copying GC                                    │
│         └── Параллельное копирование                            │
│         └── Compact heap без длинных пауз                       │
│                                                                 │
│  2020+: Modern ART                                              │
│    └── Generational GC                                          │
│         └── Young/Old generations                               │
│         └── Субмиллисекундные паузы                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Причины выбора GC:**

1. **Throughput оптимизация**: GC оптимизирован для максимальной
   пропускной способности, а не минимальной латентности.

2. **Автоматическое управление циклами**: GC автоматически обнаруживает
   и собирает циклические ссылки - это огромное упрощение для разработчика.

3. **Java экосистема**: Миллионы Java-библиотек работают без модификации.

4. **Простота входа**: Разработчику не нужно думать о владении объектами.

5. **Серверное наследие**: Java создавалась для серверов, где throughput
   важнее latency.

---

## Интуиция: 5 аналогий для понимания

### Аналогия 1: Библиотекарь с формулярами (ARC)

```
┌─────────────────────────────────────────────────────────────────┐
│                    ARC = Библиотекарь                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Книга = Объект в памяти                                        │
│  Формуляр = Reference Count                                     │
│  Читатель = Ссылка на объект                                    │
│                                                                 │
│  ┌──────────┐     ┌──────────────────────────────────┐          │
│  │  Книга   │     │         Формуляр книги           │          │
│  │ "Swift"  │────▶│  Читатель 1: Иван    (retain)    │          │
│  │          │     │  Читатель 2: Мария   (retain)    │          │
│  │          │     │  Читатель 3: Петр    (retain)    │          │
│  │          │     │  ─────────────────────────────   │          │
│  │          │     │  Всего читателей: 3              │          │
│  └──────────┘     └──────────────────────────────────┘          │
│                                                                 │
│  Когда Иван возвращает книгу (release): count = 2               │
│  Когда Мария возвращает (release): count = 1                    │
│  Когда Петр возвращает (release): count = 0                     │
│                                                                 │
│  count = 0 → Книга немедленно отправляется на полку (deinit)    │
│                                                                 │
│  ПРОБЛЕМА: Если Иван записал, что книга у Марии,                │
│            а Мария записала, что книга у Ивана,                 │
│            книга никогда не вернется! (retain cycle)            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Аналогия 2: Горничная в отеле (GC)

```
┌─────────────────────────────────────────────────────────────────┐
│                      GC = Горничная                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Номер = Объект в памяти                                        │
│  Гость = Активная ссылка                                        │
│  Горничная = Garbage Collector                                  │
│                                                                 │
│  Горничная НЕ следит за каждым выходом гостя.                   │
│  Вместо этого она периодически обходит отель:                   │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  Этаж 1 (Young Generation)                              │    │
│  │  ┌───┐ ┌───┐ ┌───┐ ┌───┐ ┌───┐ ┌───┐ ┌───┐ ┌───┐       │    │
│  │  │ G │ │   │ │ G │ │   │ │   │ │ G │ │   │ │   │       │    │
│  │  └───┘ └───┘ └───┘ └───┘ └───┘ └───┘ └───┘ └───┘       │    │
│  │    ↑           ↑                   ↑                    │    │
│  │  гость     гость               гость                    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  Фаза 1 (Mark): Горничная отмечает занятые номера               │
│  Фаза 2 (Sweep): Убирает пустые номера                          │
│                                                                 │
│  ПРОБЛЕМА: Во время уборки гости должны ждать!                  │
│            (Stop-the-World pause)                               │
│                                                                 │
│  ПРЕИМУЩЕСТВО: Даже если два гостя записали друг друга          │
│                как соседей по номеру, горничная это              │
│                обнаружит и уберет оба номера (нет cycle leak)   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Аналогия 3: Бухгалтерия (ARC)

```
┌─────────────────────────────────────────────────────────────────┐
│               ARC = Бухгалтерия реального времени               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Каждая транзакция записывается немедленно:                     │
│                                                                 │
│  09:00:01 - Создан объект A          | Баланс A: 1              │
│  09:00:02 - Ссылка на A из B         | Баланс A: 2              │
│  09:00:03 - Ссылка на A из C         | Баланс A: 3              │
│  09:00:04 - B удалил ссылку          | Баланс A: 2              │
│  09:00:05 - C удалил ссылку          | Баланс A: 1              │
│  09:00:06 - Создатель удалил ссылку  | Баланс A: 0 → ЛИКВИДАЦИЯ │
│                                                                 │
│  + Мгновенное знание состояния                                  │
│  + Предсказуемое время ликвидации                               │
│  - Накладные расходы на каждую операцию                         │
│  - Ручное разрешение взаимных долгов (cycles)                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Аналогия 4: Инвентаризация (GC)

```
┌─────────────────────────────────────────────────────────────────┐
│                   GC = Периодическая инвентаризация             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Склад не ведет учет каждой единицы в реальном времени.         │
│  Вместо этого проводит периодическую инвентаризацию:            │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  Обычная работа (между инвентаризациями):               │    │
│  │                                                         │    │
│  │  - Товары поступают и выбывают свободно                 │    │
│  │  - Никто не считает каждую единицу                      │    │
│  │  - Максимальная пропускная способность                  │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                           │                                     │
│                           ▼                                     │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  Инвентаризация (GC Cycle):                             │    │
│  │                                                         │    │
│  │  1. СТОП РАБОТЫ (Stop-the-World)                        │    │
│  │  2. Пометить все используемые товары                    │    │
│  │  3. Выбросить непомеченные                              │    │
│  │  4. ПРОДОЛЖИТЬ РАБОТУ                                   │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  + Высокая пропускная способность                               │
│  + Автоматическое обнаружение "мертвых" циклов                  │
│  - Непредсказуемые паузы                                        │
│  - Память освобождается с задержкой                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Аналогия 5: Явное владение vs Автоматическая уборка

```
┌─────────────────────────────────────────────────────────────────┐
│     ARC: Явное владение              GC: Автоматическая уборка  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────┐       ┌─────────────────────┐          │
│  │   Аренда машины     │       │   Каршеринг         │          │
│  ├─────────────────────┤       ├─────────────────────┤          │
│  │                     │       │                     │          │
│  │ • Договор аренды    │       │ • Просто берешь     │          │
│  │   (retain)          │       │   машину            │          │
│  │                     │       │                     │          │
│  │ • Возврат по        │       │ • Оставляешь где    │          │
│  │   договору (release)│       │   угодно            │          │
│  │                     │       │                     │          │
│  │ • Машина сразу      │       │ • Машину заберут    │          │
│  │   доступна другим   │       │   когда-нибудь      │          │
│  │                     │       │                     │          │
│  │ • Если не вернул -  │       │ • Машина в лимбо    │          │
│  │   машина "потеряна" │       │   до сбора          │          │
│  │   (memory leak)     │       │                     │          │
│  │                     │       │                     │          │
│  └─────────────────────┘       └─────────────────────┘          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Как это работает: технические детали

### iOS (ARC) — Automatic Reference Counting

#### Базовый механизм

```swift
// Swift: ARC в действии

class Person {
    let name: String

    init(name: String) {
        self.name = name
        print("✓ \(name) создан")
    }

    deinit {
        print("✗ \(name) освобожден")
    }
}

func demonstrateARC() {
    print("--- Начало функции ---")

    var person1: Person? = Person(name: "Иван")  // refCount = 1
    // Вывод: ✓ Иван создан

    var person2 = person1  // refCount = 2
    var person3 = person1  // refCount = 3

    print("Сейчас refCount = 3")

    person1 = nil  // refCount = 2
    print("После person1 = nil, refCount = 2")

    person2 = nil  // refCount = 1
    print("После person2 = nil, refCount = 1")

    person3 = nil  // refCount = 0 → deinit вызывается НЕМЕДЛЕННО
    // Вывод: ✗ Иван освобожден

    print("--- Конец функции ---")
}

// Вызов:
demonstrateARC()

// Полный вывод:
// --- Начало функции ---
// ✓ Иван создан
// Сейчас refCount = 3
// После person1 = nil, refCount = 2
// После person2 = nil, refCount = 1
// ✗ Иван освобожден
// --- Конец функции ---
```

#### ASCII-диаграмма: вставка retain/release компилятором

```
┌─────────────────────────────────────────────────────────────────┐
│           Компиляция Swift кода с ARC                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Исходный код                  Скомпилированный код             │
│  (Swift)                       (SIL/LLVM IR)                    │
│                                                                 │
│  ┌─────────────────────┐       ┌─────────────────────────────┐  │
│  │                     │       │                             │  │
│  │ func example() {    │       │ func example() {            │  │
│  │   let a = MyClass() │ ───▶  │   let a = MyClass()         │  │
│  │                     │       │   swift_retain(a)  // +1    │  │
│  │                     │       │                             │  │
│  │   let b = a         │ ───▶  │   let b = a                 │  │
│  │                     │       │   swift_retain(a)  // +1    │  │
│  │                     │       │                             │  │
│  │   useObject(b)      │       │   useObject(b)              │  │
│  │                     │       │                             │  │
│  │ } // scope ends     │ ───▶  │   swift_release(b) // -1    │  │
│  │                     │       │   swift_release(a) // -1    │  │
│  │                     │       │   // refCount=0 → deinit    │  │
│  │                     │       │ }                           │  │
│  └─────────────────────┘       └─────────────────────────────┘  │
│                                                                 │
│  Компилятор анализирует lifetime и вставляет:                   │
│  • swift_retain() при копировании ссылки                        │
│  • swift_release() при выходе ссылки из scope                   │
│  • Оптимизации (elision) когда retain/release не нужны          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Детерминизм deinit

```swift
// Важное свойство ARC: deinit вызывается детерминистично

class FileHandler {
    let filename: String
    private var handle: FileHandle?

    init(filename: String) {
        self.filename = filename
        self.handle = FileHandle(forWritingAtPath: filename)
        print("Файл \(filename) открыт")
    }

    deinit {
        // Гарантированно вызовется при refCount = 0
        // Можно безопасно закрывать ресурсы
        handle?.closeFile()
        print("Файл \(filename) закрыт")
    }

    func write(_ data: Data) {
        handle?.write(data)
    }
}

func processFile() {
    let handler = FileHandler(filename: "/tmp/data.txt")
    handler.write("Hello".data(using: .utf8)!)
    // После выхода из функции handler СРАЗУ освобождается
    // deinit вызовется НЕМЕДЛЕННО, файл закроется
}

processFile()
print("Функция завершена, файл уже закрыт")

// Вывод:
// Файл /tmp/data.txt открыт
// Файл /tmp/data.txt закрыт
// Функция завершена, файл уже закрыт
```

### Android (GC) — Garbage Collection

#### Базовый механизм

```kotlin
// Kotlin: GC в действии

class Person(val name: String) {
    init {
        println("✓ $name создан")
    }

    // ВНИМАНИЕ: finalize() deprecated с Java 9!
    // Показан только для демонстрации недетерминизма
    @Deprecated("Use try-with-resources or explicit cleanup")
    protected fun finalize() {
        println("✗ $name финализирован (когда-нибудь...)")
    }
}

fun demonstrateGC() {
    println("--- Начало функции ---")

    var person1: Person? = Person("Иван")
    var person2 = person1
    var person3 = person1

    println("Созданы 3 ссылки на один объект")

    person1 = null
    person2 = null
    person3 = null

    println("Все ссылки обнулены")
    println("Но объект ЕЩЕ НЕ освобожден!")
    println("Он будет собран при следующем GC цикле")

    // Даже явный вызов НЕ гарантирует немедленную сборку
    System.gc()  // Это лишь ПОДСКАЗКА для GC

    println("--- Конец функции ---")
}

// Вызов:
demonstrateGC()

// Возможный вывод (порядок finalize непредсказуем!):
// --- Начало функции ---
// ✓ Иван создан
// Созданы 3 ссылки на один объект
// Все ссылки обнулены
// Но объект ЕЩЕ НЕ освобожден!
// Он будет собран при следующем GC цикле
// --- Конец функции ---
// (... где-то позже, может быть ...)
// ✗ Иван финализирован (когда-нибудь...)
// (... или вообще не вызовется, если приложение завершится раньше)
```

#### ASCII-диаграмма: фазы Mark & Sweep

```
┌─────────────────────────────────────────────────────────────────┐
│                    GC Mark & Sweep Cycle                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ФАЗА 1: MARK (Пометка)                                         │
│  ────────────────────                                           │
│                                                                 │
│  GC Roots (стартовые точки):                                    │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ • Stack variables (локальные переменные)                │    │
│  │ • Static fields (статические поля)                      │    │
│  │ • JNI references (нативные ссылки)                      │    │
│  │ • Thread objects (объекты потоков)                      │    │
│  └─────────────────────────────────────────────────────────┘    │
│                           │                                     │
│                           ▼                                     │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                        HEAP                               │  │
│  │                                                           │  │
│  │    [A]───────▶[B]───────▶[C]      Достижимы от root       │  │
│  │     │          │          │       → Помечены как LIVE     │  │
│  │     │          │          ▼                               │  │
│  │     │          └────────▶[D]                              │  │
│  │     │                                                     │  │
│  │     ▼                                                     │  │
│  │    [E]◀──────────────────[F]      Циклическая ссылка,     │  │
│  │     │                     ▲       но достижимы от A       │  │
│  │     └─────────────────────┘       → Помечены как LIVE     │  │
│  │                                                           │  │
│  │    [G]───────▶[H]                 Недостижимы от root     │  │
│  │     ▲          │                  → НЕ помечены           │  │
│  │     └──────────┘                  → Будут собраны         │  │
│  │                                                           │  │
│  │    [I]        [J]                 Изолированные объекты   │  │
│  │                                   → Будут собраны         │  │
│  │                                                           │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ФАЗА 2: SWEEP (Очистка)                                        │
│  ───────────────────────                                        │
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                        HEAP                               │  │
│  │                                                           │  │
│  │    [A]───────▶[B]───────▶[C]      ЖИВЫЕ объекты остаются  │  │
│  │     │          │          │                               │  │
│  │     │          │          ▼                               │  │
│  │     │          └────────▶[D]                              │  │
│  │     │                                                     │  │
│  │     ▼                                                     │  │
│  │    [E]◀──────────────────[F]                              │  │
│  │     │                     ▲                               │  │
│  │     └─────────────────────┘                               │  │
│  │                                                           │  │
│  │    [░░░░░░░░░░░░░░░░░░░░]         G, H освобождены        │  │
│  │                                                           │  │
│  │    [░░░]      [░░░]               I, J освобождены        │  │
│  │                                                           │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
│  Ключевое отличие от ARC:                                       │
│  Цикл E↔F будет собран когда A станет недостижимым!            │
│  ARC бы оставил этот цикл в памяти навсегда.                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Недетерминизм finalize

```kotlin
// ВАЖНО: Никогда не полагайтесь на finalize() для освобождения ресурсов!

class DatabaseConnection(val name: String) : AutoCloseable {
    private var isClosed = false

    init {
        println("[$name] Соединение открыто")
    }

    // НЕПРАВИЛЬНО: полагаться на finalize
    @Deprecated("Don't use finalize for resource cleanup!")
    protected fun finalize() {
        if (!isClosed) {
            println("[$name] ПРЕДУПРЕЖДЕНИЕ: Соединение не было закрыто!")
            // Попытка закрыть в finalize - плохая практика:
            // 1. Может не вызваться вообще
            // 2. Порядок вызова непредсказуем
            // 3. Может вызваться в любом потоке
        }
    }

    // ПРАВИЛЬНО: явный метод закрытия
    override fun close() {
        if (!isClosed) {
            isClosed = true
            println("[$name] Соединение закрыто")
        }
    }
}

// ПРАВИЛЬНОЕ использование:
fun correctUsage() {
    DatabaseConnection("db1").use { conn ->
        // Работа с соединением
        // close() вызовется автоматически при выходе из блока
    }
    // Соединение гарантированно закрыто здесь
}

// НЕПРАВИЛЬНОЕ использование:
fun incorrectUsage() {
    val conn = DatabaseConnection("db2")
    // Работа с соединением
    // Забыли вызвать close()
    // finalize() МОЖЕТ вызваться... когда-нибудь... или никогда
}
```

---

## Главная проблема каждой модели

### iOS: Retain Cycles (Циклы сильных ссылок)

```
┌─────────────────────────────────────────────────────────────────┐
│                    Проблема: Retain Cycle                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Сценарий: Два объекта ссылаются друг на друга                  │
│                                                                 │
│         ┌───────────┐        strong        ┌───────────┐        │
│         │  Person   │◀─────────────────────│ Apartment │        │
│         │           │                      │           │        │
│         │ refCount  │        strong        │ refCount  │        │
│         │    = 2    │─────────────────────▶│    = 2    │        │
│         └───────────┘                      └───────────┘        │
│              ▲                                   ▲              │
│              │                                   │              │
│         strong (1)                          strong (1)          │
│              │                                   │              │
│         [внешняя                           [внешняя             │
│          ссылка]                            ссылка]             │
│                                                                 │
│  Когда внешние ссылки обнулятся:                                │
│                                                                 │
│         ┌───────────┐        strong        ┌───────────┐        │
│         │  Person   │◀─────────────────────│ Apartment │        │
│         │           │                      │           │        │
│         │ refCount  │        strong        │ refCount  │        │
│         │    = 1    │─────────────────────▶│    = 1    │        │
│         └───────────┘                      └───────────┘        │
│                                                                 │
│  refCount никогда не достигнет 0!                               │
│  Объекты останутся в памяти НАВСЕГДА = MEMORY LEAK              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Код примера проблемы:

```swift
// ПРОБЛЕМА: Retain Cycle

class Person {
    let name: String
    var apartment: Apartment?  // strong reference

    init(name: String) {
        self.name = name
        print("✓ Person \(name) создан")
    }

    deinit {
        print("✗ Person \(name) освобожден")
    }
}

class Apartment {
    let unit: String
    var tenant: Person?  // strong reference - ПРОБЛЕМА!

    init(unit: String) {
        self.unit = unit
        print("✓ Apartment \(unit) создана")
    }

    deinit {
        print("✗ Apartment \(unit) освобождена")
    }
}

func createRetainCycle() {
    var john: Person? = Person(name: "John")
    var unit4A: Apartment? = Apartment(unit: "4A")

    // Создаем retain cycle
    john?.apartment = unit4A  // john -> unit4A (strong)
    unit4A?.tenant = john     // unit4A -> john (strong)

    // Обнуляем внешние ссылки
    john = nil
    unit4A = nil

    print("Внешние ссылки обнулены, но deinit НЕ вызвался!")
}

createRetainCycle()
print("Функция завершена")

// Вывод:
// ✓ Person John создан
// ✓ Apartment 4A создана
// Внешние ссылки обнулены, но deinit НЕ вызвался!
// Функция завершена
//
// ЗАМЕТЬТЕ: deinit НИКОГДА не вызывается!
// Объекты утекли в память.
```

#### Решение: weak reference

```swift
// РЕШЕНИЕ: Используем weak

class Person {
    let name: String
    var apartment: Apartment?  // strong - OK, Person владеет Apartment

    init(name: String) {
        self.name = name
        print("✓ Person \(name) создан")
    }

    deinit {
        print("✗ Person \(name) освобожден")
    }
}

class Apartment {
    let unit: String
    weak var tenant: Person?  // weak - РЕШЕНИЕ! Apartment НЕ владеет Person

    init(unit: String) {
        self.unit = unit
        print("✓ Apartment \(unit) создана")
    }

    deinit {
        print("✗ Apartment \(unit) освобождена")
    }
}

func noRetainCycle() {
    var john: Person? = Person(name: "John")
    var unit4A: Apartment? = Apartment(unit: "4A")

    john?.apartment = unit4A  // john -> unit4A (strong)
    unit4A?.tenant = john     // unit4A -> john (WEAK)

    john = nil    // refCount Person = 0 → deinit
    unit4A = nil  // refCount Apartment = 0 → deinit
}

noRetainCycle()
print("Функция завершена")

// Вывод:
// ✓ Person John создан
// ✓ Apartment 4A создана
// ✗ Person John освобожден
// ✗ Apartment 4A освобождена
// Функция завершена
```

```
┌─────────────────────────────────────────────────────────────────┐
│                    Решение: weak reference                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│         ┌───────────┐        weak         ┌───────────┐         │
│         │  Person   │◀╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌│ Apartment │         │
│         │           │  (не увеличивает    │           │         │
│         │ refCount  │   refCount)         │ refCount  │         │
│         │    = 1    │────────────────────▶│    = 2    │         │
│         └───────────┘       strong        └───────────┘         │
│              ▲                                   ▲              │
│              │                                   │              │
│         strong (1)                          strong (1)          │
│                                                                 │
│  Когда внешняя ссылка на Person обнулится:                      │
│  - Person.refCount = 0 → deinit вызывается                      │
│  - Apartment.tenant автоматически становится nil                │
│  - Apartment.refCount = 1 (только внешняя ссылка)               │
│                                                                 │
│  Когда внешняя ссылка на Apartment обнулится:                   │
│  - Apartment.refCount = 0 → deinit вызывается                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Android: GC Pauses (Stop-the-World)

```
┌─────────────────────────────────────────────────────────────────┐
│                    Проблема: GC Pauses                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Timeline анимации при 60 FPS (16.67ms на кадр):                │
│                                                                 │
│  Frame 1   Frame 2   Frame 3   Frame 4   Frame 5   Frame 6     │
│  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐    │
│  │ OK   │  │ OK   │  │  GC  │  │PAUSE │  │ OK   │  │ OK   │    │
│  │16.5ms│  │16.2ms│  │ STOP │  │ CONT │  │16.8ms│  │16.1ms│    │
│  └──────┘  └──────┘  └──┬───┘  └───┬──┘  └──────┘  └──────┘    │
│                         │          │                            │
│                         └────┬─────┘                            │
│                              │                                  │
│                         GC Pause                                │
│                         ~25-50ms                                │
│                                                                 │
│  Результат:                                                     │
│  - Frame 3 и 4 пропущены (jank)                                 │
│  - Пользователь видит "заикание" анимации                       │
│  - RecyclerView дергается при скролле                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Код примера проблемы:

```kotlin
// ПРОБЛЕМА: Excessive allocations в горячем пути

class GameRenderer {

    // ПЛОХО: Создание объектов в каждом кадре
    fun renderFrame(entities: List<Entity>) {
        for (entity in entities) {
            // Каждый кадр создаем новые объекты
            val position = Vector3(entity.x, entity.y, entity.z)  // allocation!
            val rotation = Quaternion(entity.rx, entity.ry, entity.rz, entity.rw)  // allocation!
            val matrix = Matrix4x4()  // allocation!

            matrix.setTranslation(position)
            matrix.setRotation(rotation)

            drawEntity(entity, matrix)
        }
        // После каждого кадра тысячи объектов становятся мусором
        // GC вынужден часто запускаться → паузы
    }

    // 60 FPS × 100 entities × 3 objects = 18000 allocations/sec
    // GC будет запускаться очень часто!
}
```

#### Решение: Object Pooling

```kotlin
// РЕШЕНИЕ: Object Pooling - переиспользование объектов

class Vector3Pool(private val capacity: Int = 100) {
    private val pool = ArrayDeque<Vector3>(capacity)

    fun obtain(): Vector3 {
        return pool.pollFirst() ?: Vector3()
    }

    fun free(vector: Vector3) {
        if (pool.size < capacity) {
            vector.reset()
            pool.addLast(vector)
        }
    }
}

class Matrix4x4Pool(private val capacity: Int = 100) {
    private val pool = ArrayDeque<Matrix4x4>(capacity)

    fun obtain(): Matrix4x4 {
        return pool.pollFirst() ?: Matrix4x4()
    }

    fun free(matrix: Matrix4x4) {
        if (pool.size < capacity) {
            matrix.reset()
            pool.addLast(matrix)
        }
    }
}

class OptimizedGameRenderer {
    private val vectorPool = Vector3Pool()
    private val matrixPool = Matrix4x4Pool()

    // ХОРОШО: Переиспользование объектов
    fun renderFrame(entities: List<Entity>) {
        for (entity in entities) {
            // Берем из пула вместо создания
            val position = vectorPool.obtain()
            val matrix = matrixPool.obtain()

            position.set(entity.x, entity.y, entity.z)
            matrix.setTranslation(position)

            drawEntity(entity, matrix)

            // Возвращаем в пул для переиспользования
            vectorPool.free(position)
            matrixPool.free(matrix)
        }
        // Никаких новых allocations → GC не нужен → нет пауз
    }
}
```

```kotlin
// Альтернатива: Примитивные типы вместо объектов

class UltraOptimizedRenderer {
    // Используем примитивные массивы вместо объектов
    private val positionBuffer = FloatArray(300)  // 100 entities × 3 components
    private val matrixBuffer = FloatArray(1600)   // 100 entities × 16 components

    fun renderFrame(entities: List<Entity>) {
        // Работаем напрямую с примитивами - zero allocation
        entities.forEachIndexed { index, entity ->
            val posOffset = index * 3
            positionBuffer[posOffset] = entity.x
            positionBuffer[posOffset + 1] = entity.y
            positionBuffer[posOffset + 2] = entity.z

            // Матрица inline
            val matOffset = index * 16
            computeMatrixInline(matrixBuffer, matOffset, positionBuffer, posOffset)
        }

        drawBatch(positionBuffer, matrixBuffer, entities.size)
    }
}
```

---

## KMP: Bridging Two Worlds

Kotlin Multiplatform (KMP) работает на обеих платформах и должен учитывать
особенности обоих подходов к управлению памятью.

### Смешанные Retain Cycles

```
┌─────────────────────────────────────────────────────────────────┐
│                 KMP: Смешанный Retain Cycle                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    iOS Target (ARC)                     │    │
│  │                                                         │    │
│  │    ┌──────────────┐                                     │    │
│  │    │ Swift Class  │                                     │    │
│  │    │  ViewController │───────┐                          │    │
│  │    └──────────────┘         │                           │    │
│  │           │                 │ strong                    │    │
│  │           │ strong          │ (сохраняет closure)       │    │
│  │           ▼                 │                           │    │
│  └───────────┼─────────────────┼───────────────────────────┘    │
│              │                 │                                │
│  ┌───────────┼─────────────────┼───────────────────────────┐    │
│  │           │    Kotlin/Native (shared code)              │    │
│  │           │                 │                           │    │
│  │           ▼                 │                           │    │
│  │    ┌──────────────┐         │                           │    │
│  │    │ Kotlin Class │         │                           │    │
│  │    │  ViewModel   │◀────────┘                           │    │
│  │    │              │                                     │    │
│  │    │ callback: () -> Unit                               │    │
│  │    │      ↑                                             │    │
│  │    │      │ захватывает ViewController                  │    │
│  │    └──────────────┘                                     │    │
│  │                                                         │    │
│  │  Kotlin видит callback как обычную функцию,             │    │
│  │  но на iOS это closure с strong reference к VC!         │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  РЕЗУЛЬТАТ: ViewController никогда не освободится               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### Код примера проблемы:

```kotlin
// Shared Kotlin code (commonMain)

class ViewModel {
    private var onComplete: (() -> Unit)? = null

    // ПРОБЛЕМА: callback может содержать strong reference на iOS
    fun setCallback(callback: () -> Unit) {
        onComplete = callback
    }

    fun performAction() {
        // ... async work ...
        onComplete?.invoke()
    }
}
```

```swift
// iOS Swift code

class ViewController: UIViewController {
    private let viewModel = ViewModel()

    override func viewDidLoad() {
        super.viewDidLoad()

        // ПРОБЛЕМА: self сильно захвачен в closure!
        viewModel.setCallback {
            self.updateUI()  // strong capture of self
        }
        // ViewController → ViewModel → callback → ViewController
        // Retain cycle!
    }

    func updateUI() {
        // ...
    }

    deinit {
        print("ViewController освобожден")  // Никогда не вызовется!
    }
}
```

### Решение: WeakReference expect/actual

```kotlin
// commonMain/src/.../WeakReference.kt

expect class WeakReference<T : Any>(referred: T) {
    fun get(): T?
}
```

```kotlin
// iosMain/src/.../WeakReference.kt

import kotlin.native.ref.WeakReference as NativeWeakRef

actual class WeakReference<T : Any> actual constructor(referred: T) {
    private val ref = NativeWeakRef(referred)

    actual fun get(): T? = ref.get()
}
```

```kotlin
// androidMain/src/.../WeakReference.kt

actual class WeakReference<T : Any> actual constructor(referred: T) {
    private val ref = java.lang.ref.WeakReference(referred)

    actual fun get(): T? = ref.get()
}
```

```kotlin
// Shared code with safe callback pattern

class ViewModel {
    private var onCompleteRef: WeakReference<Callback>? = null

    interface Callback {
        fun onComplete()
    }

    fun setCallback(callback: Callback) {
        // Сохраняем weak reference
        onCompleteRef = WeakReference(callback)
    }

    fun performAction() {
        // ... async work ...
        // Безопасно получаем callback, если он еще жив
        onCompleteRef?.get()?.onComplete()
    }
}
```

```swift
// iOS Swift code - fixed

class ViewController: UIViewController {
    private let viewModel = ViewModel()
    private var callbackWrapper: CallbackWrapper?

    override func viewDidLoad() {
        super.viewDidLoad()

        // Создаем wrapper с weak self
        callbackWrapper = CallbackWrapper(viewController: self)
        viewModel.setCallback(callbackWrapper!)
    }

    func updateUI() {
        // ...
    }

    deinit {
        print("ViewController освобожден")  // Теперь вызовется!
    }
}

class CallbackWrapper: ViewModel.Callback {
    weak var viewController: ViewController?

    init(viewController: ViewController) {
        self.viewController = viewController
    }

    func onComplete() {
        viewController?.updateUI()
    }
}
```

### autoreleasepool для iOS Target

```kotlin
// commonMain/src/.../Autorelease.kt

expect inline fun <T> autoreleasepool(block: () -> T): T
```

```kotlin
// iosMain/src/.../Autorelease.kt

import kotlinx.cinterop.autoreleasepool as nativeAutoreleasepool

actual inline fun <T> autoreleasepool(block: () -> T): T {
    return nativeAutoreleasepool(block)
}
```

```kotlin
// androidMain/src/.../Autorelease.kt

// На Android autoreleasepool не нужен, просто выполняем блок
actual inline fun <T> autoreleasepool(block: () -> T): T = block()
```

```kotlin
// Использование в shared code

class ImageProcessor {
    fun processImages(paths: List<String>): List<ProcessedImage> {
        return paths.map { path ->
            // На iOS каждая итерация очищает autoreleasepool
            // На Android это просто вызов лямбды
            autoreleasepool {
                loadImage(path)
                    .let { resize(it) }
                    .let { applyFilters(it) }
            }
        }
    }
}
```

---

## 6 типичных ошибок с примерами кода

### Ошибка 1: Closure capturing self strongly (iOS)

```swift
// НЕПРАВИЛЬНО ❌

class DataManager {
    var data: [String] = []
    var timer: Timer?

    func startPolling() {
        // Closure сильно захватывает self
        timer = Timer.scheduledTimer(withTimeInterval: 5.0, repeats: true) { _ in
            self.fetchData()  // strong capture!
        }
    }

    func fetchData() {
        // ...
    }

    deinit {
        timer?.invalidate()
        print("DataManager освобожден")  // Может не вызваться!
    }
}

// Проблема:
// DataManager → timer → closure → DataManager
// Даже если внешние ссылки на DataManager обнулятся,
// timer держит closure, а closure держит DataManager
```

```swift
// ПРАВИЛЬНО ✓

class DataManager {
    var data: [String] = []
    var timer: Timer?

    func startPolling() {
        // Вариант 1: [weak self]
        timer = Timer.scheduledTimer(withTimeInterval: 5.0, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            self.fetchData()
        }

        // Вариант 2: [unowned self] - если уверены, что self всегда жив
        // timer = Timer.scheduledTimer(withTimeInterval: 5.0, repeats: true) { [unowned self] _ in
        //     self.fetchData()
        // }
    }

    func fetchData() {
        // ...
    }

    deinit {
        timer?.invalidate()
        print("DataManager освобожден")  // Теперь вызовется!
    }
}
```

### Ошибка 2: Ignoring lifecycleScope (Android)

```kotlin
// НЕПРАВИЛЬНО ❌

class MyFragment : Fragment() {
    private lateinit var viewModel: MyViewModel

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        // Использование GlobalScope - ОПАСНО!
        GlobalScope.launch {
            val data = viewModel.fetchData()  // Длительная операция

            // К моменту завершения Fragment может быть уже уничтожен!
            withContext(Dispatchers.Main) {
                updateUI(data)  // Crash или утечка!
            }
        }
    }

    private fun updateUI(data: Data) {
        // Может вызваться на уничтоженном view
        binding.textView.text = data.toString()  // NullPointerException!
    }
}
```

```kotlin
// ПРАВИЛЬНО ✓

class MyFragment : Fragment() {
    private lateinit var viewModel: MyViewModel

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        // Используем viewLifecycleOwner.lifecycleScope
        viewLifecycleOwner.lifecycleScope.launch {
            val data = viewModel.fetchData()

            // Эта корутина автоматически отменится при уничтожении view
            updateUI(data)
        }

        // Альтернатива: используем repeatOnLifecycle
        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.dataFlow.collect { data ->
                    updateUI(data)
                }
            }
        }
    }

    private fun updateUI(data: Data) {
        binding.textView.text = data.toString()  // Безопасно!
    }
}
```

### Ошибка 3: Mixed retain cycle в KMP

```kotlin
// Shared code (commonMain)

class SharedViewModel {
    // Сохраняем callback как strong reference
    private var updateCallback: ((String) -> Unit)? = null

    fun registerForUpdates(callback: (String) -> Unit) {
        updateCallback = callback  // ОПАСНО на iOS!
    }

    fun unregister() {
        updateCallback = null
    }

    private fun notifyUpdate(data: String) {
        updateCallback?.invoke(data)
    }
}
```

```swift
// iOS код - НЕПРАВИЛЬНО ❌

class IOSViewController: UIViewController {
    private let viewModel = SharedViewModel()

    override func viewDidLoad() {
        super.viewDidLoad()

        // self захвачен сильно в callback!
        viewModel.registerForUpdates { data in
            self.updateLabel(with: data)  // strong capture
        }
    }

    // deinit не вызовется из-за retain cycle
    deinit {
        viewModel.unregister()  // Никогда не достигнем этой точки!
    }
}
```

```swift
// iOS код - ПРАВИЛЬНО ✓

class IOSViewController: UIViewController {
    private let viewModel = SharedViewModel()

    override func viewDidLoad() {
        super.viewDidLoad()

        // Используем [weak self]
        viewModel.registerForUpdates { [weak self] data in
            self?.updateLabel(with: data)
        }
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        // Явно отписываемся при уходе с экрана
        if isMovingFromParent {
            viewModel.unregister()
        }
    }

    deinit {
        viewModel.unregister()  // Теперь вызовется
    }
}
```

### Ошибка 4: Missing autoreleasepool в циклах

```kotlin
// НЕПРАВИЛЬНО ❌ (iosMain)

fun processLargeImageBatch(paths: List<String>) {
    for (path in paths) {
        // Каждая итерация создает временные Objective-C объекты
        // Они накапливаются до конца функции!
        val image = loadImage(path)
        val processed = applyFilters(image)
        saveImage(processed)
    }
    // Все временные объекты освобождаются только здесь
    // При 1000 изображений может случиться OOM
}
```

```kotlin
// ПРАВИЛЬНО ✓ (iosMain)

import kotlinx.cinterop.autoreleasepool

fun processLargeImageBatch(paths: List<String>) {
    for (path in paths) {
        autoreleasepool {
            // Временные объекты освобождаются в конце каждой итерации
            val image = loadImage(path)
            val processed = applyFilters(image)
            saveImage(processed)
        }
        // Здесь память от этой итерации уже освобождена
    }
}

// Еще лучше - использовать chunk processing
fun processLargeImageBatchChunked(paths: List<String>, chunkSize: Int = 10) {
    paths.chunked(chunkSize).forEach { chunk ->
        autoreleasepool {
            chunk.forEach { path ->
                val image = loadImage(path)
                val processed = applyFilters(image)
                saveImage(processed)
            }
        }
    }
}
```

### Ошибка 5: Static context leak (Android)

```kotlin
// НЕПРАВИЛЬНО ❌

object AppConfig {
    // Activity сохраняется в статическом контексте!
    lateinit var currentActivity: Activity  // MEMORY LEAK!

    fun initialize(activity: Activity) {
        currentActivity = activity
    }

    fun showDialog(message: String) {
        // Используем сохраненную Activity
        AlertDialog.Builder(currentActivity)
            .setMessage(message)
            .show()
    }
}

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        AppConfig.initialize(this)  // Activity теперь в статике!
    }

    // При повороте экрана создается новая Activity,
    // но старая останется в AppConfig навсегда!
}
```

```kotlin
// ПРАВИЛЬНО ✓

object AppConfig {
    // Храним WeakReference вместо сильной ссылки
    private var activityRef: WeakReference<Activity>? = null

    fun initialize(activity: Activity) {
        activityRef = WeakReference(activity)
    }

    fun showDialog(message: String) {
        // Получаем Activity, если она еще жива
        activityRef?.get()?.let { activity ->
            if (!activity.isFinishing && !activity.isDestroyed) {
                AlertDialog.Builder(activity)
                    .setMessage(message)
                    .show()
            }
        }
    }

    fun clear() {
        activityRef = null
    }
}

// Еще лучше - использовать Application context где возможно
object AppConfig {
    private lateinit var appContext: Context

    fun initialize(context: Context) {
        // Application context не привязан к Activity lifecycle
        appContext = context.applicationContext
    }

    fun getAppContext(): Context = appContext
}
```

### Ошибка 6: Relying on deinit/finalize для cleanup

```swift
// НЕПРАВИЛЬНО ❌ (iOS)

class NetworkConnection {
    private var socket: Socket?

    init() {
        socket = Socket.connect(host: "api.example.com", port: 443)
    }

    // Полагаемся на deinit для закрытия соединения
    deinit {
        socket?.close()
        print("Connection closed in deinit")
    }
}

// Проблема: если есть retain cycle, deinit никогда не вызовется,
// и соединение останется открытым навсегда!
```

```swift
// ПРАВИЛЬНО ✓ (iOS)

class NetworkConnection {
    private var socket: Socket?
    private var isClosed = false

    init() {
        socket = Socket.connect(host: "api.example.com", port: 443)
    }

    // Явный метод закрытия
    func close() {
        guard !isClosed else { return }
        isClosed = true
        socket?.close()
        socket = nil
        print("Connection closed explicitly")
    }

    deinit {
        // Fallback, но с предупреждением
        if !isClosed {
            print("WARNING: Connection not closed explicitly!")
            close()
        }
    }
}

// Использование с defer
func fetchData() {
    let connection = NetworkConnection()
    defer { connection.close() }  // Гарантированно закроется

    // ... работа с соединением ...
}
```

```kotlin
// НЕПРАВИЛЬНО ❌ (Android)

class DatabaseHelper : SQLiteOpenHelper(...) {
    private var database: SQLiteDatabase? = null

    fun getDatabase(): SQLiteDatabase {
        if (database == null) {
            database = writableDatabase
        }
        return database!!
    }

    // НЕ полагайтесь на finalize - он deprecated и ненадежен!
    protected fun finalize() {
        database?.close()  // Может не вызваться!
    }
}
```

```kotlin
// ПРАВИЛЬНО ✓ (Android)

class DatabaseHelper(context: Context) : SQLiteOpenHelper(
    context.applicationContext,  // Используем app context
    DATABASE_NAME,
    null,
    DATABASE_VERSION
), Closeable {

    private var database: SQLiteDatabase? = null

    fun getDatabase(): SQLiteDatabase {
        if (database == null || !database!!.isOpen) {
            database = writableDatabase
        }
        return database!!
    }

    // Явный метод закрытия, реализуем Closeable
    override fun close() {
        database?.close()
        database = null
        super.close()
    }
}

// Использование с use (эквивалент try-with-resources)
fun performDatabaseOperation() {
    DatabaseHelper(context).use { helper ->
        val db = helper.getDatabase()
        // ... операции с БД ...
    }  // close() вызовется автоматически
}
```

---

## Ментальные модели

### Модель 1: Ownership Graph (DAG vs Cyclic)

```
┌─────────────────────────────────────────────────────────────────┐
│                    Ownership Graph Model                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ИДЕАЛЬНЫЙ ГРАФ ВЛАДЕНИЯ (DAG - Directed Acyclic Graph):        │
│                                                                 │
│              ┌─────────┐                                        │
│              │  Root   │                                        │
│              └────┬────┘                                        │
│                   │                                             │
│         ┌────────┴────────┐                                     │
│         ▼                 ▼                                     │
│    ┌─────────┐       ┌─────────┐                                │
│    │    A    │       │    B    │                                │
│    └────┬────┘       └────┬────┘                                │
│         │                 │                                     │
│    ┌────┴────┐       ┌────┴────┐                                │
│    ▼         ▼       ▼         ▼                                │
│ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────────┐                             │
│ │  C  │ │  D  │ │  E  │ │    F    │                             │
│ └─────┘ └─────┘ └─────┘ └─────────┘                             │
│                                                                 │
│  Все стрелки направлены "вниз" - от владельца к владемому       │
│  Когда Root освобождается, все поддерево автоматически чистится │
│  ARC работает идеально!                                         │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ПРОБЛЕМНЫЙ ГРАФ (с циклами):                                   │
│                                                                 │
│              ┌─────────┐                                        │
│              │  Root   │                                        │
│              └────┬────┘                                        │
│                   │                                             │
│                   ▼                                             │
│              ┌─────────┐                                        │
│              │    A    │◀───────┐                               │
│              └────┬────┘        │                               │
│                   │             │                               │
│                   ▼             │ strong                        │
│              ┌─────────┐        │                               │
│              │    B    │────────┘                               │
│              └─────────┘                                        │
│                                                                 │
│  A владеет B, B владеет A - цикл!                               │
│  Даже если Root отпустит A, A и B останутся в памяти           │
│  ARC не справляется!                                            │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  РЕШЕНИЕ ДЛЯ ARC (weak references):                             │
│                                                                 │
│              ┌─────────┐                                        │
│              │  Root   │                                        │
│              └────┬────┘                                        │
│                   │ strong                                      │
│                   ▼                                             │
│              ┌─────────┐                                        │
│              │    A    │◀╌╌╌╌╌╌╌┐                               │
│              └────┬────┘        ╎                               │
│                   │ strong      ╎ weak                          │
│                   ▼             ╎                               │
│              ┌─────────┐        ╎                               │
│              │    B    │╌╌╌╌╌╌╌╌┘                               │
│              └─────────┘                                        │
│                                                                 │
│  B имеет weak reference на A - цикл разорван!                   │
│  Когда Root отпустит A, A освободится, затем B                 │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ПОЧЕМУ GC СПРАВЛЯЕТСЯ С ЦИКЛАМИ:                               │
│                                                                 │
│  GC не следует по ссылкам "от объекта к объекту".               │
│  Вместо этого он идет "от корней":                              │
│                                                                 │
│  1. Пометить все достижимые от GC Roots                         │
│  2. Если A и B недостижимы от корней - собрать оба              │
│                                                                 │
│              ┌─────────┐                                        │
│              │GC Roots │                                        │
│              └────┬────┘                                        │
│                   │                                             │
│                   ╳ (нет пути)                                  │
│                   │                                             │
│              ┌─────────┐        ┌─────────┐                     │
│              │    A    │◀──────▶│    B    │                     │
│              └─────────┘        └─────────┘                     │
│                                                                 │
│  A и B недостижимы от корней → оба будут собраны                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Модель 2: Determinism Trade-off

```
┌─────────────────────────────────────────────────────────────────┐
│                   Determinism Trade-off                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ARC                          GC                                │
│  ───                          ──                                │
│                                                                 │
│  Детерминизм                  Недетерминизм                     │
│      │                            │                             │
│      │  ┌──────────────────────┐  │                             │
│      │  │                      │  │                             │
│      ▼  │                      ▼  │                             │
│  ┌───────────────┐         ┌───────────────┐                    │
│  │ Время освобож-│         │ Память освобо-│                    │
│  │ дения известно│         │ ждается когда-│                    │
│  │ (refCount = 0)│         │ нибудь        │                    │
│  └───────────────┘         └───────────────┘                    │
│         │                          │                            │
│         ▼                          ▼                            │
│  ┌───────────────┐         ┌───────────────┐                    │
│  │ deinit надежен│         │ finalize не   │                    │
│  │ для cleanup   │         │ надежен       │                    │
│  └───────────────┘         └───────────────┘                    │
│         │                          │                            │
│         ▼                          ▼                            │
│  ┌───────────────┐         ┌───────────────┐                    │
│  │ Предсказуемая │         │ Возможны GC   │                    │
│  │ latency       │         │ паузы         │                    │
│  └───────────────┘         └───────────────┘                    │
│                                                                 │
│  НО:                         НО:                                │
│  ─────                       ─────                              │
│  ┌───────────────┐         ┌───────────────┐                    │
│  │ Retain cycles │         │ Циклы         │                    │
│  │ = ручная      │         │ обрабатываются│                    │
│  │ работа        │         │ автоматически │                    │
│  └───────────────┘         └───────────────┘                    │
│         │                          │                            │
│         ▼                          ▼                            │
│  ┌───────────────┐         ┌───────────────┐                    │
│  │ Overhead на   │         │ Throughput    │                    │
│  │ каждый        │         │ выше для      │                    │
│  │ retain/release│         │ batch работы  │                    │
│  └───────────────┘         └───────────────┘                    │
│                                                                 │
│  ВЫВОД:                                                         │
│  ARC лучше для:            GC лучше для:                        │
│  - Real-time (audio/video) - Серверных нагрузок                 │
│  - Ограниченной памяти     - Сложных графов объектов            │
│  - Предсказуемого cleanup  - Быстрой разработки                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Модель 3: Developer Responsibility

```
┌─────────────────────────────────────────────────────────────────┐
│                  Developer Responsibility Matrix                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Задача                        ARC (iOS)      GC (Android)      │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  Создание объектов             Auto          Auto               │
│  Освобождение объектов         Auto          Auto               │
│  Обнаружение утечек            Manual*       Auto               │
│  Разрешение циклов             Manual        Auto               │
│  Управление временем жизни     Explicit      Implicit           │
│  Cleanup ресурсов              deinit        try-with/use       │
│  Оптимизация allocations       Medium        High               │
│  Понимание ownership           Required      Optional           │
│                                                                 │
│  * ARC обнаруживает простые утечки через Instruments,           │
│    но retain cycles требуют понимания разработчиком             │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Шкала ответственности:                                         │
│                                                                 │
│  Manual          ARC              GC              Rust          │
│  Memory     ◀──────────────────────────────────────────▶ Borrow │
│  Management                                              Checker│
│                                                                 │
│  Больше          Средняя          Меньше           Compile-time │
│  работы          работа           работы           гарантии     │
│                                                                 │
│  C/C++           Swift/ObjC       Java/Kotlin      Rust         │
│  (malloc/free)   (weak refs)      (life is easy)   (ownership)  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Проверь себя

### Вопрос 1: Определи проблему

```swift
class DownloadManager {
    var onProgress: ((Double) -> Void)?

    func startDownload(url: URL) {
        URLSession.shared.dataTask(with: url) { data, response, error in
            // Периодически вызываем прогресс
            self.onProgress?(0.5)
        }.resume()
    }
}

class ViewController: UIViewController {
    let manager = DownloadManager()

    override func viewDidLoad() {
        super.viewDidLoad()
        manager.onProgress = { progress in
            self.updateProgressBar(progress)
        }
    }
}
```

**Вопрос**: Есть ли здесь retain cycle? Если да, как исправить?

<details>
<summary>Показать ответ</summary>

**Да, есть retain cycle!**

Цепочка:
- `ViewController` → сильная ссылка на `manager`
- `manager` → сильная ссылка на `onProgress` (closure)
- `onProgress` closure → сильно захватывает `self` (ViewController)

**Исправление:**

```swift
manager.onProgress = { [weak self] progress in
    self?.updateProgressBar(progress)
}
```

Теперь closure имеет weak ссылку на ViewController, и цикл разорван.

</details>

### Вопрос 2: Объясни поведение

```kotlin
fun main() {
    var list: MutableList<String>? = mutableListOf("a", "b", "c")

    val reference = list

    list = null

    println(reference?.size)  // Что выведется?

    System.gc()
    Thread.sleep(100)

    println(reference?.size)  // А теперь?
}
```

**Вопрос**: Что выведется в каждом случае и почему?

<details>
<summary>Показать ответ</summary>

**Вывод:**
```
3
3
```

**Объяснение:**

1. `list` и `reference` - это две ссылки на один и тот же объект в heap.

2. Когда мы делаем `list = null`, мы обнуляем только одну ссылку.
   Объект `mutableListOf("a", "b", "c")` всё еще достижим через `reference`.

3. `System.gc()` не соберет этот объект, потому что он всё еще достижим
   от GC roots через переменную `reference`.

4. Объект будет собран только когда все ссылки на него станут недостижимы
   от GC roots.

**Аналогия**: Представьте что объект - это воздушный шарик, а ссылки - веревочки.
Шарик улетит (будет собран GC) только когда отпустят все веревочки.

</details>

### Вопрос 3: Архитектурное решение

Вы разрабатываете KMP приложение с таким кодом:

```kotlin
// commonMain
class ImageCache {
    private val cache = mutableMapOf<String, ByteArray>()

    private var onEviction: ((String) -> Unit)? = null

    fun setEvictionCallback(callback: (String) -> Unit) {
        onEviction = callback
    }

    fun evict(key: String) {
        cache.remove(key)
        onEviction?.invoke(key)
    }
}

// Использование на iOS
class IOSImageManager {
    private let cache = ImageCache()

    init() {
        cache.setEvictionCallback { [self] key in
            self.logEviction(key)
        }
    }
}
```

**Вопрос**: Какие проблемы вы видите? Как бы вы их исправили, учитывая,
что это кросс-платформенный код?

<details>
<summary>Показать ответ</summary>

**Проблемы:**

1. **Retain cycle на iOS**: `IOSImageManager` → `cache` → `onEviction` closure → `IOSImageManager`

2. **Смешанное владение**: Kotlin shared code хранит callback, который на iOS
   содержит strong reference к Swift объекту.

3. **Нет очистки**: Нет способа отписаться от callback.

**Решение:**

```kotlin
// commonMain - используем паттерн Listener вместо callback

interface ImageCacheListener {
    fun onEviction(key: String)
}

class ImageCache {
    private val cache = mutableMapOf<String, ByteArray>()

    // Используем WeakReference для listener
    private var listenerRef: WeakReference<ImageCacheListener>? = null

    fun setListener(listener: ImageCacheListener) {
        listenerRef = WeakReference(listener)
    }

    fun removeListener() {
        listenerRef = null
    }

    fun evict(key: String) {
        cache.remove(key)
        listenerRef?.get()?.onEviction(key)
    }
}
```

```swift
// iOS
class IOSImageManager: ImageCacheListener {
    private let cache = ImageCache()

    init() {
        cache.setListener(self)
    }

    deinit {
        cache.removeListener()
    }

    func onEviction(key: String) {
        logEviction(key)
    }
}
```

Теперь:
- Cache держит weak reference на listener
- IOSImageManager реализует протокол напрямую (нет closure capture)
- Есть явный способ отписаться

</details>

### Вопрос 4: Оптимизация

Следующий код на Android вызывает частые GC паузы при скролле:

```kotlin
class ProductAdapter : RecyclerView.Adapter<ProductViewHolder>() {
    private var products = listOf<Product>()

    override fun onBindViewHolder(holder: ProductViewHolder, position: Int) {
        val product = products[position]

        // Форматирование цены
        val formatter = NumberFormat.getCurrencyInstance()
        holder.priceText.text = formatter.format(product.price)

        // Форматирование даты
        val dateFormatter = SimpleDateFormat("dd MMM yyyy", Locale.getDefault())
        holder.dateText.text = dateFormatter.format(product.date)

        // Создание Bitmap для иконки
        val bitmap = Bitmap.createBitmap(48, 48, Bitmap.Config.ARGB_8888)
        val canvas = Canvas(bitmap)
        drawProductIcon(canvas, product.category)
        holder.iconImage.setImageBitmap(bitmap)
    }
}
```

**Вопрос**: Определите источники allocations и предложите оптимизацию.

<details>
<summary>Показать ответ</summary>

**Источники allocations в каждом onBindViewHolder:**

1. `NumberFormat.getCurrencyInstance()` - создает новый formatter
2. `SimpleDateFormat(...)` - создает новый date formatter
3. `Bitmap.createBitmap(...)` - создает новый Bitmap 48x48
4. `Canvas(bitmap)` - создает новый Canvas

**При 60 FPS скролле с 10 видимыми элементами:**
4 объекта × 10 элементов × 60 FPS = 2400 allocations/sec!

**Оптимизированная версия:**

```kotlin
class ProductAdapter : RecyclerView.Adapter<ProductViewHolder>() {
    private var products = listOf<Product>()

    // Переиспользуемые форматтеры (один на весь adapter)
    private val priceFormatter = NumberFormat.getCurrencyInstance()
    private val dateFormatter = SimpleDateFormat("dd MMM yyyy", Locale.getDefault())

    // Bitmap pool для иконок
    private val bitmapPool = ArrayDeque<Bitmap>(20)

    private fun obtainBitmap(): Bitmap {
        return bitmapPool.pollFirst()
            ?: Bitmap.createBitmap(48, 48, Bitmap.Config.ARGB_8888)
    }

    private fun recycleBitmap(bitmap: Bitmap) {
        if (bitmapPool.size < 20) {
            bitmap.eraseColor(Color.TRANSPARENT)
            bitmapPool.addLast(bitmap)
        }
    }

    // Canvas можно переиспользовать, меняя только bitmap
    private val reusableCanvas = Canvas()

    override fun onBindViewHolder(holder: ProductViewHolder, position: Int) {
        val product = products[position]

        // Переиспользуем formatters
        holder.priceText.text = priceFormatter.format(product.price)
        holder.dateText.text = dateFormatter.format(product.date)

        // Переиспользуем bitmap из пула
        val bitmap = obtainBitmap()
        reusableCanvas.setBitmap(bitmap)
        drawProductIcon(reusableCanvas, product.category)
        holder.iconImage.setImageBitmap(bitmap)
    }

    override fun onViewRecycled(holder: ProductViewHolder) {
        // Возвращаем bitmap в пул при переиспользовании ViewHolder
        (holder.iconImage.drawable as? BitmapDrawable)?.bitmap?.let {
            recycleBitmap(it)
        }
        holder.iconImage.setImageDrawable(null)
    }
}
```

**Результат:**
- 0 allocations в steady-state при скролле
- Никаких GC пауз
- Плавная анимация 60 FPS

</details>

---

## Связанные темы

- [[ios-process-memory]] — Устройство памяти iOS процесса, сегменты, heap/stack
- [[android-process-memory]] — Dalvik/ART heap, native memory, memory-mapped files
- [[kmp-memory-management]] — Особенности управления памятью в Kotlin Multiplatform
- [[reference-counting-arc]] — Глубокое погружение в ARC: swift_retain, side tables, weak refs
- [[garbage-collection-explained]] — Алгоритмы GC: Mark-Sweep, Generational, G1, ZGC
- [[swift-memory-layout]] — Value types, reference types, copy-on-write
- [[kotlin-coroutines-memory]] — Structured concurrency и управление памятью
- [[instruments-memory-debugging]] — Профилирование памяти в Xcode
- [[android-profiler-memory]] — Профилирование памяти в Android Studio

---

## Источники

### Apple Documentation
- [Automatic Reference Counting — Swift Documentation](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting/)
- [Memory Management Programming Guide for Cocoa](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html)
- [WWDC 2021: ARC in Swift](https://developer.apple.com/videos/play/wwdc2021/10216/)
- [Instruments User Guide: Leaks](https://help.apple.com/instruments/mac/current/#/dev022f987b)

### Android Documentation
- [Manage your app's memory — Android Developers](https://developer.android.com/topic/performance/memory)
- [Memory Profiler — Android Studio](https://developer.android.com/studio/profile/memory-profiler)
- [Debug your app's memory — Android Developers](https://developer.android.com/studio/debug/memory)
- [ART and Dalvik — AOSP](https://source.android.com/docs/core/runtime)

### Kotlin Multiplatform
- [Kotlin/Native memory management](https://kotlinlang.org/docs/native-memory-manager.html)
- [Kotlin/Native migration guide](https://kotlinlang.org/docs/native-migration-guide.html)
- [Concurrency in Kotlin Multiplatform](https://kotlinlang.org/docs/multiplatform-mobile-concurrency-overview.html)

### Academic Papers
- Bacon, D. F., et al. "A Unified Theory of Garbage Collection." OOPSLA 2004.
- Click, C., et al. "The Pauseless GC Algorithm." VEE 2005.

### Books
- "Pro Swift Memory Management" by Joe Groff
- "Kotlin in Action" by Dmitry Jemerov and Svetlana Isakova
- "Advanced Swift" by Chris Eidhof, Ole Begemann, and Airspeed Velocity

---

*Последнее обновление: 2026-01-11*
