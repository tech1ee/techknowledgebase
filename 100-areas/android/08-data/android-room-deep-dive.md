---
title: "Room Deep-dive: ORM поверх SQLite для Android"
created: 2026-02-11
modified: 2026-02-11
type: deep-dive
area: android
status: published
confidence: high
cs-foundations: [orm, sql, compile-time-verification, reactive-streams, database-design]
tags:
  - topic/android
  - topic/data
  - type/deep-dive
  - level/intermediate
related:
  - "[[android-data-persistence]]"
  - "[[android-room-migrations]]"
  - "[[android-room-performance]]"
  - "[[android-datastore-guide]]"
  - "[[android-repository-pattern]]"
  - "[[kotlin-coroutines]]"
  - "[[kotlin-flow]]"
  - "[[database-design-optimization]]"
prerequisites:
  - "[[android-data-persistence]]"
  - "[[android-activity-lifecycle]]"
  - "[[kotlin-coroutines]]"
---

# Room Deep-dive: ORM поверх SQLite для Android

Room -- это compile-time ORM-библиотека от Google, которая превращает Kotlin data-классы в таблицы SQLite и проверяет каждый SQL-запрос ещё до того, как приложение запустится. Ключевой инсайт Room прост: если код скомпилировался -- запрос к базе данных точно выполнится корректно. Ни одна другая Android-библиотека для работы с данными не даёт такой гарантии на этапе сборки.

---

## Зачем это знать

До появления Room каждый Android-разработчик, работавший с SQLite, сталкивался с тремя неизбежными проблемами. Первая -- boilerplate: для каждой таблицы приходилось вручную писать `SQLiteOpenHelper`, создавать `ContentValues` для вставки, разбирать `Cursor` при чтении. Второй строчкой шли runtime crashes: опечатка в названии колонки (`"usres"` вместо `"users"`) проходила компиляцию, но обрушивала приложение у пользователя. Третья -- SQL injection: если параметры запроса подставлялись через конкатенацию строк, злоумышленник мог выполнить произвольный SQL.

Эти проблемы выглядят техническими, но их последствия -- бизнесовые. Crash в production означает потерю пользователей. SQL injection означает потерю данных. Boilerplate означает потерю времени: разработчик тратит часы на код, который можно сгенерировать автоматически.

Room решает все три проблемы одним архитектурным решением: переносом проверки SQL с runtime на compile-time. Это означает, что ошибки обнаруживаются не когда пользователь открывает экран, а когда разработчик нажимает Build. Идея не нова: типизированные языки делают то же самое с типами данных (ошибка типа обнаруживается при компиляции, а не в runtime). Room распространяет эту философию на SQL.

Понимание Room на глубоком уровне -- не просто знание API. Это понимание принципов, которые применимы в любой области: compile-time verification, code generation, abstraction over storage, reactive data access. Эти принципы работают в Room, в SQLDelight, в Dagger/Hilt, в Protocol Buffers -- везде, где annotation processing генерирует безопасный код.

---

## Терминология

| Термин | Что это | Аналогия из реальной жизни |
|--------|---------|---------------------------|
| **Entity** | Kotlin data class, который представляет таблицу в базе данных | Бланк анкеты: поля фиксированы, каждое имеет свой тип |
| **DAO** | Data Access Object -- интерфейс с методами для CRUD-операций | Секретарь-референт: принимает запросы, возвращает результаты, сам не решает КАК хранить |
| **RoomDatabase** | Абстрактный класс -- точка входа к DAO и базе | Здание архива: содержит все картотеки (DAO) и сейфы (таблицы) |
| **Migration** | Инструкция по изменению схемы БД при обновлении версии | Приказ о реорганизации: добавить отдел, переименовать должность |
| **TypeConverter** | Функция конвертации сложного типа в примитив SQLite | Переводчик: Date говорит по-русски, SQLite понимает только Long |
| **@Query** | Аннотация с SQL-запросом, проверяемым при компиляции | Бланк запроса с печатью нотариуса: если формат верный -- запрос примут |
| **Flow** | Реактивный поток данных из Room, обновляющийся при изменении таблицы | Табло вылетов в аэропорту: обновляется само, когда меняется расписание |
| **InvalidationTracker** | Механизм внутри Room, отслеживающий изменения в таблицах | Датчик движения: реагирует на любое изменение в помещении |

---

## Историческая справка

### SQLiteOpenHelper: начало (2008)

Когда Android 1.0 вышел в сентябре 2008 года, единственным способом работы с локальной базой данных был `SQLiteOpenHelper` -- тонкая обёртка над C-библиотекой SQLite. Разработчик писал SQL-запросы как строки, вручную создавал `ContentValues` для записи и вручную разбирал `Cursor` для чтения. Никаких проверок: опечатка в названии таблицы обнаруживалась только при запуске на устройстве.

Это было терпимо для небольших приложений с одной-двумя таблицами. Но Android рос, приложения усложнялись, и boilerplate-код стал занимать сотни строк. Кроме того, `SQLiteOpenHelper` не запрещал делать запросы на Main Thread -- а это блокировало UI и вызывало ANR (Application Not Responding).

### Попытки сообщества: ORMLite, GreenDAO, Realm (2011-2015)

Сообщество Android не стало ждать Google. В 2011-2013 годах появились несколько ORM-библиотек: **ORMLite** (основанный на Java Reflection), **GreenDAO** (с кодогенерацией на Java), **Realm** (собственная база данных вместо SQLite). Каждая решала часть проблем, но создавала новые. ORMLite использовал reflection, что замедляло работу. GreenDAO генерировал Java-код, но не проверял SQL. Realm требовал наследования от `RealmObject`, ломая принцип immutable data classes.

Ни одна из этих библиотек не стала стандартом де-факто, потому что ни одна не имела поддержки Google и интеграции с остальной экосистемой Android. Это важный урок: в мире Android, где Google контролирует SDK, build tools и рекомендации по архитектуре, сторонние ORM всегда будут на шаг позади по интеграции с LiveData, ViewModel, Paging и другими Jetpack-компонентами.

### Google I/O 2017: рождение Room

На конференции Google I/O в мае 2017 года команда Android Architecture Components представила Room как часть новой архитектурной философии Android. Ключевую роль в разработке и продвижении Room сыграла **Florina Muntenescu** -- Developer Advocate из Google, которая написала серию статей "7 Steps to Room" и провела десятки докладов, объясняя принципы compile-time verification.

Принципиальное отличие Room от предшественников: это не попытка скрыть SQL, а попытка сделать SQL безопасным. Room не изобретает свой язык запросов -- он проверяет стандартный SQL при компиляции. Разработчик пишет обычные SELECT, INSERT, UPDATE -- и KSP/KAPT проверяет их синтаксис, названия таблиц, типы данных и соответствие возвращаемого типа.

### Эволюция Room: от 1.0 до 2.7

| Версия | Год | Ключевое нововведение |
|--------|-----|----------------------|
| 1.0 | 2017 | Первый релиз: Entity, DAO, Database, LiveData |
| 2.0 | 2018 | Поддержка RxJava, @Relation |
| 2.1 | 2019 | FTS (Full-Text Search), Views |
| 2.2 | 2020 | Incremental annotation processing, pre-packaged DB |
| 2.3 | 2021 | Kotlin coroutines first-class support, enum TypeConverter |
| 2.4 | 2022 | AutoMigration, Multimap return types (Map<User, List<Post>>) |
| 2.5 | 2023 | KSP по умолчанию (вместо KAPT), Paging 3 интеграция |
| 2.7 | 2024 | Kotlin Multiplatform (KMP) -- поддержка iOS, Desktop, Native |

Эволюция Room отражает эволюцию Kotlin на Android. Ранние версии возвращали LiveData, потому что корутин ещё не было. С Room 2.3 suspend-функции стали first-class citizens. С Room 2.7 библиотека вышла за пределы Android, поддержав KMP.

---

## Prerequisites

| Prerequisite | Что нужно знать | Почему |
|-------------|----------------|--------|
| [[android-data-persistence]] | Обзор способов хранения данных, место Room среди DataStore и Files | Без контекста непонятно, зачем выбирать Room |
| [[android-activity-lifecycle]] | Жизненный цикл Activity и process death | Room хранит данные, которые переживают пересоздание Activity |
| [[kotlin-coroutines]] | suspend-функции, Dispatchers, structured concurrency | DAO-методы Room -- suspend-функции, выполняемые вне Main Thread |

---

## Архитектура Room

Мы разобрали историю и терминологию. Теперь -- КАК Room работает внутри, между вашим Kotlin-кодом и SQLite.

### KSP/KAPT: кодогенерация при компиляции

Room -- это не runtime-библиотека, которая использует reflection для маппинга объектов. Room -- это **annotation processor**, который при компиляции анализирует ваши аннотации (`@Entity`, `@Dao`, `@Query`) и **генерирует** Java/Kotlin-код, выполняющий реальные SQL-операции.

Когда вы пишете интерфейс `UserDao` с методом `@Query("SELECT * FROM users")`, Room при компиляции создаёт класс `UserDao_Impl`, внутри которого -- вызов `SupportSQLiteDatabase.query()` с параметризованным SQL. Этот сгенерированный код работает напрямую с SQLite, без reflection, без прокси-объектов, без динамического создания запросов. Именно поэтому Room добавляет нулевой runtime overhead по сравнению с ручной работой с SQLite.

Раньше для обработки аннотаций использовался KAPT (Kotlin Annotation Processing Tool), который работал через двойной перевод: сначала Kotlin-код конвертировался в Java stubs, потом Java annotation processor обрабатывал эти stubs. Двойной перевод замедлял сборку, особенно в проектах с десятками Entity.

С Room 2.5+ по умолчанию используется KSP (Kotlin Symbol Processing) -- annotation processor нового поколения от Google. KSP работает напрямую с Kotlin-символами, минуя стадию Java stubs. Результат: ускорение компиляции Room в 2-3 раза. Миграция с KAPT на KSP -- замена `kapt(...)` на `ksp(...)` в `build.gradle.kts` и, в большинстве случаев, никаких изменений в коде.

> **Ключевая идея:** Room генерирует код, а не интерпретирует его. Это значит: нулевой runtime overhead, полная compile-time проверка, и возможность открыть сгенерированный файл и прочитать, что именно Room делает.

### SupportSQLiteDatabase: абстракция над SQLite

Room не работает с Android-классом `SQLiteDatabase` напрямую. Вместо этого он использует интерфейс `SupportSQLiteDatabase` из библиотеки `androidx.sqlite`. Зачем? Чтобы позволить подставлять разные реализации: стандартную Android SQLite, SQLCipher (для шифрования), или собственную реализацию для тестов.

Это классическое применение принципа Dependency Inversion (буква D в SOLID): модуль высокого уровня (Room) зависит от абстракции (`SupportSQLiteDatabase`), а не от конкретной реализации (`android.database.sqlite.SQLiteDatabase`). Благодаря этому архитектурному решению, принятому в 2017 году, в Room 2.7 (2024) стало возможным поддержать KMP -- достаточно подставить `NativeSQLiteDriver` для iOS вместо `AndroidSQLiteDriver`. Ни одна строка Room-кода не знает, с какой реализацией SQLite она работает.

### Compile-time SQL verification

Самая ценная возможность Room -- проверка SQL при компиляции. Когда вы пишете `@Query("SELECT * FROM users WHERE age > :minAge")`, annotation processor выполняет следующие шаги:

1. **Парсинг SQL** -- разбирает запрос на токены (SELECT, FROM, WHERE)
2. **Валидация таблиц** -- проверяет, что таблица `users` существует (есть `@Entity(tableName = "users")`)
3. **Валидация колонок** -- проверяет, что колонка `age` существует в Entity
4. **Валидация параметров** -- проверяет, что `:minAge` соответствует аргументу метода
5. **Валидация типов** -- проверяет, что возвращаемый тип метода соответствует колонкам SELECT

Если любой шаг не проходит -- сборка падает с понятной ошибкой: `error: There is a problem with the query: [SQLITE_ERROR] SQL error or missing database (no such table: usres)`.

### Аналогия: Room как переводчик-нотариус

Представьте, что вы подаёте документ в государственное учреждение другой страны. Переводчик-нотариус не просто переводит текст -- он проверяет, что все поля заполнены, формат даты правильный, подписи на месте. Если что-то не так -- он возвращает документ вам до отправки, а не после.

Room работает так же. Ваш "документ" -- это Kotlin-код с аннотациями. "Другая страна" -- это SQLite, который понимает только SQL. Room переводит (генерирует SQL-код) и заверяет (проверяет корректность) -- всё при компиляции. Если вы допустили опечатку -- документ вернётся вам, а не уйдёт в "другую страну" (runtime), где ошибку обнаружит уже пользователь.

```
┌─────────────────────────────────────────────────────────────┐
│                    Архитектура Room                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Ваш код            Compile-time              Runtime       │
│  ┌──────────┐      ┌──────────────────┐      ┌──────────┐ │
│  │ @Entity  │      │ KSP/KAPT:        │      │ Generated│ │
│  │ @Dao     │─────▶│ 1. Parse SQL     │─────▶│ _Impl    │ │
│  │ @Query   │      │ 2. Check tables  │      │ classes  │ │
│  │ @Database│      │ 3. Check columns │      │          │ │
│  └──────────┘      │ 4. Check types   │      │ ↓        │ │
│                    │ 5. Generate code │      │ Support- │ │
│                    └──────────────────┘      │ SQLite-  │ │
│                         │                    │ Database │ │
│                    Build error               └──────────┘ │
│                    если ошибка                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

Мы разобрали, как Room устроен изнутри. Теперь разберём три ключевых компонента, которые вы пишете: Entity (что хранить), DAO (как обращаться) и Database (где всё объединяется).

---

## Entity: таблица в виде data class

### Что такое Entity

Entity -- это Kotlin data class, аннотированный `@Entity`, который Room превращает в таблицу SQLite. Каждое свойство класса становится колонкой таблицы, каждый экземпляр класса -- строкой. Это центральный элемент Object-Relational Mapping: объект в Kotlin-мире соответствует строке в SQL-мире.

Важно понимать, что Entity -- это не произвольный объект. Это строгий контракт между вашим кодом и базой данных. Если вы добавите поле в Entity без миграции -- приложение упадёт при старте. Если вы измените тип поля -- данные станут нечитаемыми. Entity фиксирует структуру, и Room обеспечивает её соблюдение.

### Аналогия: Entity как бланк анкеты

Представьте, что вы приходите в паспортный стол. Вам дают бланк анкеты: Фамилия (строка), Дата рождения (дата), Номер паспорта (число). Вы не можете добавить своё поле, не можете написать дату в поле "Фамилия", не можете оставить обязательное поле пустым. Бланк определяет структуру -- вы только заполняете данные.

Entity в Room работает так же. Data class определяет "бланк" (структуру таблицы), а каждый объект этого класса -- "заполненную анкету" (строку в таблице). Аннотации `@PrimaryKey`, `@ColumnInfo`, `@Index` -- это правила заполнения: какое поле обязательно, какое уникально, по какому полю будет быстрый поиск.

Продолжая аналогию: если паспортный стол решает добавить новое поле "ИНН" в анкету (миграция базы данных), все уже заполненные анкеты нужно дополнить этим полем. Room Migration -- это инструкция "для всех существующих анкет проставить поле ИНН со значением по умолчанию". Без такой инструкции -- все старые анкеты станут недействительными (приложение упадёт).

### Ключевые аннотации Entity

**@PrimaryKey** определяет уникальный идентификатор строки. С `autoGenerate = true` Room поручает SQLite автоматически назначать числовой ID. Без primary key Room не скомпилируется -- каждая строка в реляционной базе данных обязана быть идентифицируемой.

**@ColumnInfo** позволяет задать имя колонки, отличное от имени свойства Kotlin. Это важно, когда backend API возвращает `full_name` (snake_case), а в Kotlin принято `fullName` (camelCase). Параметр `defaultValue` задаёт значение по умолчанию на уровне SQL -- оно используется при миграциях, когда новая колонка добавляется к существующим строкам.

**@Index** создаёт индекс для ускорения SELECT-запросов с WHERE или ORDER BY. Composite index (`@Index(value = ["last_name", "first_name"])`) ускоряет запросы, фильтрующие по нескольким полям одновременно. Но у индексов есть цена: каждый INSERT и UPDATE становятся медленнее, потому что SQLite обновляет не только таблицу, но и все её индексы.

**@ForeignKey** определяет внешний ключ -- связь между таблицами. Foreign key -- это обещание: "значение в этой колонке обязательно существует в другой таблице". Если вы попытаетесь вставить Task с `projectId = 999`, но проект с `id = 999` не существует -- SQLite бросит исключение.

Параметр `onDelete` определяет, что происходит при удалении родительской строки. `CASCADE` -- каскадное удаление: если проект удалён, все его задачи удаляются автоматически. `SET_NULL` -- дочерние строки сохраняются, но foreign key обнуляется. `RESTRICT` -- удаление родителя запрещено, пока есть дочерние строки. Выбор стратегии зависит от бизнес-логики: для "задачи проекта" логичен CASCADE, для "автор статьи" -- SET_NULL (статья остаётся, автор удалён).

Важное замечание: SQLite по умолчанию НЕ проверяет foreign keys. Нужно включить их через `PRAGMA foreign_keys = ON` при каждом открытии соединения. Room делает это автоматически начиная с версии 2.0, но если вы используете pre-packaged database или raw queries -- проверьте.

**@Ignore** исключает свойство из маппинга. Room не создаст колонку для этого поля. Полезно для вычисляемых свойств или данных, которые существуют только в runtime.

Покажем, как все эти аннотации работают вместе в реальном Entity.

```kotlin
@Entity(
    tableName = "tasks",
    indices = [Index(value = ["due_date"])],  // Индекс для сортировки по дедлайну
    foreignKeys = [ForeignKey(
        entity = Project::class,
        parentColumns = ["id"],
        childColumns = ["project_id"],
        onDelete = ForeignKey.CASCADE          // Удалить задачи при удалении проекта
    )]
)
data class Task(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,                          // SQLite сам назначит уникальный ID
    @ColumnInfo(name = "project_id")
    val projectId: Long,                       // Связь с таблицей projects
    val title: String,                         // Имя колонки = имя свойства
    @ColumnInfo(name = "due_date")
    val dueDate: Long,                         // Unix timestamp (нужен TypeConverter для Date)
    @ColumnInfo(defaultValue = "0")
    val isCompleted: Boolean = false,           // Значение по умолчанию в SQL
    @Ignore
    val isOverdue: Boolean = false              // НЕ сохраняется в БД -- вычисляется в runtime
)
```

Этот Entity демонстрирует пять ключевых аннотаций в одном месте. Обратите внимание на `@Ignore`: поле `isOverdue` вычисляется в коде (например, `dueDate < System.currentTimeMillis()`), и хранить его в базе нет смысла -- оно устареет в момент записи. А `@ForeignKey` с CASCADE гарантирует: если проект удалён -- все его задачи удаляются автоматически, без дополнительного кода.

Мы разобрали Entity -- структуру данных. Но кто выполняет запросы к этим таблицам? Кто вставляет, читает, обновляет и удаляет строки?

---

## DAO: Data Access Object

### Паттерн DAO: история

Паттерн DAO (Data Access Object) появился задолго до Room. Его описали в 2001 году в книге "Core J2EE Patterns" (Deepak Alur, John Crupi, Dan Malks) как способ отделить бизнес-логику от логики доступа к данным. Идея проста: код, который решает "что показать пользователю", не должен знать, откуда берутся данные -- из PostgreSQL, файла или сети.

В контексте Enterprise Java паттерн DAO решал конкретную проблему: бизнес-логика (EJB) не должна содержать JDBC-вызовы, потому что это делает её нетестируемой и привязанной к конкретной базе данных. Выделение доступа к данным в отдельный объект позволяло подменять реализацию: в production -- Oracle, в тестах -- in-memory mock.

В Room DAO реализован как интерфейс (или абстрактный класс), аннотированный `@Dao`. Вы описываете методы с аннотациями (`@Insert`, `@Query`, `@Delete`), а Room при компиляции генерирует их реализацию. Вы определяете контракт ("что хочу получить"), Room обеспечивает выполнение ("как это сделать"). Принцип тот же, что и в J2EE, но реализация элегантнее: вместо класса с boilerplate-кодом -- интерфейс с аннотациями.

### Аналогия: DAO как секретарь-референт

Представьте приёмную директора крупной компании. Секретарь-референт -- это DAO. Вы приходите и говорите: "Мне нужен список всех сотрудников отдела маркетинга" (аналог `@Query`). Или: "Добавьте нового сотрудника в штат" (аналог `@Insert`). Секретарь принимает запрос, обращается к картотеке (базе данных), и возвращает результат.

Ключевой момент: секретарь не решает, КАК хранятся данные -- в папках, шкафах или электронной системе. Вы не должны знать об этом. Если завтра компания перейдёт с бумажного архива на электронный, ваш способ обращения к секретарю не изменится. Точно так же, если вы замените SQLite на другую базу (через `SupportSQLiteDatabase`), ваш DAO-интерфейс останется прежним.

### @Insert, @Update, @Delete: автогенерация

Для стандартных CRUD-операций Room генерирует SQL автоматически. Вам не нужно писать `INSERT INTO users VALUES (...)` вручную -- достаточно аннотации.

`@Insert` принимает один объект или список. Параметр `onConflict` определяет, что делать при конфликте primary key: `REPLACE` перезапишет строку, `IGNORE` пропустит, `ABORT` (по умолчанию) выбросит исключение. Метод может возвращать `Long` (ID вставленной строки) или `List<Long>` (для списка).

`@Update` находит строку по primary key и обновляет все остальные колонки. Возвращает `Int` -- количество обновлённых строк. Если строка с таким primary key не найдена -- ничего не произойдёт, ошибки не будет.

`@Delete` также находит строку по primary key и удаляет её. Возвращает `Int` -- количество удалённых строк.

### @Query: compile-time проверка SQL

`@Query` -- самая мощная аннотация Room. Она принимает произвольный SQL-запрос и проверяет его при компиляции. Параметры передаются через `:paramName`, и Room автоматически экранирует их -- SQL injection невозможен.

Покажем типичный DAO с разными типами запросов.

```kotlin
@Dao
interface TaskDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(task: Task): Long           // Возвращает ID

    @Query("SELECT * FROM tasks WHERE project_id = :projectId ORDER BY due_date")
    fun getByProject(projectId: Long): Flow<List<Task>>  // Реактивный поток

    @Query("SELECT * FROM tasks WHERE id = :id")
    suspend fun getById(id: Long): Task?           // Одноразовый запрос

    @Query("SELECT COUNT(*) FROM tasks WHERE is_completed = 0")
    fun getActiveCount(): Flow<Int>                // Скаляр через Flow

    @Update
    suspend fun update(task: Task)                 // По primary key

    @Delete
    suspend fun delete(task: Task)                 // По primary key

    @Query("DELETE FROM tasks WHERE is_completed = 1")
    suspend fun deleteCompleted(): Int             // Кастомное удаление
)
```

Этот DAO показывает ключевое решение: `suspend` vs `Flow`. Методы с `suspend` выполняются один раз и возвращают результат. Методы с `Flow` возвращают поток, который автоматически переэмитит данные при любом изменении таблицы. Правило простое: если данные показываются на экране и должны обновляться при изменениях -- `Flow`. Если вам нужен одноразовый снимок (например, для валидации перед сохранением) -- `suspend`.

### @Transaction: атомарные операции

Когда операция включает несколько запросов, которые должны выполниться "всё или ничего", используется `@Transaction`. Без неё Room оборачивает каждый метод в отдельную транзакцию. С `@Transaction` все запросы внутри метода выполняются в одной транзакции.

Типичный случай: вы хотите удалить старые данные и вставить новые. Без транзакции возможна ситуация: старые удалены, но вставка упала -- пользователь видит пустой экран. С транзакцией: либо всё успешно, либо ничего не произошло.

```kotlin
@Dao
abstract class ProjectDao {
    @Insert
    abstract suspend fun insertProject(project: Project): Long

    @Insert
    abstract suspend fun insertTasks(tasks: List<Task>)

    @Transaction  // Всё или ничего: проект + задачи
    open suspend fun insertProjectWithTasks(
        project: Project,
        tasks: List<Task>
    ) {
        val projectId = insertProject(project)
        val tasksWithProject = tasks.map { it.copy(projectId = projectId) }
        insertTasks(tasksWithProject)
    }
}
```

Здесь `@Transaction` гарантирует: если вставка задач упадёт (например, нарушен foreign key), вставка проекта тоже откатится. Обратите внимание, что DAO должен быть `abstract class` (не `interface`), потому что `@Transaction` требует реализацию метода (тело функции), а интерфейсы в Kotlin не поддерживают `open` методы с телом для Room.

Мы разобрали Entity (что хранить) и DAO (как обращаться). Осталось понять, где эти компоненты объединяются.

---

## Database: RoomDatabase class

### Единая точка входа

`RoomDatabase` -- это абстрактный класс, аннотированный `@Database`, который связывает Entity и DAO вместе. Он перечисляет все Entity (таблицы) и предоставляет абстрактные методы для получения DAO. При компиляции Room генерирует реализацию этого класса (`AppDatabase_Impl`), которая содержит логику создания таблиц, миграций и предоставления DAO.

### Singleton: почему экземпляр один

RoomDatabase должен быть singleton -- один экземпляр на всё приложение. Причина -- в архитектуре SQLite. SQLite использует файловые блокировки для обеспечения thread safety: только один процесс может писать в файл одновременно. Если создать несколько экземпляров `RoomDatabase`, каждый откроет своё соединение с файлом, и при одновременной записи возникнут конфликты блокировок (`SQLiteDatabaseLockedException`).

Кроме того, RoomDatabase содержит `InvalidationTracker` -- механизм отслеживания изменений для Flow-запросов. Если экземпляров несколько, изменение через один не уведомит Flow через другой -- реактивность сломается.

Паттерн Double-Checked Locking с `@Volatile` и `synchronized` -- стандартный способ создания singleton в многопоточной среде.

Покажем типичную реализацию RoomDatabase.

```kotlin
@Database(
    entities = [Project::class, Task::class],  // Все таблицы
    version = 1,
    exportSchema = true    // Экспортировать JSON-схему для тестов миграций
)
@TypeConverters(AppConverters::class)
abstract class AppDatabase : RoomDatabase() {
    abstract fun projectDao(): ProjectDao
    abstract fun taskDao(): TaskDao

    companion object {
        @Volatile private var INSTANCE: AppDatabase? = null

        fun getInstance(context: Context): AppDatabase =
            INSTANCE ?: synchronized(this) {
                INSTANCE ?: Room.databaseBuilder(
                    context.applicationContext,  // НЕ Activity context -- утечка памяти
                    AppDatabase::class.java,
                    "app_database"
                ).build().also { INSTANCE = it }
            }
    }
}
```

Обратите внимание на `context.applicationContext`: используется контекст приложения, а не Activity. Если передать Activity context, RoomDatabase будет удерживать ссылку на Activity после её уничтожения -- классическая утечка памяти. `exportSchema = true` экспортирует JSON-файл со схемой базы данных в папку сборки -- это необходимо для тестирования миграций и для аудита изменений схемы.

### Callbacks: жизненный цикл базы данных

RoomDatabase предоставляет три callback-а, которые позволяют выполнить код на определённых этапах жизненного цикла базы данных.

`onCreate` вызывается один раз -- когда база создаётся впервые на устройстве. Это идеальное место для pre-population: заполнения базы начальными данными. Например, приложение со справочником городов может загрузить список городов из JSON-файла в assets при первом запуске.

`onOpen` вызывается при каждом открытии базы данных. Полезно для выполнения PRAGMA-команд (например, `PRAGMA foreign_keys = ON`, которая включает поддержку foreign keys в SQLite -- по умолчанию она отключена).

`onDestructiveMigration` вызывается, когда Room не нашёл подходящую миграцию и пересоздал базу с нуля (если вы использовали `.fallbackToDestructiveMigration()` в builder). Это сигнал: все данные потеряны. Используйте callback для логирования или уведомления пользователя.

### Thread safety и internal locking

Room внутри использует механизм блокировок, чтобы гарантировать безопасность при параллельном доступе из нескольких корутин. SQLite поддерживает Write-Ahead Logging (WAL mode), который Room включает по умолчанию. WAL позволяет одному потоку писать, пока другие читают, -- без блокировки читателей. Это означает, что Flow-подписки продолжают получать данные даже во время записи.

Однако два одновременных write-вызова всё равно сериализуются: второй ждёт завершения первого. Room управляет этим через internal executor, и вам не нужно использовать собственные мьютексы или synchronized-блоки для доступа к DAO.

Мы разобрали три основных компонента Room. Теперь углубимся в связи между Entity -- одну из самых мощных, но и самых запутанных возможностей.

---

## Relations: связи между Entity

### Зачем нужны связи

В реальных приложениях данные редко существуют изолированно. Пользователь имеет посты, проект содержит задачи, заказ включает товары. В реляционных базах данных эти связи моделируются через foreign keys и JOIN-запросы. Room предоставляет аннотации для декларативного описания связей без ручного написания JOIN.

Понимание связей в Room критично для проектирования базы данных. Неправильно выбранный тип связи приводит к проблемам: денормализация через JSON-строки (нарушение 1NF) ломает возможность поиска, а избыточные JOIN для простых вложенных объектов создают лишнюю сложность. Room предоставляет три инструмента для трёх разных ситуаций: `@Embedded`, `@Relation`, `@Junction`.

### @Embedded: вложенные объекты

`@Embedded` позволяет включить поля одного объекта в другой на уровне одной таблицы. Это НЕ связь между таблицами -- это декомпозиция одной таблицы на логические группы.

### Аналогия: Embedded как вкладыш в конверт

Представьте конверт (Entity) с письмом. В конверт вы вкладываете визитную карточку (Embedded-объект). Это не отдельное письмо -- это часть того же конверта. В базе данных все поля визитки хранятся в той же строке, что и письмо. Не нужен отдельный конверт (таблица), не нужен адрес (foreign key).

### @Relation: one-to-one, one-to-many

`@Relation` описывает связь между двумя отдельными таблицами. Room выполняет два запроса: сначала загружает родительский Entity, потом -- дочерние, и объединяет результаты в памяти.

### Аналогия: Relation как ссылка на другое дело в архиве

Если Embedded -- это вкладыш в конверт (всё в одном месте), то Relation -- это записка: "Подробности см. в деле N547, шкаф 3". Вы открываете одно дело (родительский Entity), видите ссылку, идёте к другому шкафу (другая таблица), находите связанные документы (дочерние Entity). Это два отдельных хранилища, связанных ссылкой.

### @Junction: many-to-many

Связь "многие-ко-многим" требует промежуточную таблицу (junction table). Классический пример: студент записан на несколько курсов, каждый курс имеет несколько студентов. Промежуточная таблица `StudentCourseCrossRef` хранит пары (studentId, courseId).

Покажем все три типа связей.

```kotlin
// Embedded: Address -- часть User, НЕ отдельная таблица
data class Address(
    val street: String,
    val city: String,
    @ColumnInfo(name = "zip_code") val zipCode: String
)

@Entity(tableName = "users")
data class User(
    @PrimaryKey val id: Long,
    val name: String,
    @Embedded val address: Address  // Колонки street, city, zip_code в таблице users
)

// Relation one-to-many: User -> List<Post>
data class UserWithPosts(
    @Embedded val user: User,
    @Relation(parentColumn = "id", entityColumn = "user_id")
    val posts: List<Post>           // Room выполнит второй SELECT автоматически
)
```

Здесь `UserWithPosts` -- это не Entity (нет `@Entity`), а result class. Room при вызове `@Query` для `UserWithPosts` выполнит два запроса: `SELECT * FROM users` и `SELECT * FROM posts WHERE user_id IN (...)`, а затем объединит результаты по ключам.

### @Junction: подробнее о many-to-many

Связь "многие-ко-многим" -- наиболее сложная из трёх типов. В реляционных базах данных она невозможна напрямую: нельзя хранить "список ID" в одной ячейке (это нарушает 1NF). Решение -- промежуточная таблица (junction table, или cross-reference table), которая хранит пары ключей.

Room моделирует это через `@Junction`. Вы создаёте Entity для промежуточной таблицы с двумя foreign keys, а в result class указываете `@Relation` с параметром `associateBy = Junction(...)`. Room сгенерирует три запроса: загрузка родителей, загрузка промежуточной таблицы, загрузка дочерних -- и объединит результаты.

Важно помнить: `@Relation` в Room всегда выполняет отдельные запросы (не SQL JOIN). Это упрощает API, но может быть неэффективным для больших наборов данных. Если нужен один оптимизированный JOIN-запрос -- напишите его вручную в `@Query` и используйте Multimap return type.

### Multimap return types (Room 2.4+)

С Room 2.4 появилась возможность возвращать `Map<User, List<Post>>` напрямую из `@Query` с JOIN, без создания отдельного result class. Это значительное упрощение: раньше для каждой комбинации связей нужен был отдельный data class. Теперь можно написать один JOIN-запрос и получить структурированный результат.

Multimap return types работают с `Map`, `ImmutableMap`, `Map<Entity, List<Entity>>` и даже `Map<Entity, Entity>` для one-to-one связей. Room автоматически определяет, как группировать результаты JOIN по ключу.

Для сложных связей (three-way join, nested relations, фильтрация внутри связи) по-прежнему нужны dedicated result classes с `@Relation`. Multimap -- это упрощение для простых случаев, а не замена всего механизма связей.

---

## TypeConverters: конвертация сложных типов

### Проблема: ограниченные типы SQLite

SQLite поддерживает только пять типов данных: `NULL`, `INTEGER`, `REAL`, `TEXT`, `BLOB`. Kotlin-мир богаче: `Date`, `Enum`, `List`, `UUID`, `Instant`. TypeConverter -- это мост между двумя мирами: он преобразует сложный Kotlin-тип в примитив SQLite и обратно.

TypeConverter -- это класс с методами, аннотированными `@TypeConverter`. Каждый метод принимает один тип и возвращает другой. Room автоматически применяет нужный конвертер при записи и чтении.

### Scope TypeConverters

`@TypeConverters` можно применить на трёх уровнях, и выбор уровня влияет на видимость конвертера. На уровне `@Database` -- конвертер действует на все Entity и все DAO в приложении. На уровне конкретного Entity -- только при чтении и записи этой таблицы. На уровне конкретного DAO -- только для запросов этого DAO.

Рекомендация -- применять на уровне Database, чтобы конвертеры были доступны везде. Ситуация, когда один и тот же тип (например, `Date`) конвертируется по-разному в разных таблицах, -- антипаттерн, который приведёт к путанице и ошибкам.

Покажем типичные TypeConverters.

```kotlin
class AppConverters {
    @TypeConverter
    fun fromTimestamp(value: Long?): Date? =  // SQLite Long → Kotlin Date
        value?.let { Date(it) }

    @TypeConverter
    fun dateToTimestamp(date: Date?): Long? =  // Kotlin Date → SQLite Long
        date?.time

    @TypeConverter
    fun fromEnum(value: Priority): String =    // Enum → String (читаемо в DB Browser)
        value.name

    @TypeConverter
    fun toEnum(value: String): Priority =      // String → Enum
        Priority.valueOf(value)
}
```

Каждая пара конвертеров работает в обе стороны: при записи в базу и при чтении из базы. Room определяет, какой конвертер вызвать, по типам аргумента и возвращаемого значения.

### Подводные камни TypeConverters

**Сериализация списков в JSON.** Часто разработчики конвертируют `List<String>` в JSON-строку через Gson или Moshi. Это работает, но нарушает первую нормальную форму (1NF): одна ячейка содержит множество значений. Вы не сможете написать `WHERE tags CONTAINS "kotlin"` -- придётся загружать все строки и фильтровать в Kotlin-коде. Если нужен поиск по элементам списка -- используйте отдельную таблицу с `@Relation`.

**Null safety.** TypeConverter должен корректно обрабатывать `null`. Если колонка nullable (`Long?`), а конвертер принимает только `Long` -- crash при чтении NULL из базы. Рекомендация: всегда делайте параметры и возвращаемые типы конвертеров nullable, даже если "сейчас null не бывает". Схема базы может измениться, а старые конвертеры остаются.

**Enum и обратная совместимость.** Если Enum конвертируется через `ordinal` (индекс), добавление нового значения в середину enum сломает все существующие данные. Представьте: enum `Priority` имеет `LOW(0)`, `MEDIUM(1)`, `HIGH(2)`. Вы добавляете `URGENT` между `MEDIUM` и `HIGH`. Теперь `HIGH = 3`, но в базе хранятся строки с `2`, означавшие `HIGH`, -- а Room прочитает их как `URGENT`. Конвертируйте через `name` -- строковое имя стабильнее числового индекса. Строка `"HIGH"` останется `"HIGH"` независимо от порядка в enum.

**Производительность конвертеров.** TypeConverter вызывается для каждой строки результата запроса. Если конвертер делает тяжёлую работу (парсинг JSON через Gson), это может замедлить чтение тысяч строк. Для сложных конвертеров рассмотрите ленивую десериализацию или кэширование результатов.

---

## Reactive queries с Flow

### Как работает InvalidationTracker

Мы разобрали TypeConverters. Теперь -- одна из самых мощных возможностей Room: реактивные запросы через Flow.

Когда DAO-метод возвращает `Flow<List<Task>>`, Room не просто выполняет один запрос. Он регистрирует "наблюдателя" в `InvalidationTracker` -- внутреннем механизме, который отслеживает изменения в таблицах. InvalidationTracker использует SQLite triggers: при каждом INSERT, UPDATE или DELETE в таблице триггер записывает факт изменения во внутреннюю служебную таблицу.

Когда Room обнаруживает, что таблица изменилась, он перевыполняет запрос и эмитит новый результат во все Flow, подписанные на эту таблицу. Именно перевыполняет целиком -- Room не знает, какие именно строки изменились, только что таблица "невалидна".

### Критический момент: granularity уведомлений

InvalidationTracker отслеживает изменения на уровне **таблицы**, не строки. Это значит: если вы обновите поле `isCompleted` у задачи с id=5, Flow, наблюдающий за задачей с id=10, тоже получит уведомление и перевыполнит запрос.

Для большинства приложений это не проблема -- запросы к SQLite быстрые (микросекунды для сотен строк). Но если вы наблюдаете за таблицей с тысячами строк, которая обновляется часто (например, при пагинации с сервера), это может вызвать лишнюю работу.

> **Ключевая идея:** `distinctUntilChanged()` -- обязательный оператор для Flow из Room. Он фильтрует повторные эмиссии, когда данные не изменились. Без него UI может перерисовываться при каждом INSERT в таблицу, даже если конкретный запрос возвращает тот же результат.

```kotlin
// Без distinctUntilChanged: Flow emit при ЛЮБОМ изменении таблицы tasks
val tasks: Flow<List<Task>> = taskDao.getByProject(projectId)

// С distinctUntilChanged: Flow emit только когда результат запроса изменился
val tasks: Flow<List<Task>> = taskDao.getByProject(projectId)
    .distinctUntilChanged()  // Сравнивает список, emit только при реальном изменении
```

Этот код демонстрирует разницу: первый вариант переэмитит список при ЛЮБОЙ операции над таблицей `tasks` (даже при изменении задач другого проекта). Второй -- только когда результат `SELECT * FROM tasks WHERE project_id = :projectId` действительно вернёт другие данные.

### Внутренний механизм: как Room узнаёт об изменениях

Стоит разобраться глубже, КАК InvalidationTracker узнаёт об изменениях. Room при создании базы данных добавляет специальную служебную таблицу `room_table_modification_log`. Для каждой пользовательской таблицы Room создаёт SQLite trigger (триггер) на INSERT, UPDATE и DELETE. Каждый триггер записывает в `room_table_modification_log` номер таблицы, которая изменилась.

Периодически (после каждой транзакции) Room проверяет эту служебную таблицу. Если в ней есть записи -- значит, какие-то таблицы изменились. Room определяет, какие Flow подписаны на изменённые таблицы, перевыполняет их запросы и эмитит новые данные. После этого служебная таблица очищается.

Этот механизм объясняет, почему уведомления работают на уровне таблицы: триггер не знает, какая именно строка изменилась -- он знает только, что таблица была модифицирована. Также это объясняет, почему Room не поддерживает real-time уведомления от другого процесса: триггеры работают только внутри того же SQLite-соединения.

### Flow vs LiveData

Ранние версии Room (1.0-2.2) использовали LiveData для реактивных запросов. С Room 2.2+ появилась поддержка Flow, и сегодня она рекомендуется вместо LiveData. Причины:

| Критерий | LiveData | Flow |
|----------|----------|------|
| **Жизненный цикл** | Привязан к lifecycle (pause/resume) | Управляется CoroutineScope |
| **Операторы** | Минимальные (map, switchMap) | Полный набор (map, filter, combine, debounce, flatMapLatest) |
| **Threading** | Только Main Thread для observe | Любой dispatcher через flowOn |
| **Тестирование** | Нужен InstantTaskExecutorRule | Стандартные корутины (runTest) |
| **Многоплатформенность** | Только Android | Kotlin Multiplatform |

Flow лучше, потому что он не привязан к Android-платформе, предоставляет мощные операторы трансформации и естественно интегрируется с корутинами. LiveData остаётся в старых проектах, но для нового кода рекомендуется Flow.

Переход с LiveData на Flow в Room прост: замените тип возвращаемого значения DAO-метода с `LiveData<List<Task>>` на `Flow<List<Task>>`. В ViewModel используйте `stateIn()` для конвертации cold Flow в hot StateFlow, привязанный к viewModelScope. В Compose используйте `collectAsStateWithLifecycle()` вместо `observeAsState()`. Миграция пошаговая: можно менять по одному DAO-методу, не трогая остальные.

---

## Room + Paging 3

Мы разобрали реактивные запросы. Но что если данных тысячи строк -- загружать все в память?

Room интегрируется с библиотекой Paging 3, позволяя загружать данные постранично прямо из SQLite. DAO-метод возвращает `PagingSource<Int, Task>`, а Paging 3 автоматически загружает страницы при прокрутке RecyclerView или LazyColumn.

Для приложений с серверной пагинацией (сервер + локальный кэш) используется `RemoteMediator` -- компонент, который загружает данные с сервера, сохраняет их в Room, а `PagingSource` из Room подаёт их в UI. Это реализация паттерна Single Source of Truth на уровне пагинации: UI всегда читает из базы, а RemoteMediator только пополняет её.

Почему это важно? Без пагинации приложение с 10,000 задач загрузит все в память одним запросом. С пагинацией Room загружает 20-50 элементов за раз, и подгружает следующую страницу при прокрутке. Это критично для производительности и потребления памяти на мобильных устройствах с ограниченными ресурсами.

Интеграция Room + Paging 3 элегантна: Room генерирует `PagingSource`, который знает общее количество строк и умеет загружать произвольную страницу через `SELECT ... LIMIT :limit OFFSET :offset`. При изменении данных (INSERT, DELETE) `PagingSource` автоматически инвалидируется через InvalidationTracker, и Paging 3 запрашивает данные заново.

Детальный разбор Paging 3 -- тема для отдельного deep-dive. Здесь важно понять принцип: Room предоставляет `PagingSource`, а не `List` или `Flow<List>`, и Paging 3 берёт на себя управление загрузкой и отображением страниц.

---

## Room KMP (2.7.0+)

С версии 2.7.0 Room поддерживает Kotlin Multiplatform. Это стало возможным благодаря абстракции `SupportSQLiteDatabase` и модульной архитектуре Room: платформо-зависимый код вынесен в драйверы.

### Поддерживаемые платформы

| Платформа | Драйвер | Статус |
|-----------|---------|--------|
| Android | `AndroidSQLiteDriver` | Стабильный |
| iOS | `NativeSQLiteDriver` (через SQLite C API) | Стабильный |
| JVM (Desktop) | `BundledSQLiteDriver` | Стабильный |
| Native (Linux, macOS) | `NativeSQLiteDriver` | Экспериментальный |

### Что работает на всех платформах

Entity, DAO, @Query, TypeConverters, Migrations -- всё работает одинаково на всех поддерживаемых платформах. Room генерирует platform-specific реализации через expect/actual механизм KMP. DAO-интерфейс вы пишете один раз в `commonMain`, а Room генерирует `_Impl` для каждой целевой платформы.

Это стало возможным благодаря архитектурному решению, принятому ещё в Room 1.0: абстракция через `SupportSQLiteDatabase`. Разработчики Room не привязывали библиотеку к конкретной реализации SQLite -- они работали через интерфейс. Годы спустя это решение окупилось: достаточно было реализовать `SupportSQLiteDatabase` для iOS (через C-библиотеку SQLite) и Desktop (через bundled SQLite), и весь annotation processing заработал на новых платформах.

### Ограничения KMP-версии

Не все возможности Room доступны на всех платформах. AutoMigration работает только на Android (зависит от Android framework). Callback `onOpen` и `onCreate` могут вести себя по-разному на разных драйверах. FTS (Full-Text Search) ограничен возможностями конкретной сборки SQLite на целевой платформе.

Кроме того, тестирование на разных платформах сложнее: `MigrationTestHelper` -- Android-only инструмент, и для iOS/Desktop нужно писать собственные тесты миграций. Инструменты инспекции базы данных (Database Inspector в Android Studio) также работают только с Android-устройствами.

Если вы планируете KMP-проект с Room, начинайте с commonMain: определите Entity и DAO в общем коде, а Database-singleton создавайте в platform-specific модулях с соответствующими драйверами. Тестируйте на Android (где инструментарий зрелый), а затем верифицируйте на остальных платформах.

---

## Распространённые заблуждения

| Миф | Реальность | Почему это заблуждение |
|-----|-----------|----------------------|
| "Room медленнее чистого SQLite" | Room генерирует код, идентичный ручному. Overhead -- только при компиляции, не в runtime. Сгенерированный `_Impl` вызывает тот же `SQLiteDatabase.query()` | Люди путают compile-time cost с runtime cost |
| "@Transaction нужен на каждый метод" | Room автоматически оборачивает каждый `@Insert`/`@Update`/`@Delete` в транзакцию. Явный `@Transaction` нужен только для нескольких операций или read consistency | Перестраховка из мира JDBC, где auto-commit по умолчанию |
| "Flow из Room = точные обновления" | Flow переэмитит при ЛЮБОМ изменении таблицы, даже нерелевантном. Нужен `distinctUntilChanged()` | InvalidationTracker работает на уровне таблиц, не строк |
| "Room заменяет SQL знания" | Room проверяет SQL, но не пишет его за вас. Для JOIN, GROUP BY, HAVING, подзапросов нужно знать SQL | Room -- инструмент проверки, не генератор запросов |
| "autoGenerate = true обязателен" | autoGenerate нужен, когда ID генерирует клиент. Если ID приходит с сервера -- используйте серверный ID как primary key | Привычка из автоинкрементных баз |
| "Entity = Domain model" | Entity привязан к схеме БД. Domain model -- к бизнес-логике. Смешение ломает оба слоя при изменении одного | Упрощение "зачем два класса для одного объекта" |
| "Room работает только на Android" | С версии 2.7 Room поддерживает KMP: iOS, Desktop, Native | Устаревшая информация до 2024 года |

---

## Когда НЕ использовать Room

Room -- отличный выбор для большинства Android-приложений, но не для всех. Вот ситуации, когда альтернативы лучше.

**SQLDelight -- когда KMP с полным контролем над SQL.** SQLDelight работает наоборот: вы пишете SQL-файлы, а SQLDelight генерирует Kotlin-интерфейсы. Если ваша команда сильна в SQL и хочет полный контроль над запросами в KMP-проекте, SQLDelight может быть удобнее Room. Room KMP пока моложе и имеет больше ограничений.

**Realm -- когда нужна realtime-синхронизация.** Realm Sync предоставляет встроенную синхронизацию с облаком (MongoDB Atlas). Если ваше приложение -- мессенджер или collaborative tool, где данные должны синхронизироваться в реальном времени между устройствами, Realm Sync решает эту задачу из коробки. С Room вам придётся строить синхронизацию самостоятельно.

**ObjectBox -- когда NoSQL семантика важнее SQL.** ObjectBox -- объектная база данных без SQL. Если ваши данные -- глубоко вложенные объекты без реляционных связей (иерархические документы, конфигурации), ObjectBox может быть проще: не нужно думать о нормализации и JOIN.

**Чистый SQLite -- когда Room overhead при компиляции критичен.** В проектах с 50+ Entity Room annotation processing может добавлять 15-30 секунд к каждой инкрементальной сборке. Если это неприемлемо, а compile-time проверка не критична (например, для внутреннего инструмента с одним разработчиком), чистый SQLite через `SupportSQLiteDatabase` -- легитимный выбор.

**Embedded databases с другой семантикой.** Если ваши данные -- это временные сессии (пользователь авторизовался, работает, вышел -- данные не нужны), full-blown Room с миграциями -- overkill. Рассмотрите in-memory хранилище или простой key-value store через DataStore. Room оправдан, когда данные должны пережить process death и сохраняться между сессиями.

Принцип выбора можно свести к вопросу: "Нужны ли мне SQL-запросы (WHERE, JOIN, GROUP BY) и compile-time проверка?" Если да -- Room. Если нет -- скорее всего, существует более простой инструмент для вашей задачи.

---

## Подводные камни

### 1. Запросы на Main Thread

Room по умолчанию запрещает запросы на Main Thread и бросает `IllegalStateException`. Существует метод `.allowMainThreadQueries()` в builder, но использовать его -- антипаттерн. Даже простой `SELECT COUNT(*)` может заблокировать UI на 16 мс (один кадр), а при большой таблице или конкурентной записи -- на сотни миллисекунд.

Почему Room так строг? Потому что SQLite операции включают файловый I/O. Файловая система -- непредсказуемый ресурс: чтение может занять микросекунды на SSD и десятки миллисекунд на eMMC (дешёвые Android-устройства). Кроме того, если другой поток пишет в базу, чтение ждёт снятия блокировки. Поэтому всегда используйте `suspend` или `Flow`, и Room выполнит запрос вне Main Thread автоматически.

### 2. Забытый exportSchema

Если `exportSchema = true` (рекомендуется), Room экспортирует JSON-файл со схемой в папку build. Нужно указать путь в `build.gradle.kts`:

```kotlin
ksp {
    arg("room.schemaLocation", "$projectDir/schemas")
}
```

Без этого -- warning при компиляции. Экспортированные схемы нужны для `MigrationTestHelper`, который автоматически тестирует миграции.

### 3. Множественные операции без @Transaction

Если вы вызываете несколько DAO-методов подряд (delete + insert), каждый выполняется в своей транзакции. При crash между ними данные могут оказаться в inconsistent state. Оборачивайте в `@Transaction` или используйте `withTransaction` на RoomDatabase.

### 4. Неправильный scope для TypeConverters

TypeConverter, объявленный на уровне Entity, не будет работать для DAO-запросов, возвращающих этот тип из другого Entity. Объявляйте на уровне `@Database` -- это гарантирует доступность везде.

### 5. Большие объекты в Entity

Хранение больших JSON-строк или BLOB (изображения) в Entity замедляет запросы: SQLite загружает все колонки строки, даже если SELECT выбирает только одну. Для больших данных: храните файл в `filesDir`, а в Entity -- путь к файлу.

### 6. Flow без lifecycle awareness

`Flow` из Room -- cold flow. Он активен, пока есть подписчик. Если `collect` вызван в Activity без привязки к lifecycle, Flow будет работать даже когда Activity в фоне -- лишняя работа CPU и батареи. Используйте `repeatOnLifecycle(Lifecycle.State.STARTED)` или `collectAsStateWithLifecycle()` в Compose.

### 7. Пересоздание базы при каждом запуске (inMemoryDatabaseBuilder)

`Room.inMemoryDatabaseBuilder()` создаёт базу в оперативной памяти -- без файла на диске. Данные теряются при завершении процесса. Это полезно для тестов (каждый тест начинает с чистой базы), но категорически не подходит для production. Иногда разработчики используют in-memory базу "для скорости", не осознавая, что данные исчезнут при сворачивании приложения на фоне (Android может убить процесс в любой момент).

### 8. Игнорирование schema export

Если `exportSchema = false` или не настроен путь для экспорта, Room не сохраняет JSON-схему. Это означает: невозможно использовать `MigrationTestHelper` для автоматического тестирования миграций, невозможно просмотреть историю изменений схемы, невозможно обнаружить случайные изменения Entity до release. Рекомендация: всегда `exportSchema = true` и добавляйте папку `schemas/` в git.

---

## Связь с другими темами

**[[android-data-persistence]]** -- обзорный файл по всем способам хранения данных на Android: Room, DataStore, Files. Текущий deep-dive раскрывает Room подробно, а Data Persistence даёт контекст выбора: когда Room, когда DataStore, когда файлы. Рекомендуется прочитать Data Persistence первым, чтобы понять место Room среди альтернатив, и возвращаться к нему после этого deep-dive для закрепления.

**[[android-room-migrations]]** -- отдельный deep-dive по миграциям схемы базы данных. В текущем файле миграции упомянуты, но не раскрыты. Migrations deep-dive покрывает AutoMigration, ручные миграции, тестирование миграций через `MigrationTestHelper`, и стратегии безопасного обновления схемы в production. Изучайте после освоения Entity и Database.

**[[android-room-performance]]** -- deep-dive по оптимизации производительности Room: индексы, EXPLAIN QUERY PLAN, WAL mode, prepared statements, benchmark Room vs raw SQLite. Текущий файл объясняет архитектуру, Performance deep-dive -- как сделать её быстрой. Изучайте, когда столкнётесь с реальными проблемами производительности.

**[[android-datastore-guide]]** -- альтернатива Room для простых key-value данных. DataStore заменяет SharedPreferences и подходит для настроек (тема, язык, feature flags). Если данные не имеют реляционной структуры и не нужны SQL-запросы -- DataStore проще и легче. Понимание обеих технологий позволяет выбрать правильный инструмент.

**[[android-repository-pattern]]** -- Repository pattern координирует данные из нескольких источников: Room (локальные), Retrofit (сетевые), in-memory cache. Room DAO используется как Local Data Source внутри Repository, обеспечивая Single Source of Truth. Текущий файл объясняет Room изолированно, Repository pattern -- как Room встраивается в архитектуру приложения. Изучайте параллельно или после Room deep-dive. Важно: SSOT, offline-first стратегии и кэширование подробно раскрыты в Repository pattern и не дублируются здесь.

**[[kotlin-coroutines]]** -- все suspend-методы DAO выполняются через корутины. Без понимания Dispatchers, structured concurrency и CoroutineScope невозможно правильно вызывать Room DAO: какой dispatcher использовать (Room использует свой internal dispatcher), как обрабатывать ошибки (`try/catch` vs `runCatching`), как отменять запросы при уходе с экрана.

**[[kotlin-flow]]** -- Flow из Room -- это cold flow, эмитящий новые данные при изменении таблицы. Понимание операторов Flow критично: `distinctUntilChanged()` для фильтрации ложных обновлений, `map` для трансформации Entity в Domain model, `combine` для объединения данных из разных DAO, `flatMapLatest` для зависимых запросов (выбрал проект -> загрузить задачи).

**[[database-design-optimization]]** -- нормализация, индексы, EXPLAIN QUERY PLAN, денормализация для производительности. Room работает поверх SQLite, и все принципы реляционного проектирования применимы: 1NF/2NF/3NF определяют, как структурировать Entity, индексы ускоряют WHERE-запросы. Изучайте для глубокого понимания, почему Room Entity спроектирован именно так.

---

## Источники и дальнейшее чтение

- **Meier R. (2022).** *Professional Android.* -- подробное описание Room с production-ready примерами Entity, DAO, миграций и TypeConverters. Рекомендуется как практическое руководство после понимания теории из текущего файла.

- **Phillips B. et al. (2022).** *Android Programming: The Big Nerd Ranch Guide.* -- пошаговое руководство по Room от основ до Relations. Отличная книга для тех, кто предпочитает учиться через building -- каждая глава строит реальное приложение.

- **Alur D., Crupi J., Malks D. (2003).** *Core J2EE Patterns: Best Practices and Design Strategies.* -- оригинальное описание паттерна DAO (Data Access Object), который Room реализует через аннотации. Понимание первоисточника помогает осознать, почему DAO -- интерфейс, а не класс, и почему он абстрагирует источник данных.

- **Muntenescu F. (2017-2022).** *7 Steps to Room / Room series on Medium.* -- серия статей от Developer Advocate Google, объясняющая design decisions Room: почему compile-time verification, почему annotation processing, почему Flow вместо LiveData. Лучший источник для понимания "почему так", а не только "как".

- **Android Developers (2024).** *Save Data in a Local Database Using Room.* -- официальная документация. Всегда актуальна, содержит последние API и best practices. Используйте как reference после прочтения текущего deep-dive.

- **Android Developers (2024).** *Room KMP Migration Guide.* -- руководство по использованию Room в Kotlin Multiplatform проектах. Покрывает платформо-специфичные драйверы, ограничения и migration path с Android-only Room.

---

*Создано: 2026-02-11 | На основе официальной документации Android, Core J2EE Patterns и серии статей Florina Muntenescu*
