---
title: "Миграции Room: обновление схемы без потери данных"
created: 2026-02-11
modified: 2026-02-11
type: deep-dive
area: android
status: published
confidence: high
cs-foundations: [database-migration, schema-versioning, backward-compatibility, testing]
tags:
  - topic/android
  - topic/data
  - type/deep-dive
  - level/intermediate
related:
  - "[[android-room-deep-dive]]"
  - "[[android-data-persistence]]"
  - "[[android-room-performance]]"
  - "[[android-testing]]"
  - "[[android-ci-cd]]"
prerequisites:
  - "[[android-room-deep-dive]]"
  - "[[android-data-persistence]]"
---

# Миграции Room: обновление схемы без потери данных

У пользователя на телефоне живёт база данных версии 3. Вы выпускаете обновление приложения, где схема БД — уже версия 5. В момент первого запуска новой версии Room должен трансформировать существующие данные под новую структуру — не потеряв ни одной записи. Миграции — это механизм, который делает такую трансформацию контролируемой и предсказуемой. Без миграции пользователь потеряет все локальные данные при обновлении, и никакой «откат из Play Store» это не вернёт.

---

## Зачем это знать

Представьте ситуацию. Вы разрабатываете приложение для заметок. В версии 1.0 у таблицы `notes` три колонки: `id`, `title`, `content`. Приложение работает, пользователи создают заметки, накапливают данные. В версии 2.0 вы добавляете колонку `color` для цветовых меток. Выпускаете обновление в Google Play. Пользователь обновляет приложение — и видит пустой экран. Все его 200 заметок исчезли.

Что произошло? Room обнаружил, что схема базы данных на устройстве (версия 1) не соответствует схеме в коде (версия 2). Не найдя инструкций по преобразованию, Room бросил `IllegalStateException` — приложение крашнулось. Или, если вы по совету со StackOverflow добавили `fallbackToDestructiveMigration()`, Room молча удалил старую базу и создал новую с нуля. Результат один: данные потеряны.

Это не теоретическая проблема. По данным Android Vitals, некорректные миграции — одна из распространённых причин крашей после обновлений. Особенно болезненно это в приложениях, работающих офлайн: мессенджеры, менеджеры задач, финансовые трекеры — везде, где локальная БД является единственным источником данных пользователя.

Понимание миграций позволяет вам менять схему базы данных уверенно: добавлять колонки, создавать новые таблицы, преобразовывать типы данных — всё это без риска потери пользовательских данных и без крашей в production.

Проблема усугубляется тем, что мобильные приложения обновляются асинхронно. В серверном мире вы контролируете момент миграции базы данных: останавливаете сервис, мигрируете, запускаете. На мобильных устройствах каждый пользователь обновляется в своё время. Один обновился вчера, другой — через три месяца. Это значит, что ваши миграции должны корректно работать с любой предыдущей версией схемы. Пользователь мог пропустить пять обновлений и перепрыгнуть с версии 2 сразу на версию 7 — и всё должно работать.

---

## Терминология

| Термин | Значение | Аналогия из жизни |
|--------|----------|-------------------|
| **Migration** | Набор SQL-инструкций для преобразования схемы из одной версии в другую | Инструкция для бригады ремонтников: что именно перестроить в квартире |
| **Schema** | Структура базы данных: таблицы, колонки, типы, индексы, foreign keys | Чертёж квартиры: где стены, двери, розетки |
| **Version** | Целое число в `@Database(version = N)`, идентифицирующее версию схемы | Номер ревизии чертежа |
| **AutoMigration** | Механизм Room 2.4+, автоматически генерирующий SQL для простых изменений | Автопилот: справляется с прямой дорогой без участия водителя |
| **DestructiveMigration** | Fallback: удаление всей БД и создание с нуля | Снос дома вместо ремонта |
| **MigrationTestHelper** | Класс из `room-testing` для тестирования миграций на реальной SQLite | Макет квартиры, на котором пробуют ремонт перед настоящим |
| **SchemaExport** | JSON-файл с полным описанием схемы каждой версии | Архив чертежей: каждая ревизия сохранена |

---

## Историческая справка

Проблема миграции схем баз данных существует столько же, сколько существуют реляционные базы данных. Но на мобильных устройствах она приобретает особую остроту: вы не контролируете момент обновления, не можете откатить изменения, и у каждого пользователя может быть своя версия схемы.

**2008 — SQLiteOpenHelper и ручные миграции.** С первой версии Android SDK разработчики управляли миграциями через `SQLiteOpenHelper`. Метод `onUpgrade(db, oldVersion, newVersion)` вызывался при несовпадении версий. Внутри — ручной SQL. Подход работал, но имел серьёзные недостатки: строковый SQL без проверок на этапе компиляции, единый метод для всех версий (превращался в длинную цепочку `if (oldVersion < N)`), отсутствие инструментов тестирования. Одна опечатка в ALTER TABLE — и тысячи пользователей теряли данные.

**2017 — Room 1.0 (Architecture Components).** Google выпустил Room как часть Architecture Components. Room добавил compile-time проверки SQL, аннотационный процессор для генерации кода и класс `Migration` с чётким контрактом: `startVersion`, `endVersion`, метод `migrate()`. Миграции стали типизированными объектами, но SQL по-прежнему писался вручную. Появился `MigrationTestHelper` для тестирования.

**2020 — Room 2.3: Schema export improvements.** Улучшилась поддержка экспорта схем в JSON. Эти файлы стали ключевым инструментом для автоматической валидации миграций в тестах.

**2021 — Room 2.4: AutoMigration.** Самое значимое обновление системы миграций. Room научился анализировать разницу между схемами двух версий и автоматически генерировать SQL для простых изменений: добавление колонки, добавление таблицы, удаление таблицы. Для неоднозначных изменений (переименование колонки, удаление колонки) появился `AutoMigrationSpec` с аннотациями `@RenameColumn`, `@DeleteColumn`, `@RenameTable`, `@DeleteTable`. Автоматические миграции покрыли примерно 70-80% типичных сценариев, радикально снизив количество ручного SQL.

**2023 — Room 2.6: KSP by default.** Room перешёл с KAPT на KSP (Kotlin Symbol Processing) как основной annotation processor, что ускорило компиляцию и улучшило поддержку Kotlin-специфичных конструкций.

Мы увидели эволюцию от полностью ручного процесса к полуавтоматическому. Но понимание ручных миграций остаётся критичным: AutoMigration покрывает не все сценарии, и когда он не справляется — вы должны уметь написать SQL самостоятельно.

Интересно, что проблема миграций на мобильных устройствах принципиально отличается от серверной разработки. На сервере DBA (Database Administrator) может откатить миграцию, если что-то пошло не так. На мобильном устройстве откат невозможен: обновление прошло, база мигрировала, предыдущей версии больше нет. Это делает тестирование миграций на мобильных платформах критически важным — у вас ровно одна попытка.

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| Room basics (Entity, DAO, Database) | Понимать структуру Room-приложения | [[android-room-deep-dive]] |
| SQL basics (ALTER TABLE, CREATE TABLE) | Писать ручные миграции | [[android-data-persistence]] |
| Основы тестирования Android | Писать migration-тесты | [[android-testing]] |
| Gradle / build.gradle.kts | Настроить schema export и зависимости | [[android-gradle-fundamentals]] |

---

## Аналогия: ремонт квартиры с жильцами внутри

Миграция базы данных — это ремонт квартиры, в которой продолжают жить люди. Вы не можете выселить жильцов (удалить данные), сделать ремонт и заселить обратно. Жильцы (данные) остаются на месте на каждом этапе.

Хотите добавить розетку в стену (добавить колонку)? Просто просверлите отверстие и подключите провод — стена остаётся, мебель на месте. Это самый простой вид ремонта, и Room AutoMigration справляется с ним автоматически.

Хотите объединить две маленькие комнаты в одну большую (объединить таблицы)? Сначала перенесите мебель из обеих комнат в коридор (временная таблица), снесите перегородку, перенесите мебель обратно. Если снести стену первой — мебель раздавит. Порядок шагов критичен.

Хотите сменить газовую плиту на электрическую (изменить тип колонки)? Нельзя просто вырвать газовую — нужно сначала установить электрическую рядом, перенести посуду, а потом демонтировать старую. В SQLite нет `ALTER COLUMN TYPE` — приходится создавать новую таблицу, копировать данные и удалять старую.

Каждый шаг ремонта должен оставлять квартиру пригодной для жизни. Если после шага 3 из 5 отключится электричество (crash приложения), жильцы не должны оказаться на улице. Это принцип атомарности: миграция выполняется в транзакции, и если что-то идёт не так — откатывается полностью.

Ещё одна полезная аналогия — переезд офиса. Компания работает в здании A и переезжает в здание B. Нельзя просто закрыть здание A и открыть B — нужно перевезти все документы, подключить телефоны, настроить интернет. Причём сотрудники продолжают работать во время переезда. Каждый кабинет (таблица) упаковывается, переносится и распаковывается отдельно. Если что-то потерялось при переезде (данные повреждены), бизнес останавливается. Поэтому профессиональные переезды делают по плану, с чеклистом и проверкой после каждого этапа — точно так же, как мы тестируем каждую миграцию.

---

## Как работают миграции в Room

Разобравшись с аналогией, посмотрим на механизм изнутри. Что происходит, когда пользователь запускает обновлённое приложение?

### Последовательность событий

Room хранит версию базы данных в специальном поле заголовка файла SQLite (`PRAGMA user_version`). Каждый SQLite-файл содержит это число — оно записывается при создании или миграции базы. Когда вы указываете `@Database(version = 5)` в коде, Room знает, какая версия схемы ожидается.

При открытии базы данных Room сравнивает два числа: версию в файле SQLite на устройстве и версию в аннотации `@Database` в коде. Если числа совпадают — база открывается нормально. Если версия в коде больше — Room начинает искать путь миграции.

Путь миграции — это цепочка объектов `Migration`, каждый из которых трансформирует схему с одной версии на следующую. Например, если на устройстве версия 2, а в коде версия 5, Room ищет цепочку: `Migration(2,3)` -> `Migration(3,4)` -> `Migration(4,5)`. Каждая миграция выполняется последовательно, в одной транзакции SQLite.

Room также поддерживает shortcut-миграции: `Migration(2,5)` выполнит переход напрямую, минуя промежуточные версии. Это полезно для оптимизации — вместо трёх ALTER TABLE можно написать одну более эффективную трансформацию.

```
Файл SQLite на устройстве         Код приложения
┌─────────────────────┐           ┌──────────────────────┐
│ user_version = 2    │           │ @Database(version = 5)│
└─────────┬───────────┘           └──────────┬───────────┘
          │                                  │
          │         Room сравнивает           │
          └──────────┐  ┌────────────────────┘
                     ▼  ▼
              ┌──────────────┐
              │  2 ≠ 5       │
              │  Ищем путь:  │
              └──────┬───────┘
                     │
          ┌──────────┼──────────┐
          ▼          ▼          ▼
    Migration(2,3) (3,4)     (4,5)
          │          │          │
          └──────────┴──────────┘
                     │
              Или shortcut:
            Migration(2,5)
```

Если Room не находит ни полной цепочки, ни shortcut-миграции — он бросает `IllegalStateException` с сообщением: «A migration from 2 to 5 was required but not found». Приложение крашится. Это осознанное решение разработчиков Room: лучше crash, чем тихая потеря данных.

> **Ключевая идея:** Room выбирает кратчайший путь миграции. Если есть и `Migration(1,3)`, и цепочка `Migration(1,2)` + `Migration(2,3)`, Room предпочтёт shortcut `Migration(1,3)`.

После выполнения всех миграций Room валидирует итоговую схему: проверяет, что все таблицы, колонки, индексы и foreign keys соответствуют описанию в `@Entity` аннотациях. Если валидация не проходит — снова crash. Это второй уровень защиты: даже если SQL в миграции выполнился без ошибок, Room убедится, что результат корректен.

### Почему именно такой подход

Можно было бы спроектировать систему иначе: Room мог бы молча удалять и пересоздавать базу, или автоматически генерировать миграции для всех случаев. Но разработчики Room выбрали «безопасный по умолчанию» (safe by default) подход. Причина — цена ошибки. На сервере потеря данных одного пользователя — инцидент. На мобильном устройстве потеря данных — это потеря доверия пользователя, негативный отзыв в Play Store и удаление приложения. Поэтому Room предпочитает crash (который разработчик увидит в crashlytics и исправит) тихой потере данных (которую пользователь обнаружит, когда его 200 заметок исчезнут).

Этот подход перекликается с философией Kotlin: null safety тоже заставляет разработчика явно обрабатывать nullable-случаи, а не позволяет `NullPointerException` случаться тихо. Явность и предсказуемость — лучше, чем «магия» и неожиданности.

Транзакционность миграции заслуживает отдельного пояснения. Room оборачивает каждую миграцию (не всю цепочку, а каждый отдельный шаг) в SQLite-транзакцию. Если внутри `migrate()` происходит ошибка — все изменения откатываются, и база остаётся в состоянии предыдущей версии. Это означает, что неуспешная миграция не оставляет базу в «полуготовом» состоянии. Пользователь увидит crash, перезапустит приложение — и миграция попробует выполниться снова. Это поведение аналогично ACID-транзакциям в серверных базах данных: атомарность гарантирует, что изменения либо применяются полностью, либо не применяются вовсе.

---

## Manual Migration

Теперь, когда механизм понятен, разберём практику. Ручные миграции — основной инструмент до Room 2.4 и fallback для сложных случаев после. Каждая миграция — это объект класса `Migration` с двумя параметрами (начальная и конечная версия) и методом `migrate()`, содержащим SQL.

### Добавление колонки

Самый частый сценарий: в новой версии Entity появилось новое поле. Допустим, вы добавили поле `avatarUrl` в таблицу `users`. В SQL это одна команда `ALTER TABLE ... ADD COLUMN`.

Обратите внимание на `DEFAULT NULL` — SQLite требует значение по умолчанию для новой колонки, если таблица уже содержит данные. Без `DEFAULT` существующие строки не смогут получить значение для нового поля.

```kotlin
// Миграция с версии 1 на версию 2:
// добавляем колонку avatar_url в таблицу users
val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(db: SupportSQLiteDatabase) {
        db.execSQL(
            "ALTER TABLE users ADD COLUMN avatar_url TEXT DEFAULT NULL"
        )
    }
}
```

После выполнения миграции Room проверит, что таблица `users` содержит колонку `avatar_url` типа `TEXT`, nullable. Если ваш Entity класс объявляет `avatarUrl: String` (не nullable), а миграция создала nullable колонку — валидация провалится. Типы в миграции и в Entity должны совпадать точно.

### Добавление таблицы

Второй по частоте сценарий — новая Entity. Вы добавили таблицу `tags` для системы меток. Миграция содержит полный `CREATE TABLE` с теми же колонками, типами и constraints, что описаны в Entity.

Здесь важен нюанс: SQL в миграции должен точно соответствовать тому, что Room сгенерировал бы для Entity. Самый надёжный способ узнать правильный SQL — посмотреть в экспортированный JSON-файл схемы (об этом ниже). Room генерирует `CREATE TABLE` с конкретными именами, типами и constraints. Если ваш ручной SQL отличается хотя бы в имени индекса — валидация провалится.

```kotlin
// Миграция с версии 2 на 3: создаём таблицу tags
val MIGRATION_2_3 = object : Migration(2, 3) {
    override fun migrate(db: SupportSQLiteDatabase) {
        db.execSQL("""
            CREATE TABLE IF NOT EXISTS tags (
                id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                name TEXT NOT NULL,
                color INTEGER NOT NULL DEFAULT 0
            )
        """)
    }
}
```

Обратите внимание на `IF NOT EXISTS` — это страховка на случай, если таблица каким-то образом уже существует (например, миграция была частично выполнена ранее). Без этой проверки повторный запуск миграции вызовет ошибку.

### Добавление индекса

Индексы ускоряют SELECT-запросы, но замедляют INSERT и UPDATE. Добавление индекса — частая миграция при оптимизации производительности. Если ваш Entity содержит `@Index`, Room ожидает увидеть соответствующий индекс в базе данных.

```kotlin
// Миграция с версии 3 на 4: добавляем индекс на email
val MIGRATION_3_4 = object : Migration(3, 4) {
    override fun migrate(db: SupportSQLiteDatabase) {
        db.execSQL(
            "CREATE INDEX IF NOT EXISTS index_users_email ON users (email)"
        )
    }
}
```

Имя индекса (`index_users_email`) должно совпадать с тем, что Room генерирует для `@Index`. Room использует формат `index_{tableName}_{columnName}`. Если вы назовёте индекс иначе — валидация обнаружит несоответствие.

### Регистрация миграций

Все миграции передаются в `databaseBuilder` через `addMigrations()`. Room сам определит, какие из них нужны для конкретного устройства.

```kotlin
Room.databaseBuilder(context, AppDatabase::class.java, "app.db")
    .addMigrations(
        MIGRATION_1_2,  // Room выберет нужные
        MIGRATION_2_3,  // в зависимости от версии
        MIGRATION_3_4   // на устройстве
    )
    .build()
```

Room выстраивает граф миграций и находит кратчайший путь от текущей версии к целевой. Если вы добавите `MIGRATION_1_4` как shortcut, Room предпочтёт его цепочке из трёх миграций.

### Практический совет: shortcut-миграции

По мере роста приложения количество миграций увеличивается. Проект с двухлетней историей может иметь 15-20 версий схемы. Цепочка из 15 последовательных миграций при обновлении с версии 1 работает, но медленно — каждая миграция открывает транзакцию, выполняет SQL, закрывает транзакцию. Shortcut-миграция позволяет «перепрыгнуть» несколько версий одним эффективным SQL. Например, если миграции 3→4, 4→5 и 5→6 добавляют три колонки по одной, shortcut 3→6 может добавить все три одной операцией. Однако shortcut-миграции нужно поддерживать параллельно с пошаговыми — это дополнительная нагрузка на разработчика и дополнительные тесты. На практике shortcut-миграции оправданы только для очень старых версий или очень больших баз данных, где время миграции критично.

---

## Ограничения SQLite ALTER TABLE

Прежде чем перейти к AutoMigration, необходимо понять ключевое ограничение, которое определяет сложность многих миграций. SQLite — встраиваемая база данных с минималистичным набором команд. В отличие от PostgreSQL или MySQL, SQLite исторически поддерживал крайне ограниченный `ALTER TABLE`.

**До SQLite 3.35 (Android 12, API 31):** ALTER TABLE мог только добавлять колонку (`ADD COLUMN`) и переименовывать таблицу (`RENAME TABLE`). Нельзя было удалить колонку, изменить тип колонки, добавить или удалить constraint. Это означает, что на устройствах с Android 11 и ниже (а это значительная часть аудитории) для удаления колонки нужна процедура из четырёх шагов: создать новую таблицу без лишней колонки, скопировать данные, удалить старую таблицу, переименовать новую.

**SQLite 3.35+ (Android 12+):** Добавлена поддержка `DROP COLUMN`. Но `ALTER COLUMN TYPE` по-прежнему не поддерживается. Если вам нужно изменить тип колонки с `TEXT` на `INTEGER` — создание новой таблицы и копирование данных остаётся единственным путём.

Почему SQLite так ограничен? Это осознанное дизайнерское решение. SQLite — встраиваемая база данных, спроектированная Ричардом Хиппом (D. Richard Hipp) в 2000 году для использования на ракетных крейсерах ВМС США. Приоритеты: надёжность, компактность, нулевая конфигурация. Сложный ALTER TABLE требует перестройки внутренних структур данных (B-tree), что противоречит принципу простоты. PostgreSQL может позволить себе ALTER COLUMN TYPE, потому что за ним стоит отдельный серверный процесс с контролируемыми ресурсами. SQLite работает в адресном пространстве вашего приложения, на устройстве с ограниченной памятью и батареей. Простота внутренней реализации — гарантия надёжности.

> **Ключевая идея:** Ограничения SQLite ALTER TABLE — главная причина сложности миграций. Каждый раз, когда вы не можете решить задачу одним ALTER TABLE, приходится использовать четырёхшаговый паттерн: CREATE → COPY → DROP → RENAME.

Эти ограничения важно держать в голове при проектировании схемы базы данных. Если вы заранее знаете, что тип колонки может измениться — заложите это в первоначальный дизайн. Например, используйте `INTEGER` для дат с самого начала (Unix timestamp), а не `TEXT`. Это избавит от сложной миграции в будущем.

Разобравшись с ограничениями SQLite, переходим к инструменту, который автоматизирует большинство простых миграций.

---

## AutoMigration (Room 2.4+)

Разобравшись с ручными миграциями и ограничениями SQLite, перейдём к автоматизации. AutoMigration — механизм Room, который анализирует JSON-файлы схем двух версий, находит различия и генерирует SQL для миграции автоматически.

### Когда AutoMigration работает

AutoMigration справляется с простыми, однозначными изменениями. Думайте о нём как об автопилоте автомобиля: он отлично едет по прямой дороге, но на сложных перекрёстках нужно переключиться на ручное управление.

| Изменение | AutoMigration справится? |
|-----------|:------------------------:|
| Добавление колонки (с default value) | Да |
| Добавление новой таблицы | Да |
| Удаление таблицы (с `@DeleteTable`) | Да |
| Добавление индекса | Да |
| Удаление колонки (с `@DeleteColumn`) | Да |
| Переименование колонки (с `@RenameColumn`) | Да |
| Переименование таблицы (с `@RenameTable`) | Да |
| Изменение типа колонки | Нет |
| Разделение таблицы на две | Нет |
| Объединение двух таблиц | Нет |
| Добавление foreign key | Нет |
| Сложная трансформация данных | Нет |

### Базовое использование

Для простейших случаев AutoMigration не требует никакого дополнительного кода. Вы добавляете новую колонку в Entity, увеличиваете версию в `@Database` и указываете `autoMigrations`.

```kotlin
// Версия 5 → 6: добавили колонку is_archived
@Database(
    entities = [Note::class],
    version = 6,
    autoMigrations = [
        AutoMigration(from = 5, to = 6)  // Room сам сгенерирует SQL
    ]
)
abstract class AppDatabase : RoomDatabase()
```

Room на этапе компиляции сравнит JSON-схемы версий 5 и 6, обнаружит новую колонку `is_archived` и сгенерирует `ALTER TABLE notes ADD COLUMN is_archived INTEGER NOT NULL DEFAULT 0`. Вам не нужно писать SQL вручную.

### AutoMigrationSpec для неоднозначных изменений

Некоторые изменения Room не может интерпретировать однозначно. Если колонка `color` исчезла и появилась колонка `theme_color` — это переименование или удаление старой и создание новой? Room не может угадать, и попросит вас уточнить через `AutoMigrationSpec`.

Представьте, что вы решили переименовать колонку `color` в `theme_color` и удалить неиспользуемую колонку `legacy_flag`. Room увидит, что `color` исчезла и `theme_color` появилась, но не поймёт связь между ними. `AutoMigrationSpec` явно сообщает Room о намерении.

```kotlin
@Database(
    entities = [Note::class],
    version = 7,
    autoMigrations = [
        AutoMigration(
            from = 6, to = 7,
            spec = AppDatabase.Migration6to7::class  // Подсказки для Room
        )
    ]
)
abstract class AppDatabase : RoomDatabase() {
    @RenameColumn(tableName = "notes", fromColumnName = "color", toColumnName = "theme_color")
    @DeleteColumn(tableName = "notes", columnName = "legacy_flag")
    class Migration6to7 : AutoMigrationSpec
}
```

Доступные аннотации для `AutoMigrationSpec`: `@RenameColumn`, `@RenameTable`, `@DeleteColumn`, `@DeleteTable`. Каждая аннотация устраняет неоднозначность конкретного изменения. Room берёт на себя генерацию SQL, вы лишь указываете намерение.

Здесь стоит обратить внимание на важную деталь: `AutoMigrationSpec` можно использовать не только для разрешения неоднозначностей. Он также позволяет реализовать интерфейс `AutoMigrationSpec` с методом `onPostMigrate(db: SupportSQLiteDatabase)`. Этот метод вызывается после выполнения автоматически сгенерированного SQL и позволяет выполнить дополнительные действия: заполнить новую колонку значениями по умолчанию на основе логики (не просто SQL DEFAULT), обновить данные, создать дополнительные индексы. Это гибридный подход: Room генерирует структурную миграцию, а вы дописываете логику обработки данных.

### Когда AutoMigration не справляется: практические признаки

На этапе компиляции Room сообщит, если AutoMigration не может обработать изменение. Типичное сообщение: «AutoMigration encountered an ambiguous schema change». Это происходит, когда Room видит, что колонка исчезла и одновременно появилась новая — но не может определить, это переименование или удаление плюс создание. Если вы видите такое сообщение — добавьте `AutoMigrationSpec` с соответствующей аннотацией. Если Room сообщает, что изменение «not supported by AutoMigration» — переходите к ручной миграции. Не пытайтесь «обмануть» AutoMigration серией мелких шагов: это может привести к некорректной миграции, которую Room не сможет валидировать.

### Комбинирование Auto и Manual миграций

В реальных проектах часть миграций автоматические, часть ручные. Room позволяет комбинировать оба подхода. AutoMigration указывается в аннотации `@Database`, ручные миграции передаются в `databaseBuilder`.

```kotlin
@Database(
    entities = [Note::class, Tag::class],
    version = 8,
    autoMigrations = [
        AutoMigration(from = 5, to = 6),  // Простое: добавление колонки
        AutoMigration(from = 6, to = 7, spec = Migration6to7::class)
    ]
)
abstract class AppDatabase : RoomDatabase()

// Ручная миграция для сложного случая
val MIGRATION_7_8 = object : Migration(7, 8) {
    override fun migrate(db: SupportSQLiteDatabase) {
        // Сложная трансформация: AutoMigration не справится
        db.execSQL("CREATE TABLE tags_new (...)")
        db.execSQL("INSERT INTO tags_new SELECT ... FROM tags")
        db.execSQL("DROP TABLE tags")
        db.execSQL("ALTER TABLE tags_new RENAME TO tags")
    }
}
```

Room выстраивает единый граф миграций из обоих источников. Порядок выполнения определяется номерами версий, а не порядком объявления.

---

## Destructive Fallback: когда уничтожение допустимо

Иногда потеря данных — приемлемый вариант. Звучит провокационно, но есть сценарии, где destructive fallback оправдан.

### Когда destructive fallback допустим

**Кэш-база данных.** Если база хранит кэш серверных данных, которые можно заново загрузить по API, потеря кэша — это не потеря данных, а лишь необходимость повторной загрузки. Пользователь увидит кратковременный экран загрузки вместо данных из кэша.

**Предрелизные версии.** В alpha/beta-версиях, когда схема меняется ежедневно, писать миграции для каждого изменения непрактично. Бета-тестеры готовы к потере данных.

**Первый запуск после установки.** Если приложение проверяет, залогинен ли пользователь, и при отсутствии сессии перенаправляет на экран авторизации — destructive migration при отсутствии пути миграции может быть приемлема.

### Когда destructive fallback НЕДОПУСТИМ

**Пользовательский контент.** Заметки, сообщения, фотографии, закладки — всё, что пользователь создал вручную. Потеря таких данных вызывает удаление приложения и негативные отзывы.

**Offline-first приложения.** Если база данных — единственный источник данных (нет серверного бэкенда), destructive migration означает полную и невосстановимую потерю данных.

**Финансовые и медицинские данные.** Помимо пользовательского недовольства, потеря таких данных может иметь юридические последствия.

### Варианты API

Room предоставляет два варианта destructive fallback с разной степенью контроля.

```kotlin
// Вариант 1: уничтожать при ЛЮБОМ отсутствующем пути миграции
Room.databaseBuilder(context, AppDatabase::class.java, "cache.db")
    .fallbackToDestructiveMigration()  // Опасно для user data!
    .build()

// Вариант 2: уничтожать только при миграции С конкретных версий
Room.databaseBuilder(context, AppDatabase::class.java, "app.db")
    .fallbackToDestructiveMigrationFrom(1, 2, 3)  // Только с версий 1-3
    .addMigrations(MIGRATION_4_5, MIGRATION_5_6)   // Остальные — ручные
    .build()
```

Второй вариант безопаснее: вы указываете конкретные старые версии, для которых миграция не нужна (например, данные из пре-релизных версий), а для остальных требуете явные миграции.

### Паттерн двух баз данных

Зрелое решение для production-приложений — разделение баз данных. Создайте две отдельные базы: одну для пользовательских данных (с полноценными миграциями), другую для кэша (с destructive fallback). Это позволяет свободно менять структуру кэша, не рискуя пользовательскими данными. Каждая база — отдельный `RoomDatabase` класс, отдельный файл на диске, независимые миграции.

Аналогия из жизни: в больнице есть архив медицинских карт (пользовательские данные) и стенд с расписанием дежурств (кэш). Расписание можно перепечатать в любой момент — оно восстановимо. Медицинские карты уникальны и требуют бережного обращения. Разумная организация хранит их раздельно с разным уровнем защиты.

Перейдём от стратегий уничтожения к стратегиям трансформации — сложным миграциям, где данные нужно не просто сохранить, а преобразовать.

---

## Сложные сценарии миграций

Мы разобрали простые случаи: добавление колонки, таблицы, индекса. Теперь перейдём к ситуациям, где AutoMigration бессилен и нужен ручной SQL. Каждый из этих сценариев требует четырёхшагового паттерна, который напоминает операцию на сердце: нельзя просто «вырезать и заменить» — нужно подключить временный обход, провести операцию и переключить обратно.

### Изменение типа колонки

Типичная ситуация: вы хранили дату как `TEXT` (строка «2026-01-15»), а теперь хотите хранить как `INTEGER` (Unix timestamp). SQLite не позволяет изменить тип колонки через ALTER TABLE — это фундаментальное ограничение, обсуждённое выше.

Решение — четырёхшаговый паттерн. Мы создаём новую таблицу с правильными типами, копируем данные с преобразованием, удаляем старую таблицу и переименовываем новую.

```kotlin
val MIGRATION_4_5 = object : Migration(4, 5) {
    override fun migrate(db: SupportSQLiteDatabase) {
        // 1. Создаём новую таблицу с правильным типом
        db.execSQL("""CREATE TABLE notes_new (
            id INTEGER PRIMARY KEY NOT NULL,
            title TEXT NOT NULL,
            created_at INTEGER NOT NULL
        )""")
        // 2. Копируем с преобразованием TEXT → INTEGER
        db.execSQL("""INSERT INTO notes_new (id, title, created_at)
            SELECT id, title, strftime('%s', created_at)
            FROM notes""")
        // 3. Удаляем старую таблицу
        db.execSQL("DROP TABLE notes")
        // 4. Переименовываем новую
        db.execSQL("ALTER TABLE notes_new RENAME TO notes")
    }
}
```

Что может пойти не так? Функция `strftime('%s', created_at)` вернёт `NULL`, если строка даты в `created_at` не соответствует формату ISO-8601 (`YYYY-MM-DD`). Если хотя бы одна строка содержит дату в формате «15 Jan 2026» — конвертация даст NULL, а колонка объявлена как `NOT NULL`. Миграция провалится. Поэтому перед такой миграцией стоит проверить данные или использовать `COALESCE` для обработки некорректных значений.

### Разделение таблицы на две

Иногда одна таблица «раздувается» — в ней слишком много колонок, часть из которых логически относится к другой сущности. Нормализация базы данных требует разделения.

Допустим, таблица `users` содержит адресные данные (`street`, `city`, `country`), которые вы хотите выделить в отдельную таблицу `addresses` с foreign key на `users`.

```kotlin
val MIGRATION_5_6 = object : Migration(5, 6) {
    override fun migrate(db: SupportSQLiteDatabase) {
        // 1. Создаём таблицу addresses
        db.execSQL("""CREATE TABLE addresses (
            id INTEGER PRIMARY KEY NOT NULL,
            user_id INTEGER NOT NULL,
            street TEXT, city TEXT, country TEXT,
            FOREIGN KEY (user_id) REFERENCES users(id)
                ON DELETE CASCADE
        )""")
        // 2. Переносим адресные данные
        db.execSQL("""INSERT INTO addresses (user_id, street, city, country)
            SELECT id, street, city, country FROM users""")
        // 3-4. Пересоздаём users без адресных колонок
        db.execSQL("""CREATE TABLE users_new (
            id INTEGER PRIMARY KEY NOT NULL,
            name TEXT NOT NULL, email TEXT
        )""")
        db.execSQL("INSERT INTO users_new SELECT id, name, email FROM users")
        db.execSQL("DROP TABLE users")
        db.execSQL("ALTER TABLE users_new RENAME TO users")
    }
}
```

Здесь порядок операций критичен. Если удалить адресные колонки из `users` до создания `addresses`, данные будут потеряны. Сначала создаём целевую таблицу, копируем данные, и только потом удаляем источник.

### Объединение двух таблиц в одну

Обратный случай: две таблицы объединяются. Допустим, `user_profile` и `user_settings` сливаются в одну таблицу `users`, потому что всегда загружаются вместе и разделение создаёт ненужные JOIN-запросы.

Здесь сложность в том, что нужно объединить данные из двух таблиц с matching по ключу. Если у пользователя нет записи в `user_settings` — JOIN потеряет его. Используйте LEFT JOIN, чтобы сохранить всех пользователей, даже без настроек.

```kotlin
val MIGRATION_6_7 = object : Migration(6, 7) {
    override fun migrate(db: SupportSQLiteDatabase) {
        db.execSQL("""CREATE TABLE users_merged (
            id INTEGER PRIMARY KEY NOT NULL,
            name TEXT NOT NULL,
            email TEXT,
            theme TEXT DEFAULT 'light',
            notifications INTEGER DEFAULT 1
        )""")
        // LEFT JOIN: сохраняем пользователей даже без настроек
        db.execSQL("""INSERT INTO users_merged
            SELECT p.id, p.name, p.email,
                   COALESCE(s.theme, 'light'),
                   COALESCE(s.notifications, 1)
            FROM user_profile p
            LEFT JOIN user_settings s ON p.id = s.user_id""")
        db.execSQL("DROP TABLE user_profile")
        db.execSQL("DROP TABLE user_settings")
        db.execSQL("ALTER TABLE users_merged RENAME TO users")
    }
}
```

`COALESCE` обеспечивает значения по умолчанию для пользователей, у которых нет записи в `user_settings`. Без него `theme` и `notifications` стали бы NULL, что может нарушить NOT NULL constraint.

### Добавление foreign key к существующей таблице

Ещё один сценарий, который AutoMigration не поддерживает: добавление foreign key constraint к таблице, которая уже существует. SQLite не позволяет добавить foreign key через ALTER TABLE — constraints задаются только при создании таблицы. Это значит, что для добавления foreign key нужен всё тот же четырёхшаговый паттерн.

Но перед тем как создать foreign key, необходимо убедиться, что данные в таблице удовлетворяют constraint. Если в колонке `category_id` есть значение 42, а в таблице `categories` нет записи с `id = 42` — foreign key constraint будет нарушен. SQLite может не сообщить об этом сразу (foreign keys проверяются при вставке, а не при создании таблицы), но Room валидация обнаружит проблему. Перед миграцией стоит «вычистить» данные: удалить или обновить записи с несуществующими ссылками.

### Общий принцип сложных миграций

Все сложные миграции следуют одному и тому же паттерну, который можно запомнить по аналогии с пересадкой дерева. Нельзя выдернуть дерево и воткнуть его в другое место — корни повредятся. Правильный процесс: выкопать яму на новом месте (CREATE TABLE), пересадить дерево с комом земли (INSERT ... SELECT), засыпать старую яму (DROP TABLE), поставить табличку с названием (RENAME). Каждый раз, когда SQLite не позволяет изменить таблицу напрямую, этот четырёхшаговый паттерн — ваш единственный инструмент.

Теперь, когда мы умеем писать миграции любой сложности, встаёт вопрос: как убедиться, что они работают?

---

## Тестирование миграций

Мы разобрали, как писать миграции. Но как убедиться, что они работают? Тестирование миграций — не опциональный шаг, а критически важная практика. Миграция, не прошедшая тестирование, — это бомба с часовым механизмом. Она может работать на вашем тестовом устройстве с версией 7, но провалиться у пользователя с версией 3.

Аналогия: тестирование миграций — это stress-test ремонта на макете квартиры. Строительная компания не начинает ремонт реальной квартиры без проверки на модели. Вы создаёте базу данных версии N, заполняете тестовыми данными, запускаете миграцию до версии N+1 и проверяете: все ли данные на месте, все ли типы правильные, все ли constraints соблюдены.

### Зависимости для тестирования

Для тестирования миграций нужна библиотека `room-testing`, которая предоставляет `MigrationTestHelper` — специальный JUnit Rule (или Extension для JUnit 5).

```kotlin
// build.gradle.kts
dependencies {
    androidTestImplementation("androidx.room:room-testing:2.6.1")
}
```

### Schema export: основа тестирования

`MigrationTestHelper` использует экспортированные JSON-файлы схем для создания базы данных нужной версии. Без этих файлов тестирование миграций невозможно. Room генерирует JSON-файл для каждой версии схемы, если вы включили `exportSchema = true` (по умолчанию) и указали путь для сохранения.

```kotlin
// build.gradle.kts — указываем KSP куда сохранять схемы
ksp {
    arg("room.schemaLocation", "$projectDir/schemas")
}
```

После компиляции в директории `schemas/` появится JSON-файл для каждой версии. Например, `com.example.AppDatabase/5.json` содержит полное описание схемы версии 5: все таблицы, колонки с типами, индексы, foreign keys.

### Написание migration-теста

Тест миграции создаёт базу данных старой версии, наполняет тестовыми данными, выполняет миграцию и проверяет результат. `MigrationTestHelper` берёт на себя создание базы данных из JSON-схемы и валидацию после миграции.

```kotlin
@RunWith(AndroidJUnit4::class)
class MigrationTest {
    @get:Rule
    val helper = MigrationTestHelper(
        InstrumentationRegistry.getInstrumentation(),
        AppDatabase::class.java  // Room найдёт JSON-схемы автоматически
    )

    @Test
    fun migrate1to2() {
        // 1. Создаём БД версии 1 и вставляем данные
        helper.createDatabase("test-db", 1).apply {
            execSQL("INSERT INTO users (id, name) VALUES (1, 'Alice')")
            close()
        }
        // 2. Запускаем миграцию и валидируем схему
        val db = helper.runMigrationsAndValidate(
            "test-db", 2, true, MIGRATION_1_2
        )
        // 3. Проверяем, что данные сохранились
        val cursor = db.query("SELECT * FROM users WHERE id = 1")
        assert(cursor.moveToFirst())
        assert(cursor.getString(cursor.getColumnIndex("name")) == "Alice")
    }
}
```

Метод `runMigrationsAndValidate` выполняет три действия: запускает указанные миграции, валидирует итоговую схему против JSON-файла целевой версии и возвращает открытую базу данных для дополнительных проверок. Третий параметр (`true`) включает валидацию.

### Тестирование цепочки миграций

Недостаточно тестировать каждую миграцию изолированно. Нужно проверить полный путь: от самой старой версии, которая может быть на устройствах пользователей, до текущей. Это гарантирует, что пользователь с версией 1 сможет обновиться до версии 7 без проблем.

```kotlin
@Test
fun migrateAll() {
    // Создаём самую старую версию
    helper.createDatabase("test-db", 1).apply {
        execSQL("INSERT INTO users (id, name) VALUES (1, 'Bob')")
        close()
    }
    // Выполняем ВСЕ миграции последовательно
    helper.runMigrationsAndValidate(
        "test-db", 7, true,
        MIGRATION_1_2, MIGRATION_2_3, MIGRATION_3_4,
        MIGRATION_4_5, MIGRATION_5_6, MIGRATION_6_7
    )
}
```

Этот тест — ваша главная защита. Если он проходит, вы можете быть уверены, что любой пользователь, независимо от версии на его устройстве, сможет безопасно обновиться.

### Что тестировать помимо схемы

Валидация схемы (`runMigrationsAndValidate`) проверяет структуру, но не данные. Room убедится, что колонка `created_at` существует и имеет тип `INTEGER`, но не проверит, что все даты корректно сконвертированы из `TEXT` в `INTEGER`. Для проверки данных после миграции используйте обычные SQL-запросы к базе данных, возвращённой из `runMigrationsAndValidate`.

Хорошая практика — создавать «граничные» тестовые данные: строки с NULL-значениями, максимально длинные строки, специальные символы (Unicode emoji, RTL текст), экстремальные числа (максимальный Long). Если ваша миграция конвертирует данные — именно граничные случаи чаще всего ломаются. Это аналогично stress-тестированию в строительстве: мост тестируют не только при нормальной нагрузке, но и при максимальной, с учётом ветра, вибрации и перепадов температуры.

### CI/CD интеграция

Тесты миграций должны выполняться при каждом Pull Request, где меняется схема базы данных. Рекомендуемая практика: в CI-пайплайне добавить проверку, что JSON-файл новой версии схемы добавлен в коммит. Без экспортированной схемы тесты не смогут работать.

```
CI Pipeline:
  1. Проверить: JSON-файл новой версии есть в /schemas
  2. Проверить: версия в @Database увеличена
  3. Запустить migration-тесты на instrumented tests
  4. Запустить полный path-тест (от версии 1 до текущей)
```

---

## Schema Export и версионирование

Мы упоминали JSON-файлы схем в разделе о тестировании. Теперь разберём их подробнее — это один из самых недооценённых инструментов Room.

### Что внутри JSON-файла схемы

Каждый JSON-файл содержит полное описание базы данных конкретной версии: все таблицы с колонками (имена, типы, nullable, default values), все индексы (имена, колонки, уникальность), все foreign keys (колонки, таблицы, ON DELETE/ON UPDATE действия), все views.

Эти файлы — эталонное описание того, как должна выглядеть база данных после миграции. `MigrationTestHelper` сравнивает реальную схему после миграции с описанием в JSON. Любое расхождение — ошибка теста.

### Коммит в Git

JSON-файлы схем **обязательно** должны быть закоммичены в Git. Это не артефакт сборки, а часть исходного кода. Без них невозможно тестировать миграции, невозможно воспроизвести проблемы, невозможно выполнить code review миграции.

Добавьте в `.gitignore` исключение для директории `schemas/`:

```
# Не игнорируем Room schemas — они нужны для migration-тестов
!app/schemas/
```

Каждая версия — отдельный файл, и Git хранит полную историю изменений схемы. На code review ревьюер может открыть JSON двух версий, увидеть различия и проверить, что миграция корректно их обрабатывает.

### Зачем хранить ВСЕ версии

Со временем в директории `schemas/` накапливается много файлов: `1.json`, `2.json`, ..., `15.json`. Возникает соблазн удалить старые. Не делайте этого. Каждый JSON-файл — это возможность создать базу данных определённой версии для тестирования. Если вы удалите `1.json`, вы больше не сможете протестировать полный путь миграции от версии 1 до текущей. А ведь у кого-то из пользователей может быть именно версия 1 — тот, кто установил приложение при запуске и не обновлял два года.

На code review JSON-файлы схемы — ценный артефакт. Ревьюер видит diff между двумя версиями JSON: какие колонки добавлены, какие типы изменены, какие индексы созданы. Это позволяет проверить, что миграция корректно обрабатывает каждое изменение, не глядя на код миграции отдельно. JSON-файл — это «чертёж после ремонта», а миграция — «инструкция ремонта». Сверка одного с другим — стандартная практика контроля качества.

### Database Inspector

Android Studio предоставляет Database Inspector (View -> Tool Windows -> App Inspection -> Database Inspector) — инструмент для просмотра и редактирования базы данных на работающем устройстве или эмуляторе. С его помощью можно проверить результат миграции визуально: просмотреть структуру таблиц, данные в них и выполнить произвольный SQL-запрос. Это полезно для быстрой отладки, но не заменяет автоматические тесты.

Типичный workflow отладки миграции: написали миграцию, запустили приложение на эмуляторе с базой старой версии, открыли Database Inspector, проверили структуру таблиц и данные. Если что-то не так — исправили SQL, очистили данные эмулятора, повторили. После ручной проверки — обязательно написали автоматический тест, чтобы закрепить корректность.

Мы разобрали инструменты. Теперь сведём все знания в чеклист для production-релиза.

---

## Production Checklist

Перед релизом обновления с миграцией базы данных пройдите эти 7 пунктов. Каждый пропущенный пункт — потенциальный crash или потеря данных в production.

```
□ 1. Версия в @Database увеличена на 1
□ 2. JSON-файл новой версии экспортирован и закоммичен
□ 3. Migration (auto или manual) зарегистрирована
□ 4. SQL в ручной миграции ТОЧНО соответствует Entity
      (проверьте по JSON-файлу: имена, типы, constraints)
□ 5. Migration-тест написан и проходит
□ 6. Полный path-тест (от версии 1 до текущей) проходит
□ 7. Тест на реальных данных: база с production-подобными
      данными мигрирует без ошибок
```

> **Ключевая идея:** Пункт 4 — причина большинства провалов. Разница между `TEXT` и `TEXT NOT NULL`, между `DEFAULT NULL` и отсутствием `DEFAULT` — достаточна, чтобы валидация Room провалилась. Всегда сверяйте SQL миграции с JSON-файлом схемы.

---

## Распространённые заблуждения

| Заблуждение | Реальность |
|-------------|-----------|
| «AutoMigration справится с любым изменением» | AutoMigration покрывает ~70-80% сценариев. Изменение типа колонки, разделение и объединение таблиц, сложные трансформации данных требуют ручных миграций. |
| «Destructive migration безопасна, если данные синхронизируются с сервером» | Синхронизация может быть частичной. Если пользователь создал записи офлайн и они ещё не отправлены на сервер — destructive migration их уничтожит. |
| «Миграцию можно не тестировать — она простая» | Простота SQL не гарантирует корректность. Опечатка в имени колонки, несовпадение типа, отсутствующий DEFAULT — каждая мелочь вызывает crash у пользователей. |
| «Достаточно тестировать миграцию N→N+1» | Пользователь может обновиться с версии 1 до версии 8 за один раз. Нужно тестировать полный путь миграции. |
| «JSON-файлы схем — артефакт сборки, их не нужно коммитить» | Без JSON-файлов невозможно тестировать миграции. Они — часть исходного кода, как Entity и DAO. |
| «Room сам создаст индексы, если добавить @Index» | Room создаёт индексы только при первой установке (onCreate). При обновлении (миграции) вы должны создать индекс явно через CREATE INDEX в миграции. |
| «fallbackToDestructiveMigration — нормальный fallback для production» | Это «ядерная кнопка». Допустимо только для кэш-баз данных, где данные восстановимы с сервера. Для пользовательских данных — потеря всех данных без предупреждения. |

---

## Подводные камни

**1. Несовпадение SQL миграции и Entity.** Самая частая ошибка. Вы написали `ALTER TABLE users ADD COLUMN age INTEGER`, а в Entity объявили `val age: Int` (не nullable). Room ожидает `INTEGER NOT NULL`, а получил nullable `INTEGER`. Валидация провалится с криптичным сообщением об ошибке. Всегда проверяйте SQL по JSON-файлу схемы.

**2. Забытый DEFAULT для NOT NULL колонки.** Если добавляете NOT NULL колонку в существующую таблицу, SQLite требует `DEFAULT` value. Без него `ALTER TABLE` провалится, потому что существующие строки не смогут получить значение. Room при первой установке это решает автоматически, но при миграции — ваша ответственность.

**3. Потерянные индексы.** Если вы используете четырёхшаговый паттерн (CREATE → COPY → DROP → RENAME), индексы старой таблицы не переносятся на новую автоматически. Нужно создать их заново через `CREATE INDEX` после `RENAME`.

**4. Foreign key constraints.** При четырёхшаговом паттерне с таблицей, на которую ссылаются другие таблицы через foreign key, порядок операций критичен. Нельзя удалить таблицу, пока на неё есть ссылки. Сначала отключите foreign keys (`PRAGMA foreign_keys=OFF`), выполните операции, включите обратно и проверьте (`PRAGMA foreign_key_check`).

**5. Миграция на устройствах с разными версиями SQLite.** `DROP COLUMN` работает только на SQLite 3.35+ (Android 12+). Если ваше `minSdk < 31`, используйте четырёхшаговый паттерн вместо `ALTER TABLE DROP COLUMN`. Room AutoMigration учитывает это автоматически, но в ручных миграциях — ваша ответственность.

**6. Большие таблицы и время миграции.** Четырёхшаговый паттерн копирует все данные из старой таблицы в новую. Если таблица содержит миллионы записей, миграция может занять несколько секунд. Пользователь видит «зависшее» приложение. Рассмотрите показ прогресс-бара на splash-экране, если миграция потенциально долгая.

**7. WAL-режим и миграция.** Room по умолчанию использует WAL (Write-Ahead Logging). При миграции WAL-файл должен быть «вычищен» (checkpoint) до начала. Room делает это автоматически, но если вы работаете с базой данных напрямую (минуя Room) — учитывайте этот нюанс.

**8. Downgrade — понижение версии.** Если пользователь каким-то образом откатился на предыдущую версию приложения (sideload APK, тестирование), Room обнаружит, что версия в файле выше, чем в коде. По умолчанию это crash. Для обработки используйте `fallbackToDestructiveMigrationOnDowngrade()` — но помните, что это тоже уничтожает все данные. Корректный downgrade-путь — отдельная задача, которая редко встречается в production, но может быть важна для тестовых сборок.

Каждый из этих камней когда-то стоил кому-то часов отладки или негативных отзывов в Play Store. Предупреждён — значит вооружён.

---

## Связь с другими темами

**[[android-room-deep-dive]]** — Глубокое понимание Room (Entity, DAO, TypeConverters, Relations) — необходимый фундамент для работы с миграциями. Без знания того, как Room генерирует SQL из аннотаций, невозможно написать корректную миграцию — ведь SQL в миграции должен точно соответствовать тому, что Room ожидает увидеть в базе данных. Читайте Room deep-dive до этого материала.

**[[android-data-persistence]]** — Миграции — часть более широкой темы хранения данных на Android. Data persistence объясняет, почему Room является предпочтительным способом хранения структурированных данных, когда выбрать DataStore или файловое хранилище, и как устроен паттерн Single Source of Truth. Контекст выбора инструмента хранения влияет на то, нужны ли миграции вообще: DataStore не требует миграций в привычном смысле, а кэш-база может обойтись destructive fallback.

**[[android-room-performance]]** — Миграции влияют на производительность двумя способами. Во-первых, четырёхшаговый паттерн (CREATE → COPY → DROP → RENAME) копирует все данные, что может быть медленным на больших таблицах. Во-вторых, добавление или удаление индексов в миграции напрямую влияет на скорость запросов. Понимание performance-аспектов Room помогает писать миграции, которые не только корректны, но и эффективны.

**[[android-testing]]** — Тестирование миграций — это подмножество инструментального тестирования Android. `MigrationTestHelper` работает как JUnit Rule, требует `androidTest` директорию и запускается на реальном устройстве или эмуляторе (не на JVM). Понимание testing-инфраструктуры Android — setup, runners, assertions — необходимо для написания надёжных migration-тестов.

**[[android-ci-cd]]** — Миграционные тесты должны быть частью CI-пайплайна. Каждый PR, меняющий схему базы данных, должен содержать обновлённый JSON-файл схемы и passing migration-тест. Автоматизация этой проверки в CI/CD предотвращает попадание некорректных миграций в production. Интеграция migration-тестов в CI описана в материале по CI/CD.

---

## Источники и дальнейшее чтение

- **Meier R. (2022).** *Professional Android.* — Глава по Room содержит подробные примеры ручных миграций с пошаговыми объяснениями, включая сложные сценарии с foreign keys и индексами. Одна из немногих книг, где миграции разбираются на production-уровне.

- **Phillips B. et al. (2022).** *Android Programming: The Big Nerd Ranch Guide.* — Практический подход: от первой Entity до первой миграции. Хорошо объясняет связь между аннотациями Room и сгенерированным SQL. Рекомендуется для начинающих как first-read.

- **Kleppmann M. (2017).** *Designing Data-Intensive Applications.* — Глава 4 «Encoding and Evolution» разбирает schema evolution на уровне теории: forward/backward compatibility, schema-on-read vs schema-on-write. Даёт фундаментальное понимание, ПОЧЕМУ миграции устроены именно так, безотносительно конкретных инструментов.

- **Google (2024).** *Room Database Migrations* — [developer.android.com/training/data-storage/room/migrating-db-versions](https://developer.android.com/training/data-storage/room/migrating-db-versions) — Официальная документация с актуальными примерами AutoMigration, MigrationTestHelper и schema export. Первый источник при возникновении конкретных вопросов.

- **Google (2024).** *Testing Migrations* — [developer.android.com/training/data-storage/room/migrating-db-versions#testing](https://developer.android.com/training/data-storage/room/migrating-db-versions#testing) — Подробное руководство по настройке MigrationTestHelper с KSP, включая примеры для JUnit 4 и JUnit 5.

---

*Создано: 2026-02-11 | На основе Room 2.6.x, SQLite 3.39+ (Android 14)*
