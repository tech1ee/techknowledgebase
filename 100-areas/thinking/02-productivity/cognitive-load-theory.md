---
title: "Теория когнитивной нагрузки: почему сложное кажется сложным"
created: 2025-12-19
modified: 2025-12-19
type: concept
status: published
confidence: high
sources_verified: true
tags:
  - topic/thinking
  - thinking/cognitive-load
  - learning/instructional-design
  - productivity/learning
  - type/concept
  - level/intermediate
related:
  - "[[how-brain-learns]]"
  - "[[learning-complex-things]]"
  - "[[engaging-writing]]"
  - "[[deep-work]]"
prerequisites:
  - "[[how-brain-learns]]"
---

# Теория когнитивной нагрузки: почему сложное кажется сложным

Рабочая память ограничена (~7±2 элементов). Три типа нагрузки: внутренняя (сложность материала), внешняя (плохой дизайн — можно убрать), полезная (формирование схем — хорошая нагрузка). Монолиты становятся нечитаемыми из-за высокой интерактивности элементов. Хороший код и документация минимизируют внешнюю нагрузку, оставляя ресурсы для понимания.

---

## Почему это важно для разработчиков

Каждый разработчик ежедневно сталкивается с когнитивной нагрузкой:

```
Типичный день программиста:

08:00  Открываю PR на ревью — 15 файлов, 800 строк
       → "Что тут вообще происходит?"

10:00  Документация библиотеки — стена текста без примеров
       → "Где тут то, что мне нужно?"

14:00  Легаси-код — функция на 500 строк
       → "Боюсь трогать, не понимаю логику"

16:00  Митинг по архитектуре — 12 микросервисов на диаграмме
       → "Как это всё связано?"
```

Во всех случаях проблема одна: **когнитивная перегрузка**.

Теория когнитивной нагрузки (Cognitive Load Theory) объясняет:
- Почему одни объяснения понятны, а другие — нет
- Почему "стена кода" парализует
- Как проектировать код, документацию и обучение эффективно

---

## Что такое теория когнитивной нагрузки

### Краткая история

**John Sweller** (1988) — австралийский психолог, исследовавший, как люди решают задачи.

Он обнаружил: традиционные методы обучения (решай задачи, учись на ошибках) часто неэффективны. Почему? Потому что перегружают рабочую память.

### Ключевое открытие

```
┌─────────────────────────────────────────────────────────────────┐
│                     РАБОЧАЯ ПАМЯТЬ ОГРАНИЧЕНА                    │
│                                                                  │
│   Долгосрочная память:     Рабочая память:                       │
│   ∞ (практически           ~7±2 элементов                        │
│   безгранична)             (Miller, 1956)                        │
│                                                                  │
│   ████████████████████     █████████                             │
│   ████████████████████     Это ВСЁ, что                          │
│   ████████████████████     можно держать                         │
│   ████████████████████     в голове                              │
│   ████████████████████     одновременно                          │
│   ...                                                            │
│                                                                  │
│   Хранение: отлично        Обработка: бутылочное горлышко       │
└─────────────────────────────────────────────────────────────────┘
```

**Ключевой вывод Sweller:**

Если когнитивная нагрузка превышает ёмкость рабочей памяти → обучение не происходит. Информация просто не усваивается.

### Модель рабочей памяти

```
                    ОБРАБОТКА ИНФОРМАЦИИ

Входящая            Рабочая память         Долгосрочная
информация    →     (ограничена)      ↔    память
                         │                 (схемы)
                         │
                    ┌────┴────┐
                    │ 7±2     │
                    │элементов│
                    │ макс.   │
                    └─────────┘
                         │
            ┌────────────┼────────────┐
            ↓            ↓            ↓
        Внутренняя   Внешняя     Полезная
        нагрузка     нагрузка    нагрузка

   Если сумма > ёмкости → ПЕРЕГРУЗКА → обучение не происходит
```

---

## Три типа когнитивной нагрузки

### 1. Внутренняя нагрузка (Intrinsic Load)

**Что это:** Сложность, присущая самому материалу. Определяется количеством элементов и связями между ними.

**Ключевая характеристика:** НЕ МОЖЕТ быть уменьшена без упрощения контента.

```
Примеры внутренней нагрузки:

НИЗКАЯ:                          ВЫСОКАЯ:
─────────────                    ─────────────
2 + 2 = ?                        Квантовая механика
Переменная в Python              Распределённые транзакции
HTML-тег <p>                     Kubernetes networking
Простой SELECT                   SQL с 5 JOIN и подзапросами
```

**Для разработчиков:**

```python
# Низкая внутренняя нагрузка — один изолированный концепт
def add(a, b):
    return a + b

# Высокая внутренняя нагрузка — много связанных концептов
async def process_order(order_id: str, db: Database, cache: Redis,
                        queue: MessageQueue, payment: PaymentService):
    async with db.transaction():
        order = await db.orders.get(order_id)
        if not order:
            raise OrderNotFound(order_id)

        inventory = await cache.get(f"inventory:{order.product_id}")
        if not inventory:
            inventory = await db.inventory.get(order.product_id)
            await cache.set(f"inventory:{order.product_id}", inventory)

        if inventory.quantity < order.quantity:
            await queue.publish("inventory.low", order.product_id)
            raise InsufficientInventory()

        payment_result = await payment.charge(order.user_id, order.total)
        # ... ещё 50 строк логики
```

**Почему второй пример сложнее?**
- 5+ компонентов (db, cache, queue, payment, order)
- Все связаны между собой
- Нужно держать в голове состояние каждого
- Порядок операций важен

### 2. Внешняя нагрузка (Extraneous Load)

**Что это:** Нагрузка от СПОСОБА представления материала. Не связана с содержанием — только с формой.

**Ключевая характеристика:** МОЖЕТ и ДОЛЖНА быть минимизирована.

```
┌─────────────────────────────────────────────────────────────────┐
│                   ВНЕШНЯЯ НАГРУЗКА                               │
│                                                                  │
│   Это "налог" на понимание, который платит читатель:             │
│                                                                  │
│   ❌ Плохая структура документа                                  │
│   ❌ Нелогичное именование переменных                            │
│   ❌ Отсутствие примеров                                         │
│   ❌ Слишком много информации сразу                              │
│   ❌ Визуальный шум (плохое форматирование)                      │
│   ❌ Необходимость прыгать между файлами/страницами              │
│                                                                  │
│   Эта нагрузка НЕ ПОМОГАЕТ понять материал.                      │
│   Она только мешает.                                             │
└─────────────────────────────────────────────────────────────────┘
```

**Пример: документация с высокой внешней нагрузкой**

```
❌ ПЛОХО (высокая внешняя нагрузка):

Функция fetchData принимает параметры options, которые описаны в разделе
4.2.1 (см. страницу 47). Возвращаемое значение зависит от режима, который
может быть sync или async (различия описаны в Приложении B). При ошибках
выбрасывается исключение типа FetchError (структура в разделе 6.3) или
NetworkError (раздел 6.4). Для настройки таймаутов см. глобальные
конфигурации в разделе 2.1.
```

Проблемы:
- Нужно прыгать по 5 разным местам
- Контекст теряется
- Рабочая память забита навигацией, не содержанием

```
✅ ХОРОШО (низкая внешняя нагрузка):

## fetchData(options)

Загружает данные с сервера.

### Параметры

| Параметр | Тип      | По умолчанию | Описание         |
|----------|----------|--------------|------------------|
| url      | string   | обязателен   | URL для запроса  |
| timeout  | number   | 5000         | Таймаут в мс     |
| mode     | 'sync' | 'async' | 'async' | Режим выполнения |

### Пример

```javascript
const data = await fetchData({
  url: '/api/users',
  timeout: 3000
});
```

### Ошибки

- `FetchError` — сервер вернул ошибку (4xx, 5xx)
- `NetworkError` — проблема с сетью
```

### 3. Полезная нагрузка (Germane Load)

**Что это:** Когнитивные усилия, направленные на ОБУЧЕНИЕ — формирование схем и автоматизацию.

**Ключевая характеристика:** Это ХОРОШАЯ нагрузка. Её нужно максимизировать.

```
┌─────────────────────────────────────────────────────────────────┐
│                   ПОЛЕЗНАЯ НАГРУЗКА                              │
│                                                                  │
│   Это усилия, которые РЕАЛЬНО помогают учиться:                  │
│                                                                  │
│   ✓ Установление связей между концепциями                        │
│   ✓ Интеграция новой информации с существующими знаниями        │
│   ✓ Формирование ментальных моделей (схем)                       │
│   ✓ Практика и закрепление                                       │
│                                                                  │
│   Когда внешняя нагрузка низкая → больше ресурсов                │
│   для полезной нагрузки → лучше обучение                         │
└─────────────────────────────────────────────────────────────────┘
```

**Пример:**

```
Изучаешь React:

Внутренняя нагрузка: понять концепцию virtual DOM, reconciliation
Внешняя нагрузка: разобраться в плохо структурированном туториале
Полезная нагрузка: связать virtual DOM с предыдущим опытом
                   (как diff в git), попрактиковаться

Цель: минимизировать внешнюю → освободить ресурсы для полезной
```

### Баланс нагрузок

```
ОБЩАЯ ЁМКОСТЬ РАБОЧЕЙ ПАМЯТИ: 100%

❌ Плохой дизайн обучения:

████████████████████████████████████  Внутренняя (35%)
████████████████████████████████████████████  Внешняя (45%)
████████████████████  Полезная (20%)
───────────────────────────────────────────────────────
                                      Итого: 100% (лимит)

→ Мало ресурсов для реального обучения
→ Устаёшь, но не учишься


✅ Хороший дизайн обучения:

████████████████████████████████████  Внутренняя (35%)
████████  Внешняя (8%)
████████████████████████████████████████████████████████  Полезная (57%)
───────────────────────────────────────────────────────
                                      Итого: 100%

→ Максимум ресурсов для обучения
→ Тот же материал усваивается лучше
```

---

## Интерактивность элементов (Element Interactivity)

### Почему одни темы объективно сложнее других

**Element Interactivity** — количество элементов, которые нужно обрабатывать одновременно.

```
НИЗКАЯ ИНТЕРАКТИВНОСТЬ:             ВЫСОКАЯ ИНТЕРАКТИВНОСТЬ:
─────────────────────────           ──────────────────────────

Элементы можно изучать              Элементы нельзя понять
по отдельности:                     по отдельности:

○ ○ ○ ○ ○                           ○───○───○
                                    │ ╲ │ ╱ │
Словарь:                            ○───○───○
cat = кот                           │ ╱ │ ╲ │
dog = собака                        ○───○───○
house = дом
                                    Пример: архитектура системы
Каждое слово независимо.            Все компоненты связаны.
Можно учить по одному.              Нужно понимать всё сразу.
```

### Примеры из разработки

```
НИЗКАЯ ИНТЕРАКТИВНОСТЬ ЭЛЕМЕНТОВ:
─────────────────────────────────
- Синтаксис отдельных команд Git (git add, git commit)
- HTML-теги по отдельности
- Базовые типы данных в языке
- Отдельные функции стандартной библиотеки

ВЫСОКАЯ ИНТЕРАКТИВНОСТЬ ЭЛЕМЕНТОВ:
──────────────────────────────────
- Git rebase с конфликтами (история + состояние + изменения)
- CSS Flexbox (контейнер + элементы + оси + выравнивание)
- Async/await с error handling (промисы + стек + исключения)
- Микросервисная архитектура (сервисы + сеть + данные + failure modes)
```

### Почему монолиты становятся непонятными

```
Эволюция кодовой базы:

ГОД 1:                    ГОД 3:                    ГОД 5:

    ┌───┐                     ┌───┐                 ┌───┬───┬───┐
    │ A │                   ┌─┤ A ├─┐               │ A │ B │ C │
    └───┘                   │ └───┘ │             ┌─┼───┼───┼───┼─┐
                            ▼       ▼             │ │ D │ E │ F │ │
    Интерактивность: 1   ┌───┐   ┌───┐           │ ├───┼───┼───┤ │
                         │ B │   │ C │           │ │ G │ H │ I │ │
                         └───┘   └───┘           │ └───┴───┴───┘ │
                                                 └───────────────┘
                         Интерактивность: 3
                                                 Интерактивность: 9+
                                                 (каждый с каждым)

Количество связей растёт экспоненциально:
n элементов → до n(n-1)/2 связей

3 модуля →  3 связи     Ещё можно держать в голове
6 модулей → 15 связей   Уже сложно
9 модулей → 36 связей   Невозможно без документации
```

**Это объясняет:**
- Почему легаси-код пугает новичков
- Почему рефакторинг монолита так сложен
- Почему микросервисы (при правильном разделении) проще понять

---

## Практические примеры для разработчиков

### Пример 1: Плохая документация

```markdown
❌ ВЫСОКАЯ ВНЕШНЯЯ НАГРУЗКА:

## API Reference

The authenticate() function accepts a configuration object that must contain
the apiKey field (string, required), optionally the timeout field (number,
default 5000), the retryCount field (number, default 3), the onError callback
(function, optional), the logger instance (object, optional, must implement
ILogger interface defined in types.ts), and the environment field (string,
one of 'development', 'staging', 'production', default 'production').
Returns a Promise that resolves to an AuthResult object containing the
token field (string), expiresAt field (Date), and refreshToken field
(string, only in production environment).
```

Проблемы:
- Стена текста
- Нет структуры
- Нет примера
- Всё в одном абзаце

```markdown
✅ НИЗКАЯ ВНЕШНЯЯ НАГРУЗКА:

## authenticate(config)

Выполняет аутентификацию и возвращает токен.

### Параметры

| Имя         | Тип       | Обязателен | По умолчанию | Описание              |
|-------------|-----------|------------|--------------|------------------------|
| apiKey      | string    | да         | —            | Ваш API ключ          |
| timeout     | number    | нет        | 5000         | Таймаут в мс          |
| retryCount  | number    | нет        | 3            | Количество повторов   |
| environment | string    | нет        | 'production' | Окружение             |

### Быстрый старт

```javascript
const auth = await authenticate({
  apiKey: 'your-api-key'
});

console.log(auth.token);     // "eyJhbG..."
console.log(auth.expiresAt); // Date object
```

### Обработка ошибок

```javascript
try {
  const auth = await authenticate({ apiKey: 'invalid' });
} catch (error) {
  if (error instanceof AuthError) {
    console.log('Ошибка аутентификации:', error.message);
  }
}
```
```

### Пример 2: Код с высокой когнитивной нагрузкой

```python
❌ ВЫСОКАЯ НАГРУЗКА (внешняя + внутренняя):

def p(d, c, u):
    r = []
    for i in d:
        if i['t'] == 'A' and i['s'] > 100 and (i['c'] == c or c == '*'):
            if u and i['u'] == u:
                r.append({'id': i['id'], 'v': i['v'] * 1.1})
            elif not u:
                r.append({'id': i['id'], 'v': i['v']})
    return sorted(r, key=lambda x: x['v'], reverse=True)[:10]
```

Проблемы:
- Непонятные имена: p, d, c, u, r, i
- Магические значения: 'A', 100, 1.1, 10
- Всё в одной функции
- Непонятна бизнес-логика

```python
✅ НИЗКАЯ ВНЕШНЯЯ НАГРУЗКА:

# Константы вынесены и названы
TRANSACTION_TYPE_ACTIVE = 'A'
MINIMUM_SCORE_THRESHOLD = 100
PREMIUM_USER_MULTIPLIER = 1.1
TOP_RESULTS_LIMIT = 10


def get_top_transactions(
    transactions: list[dict],
    category: str,
    user_id: str | None = None
) -> list[dict]:
    """
    Возвращает топ-10 активных транзакций по value.

    Args:
        transactions: Список транзакций
        category: Категория для фильтрации ('*' = все)
        user_id: Опционально, ID пользователя для премиум-множителя

    Returns:
        Список из максимум 10 транзакций, отсортированных по value
    """
    filtered = _filter_active_transactions(transactions, category)
    valued = _apply_premium_multiplier(filtered, user_id)
    return _get_top_by_value(valued, TOP_RESULTS_LIMIT)


def _filter_active_transactions(transactions, category):
    """Фильтрует только активные транзакции с достаточным score."""
    return [
        t for t in transactions
        if t['type'] == TRANSACTION_TYPE_ACTIVE
        and t['score'] > MINIMUM_SCORE_THRESHOLD
        and (category == '*' or t['category'] == category)
    ]


def _apply_premium_multiplier(transactions, user_id):
    """Применяет премиум-множитель для транзакций пользователя."""
    result = []
    for t in transactions:
        value = t['value']
        if user_id and t['user_id'] == user_id:
            value *= PREMIUM_USER_MULTIPLIER
        result.append({'id': t['id'], 'value': value})
    return result


def _get_top_by_value(items, limit):
    """Возвращает топ N элементов по value."""
    return sorted(items, key=lambda x: x['value'], reverse=True)[:limit]
```

### Пример 3: API дизайн

```javascript
❌ ВЫСОКАЯ КОГНИТИВНАЯ НАГРУЗКА:

// Нужно помнить порядок 8 параметров
createUser(
  "john",
  "doe",
  "john@example.com",
  "password123",
  true,
  false,
  "admin",
  null
);

// Что такое true, false? Какой параметр что означает?
```

```javascript
✅ НИЗКАЯ КОГНИТИВНАЯ НАГРУЗКА:

// Именованные параметры через объект
createUser({
  firstName: "john",
  lastName: "doe",
  email: "john@example.com",
  password: "password123",
  isActive: true,
  isVerified: false,
  role: "admin"
});

// Каждый параметр самодокументирован
```

---

## Принципы снижения когнитивной нагрузки

### 1. Чанкинг (Chunking)

**Принцип:** Группировать связанную информацию в логические блоки.

```
Телефонный номер:

❌ 84951234567       → 11 элементов
✅ 8 (495) 123-45-67 → 4 чанка

Код:

❌ Одна функция на 200 строк
✅ 10 функций по 20 строк с понятными названиями
```

**Применение к коду:**

```python
# ❌ Всё вместе — много элементов одновременно
def process_order(order):
    # валидация (20 строк)
    # расчёт скидок (30 строк)
    # проверка склада (25 строк)
    # создание платежа (40 строк)
    # отправка уведомлений (20 строк)
    # логирование (15 строк)
    pass

# ✅ Разбито на чанки — каждый можно понять отдельно
def process_order(order):
    validated_order = validate_order(order)
    discounted_order = apply_discounts(validated_order)
    check_inventory(discounted_order)
    payment = create_payment(discounted_order)
    send_notifications(discounted_order, payment)
    log_order_processed(discounted_order)
```

### 2. Прогрессивное раскрытие (Progressive Disclosure)

**Принцип:** Показывать информацию постепенно, от простого к сложному.

```
Документация API:

Уровень 1: Быстрый старт (3 строки кода)
     ↓
Уровень 2: Основные параметры
     ↓
Уровень 3: Продвинутые настройки
     ↓
Уровень 4: Edge cases и troubleshooting
```

**Пример:**

```markdown
## fetch() — Быстрый старт

```javascript
const data = await fetch('/api/users');
```

Хотите больше контроля? Смотрите [параметры запроса](#параметры).

---

## Параметры запроса

```javascript
const data = await fetch('/api/users', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ name: 'John' })
});
```

Нужна обработка ошибок? Смотрите [обработка ошибок](#ошибки).
```

### 3. Worked Examples (Разобранные примеры)

**Принцип:** Показывать полные решения с пошаговым объяснением эффективнее, чем давать задачи для самостоятельного решения (для новичков).

```
❌ Традиционный подход:
"Напишите функцию, которая сортирует массив..."
→ Новичок тратит когнитивные ресурсы на поиск решения
→ Мало ресурсов на понимание паттерна

✅ Worked Example:
"Вот функция сортировки. Разберём её пошагово:

Шаг 1: Мы сравниваем элементы попарно...
Шаг 2: Если левый больше правого, меняем местами...
Шаг 3: Повторяем для всего массива..."

→ Ресурсы тратятся на понимание паттерна
→ Паттерн усваивается
→ Потом можно решать задачи самостоятельно
```

### 4. Избегание эффекта разделённого внимания (Split-Attention Effect)

**Принцип:** Связанная информация должна быть физически близко.

```
❌ РАЗДЕЛЁННОЕ ВНИМАНИЕ:

Код:
```python
result = calculate_tax(amount, rate, region)
```

Смотрите описание параметров на странице 47.

→ Читатель должен держать в памяти код, пока ищет страницу 47


✅ ИНТЕГРИРОВАННАЯ ИНФОРМАЦИЯ:

```python
result = calculate_tax(
    amount,  # Сумма для налогообложения (в копейках)
    rate,    # Ставка налога (0.0 - 1.0)
    region   # Код региона для определения правил
)
```

→ Вся информация в одном месте
```

### 5. Избегание эффекта избыточности (Redundancy Effect)

**Принцип:** Дублирование информации в разных формах может МЕШАТЬ, а не помогать.

```
❌ ИЗБЫТОЧНОСТЬ (мешает):

[Картинка: стрелка от А к Б]

Текст под картинкой: "Стрелка указывает от элемента А
к элементу Б, показывая направление потока данных от
первого элемента ко второму."

→ Читатель обрабатывает одно и то же дважды
→ Когнитивные ресурсы тратятся впустую


✅ БЕЗ ИЗБЫТОЧНОСТИ:

[Картинка: стрелка от А к Б, где А = "Запрос", Б = "Ответ"]

→ Картинка самодостаточна
→ Текст не нужен
```

### 6. Модальный эффект (Modality Effect)

**Принцип:** Аудио + визуал работают лучше, чем текст + визуал.

```
Почему это работает:

┌─────────────────────────────────────────────────────────────┐
│                     КАНАЛЫ ВОСПРИЯТИЯ                        │
│                                                              │
│   Визуальный канал          Аудиальный канал                │
│   ████████████████           ████████████████                │
│   (ограничен)                (ограничен)                     │
│                                                              │
│   ❌ Текст + Картинка:                                       │
│      Оба используют визуальный канал                         │
│      → Канал перегружен                                      │
│                                                              │
│   ✅ Голос + Картинка:                                       │
│      Картинка → визуальный канал                             │
│      Голос → аудиальный канал                                │
│      → Нагрузка распределена                                 │
└─────────────────────────────────────────────────────────────┘
```

**Применение:**
- Видео-туториалы: показывать код + объяснять голосом (не читать текст с экрана)
- Презентации: минимум текста на слайдах, основное — устно
- Скринкасты: показывать действия + комментировать

---

## Мультимедийное обучение

### Теория Mayer

Richard Mayer расширил теорию когнитивной нагрузки для мультимедиа.

### Принципы мультимедийного обучения

```
┌─────────────────────────────────────────────────────────────────┐
│               МУЛЬТИМЕДИЙНЫЕ ПРИНЦИПЫ                           │
│                                                                  │
│   ✅ ПОМОГАЕТ:                                                   │
│   ─────────────                                                  │
│   • Картинка + голос (разные каналы)                            │
│   • Анимация + голос                                            │
│   • Близкое расположение связанных элементов                    │
│   • Выделение ключевой информации                               │
│                                                                  │
│   ❌ МЕШАЕТ:                                                     │
│   ──────────                                                     │
│   • Картинка + текст + голос (тот же текст)                     │
│   • Декоративные элементы без смысла                            │
│   • Фоновая музыка                                              │
│   • Разнесённые связанные элементы                              │
└─────────────────────────────────────────────────────────────────┘
```

### Визуальная vs Вербальная избыточность

```
ВИЗУАЛЬНАЯ ИЗБЫТОЧНОСТЬ — ПОМОГАЕТ:

   Текст: "Функция возвращает массив"
   +
   Схема: [input] → [function] → [array output]

   → Текст и схема дополняют друг друга
   → Разная информация через разные каналы


ВЕРБАЛЬНАЯ ИЗБЫТОЧНОСТЬ — МЕШАЕТ:

   На экране: "Нажмите кнопку Submit для отправки формы"
   Голос: "Нажмите кнопку Submit для отправки формы"

   → Одна и та же информация дважды
   → Оба канала обрабатывают одно и то же
   → Снижение эффективности
```

---

## Для кода и документации

### Почему "стена кода" так сложна

```python
❌ СТЕНА КОДА:

def complex_processor(data,config,options):result=[];seen=set();for item in data:if item.get('type')=='valid' and item['id'] not in seen:seen.add(item['id']);processed={'id':item['id'],'value':item['value']*config.get('multiplier',1),'timestamp':datetime.now()};if options.get('include_metadata'):processed['metadata']={'source':item.get('source','unknown'),'processed_at':str(datetime.now()),'version':config.get('version','1.0')};result.append(processed);return sorted(result,key=lambda x:x['value'],reverse=True) if options.get('sort_desc') else result
```

Проблемы:
1. Нет визуального чанкинга (всё в одну строку)
2. Нет пробелов между логическими блоками
3. Нет комментариев для понимания намерения
4. Все детали на одном уровне абстракции

```python
✅ СТРУКТУРИРОВАННЫЙ КОД:

def process_valid_items(
    data: list[dict],
    config: dict,
    options: dict
) -> list[dict]:
    """
    Обрабатывает валидные элементы данных.

    - Фильтрует по типу 'valid'
    - Удаляет дубликаты по id
    - Применяет множитель из конфига
    - Опционально добавляет метаданные
    """
    seen_ids: set[str] = set()
    result: list[dict] = []

    for item in data:
        # Пропускаем невалидные и дубликаты
        if not _is_valid_unique_item(item, seen_ids):
            continue

        seen_ids.add(item['id'])

        # Создаём обработанный элемент
        processed = _create_processed_item(item, config)

        # Добавляем метаданные если нужно
        if options.get('include_metadata'):
            processed['metadata'] = _create_metadata(item, config)

        result.append(processed)

    # Сортируем если указано
    if options.get('sort_desc'):
        result.sort(key=lambda x: x['value'], reverse=True)

    return result
```

### Структурирование сложных объяснений

```
ПРИНЦИП: Пирамида абстракций

                    Уровень 1: ЧТО
                    ────────────────
                    "Эта система делает X"

              Уровень 2: КАК (высокоуровнево)
              ──────────────────────────────
              "Состоит из компонентов A, B, C"
              "A отвечает за..., B за..., C за..."

        Уровень 3: КАК (детали)
        ────────────────────────────────────
        "Компонент A работает так: ..."
        "Алгоритм внутри: ..."

   Уровень 4: ПОЧЕМУ (design decisions)
   ──────────────────────────────────────────
   "Мы выбрали этот подход потому что..."
   "Альтернативы были отвергнуты из-за..."
```

**Пример применения:**

```markdown
## Система кэширования

### Что это делает
Кэширует ответы API для снижения нагрузки на БД.

### Как это работает
```
Запрос → [Кэш] → Есть? → Вернуть из кэша
            ↓
           Нет → [База данных] → Сохранить в кэш → Вернуть
```

### Компоненты

**CacheManager** — центральный компонент, координирует запросы
**RedisAdapter** — хранит данные в Redis
**TTLPolicy** — определяет время жизни записей

### Детали реализации

[Подробный код каждого компонента]

### Почему Redis?
- Нужна высокая скорость чтения (< 1ms)
- Нужна персистентность (переживает рестарт)
- Альтернатива (Memcached) не поддерживает нужные структуры данных
```

### Баланс кода и объяснений

```
❌ СЛИШКОМ МНОГО КОДА:

```python
def calculate_tax(amount, rate):
    return amount * rate

def calculate_discount(amount, discount_percent):
    return amount * (1 - discount_percent / 100)

def calculate_shipping(weight, distance):
    base = 5.0
    per_kg = 0.5
    per_km = 0.01
    return base + (weight * per_kg) + (distance * per_km)

def calculate_total(items, discount, tax_rate, weight, distance):
    subtotal = sum(item['price'] * item['quantity'] for item in items)
    after_discount = calculate_discount(subtotal, discount)
    with_tax = after_discount + calculate_tax(after_discount, tax_rate)
    with_shipping = with_tax + calculate_shipping(weight, distance)
    return with_shipping
```

[Никаких объяснений]
→ Читатель должен сам понять бизнес-логику


❌ СЛИШКОМ МНОГО ТЕКСТА:

Для расчёта общей суммы заказа мы сначала вычисляем подытог,
складывая стоимость каждого товара, умноженную на его количество.
Затем применяем скидку в процентах от подытога. После этого
рассчитываем налог от суммы после скидки. Наконец, добавляем
стоимость доставки, которая зависит от веса и расстояния...

[Никакого кода]
→ Нет конкретики, сложно понять формулы


✅ БАЛАНС:

## Расчёт суммы заказа

Формула: `итого = (подытог - скидка) * (1 + налог) + доставка`

```python
def calculate_total(items, discount, tax_rate, shipping):
    subtotal = sum(item['price'] * item['quantity'] for item in items)
    after_discount = subtotal * (1 - discount / 100)
    with_tax = after_discount * (1 + tax_rate)
    return with_tax + shipping
```

**Порядок важен:** скидка применяется ДО налога (налог считается
от уменьшенной суммы).
```

---

## Антипаттерны

### 1. Преждевременная абстракция в обучении

```
❌ АНТИПАТТЕРН: Начинать с абстракций

"Паттерн Observer реализует публикацию-подписку между объектами.
Subject хранит список Observers и уведомляет их об изменениях..."

→ Новичок: "Что? Зачем? Какие объекты?"


✅ ПРАВИЛЬНО: Начинать с конкретного примера

"Представь: у тебя есть форма с ценой товара. При изменении цены
нужно обновить 3 места: итого в корзине, счётчик на иконке, блок
с рекомендациями. Как не писать обновление каждого вручную?"

→ Теперь понятно, какую проблему решаем
→ Observer — это решение понятной проблемы
```

### 2. Документация "для себя"

```
❌ АНТИПАТТЕРН: Автор пишет для себя

// Делаем магию с данными
const result = transformData(input);

// Фиксим баг #1234
if (user.type === 3) { ... }

// TODO: рефакторить это безобразие
function legacyHandler() { ... }


✅ ПРАВИЛЬНО: Писать для читателя

// Преобразуем сырые данные API в формат для UI-компонентов
const result = transformData(input);

// Специальная логика для корпоративных клиентов (user.type === 3)
// Они имеют расширенные права на просмотр отчётов
if (user.type === USER_TYPE_ENTERPRISE) { ... }

// Обработчик для устаревшего API v1 (до миграции на v2)
// Удалить после полного перехода клиентов (Q2 2025)
function legacyHandler() { ... }
```

### 3. "Умный" код

```python
❌ АНТИПАТТЕРН: Показать своё мастерство

# List comprehension внутри list comprehension с условиями
result = [
    {k: v for k, v in d.items() if k not in excluded}
    for d in data
    if d.get('status') == 'active' and d.get('score', 0) > threshold
][:limit] if limit else [
    {k: v for k, v in d.items() if k not in excluded}
    for d in data
    if d.get('status') == 'active' and d.get('score', 0) > threshold
]


✅ ПРАВИЛЬНО: Читаемость важнее краткости

def get_active_items(data, threshold, excluded_keys, limit=None):
    """Возвращает активные элементы с score выше порога."""
    result = []

    for item in data:
        if not _is_active_above_threshold(item, threshold):
            continue

        cleaned_item = _remove_excluded_keys(item, excluded_keys)
        result.append(cleaned_item)

    if limit:
        return result[:limit]
    return result
```

---

## Чеклист для создания учебных материалов

### Перед созданием

```
□ Определена целевая аудитория и её уровень
□ Выделена ОДНА главная идея
□ Оценена внутренняя сложность материала
□ Спланирована последовательность (от простого к сложному)
```

### Структура

```
□ TL;DR или ключевой вывод в начале
□ Материал разбит на логические блоки (чанкинг)
□ Каждый блок фокусируется на одной концепции
□ Есть прогрессивное раскрытие сложности
□ Связанная информация расположена рядом
```

### Примеры и объяснения

```
□ Есть разобранные примеры (worked examples)
□ Примеры идут ДО абстрактных объяснений
□ Код сопровождается комментариями о намерении
□ Баланс между кодом и текстом
□ Примеры взяты из реальных сценариев
```

### Визуализация

```
□ Диаграммы дополняют (не дублируют) текст
□ Нет декоративных элементов без смысла
□ Подписи интегрированы в изображения
□ Используется модальный эффект (голос + визуал для видео)
```

### Снижение внешней нагрузки

```
□ Нет необходимости прыгать между разделами
□ Термины объяснены при первом использовании
□ Нет стен текста (абзацы 3-4 строки)
□ Нет стен кода (логическое разбиение, комментарии)
□ Консистентное форматирование
```

### Проверка

```
□ Можно ли понять без внешних источников?
□ Протестировано на представителе целевой аудитории
□ Что можно убрать без потери смысла? (убрано)
```

---

## Связи

- Методы эффективного обучения: [[learning-complex-things]]
- Как писать понятно: [[engaging-writing]]
- Ментальные модели для понимания: [[mental-models]]
- Системное мышление: [[systems-thinking]]

---

## Источники

- [eLearning Industry: Cognitive Load Theory](https://elearningindustry.com/cognitive-load-theory-and-instructional-design) — проверено 2025-12-19
- [ResearchGate: Cognitive Load Theory in Educational Practice](https://www.researchgate.net/publication/338908733_Cognitive_Load_Theory_Applications_for_Learning) — проверено 2025-12-19
- [SAGE Journals: Cognitive Load Theory Review](https://journals.sagepub.com/doi/10.1177/1529100612453266) — проверено 2025-12-19
- [Educational Psychology Review: Sweller's CLT](https://link.springer.com/article/10.1007/s10648-019-09465-5) — проверено 2025-12-19
- [Nielsen Norman Group: Information Scent](https://www.nngroup.com/articles/information-scent/) — проверено 2025-12-19
- [Mayer, R. E. (2009). Multimedia Learning](https://www.cambridge.org/core/books/multimedia-learning/A930E6B3F4003B4E2F8FB6DD9E3E5AFA) — Cambridge University Press

---

**Последняя верификация**: 2025-12-19
**Уровень достоверности**: high

---

*Проверено: 2026-01-09*
