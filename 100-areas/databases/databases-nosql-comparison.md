---
title: "NoSQL: MongoDB, Redis, DynamoDB, Cassandra — когда что выбирать"
created: 2025-12-22
modified: 2025-12-22
type: concept
status: published
confidence: high
tags:
  - topic/databases
  - nosql
  - mongodb
  - redis
  - dynamodb
  - cassandra
  - type/concept
  - level/intermediate
related:
  - "[[databases-overview]]"
  - "[[database-design-optimization]]"
  - "[[databases-replication-sharding]]"
prerequisites:
  - "[[databases-sql-fundamentals]]"
  - "[[caching-strategies]]"
---

# NoSQL: MongoDB, Redis, DynamoDB, Cassandra — когда что выбирать

> NoSQL — это не "против SQL", а "Not Only SQL". Разные типы баз данных для разных задач. Выбор зависит от паттернов доступа, требований к консистентности и масштабированию.

---

## TL;DR

| Тип | Представитель | Когда использовать |
|-----|---------------|-------------------|
| **Document** | MongoDB | Гибкая схема, вложенные объекты, прототипы |
| **Key-Value** | Redis | Кэш, сессии, очереди, pub/sub |
| **Wide-Column** | Cassandra | Огромные объёмы записи, time-series |
| **Graph** | Neo4j | Связи между сущностями (соцсети, рекомендации) |
| **Search** | Elasticsearch | Full-text поиск, логи, аналитика |

**Золотое правило:** Начни с PostgreSQL. Добавляй NoSQL когда SQL не справляется с конкретной задачей.

---

## Часть 1: Интуиция без кода

> NoSQL — это не "лучше" и не "хуже" чем SQL. Это набор инструментов, каждый для своей задачи. Как в кухне: вилка, ложка, нож — все нужны.

### Аналогия 1: Кухонные приборы — у каждого своя задача

```
┌─────────────────────────────────────────────────────────────────┐
│            БАЗА ДАННЫХ КАК КУХОННЫЕ ПРИБОРЫ                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   🍴 ВИЛКА (SQL/PostgreSQL)                                     │
│   • Универсальный инструмент                                    │
│   • Подходит для большинства блюд                               │
│   • Проверен временем                                           │
│   → Начни с этого!                                              │
│                                                                  │
│   🥢 ПАЛОЧКИ (MongoDB)                                          │
│   • Идеальны для определённых блюд                              │
│   • Гибкость в использовании                                    │
│   • Требуют привычки                                            │
│   → Когда данные как "вложенные контейнеры"                     │
│                                                                  │
│   🥄 ЛОЖКА (Redis)                                               │
│   • Для жидкого/горячего — идеально                             │
│   • Не заменяет вилку для стейка                                │
│   • Быстро и просто                                             │
│   → Кэш, сессии, счётчики                                       │
│                                                                  │
│   🍕 НОЖ ДЛЯ ПИЦЦЫ (Cassandra)                                  │
│   • Специализированный инструмент                               │
│   • Режет огромные объёмы быстро                                │
│   • Бесполезен для супа                                         │
│   → Миллиарды записей, time-series                              │
│                                                                  │
│   🕸️ СПАГЕТТИ-ЛОЖКА (Neo4j)                                     │
│   • Для запутанных связей                                       │
│   • Обычная ложка не справится                                  │
│   → Соцсети, рекомендации, графы                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Аналогия 2: Типы хранения — разные шкафы для разного

```
┌─────────────────────────────────────────────────────────────────┐
│               МОДЕЛИ ДАННЫХ КАК СИСТЕМЫ ХРАНЕНИЯ                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   SQL (PostgreSQL) — КАРТОТЕЧНЫЙ ШКАФ                           │
│   ┌─────────────────────────────────────┐                       │
│   │ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ │ Строгий порядок       │
│   │ │ФИО   │ │Дата  │ │Адрес │ │Тел.  │ │ Каждая карточка      │
│   │ │      │ │рожд. │ │      │ │      │ │ одинакового формата  │
│   │ └──────┘ └──────┘ └──────┘ └──────┘ │                       │
│   └─────────────────────────────────────┘                       │
│                                                                  │
│   MongoDB — ПАПКИ С ДОКУМЕНТАМИ                                  │
│   ┌─────────────────────────────────────┐                       │
│   │ 📁 Клиент_1                         │ Каждая папка может    │
│   │   ├── контракт.pdf                  │ содержать разное:     │
│   │   ├── фото.jpg                      │ • кто-то с фото      │
│   │   └── 📁 заказы                     │ • кто-то без         │
│   │        ├── заказ_1.doc              │ Гибкая структура     │
│   │        └── заказ_2.doc              │                       │
│   └─────────────────────────────────────┘                       │
│                                                                  │
│   Redis — ЗАПИСНАЯ КНИЖКА НА ХОЛОДИЛЬНИКЕ                       │
│   ┌─────────────────────────────────────┐                       │
│   │ "молоко" → купить                    │ Простые пометки      │
│   │ "Маша" → позвонить в 18:00          │ Быстрый доступ       │
│   │ "пароль WiFi" → 12345               │ Временные данные     │
│   └─────────────────────────────────────┘                       │
│                                                                  │
│   Cassandra — ТАБЛИЦА С РАСШИРЯЕМЫМИ КОЛОНКАМИ                  │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │ sensor_1 │ 10:00→25° │ 10:01→26° │ 10:02→25° │ ...     │   │
│   │ sensor_2 │ 10:00→30° │ 10:01→31° │ 10:02→32° │ ...     │   │
│   └─────────────────────────────────────────────────────────┘   │
│   Бесконечно добавляем колонки справа (time-series)             │
│                                                                  │
│   Neo4j — КАРТА МЕТРО                                            │
│       (А)───────(Б)                                              │
│        │ ╲       │                                               │
│        │  ╲      │     Важны не станции, а связи между ними     │
│        │   ╲     │     "Как добраться от А до Д?"               │
│       (В)───(Г)──(Д)                                             │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Аналогия 3: CAP-теорема — светофор в шторм

```
┌─────────────────────────────────────────────────────────────────┐
│                CAP-ТЕОРЕМА: ВЫБОР В ЭКСТРЕМАЛЬНОЙ СИТУАЦИИ       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Представьте два банкомата в разных городах:                   │
│                                                                  │
│   🏧 Москва                    🏧 Питер                         │
│       │                            │                             │
│       │         ⚡ ШТОРМ ⚡         │                             │
│       └─────────── ✗ ──────────────┘                             │
│              Связь потеряна!                                     │
│                                                                  │
│   Баланс клиента: 10,000₽                                       │
│   Клиент хочет снять: 8,000₽ в Москве                           │
│                                                                  │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  ВЫБОР 1: CONSISTENCY (консистентность)                  │   │
│   │  CP: MongoDB, PostgreSQL                                 │   │
│   │                                                          │   │
│   │  "Извините, банкомат временно не работает"              │   │
│   │  • ❌ Услуга недоступна                                  │   │
│   │  • ✅ Деньги точно в безопасности                        │   │
│   │  → Банки, финансы, критичные данные                      │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  ВЫБОР 2: AVAILABILITY (доступность)                     │   │
│   │  AP: Cassandra, DynamoDB                                 │   │
│   │                                                          │   │
│   │  "Выдаём деньги, баланс синхронизируем позже"           │   │
│   │  • ✅ Услуга работает                                    │   │
│   │  • ⚠️ Риск: оба снимут, овердрафт                       │   │
│   │  → Соцсети, метрики, логи (eventual consistency OK)      │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│   P (Partition Tolerance) — шторм СЛУЧИТСЯ.                     │
│   Сетевые разрывы неизбежны в распределённой системе.           │
│   Выбор: что важнее при разрыве — C или A?                      │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Аналогия 4: Redis — оперативная память вашего приложения

```
┌─────────────────────────────────────────────────────────────────┐
│              REDIS В АРХИТЕКТУРЕ ПРИЛОЖЕНИЯ                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Компьютер:                      Веб-приложение:               │
│                                                                  │
│   ┌─────────────────┐             ┌─────────────────┐           │
│   │   CPU           │             │   Код           │           │
│   │   (обработка)   │             │   (бизнес-логика)│          │
│   └────────┬────────┘             └────────┬────────┘           │
│            │                               │                     │
│            ▼                               ▼                     │
│   ┌─────────────────┐             ┌─────────────────┐           │
│   │   RAM           │             │   Redis         │           │
│   │   (быстро!)     │ ← 0.1 мс →  │   (in-memory)   │           │
│   │   но мало места │             │   кэш, сессии   │           │
│   └────────┬────────┘             └────────┬────────┘           │
│            │                               │                     │
│            ▼                               ▼                     │
│   ┌─────────────────┐             ┌─────────────────┐           │
│   │   SSD/HDD       │             │   PostgreSQL    │           │
│   │   (медленно)    │ ← 5-50 мс → │   MongoDB       │           │
│   │   но много места│             │   основная БД   │           │
│   └─────────────────┘             └─────────────────┘           │
│                                                                  │
│   Redis = RAM для вашего приложения:                            │
│   • Быстрый доступ к "горячим" данным                           │
│   • Ограничен памятью сервера                                   │
│   • Не для долгосрочного хранения                               │
│                                                                  │
│   Типичное использование:                                       │
│   • Кэш результатов тяжёлых запросов                            │
│   • Сессии пользователей                                        │
│   • Rate limiting счётчики                                      │
│   • Очереди задач                                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Аналогия 5: Cassandra — конвейер для массового производства

```
┌─────────────────────────────────────────────────────────────────┐
│              CASSANDRA: ПРОМЫШЛЕННЫЙ КОНВЕЙЕР                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Обычная БД (PostgreSQL) — ремесленная мастерская:            │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  Мастер                                                  │   │
│   │    │                                                     │   │
│   │    ▼                                                     │   │
│   │  ┌─────┐    Один мастер делает всё:                     │   │
│   │  │ 🔧  │    • Обработка заказа                          │   │
│   │  │     │    • Проверка качества                         │   │
│   │  └─────┘    • Упаковка                                   │   │
│   │                                                          │   │
│   │  Максимум: 1000 изделий/день                            │   │
│   │  Если мастер заболел — производство стоит               │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│   Cassandra — промышленный конвейер:                            │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │    Вход                                        Выход     │   │
│   │      │                                          │        │   │
│   │      ▼                                          │        │   │
│   │  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐   │        │   │
│   │  │ 🔧1 │→ │ 🔧2 │→ │ 🔧3 │→ │ 🔧4 │→ │ 🔧5 │───┘        │   │
│   │  └─────┘  └─────┘  └─────┘  └─────┘  └─────┘            │   │
│   │                                                          │   │
│   │  • Каждый узел независим                                │   │
│   │  • Добавить узел = увеличить мощность                   │   │
│   │  • Один упал = остальные работают                       │   │
│   │  • Миллионы записей/секунду                             │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│   Цена: нужно знать заранее, что будешь спрашивать              │
│   (нельзя "покажи все заказы где сумма > 1000")                 │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Часть 2: Почему это сложно — типичные ошибки

### Ошибка 1: "MongoDB для всего!"

**СИМПТОМ:** "Нам нужна гибкость, берём MongoDB" (для e-commerce с транзакциями)

```
┌─────────────────────────────────────────────────────────────────┐
│              MONGODB — НЕ СЕРЕБРЯНАЯ ПУЛЯ                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ❌ ПРОБЛЕМА: E-commerce на чистом MongoDB                      │
│                                                                  │
│   Требования:                                                    │
│   • Заказы со статусами ✓                                       │
│   • Оплата (ACID транзакции!) ✗                                 │
│   • Связь заказ↔товар↔склад (JOIN) ✗                           │
│   • Отчёты по продажам (агрегация) △                            │
│                                                                  │
│   Через год:                                                     │
│   • "Деньги списались, заказ не создался"                       │
│   • "Товар продан дважды"                                       │
│   • "Отчёт считается 10 минут"                                  │
│                                                                  │
│   ✅ ПРАВИЛЬНО:                                                  │
│   • PostgreSQL для: заказов, платежей, склада (ACID)            │
│   • MongoDB для: каталога товаров (гибкая схема атрибутов)      │
│   • Redis для: корзины, кэша каталога                           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:** PostgreSQL с JSONB покрывает 95% случаев "гибкой схемы". MongoDB — когда реально нужен document store.

### Ошибка 2: "Redis как основная база данных"

**СИМПТОМ:** "Redis быстрый, будем хранить всё там"

```
┌─────────────────────────────────────────────────────────────────┐
│                  REDIS — ЭТО КЭШ, НЕ БД                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Проблемы Redis как основной БД:                               │
│                                                                  │
│   1. ПАМЯТЬ = ДЕНЬГИ                                            │
│      • 100 GB данных = 100 GB RAM                               │
│      • RAM стоит ~$10/GB/месяц, SSD ~$0.10/GB/месяц             │
│      • 100x дороже!                                              │
│                                                                  │
│   2. PERSISTENCE НЕНАДЁЖЕН                                      │
│      • RDB: snapshot раз в N минут → потеря данных             │
│      • AOF: медленнее, занимает место, не 100% надёжен         │
│      • Официальная позиция Redis: "это кэш"                    │
│                                                                  │
│   3. НЕТ СЛОЖНЫХ ЗАПРОСОВ                                       │
│      • Нет SQL, нет JOINs                                       │
│      • Нет индексов по произвольным полям                       │
│      • "Найди всех пользователей из Москвы" — невозможно       │
│                                                                  │
│   ✅ ПРАВИЛЬНО:                                                  │
│   Redis + PostgreSQL/MongoDB                                     │
│   • Redis: кэш, сессии, очереди, rate limiting                  │
│   • Основная БД: всё остальное                                  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:** Redis — вспомогательная БД. Всегда есть "source of truth" в PostgreSQL/MongoDB.

### Ошибка 3: Cassandra без понимания access patterns

**СИМПТОМ:** "Cassandra масштабируется, возьмём её" → "почему запросы такие медленные?"

```
┌─────────────────────────────────────────────────────────────────┐
│            CASSANDRA: PARTITION KEY = ЖИЗНЬ ИЛИ СМЕРТЬ           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Таблица: sensor_data                                          │
│   PRIMARY KEY (sensor_id, timestamp)                            │
│                                                                  │
│   ✅ БЫСТРО (запрос по partition key):                           │
│   SELECT * FROM sensor_data                                      │
│   WHERE sensor_id = 'sensor_001'                                │
│   AND timestamp > '2025-01-01';                                  │
│   → Прямой доступ к одной партиции                              │
│                                                                  │
│   ❌ МЕДЛЕННО (без partition key):                               │
│   SELECT * FROM sensor_data                                      │
│   WHERE timestamp > '2025-01-01';                                │
│   → FULL CLUSTER SCAN! Все узлы, все партиции                   │
│   → Таймаут, OOM, падение кластера                              │
│                                                                  │
│   ❌ НЕВОЗМОЖНО:                                                 │
│   SELECT * FROM sensor_data WHERE value > 25;                   │
│   → Агрегации, фильтры по не-ключевым полям                     │
│                                                                  │
│   ✅ РЕШЕНИЕ: Денормализация (несколько таблиц)                  │
│                                                                  │
│   -- Для запроса "данные сенсора за период"                     │
│   CREATE TABLE sensor_by_id (...) PRIMARY KEY (sensor_id, ts);  │
│                                                                  │
│   -- Для запроса "все сенсоры за дату"                          │
│   CREATE TABLE sensor_by_date (...) PRIMARY KEY (date, sensor); │
│                                                                  │
│   Одни данные — несколько таблиц под разные запросы!            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:** Спроектируй access patterns ПЕРЕД выбором Cassandra. Таблица = один тип запроса.

### Ошибка 4: Игнорирование CAP-последствий

**СИМПТОМ:** "Eventual consistency? Да какая разница..." → потеря данных

```
┌─────────────────────────────────────────────────────────────────┐
│         EVENTUAL CONSISTENCY — ЭТО НЕ "СКОРО СТАНЕТ ОК"          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Сценарий: DynamoDB (AP система), пользователь меняет пароль   │
│                                                                  │
│   T=0: Пользователь меняет пароль на "newPass"                  │
│        → Запись попала на Node A                                │
│                                                                  │
│   T=1: Пользователь логинится с "newPass"                       │
│        → Запрос попал на Node B (ещё не синхронизирован)        │
│        → "Неверный пароль!"                                     │
│                                                                  │
│   T=2: Пользователь в панике меняет пароль снова на "panicPass" │
│        → Запись попала на Node B                                │
│                                                                  │
│   T=3: Синхронизация...                                         │
│        Node A: "newPass" (T=0)                                  │
│        Node B: "panicPass" (T=2)                                │
│        → Конфликт! Какой пароль правильный?                     │
│                                                                  │
│   Last-Write-Wins: "panicPass" (но пользователь уже ушёл)       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:**
- Критичные данные (пароли, балансы) — только CP системы (PostgreSQL, MongoDB)
- AP системы — для данных, где "почти правильно" приемлемо (счётчики лайков, аналитика)

### Ошибка 5: Преждевременная NoSQL-оптимизация

**СИМПТОМ:** "У нас будет миллион пользователей, нужен NoSQL кластер!"

```
┌─────────────────────────────────────────────────────────────────┐
│              ПРЕЖДЕВРЕМЕННАЯ ОПТИМИЗАЦИЯ                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Стартап День 1:                                               │
│   "Нам нужен MongoDB кластер с шардингом на 10 серверов,        │
│    Redis Cluster, Elasticsearch, и Kafka для событий"           │
│                                                                  │
│   Через год:                                                     │
│   • Пользователей: 1,000                                        │
│   • Данных: 10 GB                                               │
│   • Команда: 3 человека поддерживают 5 технологий              │
│   • Инфраструктура: $3,000/месяц                                │
│                                                                  │
│   ✅ ЧТО НУЖНО БЫЛО:                                             │
│   • Один PostgreSQL                                             │
│   • $50/месяц                                                    │
│   • Один человек на ops                                         │
│   • Время на продукт, а не инфраструктуру                       │
│                                                                  │
│   ПРАВИЛО: PostgreSQL держит 10,000+ RPS на одном сервере       │
│            с правильными индексами и пулом соединений           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:** Начни с PostgreSQL. Добавляй NoSQL когда PostgreSQL объективно не справляется (не "возможно не справится").

### Ошибка 6: Недооценка операционной сложности polyglot

**СИМПТОМ:** "У нас PostgreSQL, MongoDB, Redis, Elasticsearch, Cassandra..." → Хаос

```
┌─────────────────────────────────────────────────────────────────┐
│              ЦЕНА POLYGLOT PERSISTENCE                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Каждая БД — это:                                              │
│   • Отдельный мониторинг и алерты                               │
│   • Отдельный бэкап и восстановление                            │
│   • Отдельная экспертиза в команде                              │
│   • Отдельные security патчи                                    │
│   • Синхронизация данных между БД                               │
│   • Отдельная документация                                      │
│                                                                  │
│   5 БД в проекте:                                               │
│   ┌───────────────────────────────────────────────────────────┐ │
│   │ PostgreSQL ←→ MongoDB ←→ Redis ←→ Elasticsearch           │ │
│   │      ↑           ↑          ↑            ↑                │ │
│   │      └───────────┴──────────┴────────────┘                │ │
│   │         Синхронизация? Консистентность? Кто главный?      │ │
│   └───────────────────────────────────────────────────────────┘ │
│                                                                  │
│   Вопросы:                                                       │
│   • Заказ в PostgreSQL, товар в MongoDB — как JOIN?             │
│   • Redis кэш устарел — как инвалидировать?                     │
│   • Elasticsearch рассинхронизировался — как понять?            │
│                                                                  │
│   ✅ ПРАВИЛО:                                                    │
│   Добавляй БД только когда выгода > стоимости поддержки         │
│   Для команды < 10 человек: максимум 2-3 БД                     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:** Каждая новая БД должна решать конкретную проблему, которую нельзя решить существующими средствами.

---

## Часть 3: Ментальные модели

### Модель 1: Дерево решений — какую БД выбрать

```
┌─────────────────────────────────────────────────────────────────┐
│                   ВЫБОР БАЗЫ ДАННЫХ                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│                    Какие данные?                                 │
│                         │                                        │
│     ┌───────────────────┼───────────────────┐                   │
│     │                   │                   │                   │
│     ▼                   ▼                   ▼                   │
│  Связанные          Документы/         Key-Value               │
│  таблицы            JSON-объекты       (кэш, сессии)           │
│     │                   │                   │                   │
│     ▼                   │                   ▼                   │
│  ACID нужен?            │               ┌───────┐               │
│  ┌───┴───┐              │               │ Redis │               │
│  │       │              │               └───────┘               │
│ Да      Нет             │                                       │
│  │       │              │                                       │
│  ▼       ▼              ▼                                       │
│ ┌────┐ ┌────────┐    Схема часто                               │
│ │SQL │ │Может   │    меняется?                                 │
│ │PG  │ │SQL +   │    ┌───┴───┐                                 │
│ └────┘ │JSONB?  │   Да      Нет                                │
│        └────────┘    │       │                                  │
│                      ▼       ▼                                  │
│                  ┌───────┐ ┌────────────┐                       │
│                  │MongoDB│ │PostgreSQL  │                       │
│                  └───────┘ │+ JSONB     │                       │
│                            └────────────┘                       │
│                                                                  │
│         Огромный объём записи (>100K WPS)?                      │
│                         │                                        │
│                    ┌────┴────┐                                  │
│                   Да        Нет                                 │
│                    │         │                                  │
│                    ▼         ▼                                  │
│              ┌──────────┐  PostgreSQL                           │
│              │Cassandra │  справится                            │
│              │ScyllaDB  │                                       │
│              └──────────┘                                       │
│                                                                  │
│         Связи важнее данных (граф)?                             │
│                         │                                        │
│                    ┌────┴────┐                                  │
│                   Да        Нет                                 │
│                    │         │                                  │
│                    ▼         ▼                                  │
│              ┌──────────┐  Другие                               │
│              │  Neo4j   │  варианты                             │
│              └──────────┘                                       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Модель 2: CAP-выбор в реальных сценариях

```
┌─────────────────────────────────────────────────────────────────┐
│                CAP В РЕАЛЬНЫХ ЗАДАЧАХ                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   CP (Consistency + Partition Tolerance)                        │
│   "Лучше недоступен, чем неправильный"                          │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │ • Банковские переводы                                    │   │
│   │ • Платёжные системы                                      │   │
│   │ • Инвентарь (остатки на складе)                         │   │
│   │ • Бронирование (билеты, отели)                          │   │
│   │                                                          │   │
│   │ БД: PostgreSQL, MongoDB (с WriteConcern: majority)       │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│   AP (Availability + Partition Tolerance)                       │
│   "Лучше приблизительно, но работает"                           │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │ • Лента новостей                                         │   │
│   │ • Счётчики просмотров/лайков                            │   │
│   │ • Аналитика и метрики                                    │   │
│   │ • Логи и события                                         │   │
│   │ • DNS, CDN                                               │   │
│   │                                                          │   │
│   │ БД: Cassandra, DynamoDB, CouchDB                        │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│   CA (Consistency + Availability) — только single-node          │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │ • Маленькие проекты                                      │   │
│   │ • Прототипы                                              │   │
│   │ • Single-region deployment                               │   │
│   │                                                          │   │
│   │ БД: PostgreSQL, MySQL (single instance)                 │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Модель 3: Latency пирамида

```
┌─────────────────────────────────────────────────────────────────┐
│                    ПИРАМИДА LATENCY                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│                         ▲                                        │
│                        ╱ ╲      0.1 - 1 мс                      │
│                       ╱   ╲     Redis / Memcached               │
│                      ╱ RAM ╲    In-memory                       │
│                     ╱───────╲                                   │
│                    ╱         ╲  1 - 10 мс                       │
│                   ╱   SSD     ╲ PostgreSQL с индексами          │
│                  ╱    Local    ╲ MongoDB local                  │
│                 ╱───────────────╲                               │
│                ╱                 ╲ 10 - 100 мс                  │
│               ╱   Network DB      ╲ RDS, Cloud SQL              │
│              ╱    Same region      ╲ DynamoDB                   │
│             ╱───────────────────────╲                           │
│            ╱                         ╲ 100 - 500 мс             │
│           ╱      Cross-region         ╲ Global DB               │
│          ╱       Distributed           ╲ Cassandra multi-DC     │
│         ╱───────────────────────────────╲                       │
│                                                                  │
│   Оптимизация: данные ближе к вычислениям                       │
│   • Горячие данные → Redis                                      │
│   • Тёплые данные → Local SSD                                   │
│   • Холодные данные → Object Storage                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Модель 4: Data Model Fit

```
┌─────────────────────────────────────────────────────────────────┐
│            СООТВЕТСТВИЕ ДАННЫХ И МОДЕЛИ БД                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌───────────────────────────────────────────────────────────┐ │
│   │             ТИП ДАННЫХ              │    ЛУЧШИЙ FIT        │ │
│   ├─────────────────────────────────────┼─────────────────────┤ │
│   │                                     │                     │ │
│   │ Структурированные, связанные       │ SQL (PostgreSQL)    │ │
│   │ Пользователи → Заказы → Товары     │                     │ │
│   │                                     │                     │ │
│   │ JSON с переменной структурой       │ MongoDB / JSONB     │ │
│   │ Каталог: {CPU: "i7", RAM: "16GB"}  │                     │ │
│   │          {Size: "XL", Color: "red"}│                     │ │
│   │                                     │                     │ │
│   │ Временные ряды, логи               │ Cassandra, InfluxDB │ │
│   │ sensor_id + timestamp → value      │ TimescaleDB         │ │
│   │                                     │                     │ │
│   │ Кэш, сессии, счётчики              │ Redis               │ │
│   │ session:abc → {user_id: 1, ...}    │                     │ │
│   │                                     │                     │ │
│   │ Полнотекстовый поиск               │ Elasticsearch       │ │
│   │ "найди товары со словом iPhone"    │                     │ │
│   │                                     │                     │ │
│   │ Графы и связи                      │ Neo4j, ArangoDB     │ │
│   │ Друзья друзей, рекомендации        │                     │ │
│   │                                     │                     │ │
│   └───────────────────────────────────────────────────────────┘ │
│                                                                  │
│   Правило: Выбирай БД под форму данных, не под хайп            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Модель 5: Эволюция архитектуры БД

```
┌─────────────────────────────────────────────────────────────────┐
│             ЭВОЛЮЦИЯ АРХИТЕКТУРЫ ПО МЕРЕ РОСТА                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ЭТАП 1: MVP / Стартап (0-10K пользователей)                   │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │           ┌─────────────────┐                            │   │
│   │           │   PostgreSQL    │  ← Одна БД для всего      │   │
│   │           │   (single)      │                            │   │
│   │           └─────────────────┘                            │   │
│   │   Фокус: скорость разработки, простота                  │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│   ЭТАП 2: Рост (10K-100K пользователей)                         │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │   ┌─────────────────┐    ┌─────────────────┐            │   │
│   │   │   PostgreSQL    │◄──►│     Redis       │            │   │
│   │   │   (primary)     │    │   (cache)       │            │   │
│   │   └─────────────────┘    └─────────────────┘            │   │
│   │   + Добавляем кэш для горячих данных                    │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│   ЭТАП 3: Масштабирование (100K-1M пользователей)              │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │   ┌────────────┐  ┌────────────┐  ┌─────────────────┐   │   │
│   │   │ PostgreSQL │  │  MongoDB   │  │     Redis       │   │   │
│   │   │ (ACID)     │  │ (catalog)  │  │ (cache+queue)   │   │   │
│   │   └──────┬─────┘  └──────┬─────┘  └────────┬────────┘   │   │
│   │          │               │                 │            │   │
│   │          └───────────────┼─────────────────┘            │   │
│   │                          │                              │   │
│   │                  ┌───────▼───────┐                      │   │
│   │                  │ Elasticsearch │  + Полнотекстовый    │   │
│   │                  │  (search)     │    поиск             │   │
│   │                  └───────────────┘                      │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│   ЭТАП 4: Enterprise (>1M пользователей)                        │
│   + Шардинг, multi-region, специализированные БД                │
│                                                                  │
│   ПРАВИЛО: Усложняй архитектуру только когда простое            │
│            решение объективно не справляется                    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Терминология

| Термин | Значение |
|--------|----------|
| **Document Store** | БД хранит JSON/BSON документы (MongoDB, CouchDB) |
| **Key-Value Store** | Простое хранилище ключ→значение (Redis, Memcached) |
| **Wide-Column Store** | Динамические колонки в строках (Cassandra, HBase) |
| **Graph Database** | Узлы и связи как первоклассные сущности (Neo4j) |
| **CAP теорема** | Consistency, Availability, Partition Tolerance — выбери 2 |
| **Eventual Consistency** | Данные станут консистентными "в итоге" (не сразу) |
| **Sharding** | Горизонтальное разделение данных между узлами |
| **Partition Key** | Ключ для распределения данных по шардам |
| **TTL** | Time-To-Live — автоматическое удаление старых данных |
| **Polyglot Persistence** | Использование разных БД для разных задач в одном проекте |

---

## CAP теорема: фундамент выбора

```
┌─────────────────────────────────────────────────────────────────┐
│                      CAP ТЕОРЕМА                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                    Consistency (C)                              │
│                         ▲                                       │
│                        /│\                                      │
│                       / │ \                                     │
│                      /  │  \                                    │
│                     /   │   \                                   │
│           CA       / CP │ AP \       AP                         │
│        (RDBMS)    /     │     \   (Cassandra)                  │
│                  /      │      \                                │
│                 /       │       \                               │
│                ▼────────┴────────▼                              │
│          Availability (A)    Partition                          │
│                              Tolerance (P)                      │
│                                                                 │
│  CA: PostgreSQL, MySQL (single node)                            │
│  CP: MongoDB, HBase, Redis Cluster                              │
│  AP: Cassandra, DynamoDB, CouchDB                               │
│                                                                 │
│  ⚠️  В распределённой системе P обязателен → выбор C или A     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## MongoDB: Document Database

### Когда использовать

- Гибкая/меняющаяся схема данных
- Вложенные объекты (nested documents)
- Прототипирование и быстрая разработка
- Данные приходят как JSON (IoT, API интеграции)

### Когда НЕ использовать

- Сложные транзакции между документами
- Много связей между сущностями (joins)
- Строгие требования к консистентности

### Модель данных

```javascript
// Document (BSON)
{
  "_id": ObjectId("507f1f77bcf86cd799439011"),
  "name": "John Doe",
  "email": "john@example.com",
  "address": {                    // Вложенный документ
    "street": "123 Main St",
    "city": "NYC",
    "zip": "10001"
  },
  "orders": [                     // Массив документов
    { "product": "iPhone", "qty": 1, "price": 999 },
    { "product": "AirPods", "qty": 2, "price": 249 }
  ],
  "tags": ["premium", "verified"] // Массив скаляров
}
```

### Основные операции

```javascript
// ✅ Insert
db.users.insertOne({
  name: "Alice",
  email: "alice@example.com",
  createdAt: new Date()
});

// ✅ Find с вложенными полями
db.users.find({
  "address.city": "NYC",
  "orders.price": { $gt: 500 }
});

// ✅ Aggregation Pipeline
db.orders.aggregate([
  { $match: { status: "completed" } },
  { $group: {
    _id: "$customerId",
    total: { $sum: "$amount" },
    count: { $sum: 1 }
  }},
  { $sort: { total: -1 } },
  { $limit: 10 }
]);

// ✅ Индексы
db.users.createIndex({ email: 1 }, { unique: true });
db.users.createIndex({ "address.city": 1, createdAt: -1 });
db.products.createIndex({ name: "text", description: "text" }); // Full-text
```

### MongoDB vs PostgreSQL

| Критерий | MongoDB | PostgreSQL |
|----------|---------|------------|
| Схема | Гибкая (schemaless) | Строгая |
| Транзакции | Есть (с 4.0), но ограничены | Полноценные ACID |
| Связи | Embedded или manual refs | Foreign keys + JOINs |
| Масштабирование | Встроенный sharding | Сложнее (Citus, pg_partman) |
| JSON | Нативный BSON | JSONB (очень хорош!) |
| Зрелость | ~15 лет | ~35 лет |

---

## Redis: In-Memory Key-Value Store

### Когда использовать

- Кэширование (горячие данные)
- Сессии пользователей
- Rate limiting / counters
- Pub/Sub messaging
- Очереди задач
- Leaderboards / rankings

### Когда НЕ использовать

- Основное хранилище данных (persistence ненадёжен)
- Данные больше RAM
- Сложные запросы

### Структуры данных

```
┌─────────────────────────────────────────────────────────────────┐
│                   REDIS DATA STRUCTURES                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  STRING    "user:1:name" → "Alice"                              │
│            Кэш, счётчики, простые значения                      │
│                                                                 │
│  HASH      "user:1" → {name: "Alice", email: "a@b.com"}         │
│            Объекты, сессии                                      │
│                                                                 │
│  LIST      "queue:emails" → ["msg1", "msg2", "msg3"]            │
│            Очереди (LPUSH/RPOP), последние N элементов          │
│                                                                 │
│  SET       "user:1:followers" → {42, 55, 78}                    │
│            Уникальные значения, пересечения                     │
│                                                                 │
│  SORTED SET "leaderboard" → {Alice:1500, Bob:1200, Carol:800}   │
│            Рейтинги, временные ряды с score                     │
│                                                                 │
│  STREAM    "events" → ID → {field: value, ...}                  │
│            Event sourcing, логи (Redis 5.0+)                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Основные команды

```bash
# ✅ Strings
SET user:1:name "Alice"
GET user:1:name
INCR page:views              # Атомарный инкремент
SETEX session:abc 3600 data  # TTL 1 час

# ✅ Hash
HSET user:1 name "Alice" email "alice@example.com"
HGET user:1 name
HGETALL user:1

# ✅ List (очередь)
LPUSH queue:tasks "task1"    # Добавить в начало
RPOP queue:tasks             # Взять с конца (FIFO)
BRPOP queue:tasks 30         # Блокирующий pop (30 сек timeout)

# ✅ Set
SADD user:1:tags "premium" "verified"
SISMEMBER user:1:tags "premium"  # Проверка членства O(1)
SINTER user:1:friends user:2:friends  # Общие друзья

# ✅ Sorted Set (leaderboard)
ZADD leaderboard 1500 "Alice" 1200 "Bob"
ZRANK leaderboard "Alice"    # Позиция (0-indexed)
ZREVRANGE leaderboard 0 9 WITHSCORES  # Top-10

# ✅ TTL
EXPIRE key 3600              # Установить TTL
TTL key                      # Проверить оставшееся время
```

### Паттерны использования

```python
# ✅ Cache-Aside Pattern
def get_user(user_id):
    # 1. Проверить кэш
    cached = redis.get(f"user:{user_id}")
    if cached:
        return json.loads(cached)

    # 2. Запрос в БД
    user = db.query("SELECT * FROM users WHERE id = ?", user_id)

    # 3. Сохранить в кэш
    redis.setex(f"user:{user_id}", 3600, json.dumps(user))
    return user

# ✅ Rate Limiting (Fixed Window)
def is_rate_limited(user_id, limit=100, window=60):
    key = f"ratelimit:{user_id}:{int(time.time() / window)}"
    current = redis.incr(key)
    if current == 1:
        redis.expire(key, window)
    return current > limit

# ✅ Distributed Lock
def acquire_lock(lock_name, timeout=10):
    return redis.set(
        f"lock:{lock_name}",
        uuid.uuid4().hex,
        nx=True,  # Only if not exists
        ex=timeout
    )
```

---

## DynamoDB: Serverless Key-Value

### Когда использовать

- AWS-first архитектура
- Serverless (Lambda, API Gateway)
- Предсказуемая latency на любом масштабе
- Автоматическое масштабирование

### Когда НЕ использовать

- Сложные запросы (ad-hoc queries)
- Аналитика (используй Athena/Redshift)
- Малый бюджет (может быть дорого)
- Vendor lock-in неприемлем

### Модель данных

```
┌─────────────────────────────────────────────────────────────────┐
│                   DYNAMODB CONCEPTS                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Table: Orders                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ Partition Key (PK) │ Sort Key (SK) │ Attributes...       │  │
│  ├────────────────────┼───────────────┼─────────────────────┤  │
│  │ USER#123           │ ORDER#001     │ amount: 99.99       │  │
│  │ USER#123           │ ORDER#002     │ amount: 149.99      │  │
│  │ USER#123           │ PROFILE       │ name: "Alice"       │  │
│  │ USER#456           │ ORDER#001     │ amount: 49.99       │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  PK: Определяет партицию (шард)                                │
│  SK: Сортировка внутри партиции                                │
│  PK + SK = Primary Key (уникальный)                            │
│                                                                 │
│  Single Table Design: Разные типы сущностей в одной таблице   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Access Patterns

```python
import boto3

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('Orders')

# ✅ Get item by primary key
response = table.get_item(
    Key={'PK': 'USER#123', 'SK': 'ORDER#001'}
)

# ✅ Query all orders for user
response = table.query(
    KeyConditionExpression='PK = :pk AND begins_with(SK, :sk)',
    ExpressionAttributeValues={
        ':pk': 'USER#123',
        ':sk': 'ORDER#'
    }
)

# ✅ GSI (Global Secondary Index) для других access patterns
# GSI: GSI1PK = status, GSI1SK = createdAt
response = table.query(
    IndexName='GSI1',
    KeyConditionExpression='GSI1PK = :status',
    ExpressionAttributeValues={':status': 'PENDING'}
)

# ✅ Conditional Write (оптимистичная блокировка)
table.update_item(
    Key={'PK': 'USER#123', 'SK': 'PROFILE'},
    UpdateExpression='SET balance = balance - :amount',
    ConditionExpression='balance >= :amount',
    ExpressionAttributeValues={':amount': 100}
)
```

---

## Cassandra: Wide-Column Store

### Когда использовать

- Огромные объёмы записи (IoT, логи, metrics)
- Time-series данные
- Географическое распределение (multi-DC)
- Нет single point of failure

### Когда НЕ использовать

- Много обновлений существующих записей
- Сложные транзакции
- Ad-hoc запросы (нужно знать паттерны заранее)

### Модель данных

```
┌─────────────────────────────────────────────────────────────────┐
│                   CASSANDRA CONCEPTS                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Partition Key: sensor_id                                       │
│  Clustering Key: timestamp DESC                                 │
│                                                                 │
│  ┌─────────────┬──────────────────────────────────────────┐    │
│  │ sensor_id   │ timestamp → value, metadata...           │    │
│  ├─────────────┼──────────────────────────────────────────┤    │
│  │ sensor_001  │ 2025-01-01T10:00 → {temp: 25.5}          │    │
│  │             │ 2025-01-01T09:00 → {temp: 24.8}          │    │
│  │             │ 2025-01-01T08:00 → {temp: 23.2}          │    │
│  ├─────────────┼──────────────────────────────────────────┤    │
│  │ sensor_002  │ 2025-01-01T10:00 → {temp: 30.1}          │    │
│  │             │ ...                                       │    │
│  └─────────────┴──────────────────────────────────────────┘    │
│                                                                 │
│  Wide Column: Неограниченное количество колонок в строке       │
│  Partition: Единица распределения и репликации                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### CQL (Cassandra Query Language)

```sql
-- ✅ Create table
CREATE TABLE sensor_data (
    sensor_id text,
    timestamp timestamp,
    value double,
    metadata map<text, text>,
    PRIMARY KEY (sensor_id, timestamp)
) WITH CLUSTERING ORDER BY (timestamp DESC);

-- ✅ Insert (immutable, append-only)
INSERT INTO sensor_data (sensor_id, timestamp, value)
VALUES ('sensor_001', '2025-01-01T10:00:00Z', 25.5);

-- ✅ Query by partition key + clustering key range
SELECT * FROM sensor_data
WHERE sensor_id = 'sensor_001'
AND timestamp > '2025-01-01T00:00:00Z'
LIMIT 100;

-- ❌ НЕ РАБОТАЕТ без partition key!
-- SELECT * FROM sensor_data WHERE value > 25;  -- Full scan!

-- ✅ TTL — автоматическое удаление старых данных
INSERT INTO sensor_data (sensor_id, timestamp, value)
VALUES ('sensor_001', now(), 25.5) USING TTL 86400;  -- 1 day
```

---

## Сравнительная таблица

| Критерий | MongoDB | Redis | DynamoDB | Cassandra |
|----------|---------|-------|----------|-----------|
| **Тип** | Document | Key-Value | Key-Value | Wide-Column |
| **Консистентность** | Strong/Eventual | Strong | Eventual | Eventual |
| **Масштабирование** | Sharding | Cluster | Auto | Linear |
| **Latency** | ~5-50ms | ~0.5-2ms | ~5-10ms | ~5-20ms |
| **Транзакции** | Да (с 4.0) | MULTI/EXEC | Есть | Нет |
| **Схема** | Гибкая | Нет | Гибкая | Строгая |
| **Query язык** | MQL | Commands | PartiQL | CQL |
| **Hosting** | Atlas, self | Redis Cloud | AWS only | Astra, self |
| **Use case** | General | Cache | Serverless | IoT/Logs |

---

## Polyglot Persistence: комбинируем БД

```
┌─────────────────────────────────────────────────────────────────┐
│                   E-COMMERCE EXAMPLE                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐       │
│  │ PostgreSQL  │     │   MongoDB   │     │    Redis    │       │
│  │             │     │             │     │             │       │
│  │ • Users     │     │ • Products  │     │ • Sessions  │       │
│  │ • Orders    │     │ • Reviews   │     │ • Cart      │       │
│  │ • Payments  │     │ • Catalogs  │     │ • Cache     │       │
│  │             │     │             │     │ • Rate limit│       │
│  └──────┬──────┘     └──────┬──────┘     └──────┬──────┘       │
│         │                   │                   │               │
│         └───────────────────┼───────────────────┘               │
│                             │                                   │
│                    ┌────────▼────────┐                          │
│                    │ Elasticsearch   │                          │
│                    │ • Product search│                          │
│                    │ • Logs          │                          │
│                    │ • Analytics     │                          │
│                    └─────────────────┘                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

PostgreSQL: Транзакции, финансы, ACID (заказы, платежи)
MongoDB: Гибкая схема (каталоги с разными атрибутами)
Redis: Скорость (сессии, корзина, кэш)
Elasticsearch: Поиск (full-text по товарам)
```

---

## Проверь себя

<details>
<summary>1. Что означает CAP теорема и какой выбор делают разные БД?</summary>

**Ответ:** CAP теорема говорит, что в распределённой системе невозможно одновременно гарантировать:
- **Consistency** — все узлы видят одинаковые данные
- **Availability** — система отвечает на запросы
- **Partition Tolerance** — система работает при сетевых разрывах

В распределённой системе P обязателен, поэтому выбор между C и A:
- **CP (MongoDB, HBase):** При разрыве сети — отказ отвечать, но консистентность
- **AP (Cassandra, DynamoDB):** При разрыве сети — отвечают, но eventual consistency

</details>

<details>
<summary>2. Когда выбрать MongoDB вместо PostgreSQL?</summary>

**Ответ:**
- Часто меняющаяся схема данных
- Вложенные документы без нормализации
- Данные приходят как JSON (API, IoT)
- Горизонтальное масштабирование важнее транзакций
- Прототипирование и быстрый старт

НО: PostgreSQL с JSONB часто достаточно! Начни с PostgreSQL, мигрируй если нужно.

</details>

<details>
<summary>3. Для чего Redis НЕ подходит?</summary>

**Ответ:**
- **Основное хранилище данных** — persistence ненадёжен (RDB/AOF могут терять данные)
- **Данные больше RAM** — Redis in-memory, дорого
- **Сложные запросы** — нет SQL, joins, агрегаций
- **Долгосрочное хранение** — нет индексов, сложная аналитика

Redis — это кэш и вспомогательное хранилище, не замена БД.

</details>

<details>
<summary>4. Почему в Cassandra нельзя делать произвольные запросы?</summary>

**Ответ:** Cassandra оптимизирована под конкретные access patterns:
- Данные распределены по partition key
- Запрос без partition key = full cluster scan
- Нужно проектировать таблицы под запросы (denormalization)

Решение: создавай отдельные таблицы (materialized views) для каждого access pattern. Это trade-off: больше места, быстрее чтение.

</details>

<details>
<summary>5. Что такое Polyglot Persistence и когда его применять?</summary>

**Ответ:** Polyglot Persistence — использование разных типов БД для разных задач в одном проекте.

**Пример e-commerce:**
- PostgreSQL: заказы, платежи (ACID)
- MongoDB: каталог товаров (гибкая схема)
- Redis: сессии, кэш (скорость)
- Elasticsearch: поиск товаров (full-text)

**Когда применять:**
- Разные части системы имеют разные требования
- Одна БД не справляется со всеми нагрузками
- Команда готова поддерживать несколько технологий

**Цена:** сложность синхронизации, обучение, операционные затраты.

</details>

---

## Связи

- [[databases-overview]] — карта раздела
- [[databases-replication-sharding]] — масштабирование БД
- [[caching-strategies]] — паттерны кэширования
- [[architecture-distributed-systems]] — распределённые системы

---

## Источники

- [MongoDB Documentation](https://www.mongodb.com/docs/)
- [Redis Documentation](https://redis.io/docs/)
- [AWS DynamoDB Developer Guide](https://docs.aws.amazon.com/amazondynamodb/)
- [Apache Cassandra Documentation](https://cassandra.apache.org/doc/latest/)
- "Designing Data-Intensive Applications" by Martin Kleppmann — Chapter 2-3

---

*Проверено: 2025-12-22*
*Обновлено: 2026-01-09 — добавлены педагогические секции (5 аналогий: кухонные приборы, системы хранения, CAP-банкоматы, Redis как RAM, Cassandra как конвейер; 6 типичных ошибок: MongoDB для всего, Redis как основная БД, Cassandra без access patterns, игнорирование CAP, преждевременная оптимизация, недооценка polyglot; 5 ментальных моделей: дерево решений, CAP в реальности, latency пирамида, data model fit, эволюция архитектуры)*
