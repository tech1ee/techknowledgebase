---
title: "Backup & Recovery: PITR, WAL, RTO/RPO"
created: 2025-12-22
modified: 2025-12-22
type: concept
status: verified
confidence: high
tags:
  - databases
  - backup
  - recovery
  - disaster-recovery
  - postgresql
related:
  - "[[databases-overview]]"
  - "[[databases-replication-sharding]]"
  - "[[cloud-disaster-recovery]]"
---

# Backup & Recovery: PITR, WAL, RTO/RPO

> Бэкапы — страховка от катастроф. Без тестированного recovery бэкап бесполезен. Планируй RTO/RPO до того, как случится инцидент.

---

## TL;DR

- **RTO** — Recovery Time Objective: сколько времени на восстановление
- **RPO** — Recovery Point Objective: сколько данных можно потерять
- **Logical backup** — pg_dump: читаемый SQL, медленный restore
- **Physical backup** — pg_basebackup: быстрый restore, PITR
- **PITR** — Point-in-Time Recovery: восстановление на любой момент времени
- **Правило 3-2-1:** 3 копии, 2 разных носителя, 1 offsite

---

## Часть 1: Интуиция без кода

### Аналогия 1: Страховка на автомобиль (RTO и RPO)

Представь автострахование с двумя параметрами:

```
RTO (время восстановления):
┌─────────────────────────────────────────────────────┐
│ КАСКО Премиум:  Замена авто за 24 часа  │ $$$$$   │
│ КАСКО Стандарт: Ремонт за 7 дней        │ $$$     │
│ ОСАГО базовое:  Ремонт за 30 дней       │ $       │
└─────────────────────────────────────────────────────┘

RPO (потеря данных = франшиза):
┌─────────────────────────────────────────────────────┐
│ Франшиза 0₽:    Полное возмещение       │ $$$$$   │
│ Франшиза 10K₽:  Потеряете до 10 тыс.    │ $$$     │
│ Франшиза 50K₽:  Потеряете до 50 тыс.    │ $       │
└─────────────────────────────────────────────────────┘
```

**Ключевая идея:**
- **RTO** = как быстро вернут машину (время простоя)
- **RPO** = сколько денег готов потерять (франшиза = потерянные данные)
- Меньше потери → дороже страховка → чаще бэкапы

### Аналогия 2: Машина времени (PITR)

PITR — это как машина времени для базы данных:

```
                    Сегодня, 14:00
                    Ошибка! DELETE без WHERE!
                           │
                           ▼
───┬─────────┬─────────┬───┼───────────────────▶ время
   │         │         │   │
 Пн 02:00  Вт 02:00  Ср 02:00
 (full)    (incr)    (incr)
   │         │         │
   └─────────┴─────────┴─── WAL файлы ────────┘

PITR: "Отмотай время на Ср 13:59!"

1. Загружаем бэкап понедельника (отправная точка)
2. Проигрываем WAL файлы как кинолёнту
3. Останавливаемся ЗА МИНУТУ до катастрофы
4. Вуаля — DELETE никогда не было!
```

**Без PITR:** Можно только вернуться на момент бэкапа (потерять 2 дня).
**С PITR:** Можно вернуться на ЛЮБУЮ секунду между бэкапами.

### Аналогия 3: Сейф с документами (Правило 3-2-1)

Представь важные документы (паспорт, свидетельства):

```
ПЛОХО (1-1-0):                    ХОРОШО (3-2-1):
┌─────────────────┐               ┌─────────────────┐
│ Оригинал дома   │               │ 1. Оригинал дома│
│ в одном месте   │               │ 2. Копия в сейфе│
└────────┬────────┘               │ 3. Скан в облаке│
         │                        └─────────────────┘
         ▼                                │
    Пожар?                               ├── Бумага + диск
    Потоп?                               ├── Локально + удалённо
    Кража?                               └── Автономно от дома
         │
         ▼
    ВСЁ ПОТЕРЯНО

Правило 3-2-1:
• 3 копии = выживает при 2 катастрофах
• 2 носителя = защита от сбоя одного типа
• 1 offsite = защита от локальной катастрофы
```

### Аналогия 4: Фотоальбом vs Клон комнаты (Logical vs Physical)

**Logical backup (pg_dump)** — как сфотографировать содержимое комнаты:

```
┌──────────────────────────────────┐
│          КОМНАТА                 │
│  🛋️ Диван    🖼️ Картина         │
│  📺 Телевизор 🪴 Растение        │
│  📚 Книги (расположение!)        │
└──────────────────────────────────┘
              │
              ▼ pg_dump
┌──────────────────────────────────┐
│ ФОТОАЛЬБОМ (SQL файл):           │
│ "1 диван синий,                  │
│  1 картина 50x70,                │
│  1 телевизор Samsung..."         │
└──────────────────────────────────┘

✅ Легко прочитать что внутри
✅ Можно "переехать" (другая версия PostgreSQL)
✅ Можно взять только диван (одну таблицу)
❌ Восстановление = заново покупать и расставлять
```

**Physical backup (pg_basebackup)** — как сделать точный клон комнаты:

```
┌──────────────────────────────────┐
│          КОМНАТА                 │
│  🛋️ Диван    🖼️ Картина         │
│  📺 Телевизор 🪴 Растение        │
│  📚 Книги (расположение!)        │
└──────────────────────────────────┘
              │
              ▼ pg_basebackup
┌──────────────────────────────────┐
│   ТОЧНАЯ КОПИЯ КОМНАТЫ          │
│  🛋️ Диван    🖼️ Картина         │  (даже пыль!)
│  📺 Телевизор 🪴 Растение        │
│  📚 Книги (расположение!)        │
└──────────────────────────────────┘

✅ Мгновенно "въехать" (быстрый restore)
✅ Всё на своих местах (включая индексы)
❌ Нельзя "переехать" в другой дом (только та же версия)
❌ Нельзя взять только диван
```

### Аналогия 5: Чёрный ящик самолёта (WAL)

WAL работает как бортовой самописец:

```
САМОЛЁТ (PostgreSQL):
┌─────────────────────────────────────────────────┐
│  Пилот даёт команды:                            │
│  • 14:00:01 — Набор высоты 10,000 м             │
│  • 14:00:02 — Курс 270°                         │
│  • 14:00:03 — Скорость 800 км/ч                 │
│                                                 │
│  ЧЁРНЫЙ ЯЩИК (WAL) ЗАПИСЫВАЕТ ВСЁ:              │
│  ┌─────────────────────────────────────────┐   │
│  │ 14:00:01 altitude=10000                 │   │
│  │ 14:00:02 heading=270                    │   │
│  │ 14:00:03 speed=800                      │   │
│  │ ...                                     │   │
│  └─────────────────────────────────────────┘   │
└─────────────────────────────────────────────────┘

При crash:
1. Знаем состояние на момент катастрофы
2. Можем "проиграть" записи для расследования
3. Можем восстановить любой момент полёта

В PostgreSQL:
• WAL = журнал ВСЕХ изменений
• COMMIT → сначала в WAL, потом в таблицу
• Crash recovery: читаем WAL, восстанавливаем
```

---

## Часть 2: Почему это сложно

### Ошибка 1: Бэкапы без тестирования restore

**СИМПТОМ:** "Бэкапы делаем каждый день!" Инцидент → бэкап повреждён или не восстанавливается.

```
Статистика:
┌─────────────────────────────────────────────────────┐
│ 34% компаний никогда не тестировали restore        │
│ 77% столкнулись с проблемами при реальном restore  │
│ "Бэкап — гипотеза. Restore — доказательство."      │
└─────────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:**
1. Автоматизированный restore test еженедельно
2. Проверка целостности данных (checksums, row counts)
3. Измерение времени restore (укладываемся в RTO?)
4. Документирование процедуры restore

### Ошибка 2: Одна копия бэкапа (нет offsite)

**СИМПТОМ:** Бэкап на том же сервере или в том же датацентре.

```
СЦЕНАРИЙ:
┌─────────────────┐
│    Сервер       │
│  ┌───────────┐  │
│  │ Database  │  │
│  └───────────┘  │
│  ┌───────────┐  │     Ransomware / Пожар / Наводнение
│  │ Backup    │  │  ←────────────────────────────────
│  └───────────┘  │
└─────────────────┘
        │
        ▼
   ОБА ПОТЕРЯНЫ!
```

**РЕШЕНИЕ:**
- Offsite копия в другом регионе/облаке
- Air-gapped бэкапы (изолированные от сети)
- Immutable storage (нельзя перезаписать/удалить)
- Минимум 3-2-1: S3 + локальный диск + tape

### Ошибка 3: RPO не соответствует частоте бэкапов

**СИМПТОМ:** "RPO = 1 час" при ночных бэкапах.

```
Обещание:  RPO = 1 час
Реальность: Full backup раз в сутки

Инцидент в 17:00:
• Последний бэкап: 02:00
• Потеря данных: 15 ЧАСОВ (не 1 час!)

┌──────────────────────────────────────────────────┐
│ RPO     │ Минимальная частота бэкапов           │
├─────────┼────────────────────────────────────────┤
│ 1 час   │ Incremental каждый час + WAL archive  │
│ 15 мин  │ WAL archive + archive_timeout=900     │
│ 0 (!)   │ Synchronous replication               │
└──────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:** Настроить WAL archiving + archive_timeout для реального RPO.

### Ошибка 4: Physical backup без WAL = нет PITR

**СИМПТОМ:** Делают pg_basebackup, но WAL не архивируют.

```
С WAL архивами:
Base backup (Пн) ──── WAL ──── WAL ──── WAL ──── (Пт)
       │                                           │
       └───── PITR на ЛЮБОЙ момент Пн-Пт ─────────┘

БЕЗ WAL архивов:
Base backup (Пн) ─ ─ ─ ─ ─ ─ пустота ─ ─ ─ ─ ─ (Пт)
       │                                           │
       └───── Только состояние понедельника ──────┘
```

**РЕШЕНИЕ:**
```bash
# postgresql.conf
wal_level = replica
archive_mode = on
archive_command = 'cp %p /archive/%f'
archive_timeout = 60  # Форсировать архив каждую минуту
```

### Ошибка 5: Restore не укладывается в RTO

**СИМПТОМ:** RTO = 4 часа, но restore 500GB базы занимает 8 часов.

```
Проблема:
┌─────────────────────────────────────────────────────┐
│ Размер БД:        500 GB                            │
│ Сеть S3 → сервер: 100 MB/s                          │
│ Время скачивания: 500GB / 100MB/s = 1.5 часа       │
│ Время restore:    pg_restore -j4 = 6 часов         │
│ ИТОГО:            7.5 часов > RTO 4 часа!          │
└─────────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:**
1. **Hot standby:** Реплика готова принять нагрузку за минуты
2. **Local backup:** Держать копию локально (быстрее чем S3)
3. **Parallel restore:** `pg_restore -j N` (больше потоков)
4. **Physical backup:** Быстрее logical для больших БД
5. **Тестировать RTO:** Регулярно измерять реальное время restore

### Ошибка 6: Бэкап только БД, забыли конфиги

**СИМПТОМ:** Восстановили данные, но сервер не запускается — нет postgresql.conf, pg_hba.conf.

```
ЧТО НУЖНО БЭКАПИТЬ:
┌─────────────────────────────────────────────────────┐
│ ✅ Данные (pg_dump / pg_basebackup)                 │
│ ✅ postgresql.conf (настройки)                      │
│ ✅ pg_hba.conf (аутентификация)                     │
│ ✅ Roles/users: pg_dumpall --roles-only            │
│ ✅ Tablespaces (если используются)                  │
│ ✅ Extensions: pg_dump --no-data --schema-only     │
│ ✅ Cron jobs / скрипты бэкапов                     │
│ ✅ Мониторинг алерты конфиги                       │
└─────────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:** Включить конфиги в бэкап, хранить в Git, документировать setup.

---

## Часть 3: Ментальные модели

### Модель 1: RTO/RPO как SLA с бизнесом

```
             СТОИМОСТЬ ПРОСТОЯ
                    │
    ┌───────────────┼───────────────┐
    │               │               │
  $$$$$           $$$             $
    │               │               │
    ▼               ▼               ▼
┌────────┐    ┌────────┐    ┌────────┐
│ Tier 1 │    │ Tier 2 │    │ Tier 3 │
│ Core   │    │Business│    │ Dev/   │
│ Banking│    │ Apps   │    │ Test   │
├────────┤    ├────────┤    ├────────┤
│RPO: 0  │    │RPO: 1h │    │RPO: 24h│
│RTO: 15m│    │RTO: 4h │    │RTO: 48h│
├────────┤    ├────────┤    ├────────┤
│Sync rep│    │WAL+Incr│    │Daily   │
│Hot stby│    │Local+S3│    │S3 only │
│$$$$$   │    │$$$     │    │$       │
└────────┘    └────────┘    └────────┘

Вопрос к бизнесу: "Сколько стоит час простоя?"
• $5,600/мин = $336,000/час → Tier 1
• $1,000/час → Tier 2
• "Подождут" → Tier 3
```

### Модель 2: Пирамида бэкапов

```
                    ▲
                   ╱ ╲
                  ╱ W ╲     WAL архивы
                 ╱ A L ╲    (каждую минуту)
                ╱───────╲   RPO: минуты
               ╱ INCR   ╲   Incremental
              ╱ BACKUP   ╲  (ежедневно)
             ╱─────────────╲ RPO: часы
            ╱  FULL BACKUP  ╲
           ╱   (еженедельно) ╲
          ╱───────────────────╲
         ╱   OFFSITE ARCHIVE   ╲
        ╱   (ежемесячно, годовой)╲
       ╱─────────────────────────╲

Восстановление:
1. Берём последний FULL
2. Накатываем INCREMENTAL
3. Проигрываем WAL до нужного момента

Чем выше в пирамиде — тем чаще, но меньше размер.
```

### Модель 3: Матрица выбора типа бэкапа

```
┌─────────────────┬──────────────────┬──────────────────┐
│                 │   pg_dump        │  pg_basebackup   │
│                 │   (Logical)      │  (Physical)      │
├─────────────────┼──────────────────┼──────────────────┤
│ Размер БД       │  < 100 GB ✅     │  > 100 GB ✅     │
├─────────────────┼──────────────────┼──────────────────┤
│ Скорость restore│  Медленно ❌     │  Быстро ✅       │
├─────────────────┼──────────────────┼──────────────────┤
│ PITR            │  Нет ❌          │  Да (с WAL) ✅   │
├─────────────────┼──────────────────┼──────────────────┤
│ Cross-version   │  Да ✅           │  Нет ❌          │
├─────────────────┼──────────────────┼──────────────────┤
│ Partial restore │  Да (таблица) ✅ │  Нет ❌          │
├─────────────────┼──────────────────┼──────────────────┤
│ Читаемость      │  SQL текст ✅    │  Бинарник ❌     │
└─────────────────┴──────────────────┴──────────────────┘

ВЕРДИКТ:
• Маленькая БД + миграция версий → pg_dump
• Большая БД + DR + PITR → pg_basebackup + WAL
• Идеально: ОБА (pg_dump для гибкости, physical для DR)
```

### Модель 4: Временная шкала recovery

```
             ПРОШЛОЕ                    СЕЙЧАС
                │                          │
────────────────┼──────────────────────────┼──────────────▶
                │                          │           время
                │                          │
         ┌──────┴──────┐            ┌──────┴──────┐
         │ Момент      │            │ Момент      │
         │ бэкапа      │            │ инцидента   │
         └──────┬──────┘            └──────┬──────┘
                │                          │
                ◀──────────────────────────▶
                        RPO зона
                   (данные потеряны)

                               │
                               ▼
                        ┌──────────────┐
                        │ Начало       │
                        │ восстановления│
                        └──────┬───────┘
                               │
                               ◀─────────────────────▶
                                      RTO зона
                                 (время простоя)
                                              │
                                              ▼
                                       ┌──────────────┐
                                       │ Система      │
                                       │ работает     │
                                       └──────────────┘
```

### Модель 5: Цена защиты vs цена потери

```
                    СТОИМОСТЬ
                        │
                        │
    Стоимость           │                    ╱
    потери данных       │                 ╱
    (downtime +         │              ╱
     lost revenue)      │           ╱
                        │        ╱
                        │     ╱
                        │  ╱                    Стоимость
                        ├╱─────────────────── защиты
                       ╱│                      (инфраструктура +
                    ╱   │                       операции)
                 ╱      │
              ╱         │
           ╱            │
        ╱               │
     ╱                  │
  ╱                     │
────────────────────────┼───────────────────────▶
                        │                     RPO/RTO
  0 min    15 min    1 hour    4 hour    24 hour

                     ★ ОПТИМУМ
                    (пересечение)

ВЫВОД: Не переплачивай за RPO=0, если потеря данных за час
       стоит меньше, чем synchronous replication.
```

---

## Терминология

| Термин | Значение |
|--------|----------|
| **RTO** | Recovery Time Objective — максимальное время простоя |
| **RPO** | Recovery Point Objective — максимальная потеря данных |
| **Logical Backup** | Экспорт данных как SQL (pg_dump) |
| **Physical Backup** | Копия файлов БД (pg_basebackup) |
| **WAL** | Write-Ahead Log — журнал транзакций |
| **PITR** | Point-in-Time Recovery — восстановление на момент времени |
| **Incremental Backup** | Только изменения с последнего бэкапа |
| **Full Backup** | Полная копия всех данных |
| **Hot Backup** | Бэкап работающей БД без остановки |
| **Cold Backup** | Бэкап остановленной БД |

---

## RTO и RPO: бизнес-требования

```
┌─────────────────────────────────────────────────────────────────┐
│                    RTO / RPO                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Инцидент                                                       │
│     │                                                           │
│     ▼                                                           │
│  ───┼───────────────────────────────────────────────────────▶  │
│     │                                                     time  │
│     │                                                           │
│  ◀──┼──▶                           ◀────────────────────────▶  │
│    RPO                                      RTO                 │
│  Потеря данных                        Время простоя            │
│  (сколько можно потерять)            (сколько восстанавливать) │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Примеры требований:                                     │   │
│  │                                                         │   │
│  │ Банк:        RPO = 0 (нет потерь)      RTO = 15 min    │   │
│  │ E-commerce:  RPO = 1 hour              RTO = 4 hours   │   │
│  │ Blog:        RPO = 24 hours            RTO = 24 hours  │   │
│  │ Analytics:   RPO = 1 week              RTO = 1 week    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Меньше RTO/RPO = дороже инфраструктура                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Типы бэкапов

### Logical vs Physical

```
┌─────────────────────────────────────────────────────────────────┐
│              LOGICAL vs PHYSICAL BACKUP                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  LOGICAL (pg_dump)                                              │
│  ──────────────────                                             │
│  ✅ Читаемый SQL                                                 │
│  ✅ Переносимость (версии, платформы)                            │
│  ✅ Выборочный restore (одна таблица)                            │
│  ✅ Маленький размер (без индексов)                              │
│  ❌ Медленный backup (читает данные)                             │
│  ❌ Медленный restore (INSERT + индексы)                         │
│  ❌ Нет PITR                                                     │
│                                                                 │
│  PHYSICAL (pg_basebackup)                                       │
│  ─────────────────────────                                      │
│  ✅ Быстрый backup (копия файлов)                                │
│  ✅ Быстрый restore (просто скопировать)                         │
│  ✅ PITR с WAL архивами                                          │
│  ❌ Только та же версия PostgreSQL                               │
│  ❌ Нельзя выбрать часть данных                                  │
│  ❌ Больший размер (включая индексы)                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Logical Backup: pg_dump

```bash
# Полный дамп БД в SQL
pg_dump -h localhost -U postgres mydb > backup.sql

# Кастомный формат (сжатие + параллельный restore)
pg_dump -Fc mydb > backup.dump

# Параллельный дамп (быстрее для больших БД)
pg_dump -j 4 -Fd mydb -f backup_dir/

# Только схема (без данных)
pg_dump --schema-only mydb > schema.sql

# Только данные (без схемы)
pg_dump --data-only mydb > data.sql

# Одна таблица
pg_dump -t orders mydb > orders.sql

# Restore
psql mydb < backup.sql
pg_restore -d mydb backup.dump
pg_restore -j 4 -d mydb backup_dir/
```

### Physical Backup: pg_basebackup

```bash
# Базовый бэкап
pg_basebackup -h localhost -U replicator -D /backup/base \
  -Fp -Xs -P

# С checkpoint
pg_basebackup -h localhost -U replicator -D /backup/base \
  --checkpoint=fast -Fp -Xs -P

# Сжатый tar
pg_basebackup -h localhost -U replicator -D /backup \
  -Ft -z -Xs -P
# Создаёт base.tar.gz и pg_wal.tar.gz
```

---

## WAL и PITR

### Как работает WAL

```
┌─────────────────────────────────────────────────────────────────┐
│                      WAL (Write-Ahead Log)                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Транзакция делает изменения                                │
│                                                                 │
│  2. Изменения записываются в WAL (append-only)                 │
│     ┌──────────────────────────────────────────────────────┐   │
│     │ LSN 0/1000: INSERT INTO orders VALUES (1, ...)       │   │
│     │ LSN 0/1050: UPDATE accounts SET balance = ...        │   │
│     │ LSN 0/1100: COMMIT                                   │   │
│     └──────────────────────────────────────────────────────┘   │
│                                                                 │
│  3. COMMIT возвращается после записи в WAL (не в таблицы!)     │
│                                                                 │
│  4. Фоновый процесс записывает данные в таблицы               │
│                                                                 │
│  DURABILITY: Даже при crash данные есть в WAL → recovery       │
│                                                                 │
│  WAL файлы: pg_wal/000000010000000000000001 (16MB each)        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Настройка архивирования WAL

```bash
# postgresql.conf
wal_level = replica          # minimal, replica, logical
archive_mode = on
archive_command = 'cp %p /archive/%f'
# Или в S3:
# archive_command = 'aws s3 cp %p s3://mybucket/wal/%f'

archive_timeout = 60         # Архивировать частично заполненный WAL каждые 60 сек
```

### PITR: Point-in-Time Recovery

```bash
# 1. Восстановить base backup
pg_basebackup_restore или tar -xf base.tar.gz

# 2. Создать recovery.signal
touch /pgdata/recovery.signal

# 3. Настроить postgresql.conf
restore_command = 'cp /archive/%f %p'
recovery_target_time = '2025-01-15 14:30:00'
# Или: recovery_target_lsn = '0/1A000060'
# Или: recovery_target_name = 'before_migration'

# 4. Запустить PostgreSQL
pg_ctl start -D /pgdata

# PostgreSQL применит WAL до указанного момента
```

```
┌─────────────────────────────────────────────────────────────────┐
│                         PITR                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Base backup         WAL archives           Recovery target     │
│  (понедельник)       (пн-пт)                (пятница 14:30)    │
│                                                                 │
│      │                  │                        │              │
│      ▼                  ▼                        ▼              │
│  ────┼──────────────────┼────────────────────────┼────▶        │
│      │                                           │     time     │
│      │◀──────────────────────────────────────────▶│              │
│      │         Replay WAL до target time          │              │
│      │                                           │              │
│  ┌───┴───┐                                   ┌───┴───┐          │
│  │ Base  │                                   │Restored│         │
│  │Backup │                                   │  State │         │
│  └───────┘                                   └────────┘         │
│                                                                 │
│  Можно восстановить на ЛЮБОЙ момент между base backup и        │
│  последним заархивированным WAL                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Инструменты

### pgBackRest

```bash
# Конфигурация /etc/pgbackrest.conf
[mydb]
pg1-path=/var/lib/postgresql/16/main

[global]
repo1-path=/var/lib/pgbackrest
repo1-retention-full=2

# Full backup
pgbackrest --stanza=mydb backup --type=full

# Incremental backup
pgbackrest --stanza=mydb backup --type=incr

# Restore
pgbackrest --stanza=mydb restore

# PITR
pgbackrest --stanza=mydb restore \
  --target="2025-01-15 14:30:00" \
  --target-action=promote
```

### Barman (для enterprise)

```bash
# Конфигурация /etc/barman.d/mydb.conf
[mydb]
conninfo = host=primary user=barman dbname=postgres
backup_method = postgres
streaming_conninfo = host=primary user=streaming_barman

# Backup
barman backup mydb

# List backups
barman list-backup mydb

# Restore
barman recover mydb 20250115T140000 /var/lib/postgresql/restore
```

---

## Стратегии бэкапов

### Правило 3-2-1

```
┌─────────────────────────────────────────────────────────────────┐
│                    ПРАВИЛО 3-2-1                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  3 копии данных                                                │
│  │                                                              │
│  ├── Primary database                                          │
│  ├── Local backup (быстрый restore)                            │
│  └── Offsite backup (disaster recovery)                        │
│                                                                 │
│  2 разных типа носителей                                       │
│  │                                                              │
│  ├── SSD/HDD на сервере                                        │
│  └── Object storage (S3, GCS)                                  │
│                                                                 │
│  1 копия offsite                                               │
│  │                                                              │
│  └── Другой datacenter / регион / облако                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Расписание бэкапов

```
┌─────────────────────────────────────────────────────────────────┐
│                  ТИПИЧНОЕ РАСПИСАНИЕ                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Для RPO = 1 hour, RTO = 4 hours:                              │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ Full backup:    Воскресенье 02:00                        │  │
│  │ Incremental:    Ежедневно 02:00                          │  │
│  │ WAL archive:    Непрерывно (каждый полный сегмент)       │  │
│  │ WAL timeout:    60 секунд (форсировать архив)            │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  Retention:                                                     │
│  • Full backups: 4 недели                                      │
│  • Incremental: 7 дней                                         │
│  • WAL archives: 7 дней (или до oldest backup)                 │
│                                                                 │
│  Для RPO = 0 (zero data loss):                                 │
│  • Synchronous replication + streaming backup                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Тестирование восстановления

```bash
#!/bin/bash
# restore_test.sh — ОБЯЗАТЕЛЬНО тестировать регулярно!

# 1. Восстановить в отдельную директорию
pg_restore -d testdb backup.dump

# 2. Проверить целостность
psql testdb -c "SELECT count(*) FROM orders;"
psql testdb -c "SELECT count(*) FROM users;"

# 3. Проверить constraints
psql testdb -c "
  SELECT conname, conrelid::regclass
  FROM pg_constraint
  WHERE NOT convalidated;"

# 4. Замерить время
time pg_restore -d testdb backup.dump

# 5. Отправить алерт если проблема
if [ $? -ne 0 ]; then
  send_alert "Restore test failed!"
fi
```

---

## Проверь себя

<details>
<summary>1. Чем RTO отличается от RPO?</summary>

**Ответ:**
- **RTO (Recovery Time Objective):** Максимально допустимое время простоя. Сколько времени займёт восстановление.
- **RPO (Recovery Point Objective):** Максимально допустимая потеря данных. Сколько данных можно потерять (в минутах/часах).

Пример: RPO = 1 hour означает бэкапы каждый час. RTO = 4 hours означает восстановление за 4 часа.

</details>

<details>
<summary>2. Когда использовать pg_dump vs pg_basebackup?</summary>

**Ответ:**
- **pg_dump (logical):**
  - Миграция между версиями PostgreSQL
  - Выборочный restore (одна таблица)
  - Маленькие БД (< 100GB)
  - Нужен читаемый SQL

- **pg_basebackup (physical):**
  - Большие БД (быстрый restore)
  - PITR (восстановление на момент времени)
  - Disaster recovery
  - Hot standby setup

</details>

<details>
<summary>3. Что такое PITR и как он работает?</summary>

**Ответ:** PITR (Point-in-Time Recovery) — восстановление БД на любой момент времени.

Как работает:
1. Берём base backup (полная копия)
2. Применяем WAL файлы последовательно
3. Останавливаемся на указанном моменте (timestamp, LSN, named point)

Требования: `wal_level = replica`, `archive_mode = on`, непрерывный архив WAL.

</details>

<details>
<summary>4. Что такое правило 3-2-1 для бэкапов?</summary>

**Ответ:**
- **3** копии данных (production + 2 backup)
- **2** разных типа носителей (локальный диск + object storage)
- **1** копия offsite (другой datacenter/регион)

Защищает от: аппаратных сбоев, ransomware, пожара/наводнения, человеческих ошибок.

</details>

<details>
<summary>5. Почему важно тестировать restore?</summary>

**Ответ:** Бэкап без тестированного restore бесполезен.

Проблемы, которые выявляет тест:
- Corrupt backup файлы
- Неполный бэкап (забыли таблицу)
- Слишком долгий restore (не укладываемся в RTO)
- Неправильные permissions
- Отсутствующие зависимости

Рекомендация: тестировать restore еженедельно или после каждого full backup.

</details>

---

## Связи

- [[databases-overview]] — карта раздела
- [[databases-replication-sharding]] — репликация для HA
- [[cloud-disaster-recovery]] — DR в облаке
- [[devops-incident-management]] — incident response

---

## Источники

- [PostgreSQL Backup and Restore](https://www.postgresql.org/docs/current/backup.html)
- [pgBackRest Documentation](https://pgbackrest.org/)
- [Barman Documentation](https://www.pgbarman.org/)
- "PostgreSQL 16 Administration Cookbook" — Chapter on Backup

---

*Обновлено: 2026-01-09 — добавлены педагогические секции (5 аналогий: страховка/RTO-RPO, машина времени/PITR, сейф/3-2-1, фотоальбом vs клон/logical-physical, чёрный ящик/WAL; 6 типичных ошибок с решениями; 5 ментальных моделей DR) | PostgreSQL 16*
