---
title: "Transactions & ACID: уровни изоляции, блокировки, deadlocks"
created: 2025-12-22
modified: 2025-12-22
type: deep-dive
status: verified
confidence: high
tags:
  - databases
  - transactions
  - acid
  - isolation
  - locks
related:
  - "[[databases-overview]]"
  - "[[databases-sql-fundamentals]]"
  - "[[architecture-distributed-systems]]"
---

# Transactions & ACID: уровни изоляции, блокировки, deadlocks

> Транзакция — группа операций, которые выполняются как единое целое: либо все успешно, либо ни одна. ACID гарантирует целостность данных даже при сбоях и конкурентном доступе.

---

## TL;DR

- **ACID** — Atomicity, Consistency, Isolation, Durability
- **Уровни изоляции** — Read Uncommitted → Read Committed → Repeatable Read → Serializable
- **Аномалии** — Dirty Read, Non-Repeatable Read, Phantom Read, Lost Update
- **Блокировки** — Shared (чтение), Exclusive (запись), Row-level, Table-level
- **Deadlock** — взаимная блокировка, решается таймаутом или detection
- **Оптимистичные блокировки** — version/timestamp вместо locks

---

## Часть 1: Интуиция без кода

> Транзакции — это как контракт с базой данных: "Или делаешь всё как я сказал, или ничего не делаешь".

### Аналогия 1: Банковский перевод — суть ACID

```
┌─────────────────────────────────────────────────────────────────┐
│              ПЕРЕВОД ДЕНЕГ: ВСЁ ИЛИ НИЧЕГО                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Вы переводите 1000₽ другу                                     │
│                                                                  │
│   ┌──────────────────────────────────────────────────────────┐  │
│   │  ШАГ 1: Списать 1000₽ с вашего счёта                     │  │
│   │  ШАГ 2: Зачислить 1000₽ на счёт друга                    │  │
│   └──────────────────────────────────────────────────────────┘  │
│                                                                  │
│   БЕЗ ТРАНЗАКЦИИ:                                               │
│   ┌──────────┐          ┌──────────┐                            │
│   │ Вы       │          │ Друг     │                            │
│   │ 10,000₽  │          │ 5,000₽   │                            │
│   └────┬─────┘          └──────────┘                            │
│        │ -1000₽                                                  │
│        ▼                                                         │
│   ┌──────────┐          ┌──────────┐                            │
│   │ Вы       │  💥СБОЙ! │ Друг     │                            │
│   │ 9,000₽   │          │ 5,000₽   │  ← Деньги пропали!        │
│   └──────────┘          └──────────┘                            │
│                                                                  │
│   С ТРАНЗАКЦИЕЙ (ACID):                                         │
│   ┌──────────┐          ┌──────────┐                            │
│   │ Вы       │          │ Друг     │                            │
│   │ 10,000₽  │          │ 5,000₽   │                            │
│   └────┬─────┘          └──────────┘                            │
│        │ BEGIN TRANSACTION                                       │
│        │ -1000₽ (но ещё не commit)                              │
│        │ 💥СБОЙ!                                                 │
│        │ ROLLBACK — автоматически                               │
│        ▼                                                         │
│   ┌──────────┐          ┌──────────┐                            │
│   │ Вы       │          │ Друг     │                            │
│   │ 10,000₽  │          │ 5,000₽   │  ← Всё на месте!          │
│   └──────────┘          └──────────┘                            │
│                                                                  │
│   ATOMICITY = "Всё или ничего"                                  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Аналогия 2: Mutex и семафор — изоляция транзакций

```
┌─────────────────────────────────────────────────────────────────┐
│           ТРАНЗАКЦИИ КАК ПОТОКИ В ПРОГРАММИРОВАНИИ               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Знакомо?                                                       │
│                                                                  │
│   Thread 1:          Thread 2:                                   │
│   count = 10         count = 10  (оба читают одно значение)     │
│   count = count + 1  count = count + 2                          │
│   // count = 11      // count = 12                              │
│                                                                  │
│   Ожидали: 10 + 1 + 2 = 13                                      │
│   Получили: 12 (потеряли +1!)                                   │
│                                                                  │
│   В многопоточности: Mutex, Semaphore                           │
│   В базах данных:    Locks, Isolation Levels                    │
│                                                                  │
│   ┌───────────────────────────────────────────────────────────┐ │
│   │  Программирование     │    База данных                    │ │
│   ├───────────────────────┼───────────────────────────────────┤ │
│   │  Mutex                │    Exclusive Lock                 │ │
│   │  ReadWriteLock        │    Shared/Exclusive Lock          │ │
│   │  volatile             │    Read Committed                 │ │
│   │  synchronized block   │    Serializable                   │ │
│   │  Version check        │    Optimistic Locking             │ │
│   └───────────────────────┴───────────────────────────────────┘ │
│                                                                  │
│   ISOLATION = "Защита от параллельного доступа"                 │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Аналогия 3: Последний билет на концерт — конкурентный доступ

```
┌─────────────────────────────────────────────────────────────────┐
│              БРОНИРОВАНИЕ ПОСЛЕДНЕГО БИЛЕТА                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Ситуация: Остался 1 билет. Маша и Петя нажимают "Купить"      │
│   одновременно.                                                  │
│                                                                  │
│   БЕЗ ИЗОЛЯЦИИ (READ UNCOMMITTED):                              │
│   ┌─────────────────────┐  ┌─────────────────────┐              │
│   │ Маша:               │  │ Петя:               │              │
│   │ SELECT остаток → 1  │  │ SELECT остаток → 1  │              │
│   │ "Есть билет!"       │  │ "Есть билет!"       │              │
│   │ UPDATE остаток = 0  │  │ UPDATE остаток = 0  │              │
│   │ "Куплено!"          │  │ "Куплено!"          │              │
│   └─────────────────────┘  └─────────────────────┘              │
│                                                                  │
│   Результат: Оба "купили" один билет. Скандал на входе.        │
│                                                                  │
│   С ИЗОЛЯЦИЕЙ (SERIALIZABLE):                                   │
│   ┌─────────────────────┐  ┌─────────────────────┐              │
│   │ Маша:               │  │ Петя:               │              │
│   │ SELECT ... FOR      │  │ (ждёт, пока Маша    │              │
│   │ UPDATE → 1          │  │  освободит строку)  │              │
│   │ UPDATE остаток = 0  │  │        ⏳            │              │
│   │ COMMIT              │  │ SELECT ... → 0      │              │
│   │ "Куплено!"          │  │ "Билетов нет"       │              │
│   └─────────────────────┘  └─────────────────────┘              │
│                                                                  │
│   Результат: Маша купила, Петя получил честный отказ.           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Аналогия 4: Светофоры — deadlock

```
┌─────────────────────────────────────────────────────────────────┐
│                  DEADLOCK = ПРОБКА НА ПЕРЕКРЁСТКЕ                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│              🚗A                                                  │
│               │                                                  │
│               │ хочет вправо                                     │
│               ▼                                                  │
│       ──────►┌───┐◄──────                                       │
│       🚗D    │ X │    🚗B                                         │
│       хочет  └───┘   хочет                                       │
│       вниз     ▲     влево                                       │
│               │                                                  │
│               │                                                  │
│              🚗C                                                  │
│              хочет вверх                                         │
│                                                                  │
│   Каждая машина:                                                 │
│   • Держит свою полосу (lock на row)                            │
│   • Ждёт, пока освободится следующая                            │
│                                                                  │
│   A ждёт B → B ждёт C → C ждёт D → D ждёт A                     │
│   DEADLOCK! Никто не может двигаться.                           │
│                                                                  │
│   Решение в жизни: Кто-то сдаёт назад (ROLLBACK)               │
│   Решение в БД:    Система выбирает "жертву" и откатывает       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Аналогия 5: Google Docs — MVCC (версии вместо блокировок)

```
┌─────────────────────────────────────────────────────────────────┐
│           MVCC КАК ИСТОРИЯ ВЕРСИЙ В GOOGLE DOCS                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Традиционная блокировка (Microsoft Word на сетевом диске):    │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │ Файл открыт пользователем Иван. Только чтение.          │   │
│   │ [OK]                                                     │   │
│   └─────────────────────────────────────────────────────────┘   │
│   😤 Пока Иван не закроет — никто не может редактировать       │
│                                                                  │
│   MVCC (как Google Docs):                                       │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  Версия 1 (09:00): "Привет мир"        ← Иван начал      │   │
│   │  Версия 2 (09:05): "Привет, мир!"      ← Иван редактирует│   │
│   │  Версия 3 (09:10): "Привет, мир! Как"  ← Иван продолжает │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│   Пока Иван редактирует (Версия 3), Мария открывает документ:   │
│   • Мария видит Версию 2 (последнюю закоммиченную)             │
│   • Иван продолжает работать с Версией 3                        │
│   • Никто никого не блокирует!                                  │
│                                                                  │
│   В PostgreSQL:                                                  │
│   • xmin = номер транзакции, создавшей строку                   │
│   • xmax = номер транзакции, удалившей/обновившей строку        │
│   • Каждая транзакция видит свой "snapshot"                     │
│                                                                  │
│   MVCC = "Readers don't block writers, writers don't block      │
│           readers"                                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Часть 2: Почему это сложно — типичные ошибки

### Ошибка 1: "У меня транзакция — race condition невозможен!"

**СИМПТОМ:** "Два пользователя купили один товар" несмотря на BEGIN/COMMIT

```
┌─────────────────────────────────────────────────────────────────┐
│       ТРАНЗАКЦИЯ ≠ АВТОМАТИЧЕСКАЯ ЗАЩИТА ОТ RACE CONDITION       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ❌ НЕПРАВИЛЬНО (Read Committed — default!):                    │
│                                                                  │
│   Transaction A:              Transaction B:                     │
│   BEGIN;                      BEGIN;                             │
│   SELECT stock FROM           SELECT stock FROM                  │
│   products WHERE id=1;        products WHERE id=1;               │
│   → stock = 1                 → stock = 1                        │
│                                                                  │
│   -- Оба видят stock=1!                                         │
│                                                                  │
│   UPDATE products             UPDATE products                    │
│   SET stock = 0               SET stock = 0                      │
│   WHERE id = 1;               WHERE id = 1;                      │
│   COMMIT;                     COMMIT;                            │
│                                                                  │
│   Результат: Оба "успешно" продали товар!                       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:**
```sql
-- ✅ ВАРИАНТ 1: SELECT FOR UPDATE (блокировка строки)
BEGIN;
SELECT stock FROM products WHERE id = 1 FOR UPDATE;
-- Теперь вторая транзакция ждёт!
UPDATE products SET stock = stock - 1 WHERE id = 1 AND stock > 0;
COMMIT;

-- ✅ ВАРИАНТ 2: Атомарное обновление с проверкой
UPDATE products SET stock = stock - 1
WHERE id = 1 AND stock > 0
RETURNING stock;
-- Если вернул 0 строк — товар закончился

-- ✅ ВАРИАНТ 3: SERIALIZABLE isolation
BEGIN ISOLATION LEVEL SERIALIZABLE;
SELECT stock FROM products WHERE id = 1;
UPDATE products SET stock = stock - 1 WHERE id = 1;
COMMIT; -- При конфликте: ERROR: could not serialize access
```

### Ошибка 2: Неправильный уровень изоляции

**СИМПТОМ:** "Отчёт показывает неконсистентные данные"

```
┌─────────────────────────────────────────────────────────────────┐
│              ОТЧЁТ С READ COMMITTED                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Отчёт: "Сумма всех балансов"                                  │
│                                                                  │
│   SELECT SUM(balance) FROM accounts WHERE type = 'savings';     │
│   → $100,000                                                     │
│                                                                  │
│   -- Пока отчёт выполняется, происходит перевод:                │
│   -- account_1 → account_2 (оба в savings)                      │
│                                                                  │
│   SELECT SUM(balance) FROM accounts WHERE type = 'checking';    │
│   → $50,000                                                      │
│                                                                  │
│   Итого: $150,000                                                │
│                                                                  │
│   Но реальная сумма: $149,000! (или $151,000)                   │
│   Деньги "посчитались дважды" или "пропали" в момент перевода   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:**
```sql
-- ✅ Для отчётов используй REPEATABLE READ
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT SUM(balance) FROM accounts WHERE type = 'savings';
SELECT SUM(balance) FROM accounts WHERE type = 'checking';
COMMIT;
-- Оба SELECT видят один и тот же snapshot
```

### Ошибка 3: Deadlock из-за неправильного порядка блокировок

**СИМПТОМ:** "ERROR: deadlock detected"

```sql
-- ❌ ПРОБЛЕМА: Разный порядок блокировки

-- Session 1:                   -- Session 2:
BEGIN;                          BEGIN;
UPDATE accounts                 UPDATE accounts
SET balance = balance - 100     SET balance = balance - 50
WHERE id = 1;                   WHERE id = 2;
-- Заблокировали id=1           -- Заблокировали id=2

UPDATE accounts                 UPDATE accounts
SET balance = balance + 100     SET balance = balance + 50
WHERE id = 2;                   WHERE id = 1;
-- Ждём id=2... 💀              -- Ждём id=1... 💀
-- DEADLOCK!
```

**РЕШЕНИЕ:**
```sql
-- ✅ ВСЕГДА блокируй в одном порядке (по возрастанию ID)
BEGIN;
-- Сначала определяем порядок
SELECT * FROM accounts
WHERE id IN (1, 2)
ORDER BY id  -- Важно!
FOR UPDATE;

-- Теперь безопасно обновляем в любом порядке
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

### Ошибка 4: "SERIALIZABLE = последовательное выполнение"

**СИМПТОМ:** "Установил SERIALIZABLE, но всё равно deadlock"

```
┌─────────────────────────────────────────────────────────────────┐
│     SERIALIZABLE ≠ ПОСЛЕДОВАТЕЛЬНОЕ ВЫПОЛНЕНИЕ                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   SERIALIZABLE гарантирует:                                     │
│   "Результат ВЫГЛЯДИТ так, будто транзакции выполнились         │
│    последовательно"                                              │
│                                                                  │
│   НЕ гарантирует:                                               │
│   "Транзакции БУДУТ выполняться последовательно"                │
│                                                                  │
│   На практике:                                                   │
│   • Транзакции выполняются параллельно                          │
│   • При конфликте — одна откатывается                           │
│   • "ERROR: could not serialize access"                         │
│                                                                  │
│   ⚠️ Твоя обязанность: обработать ошибку и retry!              │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:**
```kotlin
// ✅ Всегда добавляй retry logic для SERIALIZABLE
fun transferMoney(fromId: Long, toId: Long, amount: BigDecimal) {
    repeat(3) { attempt ->
        try {
            transactionTemplate.execute {
                // SERIALIZABLE transaction
                accountRepository.transfer(fromId, toId, amount)
            }
            return // Успех
        } catch (e: SerializationFailureException) {
            if (attempt == 2) throw e
            Thread.sleep(Random.nextLong(10, 100)) // Случайная задержка
        }
    }
}
```

### Ошибка 5: Слишком длинная транзакция

**СИМПТОМ:** "Приложение периодически зависает" / "Lock timeout"

```
┌─────────────────────────────────────────────────────────────────┐
│              ДЛИННАЯ ТРАНЗАКЦИЯ = ПРОБЛЕМЫ                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ❌ АНТИПАТТЕРН:                                                │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │ BEGIN;                                                   │   │
│   │ SELECT * FROM orders FOR UPDATE;   ← Заблокировали!     │   │
│   │ -- вызов внешнего API (2-5 секунд)                      │   │
│   │ -- обработка данных (1 секунда)                         │   │
│   │ -- отправка email (0.5 секунд)                          │   │
│   │ UPDATE orders SET status = 'processed';                 │   │
│   │ COMMIT;                                                  │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│   Проблемы:                                                      │
│   • Блокировка держится 3-6 секунд                              │
│   • Другие транзакции ждут                                      │
│   • Риск deadlock растёт                                        │
│   • MVCC накапливает версии → bloat                             │
│                                                                  │
│   ✅ ПРАВИЛО: Транзакция < 1 секунды                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:**
```kotlin
// ✅ Разделяй бизнес-логику и транзакции

// 1. Читаем данные (короткая транзакция)
val order = transactionTemplate.execute {
    orderRepository.findByIdForProcessing(orderId)
}

// 2. Вызываем внешние сервисы (БЕЗ транзакции)
val paymentResult = paymentService.charge(order.amount)
val emailResult = emailService.sendConfirmation(order)

// 3. Обновляем статус (короткая транзакция)
transactionTemplate.execute {
    orderRepository.markAsProcessed(orderId, paymentResult.id)
}
```

### Ошибка 6: Отсутствие retry logic

**СИМПТОМ:** "Иногда операции просто не выполняются"

```
┌─────────────────────────────────────────────────────────────────┐
│         БЕЗ RETRY = ПОТЕРЯ ОПЕРАЦИЙ                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Сценарий:                                                      │
│   1. Транзакция A и B конкурируют за ресурс                     │
│   2. Deadlock detected → транзакция B откатывается              │
│   3. ❌ Код не обрабатывает ошибку                               │
│   4. Пользователь видит "Что-то пошло не так"                   │
│   5. Операция потеряна!                                         │
│                                                                  │
│   Типы ошибок, требующих retry:                                 │
│   • Deadlock detected                                           │
│   • Serialization failure (SERIALIZABLE)                        │
│   • Lock timeout                                                │
│   • Connection lost (transient)                                 │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:**
```kotlin
// ✅ Retry с exponential backoff
@Retryable(
    include = [DeadlockException::class, SerializationFailureException::class],
    maxAttempts = 3,
    backoff = Backoff(delay = 100, multiplier = 2.0, random = true)
)
@Transactional(isolation = Isolation.SERIALIZABLE)
fun criticalOperation() {
    // ...
}
```

---

## Часть 3: Ментальные модели

### Модель 1: ACID как контракт

```
┌─────────────────────────────────────────────────────────────────┐
│              ACID — КОНТРАКТ МЕЖДУ ТОБОЙ И БД                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │                  КОНТРАКТ ACID                           │   │
│   ├─────────────────────────────────────────────────────────┤   │
│   │                                                          │   │
│   │  БД ГАРАНТИРУЕТ:                 ТЫ ОБЕСПЕЧИВАЕШЬ:       │   │
│   │                                                          │   │
│   │  [A] Всё или ничего             Корректную логику       │   │
│   │      (при сбое — rollback)      отката в приложении     │   │
│   │                                                          │   │
│   │  [C] Constraints соблюдены      Правильные constraints   │   │
│   │      (FK, CHECK, UNIQUE)        в схеме БД              │   │
│   │                                                          │   │
│   │  [I] Изоляция на выбранном      Выбор подходящего       │   │
│   │      уровне                     уровня изоляции         │   │
│   │                                                          │   │
│   │  [D] Данные на диске после      Обработку ошибок        │   │
│   │      COMMIT                     при записи              │   │
│   │                                                          │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│   ⚠️ БД даёт инструменты. Использовать их правильно — твоя     │
│      ответственность!                                           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Модель 2: Уровни изоляции — спектр компромиссов

```
┌─────────────────────────────────────────────────────────────────┐
│              СПЕКТР УРОВНЕЙ ИЗОЛЯЦИИ                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Меньше защиты ◄─────────────────────────────► Больше защиты   │
│   Выше скорость ◄─────────────────────────────► Ниже скорость   │
│                                                                  │
│   ┌──────────────┬──────────────┬──────────────┬──────────────┐ │
│   │    READ      │    READ      │  REPEATABLE  │ SERIALIZABLE │ │
│   │  UNCOMMITTED │  COMMITTED   │    READ      │              │ │
│   ├──────────────┼──────────────┼──────────────┼──────────────┤ │
│   │ Dirty Read   │      ✗       │      ✗       │      ✗       │ │
│   │ Non-Repeat   │ Non-Repeat   │      ✗       │      ✗       │ │
│   │ Phantom      │ Phantom      │   Phantom*   │      ✗       │ │
│   │ Lost Update  │ Lost Update  │      ✗       │      ✗       │ │
│   ├──────────────┼──────────────┼──────────────┼──────────────┤ │
│   │  Никогда     │   Default    │   Отчёты,    │   Критичные  │ │
│   │  не исп.     │   для OLTP   │   аналитика  │   операции   │ │
│   └──────────────┴──────────────┴──────────────┴──────────────┘ │
│                                                                  │
│   * В PostgreSQL REPEATABLE READ также защищает от Phantom      │
│     благодаря MVCC (Snapshot Isolation)                         │
│                                                                  │
│   Правило большого пальца:                                      │
│   • 90% случаев: READ COMMITTED + правильные locks              │
│   • 9% случаев:  REPEATABLE READ для консистентных отчётов      │
│   • 1% случаев:  SERIALIZABLE для критичных операций            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Модель 3: Матрица совместимости блокировок

```
┌─────────────────────────────────────────────────────────────────┐
│              СОВМЕСТИМОСТЬ БЛОКИРОВОК                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│         │ Хочу SHARED │ Хочу EXCLUSIVE │ Хочу UPDATE │           │
│   ──────┼─────────────┼────────────────┼─────────────┤           │
│   SHARED│     ✓       │       ✗        │      ✓      │           │
│   EXCLUS│     ✗       │       ✗        │      ✗      │           │
│   UPDATE│     ✓       │       ✗        │      ✗      │           │
│                                                                  │
│   SHARED (FOR SHARE):                                           │
│   • "Я читаю, не меняйте"                                       │
│   • Другие могут читать                                         │
│   • Никто не может писать                                       │
│                                                                  │
│   EXCLUSIVE (FOR UPDATE):                                       │
│   • "Я собираюсь изменить"                                      │
│   • Никто не может ни читать*, ни писать                        │
│   • * В MVCC другие видят старую версию                         │
│                                                                  │
│   UPDATE LOCK (SQL Server):                                     │
│   • "Я читаю, возможно изменю"                                  │
│   • Предотвращает deadlock при read-then-write                  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Модель 4: Дерево решений — Optimistic vs Pessimistic

```
┌─────────────────────────────────────────────────────────────────┐
│         ВЫБОР СТРАТЕГИИ БЛОКИРОВКИ                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│                 Конфликты частые?                                │
│                       │                                          │
│           ┌───────────┴───────────┐                             │
│           │                       │                             │
│          Да                      Нет                            │
│           │                       │                             │
│           ▼                       ▼                             │
│   ┌───────────────┐       ┌───────────────┐                    │
│   │  PESSIMISTIC  │       │  OPTIMISTIC   │                    │
│   │  SELECT FOR   │       │  version +    │                    │
│   │  UPDATE       │       │  retry        │                    │
│   └───────────────┘       └───────────────┘                    │
│                                   │                             │
│                           Операция долгая?                      │
│                                   │                             │
│                       ┌───────────┴───────────┐                │
│                       │                       │                │
│                      Да                      Нет               │
│                       │                       │                │
│                       ▼                       ▼                │
│               ┌───────────────┐       ┌───────────────┐        │
│               │  OPTIMISTIC   │       │  Любой        │        │
│               │  (не держать  │       │  подойдёт     │        │
│               │  lock долго)  │       │               │        │
│               └───────────────┘       └───────────────┘        │
│                                                                  │
│   Примеры:                                                       │
│   • Редактирование документа (UI) → OPTIMISTIC                  │
│   • Списание денег (много конкурентов) → PESSIMISTIC            │
│   • Инкремент счётчика → Атомарный UPDATE (без lock)            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Модель 5: Временная шкала MVCC

```
┌─────────────────────────────────────────────────────────────────┐
│              MVCC: КТО ЧТО ВИДИТ                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Время →   T1    T2    T3    T4    T5    T6    T7              │
│             │     │     │     │     │     │     │               │
│   Tx100:    ├BEGIN─────────────────────COMMIT─┤                 │
│             │     │     │     │     │     │                     │
│   Tx101:    │     ├BEGIN─────────────────────COMMIT─┤           │
│             │     │     │     │     │                │           │
│   Tx102:    │     │     ├BEGIN─────────────COMMIT─┤  │           │
│             │     │     │     │     │     │     │    │           │
│   ─────────────────────────────────────────────────────         │
│                                                                  │
│   Строка "balance":                                             │
│   ┌────────┬────────┬──────────────────────────────────────┐    │
│   │  xmin  │  xmax  │  value                                │    │
│   ├────────┼────────┼──────────────────────────────────────┤    │
│   │  100   │  102   │  1000  (создана Tx100, удалена Tx102) │    │
│   │  102   │   -    │  1500  (создана Tx102)                │    │
│   └────────┴────────┴──────────────────────────────────────┘    │
│                                                                  │
│   Что видит каждая транзакция:                                  │
│   • Tx100: balance = 1000 (свою версию)                         │
│   • Tx101: balance = 1000 (Tx102 ещё не committed)              │
│   • Tx102: balance = 1500 (свои изменения)                      │
│   • После T6: все видят balance = 1500                          │
│                                                                  │
│   Старая версия (1000) будет удалена VACUUM после того,         │
│   как все транзакции, которые могли её видеть, завершатся       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Терминология

| Термин | Значение |
|--------|----------|
| **Transaction** | Группа операций с ACID гарантиями |
| **COMMIT** | Зафиксировать изменения (permanent) |
| **ROLLBACK** | Откатить все изменения транзакции |
| **Isolation Level** | Степень изоляции транзакций друг от друга |
| **Lock** | Блокировка ресурса для предотвращения конфликтов |
| **Deadlock** | Взаимная блокировка (A ждёт B, B ждёт A) |
| **MVCC** | Multi-Version Concurrency Control — версии вместо блокировок |
| **Optimistic Locking** | Проверка версии при записи, без блокировок |
| **Pessimistic Locking** | Блокировка ресурса заранее |
| **WAL** | Write-Ahead Log — журнал для durability |

---

## ACID: четыре свойства

```
┌─────────────────────────────────────────────────────────────────┐
│                         ACID                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ ATOMICITY (Атомарность)                                 │   │
│  │ Всё или ничего. Если одна операция падает —            │   │
│  │ откатываются ВСЕ операции транзакции.                  │   │
│  │                                                         │   │
│  │ Перевод денег: списание + зачисление = атомарно        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ CONSISTENCY (Консистентность)                           │   │
│  │ БД переходит из одного валидного состояния в другое.   │   │
│  │ Constraints, triggers, foreign keys соблюдаются.       │   │
│  │                                                         │   │
│  │ Баланс не может быть отрицательным (constraint)        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ ISOLATION (Изоляция)                                    │   │
│  │ Параллельные транзакции не влияют друг на друга.       │   │
│  │ Каждая видит консистентный snapshot данных.            │   │
│  │                                                         │   │
│  │ Два пользователя редактируют один документ             │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ DURABILITY (Долговечность)                              │   │
│  │ После COMMIT данные сохранены навсегда.                │   │
│  │ Даже при сбое питания, краше сервера.                  │   │
│  │                                                         │   │
│  │ WAL (Write-Ahead Log) обеспечивает recovery            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Уровни изоляции

### Аномалии чтения

```
┌─────────────────────────────────────────────────────────────────┐
│                    АНОМАЛИИ ЧТЕНИЯ                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  DIRTY READ (Грязное чтение)                                    │
│  ────────────────────────────                                   │
│  Tx1: UPDATE balance = 0     ← ещё не commit                   │
│  Tx2: SELECT balance → 0     ← видит uncommitted данные!       │
│  Tx1: ROLLBACK               ← Tx2 прочитал "фантом"           │
│                                                                 │
│  NON-REPEATABLE READ (Неповторяемое чтение)                    │
│  ──────────────────────────────────────────                    │
│  Tx1: SELECT balance → 100                                      │
│  Tx2: UPDATE balance = 50; COMMIT                               │
│  Tx1: SELECT balance → 50    ← другое значение!                │
│                                                                 │
│  PHANTOM READ (Фантомное чтение)                               │
│  ───────────────────────────────                               │
│  Tx1: SELECT * WHERE age > 18 → 10 rows                        │
│  Tx2: INSERT INTO users (age=25); COMMIT                        │
│  Tx1: SELECT * WHERE age > 18 → 11 rows  ← новая строка!       │
│                                                                 │
│  LOST UPDATE (Потерянное обновление)                           │
│  ────────────────────────────────────                          │
│  Tx1: SELECT balance → 100                                      │
│  Tx2: SELECT balance → 100                                      │
│  Tx1: UPDATE balance = 100 + 10; COMMIT                         │
│  Tx2: UPDATE balance = 100 + 20; COMMIT  ← перезаписал Tx1!    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Матрица изоляции

| Уровень | Dirty Read | Non-Repeatable | Phantom | Lost Update |
|---------|:----------:|:--------------:|:-------:|:-----------:|
| Read Uncommitted | ✗ | ✗ | ✗ | ✗ |
| Read Committed | ✓ | ✗ | ✗ | ✗ |
| Repeatable Read | ✓ | ✓ | ✗* | ✓ |
| Serializable | ✓ | ✓ | ✓ | ✓ |

*PostgreSQL Repeatable Read также защищает от Phantom благодаря MVCC

### Уровни в PostgreSQL

```sql
-- Установить уровень для транзакции
BEGIN;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- операции
COMMIT;

-- Или сразу
BEGIN ISOLATION LEVEL SERIALIZABLE;
-- операции
COMMIT;

-- Уровень по умолчанию (Read Committed)
SHOW default_transaction_isolation;
```

### Когда какой уровень

```
┌────────────────────────────────────────────────────────────────┐
│              ВЫБОР УРОВНЯ ИЗОЛЯЦИИ                             │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  READ COMMITTED (default в PostgreSQL)                         │
│  • Большинство OLTP приложений                                │
│  • Каждый SELECT видит только committed данные                 │
│  • Баланс производительности и безопасности                   │
│                                                                │
│  REPEATABLE READ                                               │
│  • Отчёты, где важна консистентность snapshot                 │
│  • Финансовые операции с несколькими чтениями                 │
│  • Long-running transactions                                   │
│                                                                │
│  SERIALIZABLE                                                  │
│  • Критические финансовые операции                            │
│  • Когда логика зависит от нескольких чтений                  │
│  • ⚠️ Может откатывать транзакции (serialization failure)     │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## Блокировки (Locks)

### Типы блокировок

```
┌─────────────────────────────────────────────────────────────────┐
│                     ТИПЫ БЛОКИРОВОК                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  По типу доступа:                                              │
│  ┌────────────────┐   ┌────────────────┐                       │
│  │ SHARED (S)     │   │ EXCLUSIVE (X)  │                       │
│  │ • Для чтения   │   │ • Для записи   │                       │
│  │ • Совместимы   │   │ • Блокирует    │                       │
│  │   между собой  │   │   все другие   │                       │
│  └────────────────┘   └────────────────┘                       │
│                                                                 │
│  Совместимость:                                                │
│  ┌─────────┬───────────┬───────────┐                           │
│  │         │ Shared(S) │Exclusive(X)                           │
│  ├─────────┼───────────┼───────────┤                           │
│  │Shared   │    ✓      │    ✗      │                           │
│  │Exclusive│    ✗      │    ✗      │                           │
│  └─────────┴───────────┴───────────┘                           │
│                                                                 │
│  По гранулярности:                                             │
│  • Row-level  — блокировка строки (default в PostgreSQL)       │
│  • Page-level — блокировка страницы (8KB)                      │
│  • Table-level — блокировка всей таблицы                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Явные блокировки в PostgreSQL

```sql
-- ✅ Блокировка строк для обновления
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
-- Другие транзакции не смогут UPDATE эту строку

-- ✅ FOR UPDATE NOWAIT — не ждать, сразу ошибка если заблокировано
SELECT * FROM accounts WHERE id = 1 FOR UPDATE NOWAIT;

-- ✅ FOR UPDATE SKIP LOCKED — пропустить заблокированные строки
-- Полезно для очередей задач
SELECT * FROM tasks
WHERE status = 'pending'
ORDER BY created_at
LIMIT 1
FOR UPDATE SKIP LOCKED;

-- ✅ FOR SHARE — shared lock (разрешает чтение, блокирует запись)
SELECT * FROM orders WHERE user_id = 1 FOR SHARE;

-- ✅ Блокировка таблицы
LOCK TABLE accounts IN EXCLUSIVE MODE;
```

### Пример: безопасный перевод денег

```sql
-- ❌ НЕПРАВИЛЬНО: race condition
BEGIN;
SELECT balance FROM accounts WHERE id = 1;  -- 100
-- Другая транзакция тоже читает 100 и списывает
UPDATE accounts SET balance = balance - 50 WHERE id = 1;
COMMIT;

-- ✅ ПРАВИЛЬНО: блокировка строки
BEGIN;
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;  -- блокируем
-- Теперь другие транзакции ждут
UPDATE accounts SET balance = balance - 50 WHERE id = 1;
COMMIT;

-- ✅ ПРАВИЛЬНО: атомарное обновление
UPDATE accounts
SET balance = balance - 50
WHERE id = 1 AND balance >= 50;  -- проверка в WHERE

-- Проверяем сколько строк обновлено
-- Если 0 — недостаточно средств
```

---

## Deadlocks

### Как возникает deadlock

```
┌─────────────────────────────────────────────────────────────────┐
│                       DEADLOCK                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Transaction A                Transaction B                     │
│  ─────────────                ─────────────                     │
│  1. LOCK row 1 ✓              1. LOCK row 2 ✓                   │
│  2. Wait for row 2...         2. Wait for row 1...              │
│       ↓                             ↓                           │
│       └──────── DEADLOCK ───────────┘                           │
│                                                                 │
│  PostgreSQL обнаруживает deadlock и откатывает одну транзакцию │
│  ERROR: deadlock detected                                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Пример deadlock

```sql
-- Session 1                      -- Session 2
BEGIN;                            BEGIN;
UPDATE accounts SET               UPDATE accounts SET
  balance = balance - 10            balance = balance - 20
WHERE id = 1;                     WHERE id = 2;
-- Заблокировали id=1             -- Заблокировали id=2

UPDATE accounts SET               UPDATE accounts SET
  balance = balance + 10            balance = balance + 20
WHERE id = 2;                     WHERE id = 1;
-- Ждём id=2...                   -- Ждём id=1... DEADLOCK!
```

### Как избежать deadlocks

```sql
-- ✅ РЕШЕНИЕ 1: Единый порядок блокировки
-- Всегда блокируй ресурсы в одном порядке (например, по ID)

BEGIN;
-- Сортируем ID: 1, 2
SELECT * FROM accounts WHERE id IN (1, 2) ORDER BY id FOR UPDATE;
UPDATE accounts SET balance = balance - 10 WHERE id = 1;
UPDATE accounts SET balance = balance + 10 WHERE id = 2;
COMMIT;

-- ✅ РЕШЕНИЕ 2: Timeout
SET lock_timeout = '5s';  -- Не ждать дольше 5 секунд

-- ✅ РЕШЕНИЕ 3: NOWAIT — сразу ошибка
SELECT * FROM accounts WHERE id = 1 FOR UPDATE NOWAIT;
-- ERROR: could not obtain lock on row

-- ✅ РЕШЕНИЕ 4: Retry logic в приложении
-- При deadlock detected — retry транзакцию
```

---

## MVCC (Multi-Version Concurrency Control)

```
┌─────────────────────────────────────────────────────────────────┐
│                         MVCC                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Вместо блокировок — версии данных                             │
│                                                                 │
│  Строка в PostgreSQL:                                          │
│  ┌─────────┬─────────┬────────────────────────────┐            │
│  │ xmin    │ xmax    │ data                       │            │
│  │ (создал)│ (удалил)│                            │            │
│  ├─────────┼─────────┼────────────────────────────┤            │
│  │ 100     │ -       │ {"balance": 100}           │ ← v1       │
│  │ 105     │ -       │ {"balance": 150}           │ ← v2       │
│  └─────────┴─────────┴────────────────────────────┘            │
│                                                                 │
│  Tx 102 (начался до 105): видит v1 (balance=100)              │
│  Tx 110 (начался после 105): видит v2 (balance=150)           │
│                                                                 │
│  Преимущества:                                                 │
│  • Readers never block writers                                 │
│  • Writers never block readers                                 │
│  • Каждая транзакция видит consistent snapshot                 │
│                                                                 │
│  Недостатки:                                                   │
│  • Старые версии занимают место → нужен VACUUM                 │
│  • Transaction ID wraparound (каждые 2 млрд транзакций)        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Оптимистичные блокировки

```
┌─────────────────────────────────────────────────────────────────┐
│              OPTIMISTIC vs PESSIMISTIC LOCKING                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  PESSIMISTIC (пессимистичная):                                 │
│  "Конфликт случится" → блокируем заранее                       │
│  ┌──────────────────────────────────────┐                      │
│  │ SELECT * FROM items FOR UPDATE;      │ ← блокировка         │
│  │ -- работаем с данными                │                      │
│  │ UPDATE items SET ...;                │                      │
│  │ COMMIT;                              │ ← освобождение       │
│  └──────────────────────────────────────┘                      │
│                                                                 │
│  OPTIMISTIC (оптимистичная):                                   │
│  "Конфликт редок" → проверяем при записи                       │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ SELECT id, name, version FROM items WHERE id = 1;        │  │
│  │ -- version = 5                                           │  │
│  │ -- работаем с данными (без блокировки)                   │  │
│  │ UPDATE items SET name = 'new', version = version + 1     │  │
│  │ WHERE id = 1 AND version = 5;                            │  │
│  │ -- Если rows_affected = 0 → кто-то изменил → retry       │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Реализация в коде

```kotlin
// ❌ Pessimistic: долгая блокировка
@Transactional
fun updateItem(id: Long, newName: String) {
    val item = repository.findByIdForUpdate(id)  // SELECT FOR UPDATE
    item.name = newName
    repository.save(item)
}

// ✅ Optimistic: версионирование
@Entity
class Item(
    @Id val id: Long,
    var name: String,
    @Version var version: Long = 0  // JPA автоматически управляет
)

@Transactional
fun updateItem(id: Long, newName: String) {
    val item = repository.findById(id)
    item.name = newName
    repository.save(item)  // При конфликте → OptimisticLockException
}

// Обработка конфликта
fun updateWithRetry(id: Long, newName: String, maxRetries: Int = 3) {
    repeat(maxRetries) { attempt ->
        try {
            updateItem(id, newName)
            return
        } catch (e: OptimisticLockException) {
            if (attempt == maxRetries - 1) throw e
            // Retry with fresh data
        }
    }
}
```

### Когда что использовать

| Критерий | Pessimistic | Optimistic |
|----------|-------------|------------|
| Частые конфликты | ✓ | ✗ |
| Редкие конфликты | ✗ | ✓ |
| Длинные транзакции | ✗ | ✓ |
| Критичные данные | ✓ | ✗ |
| High concurrency | ✗ | ✓ |
| Простота | ✓ | ✓ |

---

## Практические паттерны

### Идемпотентные операции

```sql
-- Проблема: дублирование при retry
INSERT INTO payments (id, amount, user_id)
VALUES (gen_random_uuid(), 100, 1);
-- При retry — создаётся дубликат!

-- ✅ Решение: idempotency key
INSERT INTO payments (idempotency_key, amount, user_id)
VALUES ('payment-abc-123', 100, 1)
ON CONFLICT (idempotency_key) DO NOTHING;
-- При retry — ничего не происходит
```

### Saga Pattern (распределённые транзакции)

```
┌─────────────────────────────────────────────────────────────────┐
│                    SAGA PATTERN                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Заказ товара (3 сервиса):                                     │
│                                                                 │
│  1. Order Service    ──▶  Create Order                         │
│          │                     │                               │
│          │              success│fail                           │
│          ▼                     ▼                               │
│  2. Payment Service  ──▶  Charge Card  ──▶  Refund (compensate)│
│          │                     │                               │
│          │              success│fail                           │
│          ▼                     ▼                               │
│  3. Inventory Service──▶  Reserve Stock ──▶  Release Stock     │
│                                                                 │
│  При ошибке на любом шаге — выполняем компенсирующие действия │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Проверь себя

<details>
<summary>1. Что означает каждая буква в ACID?</summary>

**Ответ:**
- **Atomicity** — атомарность, всё или ничего
- **Consistency** — консистентность, переход между валидными состояниями
- **Isolation** — изоляция, транзакции не влияют друг на друга
- **Durability** — долговечность, committed данные сохранены навсегда

</details>

<details>
<summary>2. Чем Read Committed отличается от Repeatable Read?</summary>

**Ответ:**
- **Read Committed:** Каждый SELECT видит данные на момент своего выполнения. Между двумя SELECT в одной транзакции данные могут измениться (non-repeatable read).
- **Repeatable Read:** Транзакция видит snapshot данных на момент начала. Повторный SELECT вернёт те же данные.

Repeatable Read защищает от non-repeatable read и lost update.

</details>

<details>
<summary>3. Как избежать deadlock?</summary>

**Ответ:**
1. **Единый порядок блокировки** — всегда блокировать ресурсы в одном порядке (по ID)
2. **Короткие транзакции** — меньше времени = меньше шанс deadlock
3. **NOWAIT/SKIP LOCKED** — не ждать блокировку
4. **Lock timeout** — ограничить время ожидания
5. **Retry logic** — при deadlock detected повторить транзакцию

</details>

<details>
<summary>4. Когда использовать оптимистичные блокировки?</summary>

**Ответ:**
- Конфликты редки (читают часто, пишут редко)
- Длинные операции (UI editing, long-running workflows)
- Высокая конкурентность (много параллельных пользователей)
- Распределённые системы (блокировки через сеть дороги)

Не подходит: частые конфликты, критичные финансовые операции.

</details>

<details>
<summary>5. Что такое MVCC и зачем он нужен?</summary>

**Ответ:** MVCC (Multi-Version Concurrency Control) — механизм, где вместо блокировок хранятся версии данных.

Преимущества:
- Readers не блокируют writers
- Writers не блокируют readers
- Каждая транзакция видит consistent snapshot

Как работает: Каждая строка имеет xmin (создал) и xmax (удалил). Транзакция видит только строки, где xmin < её ID и xmax > её ID или null.

Цена: Старые версии накапливаются → нужен VACUUM для очистки.

</details>

---

## Связи

- [[databases-overview]] — карта раздела
- [[databases-replication-sharding]] — распределённые транзакции
- [[architecture-distributed-systems]] — Saga, 2PC
- [[database-design-optimization]] — производительность

---

## Источники

- [PostgreSQL MVCC Documentation](https://www.postgresql.org/docs/current/mvcc.html)
- [PostgreSQL Transaction Isolation](https://www.postgresql.org/docs/current/transaction-iso.html)
- "Designing Data-Intensive Applications" by Martin Kleppmann — Chapter 7
- [Jepsen: Distributed Systems Testing](https://jepsen.io/)

---

*Проверено: 2025-12-22 | PostgreSQL 16*
*Обновлено: 2026-01-09 — добавлены педагогические секции (5 аналогий: банковский перевод/ACID, mutex/изоляция, билет на концерт/конкуренция, светофор/deadlock, Google Docs/MVCC; 6 типичных ошибок: race condition в транзакции, неправильный isolation level, deadlock из-за порядка, миф о SERIALIZABLE, длинные транзакции, отсутствие retry; 5 ментальных моделей: ACID как контракт, спектр изоляции, матрица блокировок, optimistic vs pessimistic, временная шкала MVCC)*
