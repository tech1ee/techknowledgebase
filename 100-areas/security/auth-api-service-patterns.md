---
title: "Аутентификация API и сервисов: от API keys до Zero Trust"
created: 2026-02-11
modified: 2026-02-11
type: deep-dive
status: published
confidence: high
tags:
  - topic/security
  - type/deep-dive
  - level/intermediate
related:
  - "[[authentication-authorization]]"
  - "[[auth-sessions-jwt-tokens]]"
  - "[[auth-oauth2-oidc]]"
  - "[[security-https-tls]]"
  - "[[security-api-protection]]"
prerequisites:
  - "[[authentication-authorization]]"
  - "[[auth-sessions-jwt-tokens]]"
  - "[[security-https-tls]]"
---

# Аутентификация API и сервисов: от API keys до Zero Trust

API -- это граница доверия. Каждый endpoint -- потенциальная поверхность атаки, и browser-based аутентификация (cookies, sessions) здесь не работает: машины не открывают вкладки, не вводят пароли, не кликают "Войти через Google". Machine-to-machine коммуникация требует собственных паттернов аутентификации -- от простейших API keys до Zero Trust архитектуры с взаимной верификацией на каждом шаге. Этот материал разбирает каждый паттерн до уровня конкретных механизмов, объясняя не только "как", но и "когда" и "почему".

---

## Зачем это знать

Современные системы -- API-first. Мобильное приложение общается с backend через REST или gRPC. Микросервисы вызывают друг друга десятки раз на один пользовательский запрос. Третьи стороны подключаются через публичные API. Webhooks доставляют события между системами. Каждый из этих вызовов должен быть аутентифицирован -- но каждый требует своего подхода.

Неправильный выбор паттерна аутентификации -- это либо уязвимость, либо операционный кошмар. API key для пользовательских данных -- нет изоляции прав. mTLS для публичного API -- клиенты не справятся с сертификатами. Bearer tokens без audience validation -- confused deputy attack. Знание спектра паттернов и их trade-offs позволяет выбрать минимально сложное решение, достаточное для конкретного уровня риска.

> **Ключевая идея:** Аутентификация API -- это не один универсальный механизм, а набор инструментов. Выбор определяется тем, КТО вызывает API (человек, сервис, внешняя система) и КАКОЙ уровень доверия между сторонами.

---

## Терминология

| Термин | Что это | Аналогия из реальной жизни |
|--------|---------|---------------------------|
| **API Key** | Статическая строка, идентифицирующая приложение/проект | Номер читательского билета: идентифицирует, но не даёт особых прав |
| **Bearer Token** | Динамический токен, дающий доступ предъявителю | Билет на концерт: кто держит -- тот проходит |
| **HMAC Signature** | Подпись запроса общим секретом для подтверждения подлинности | Сургучная печать на письме: получатель знает форму печати отправителя |
| **mTLS** | Mutual TLS -- обоюдная проверка сертификатов клиента и сервера | Два человека показывают паспорта друг другу на границе |
| **Service Account** | Управляемая платформой идентичность для сервиса | Служебное удостоверение сотрудника: выдаётся организацией, а не человеком |
| **Service Mesh** | Инфраструктурный слой для управления сетевым взаимодействием сервисов | Внутренняя почтовая служба компании: проверяет отправителя автоматически |
| **Sidecar Proxy** | Прокси-контейнер рядом с сервисом, обрабатывающий сетевой трафик | Личный секретарь: фильтрует звонки и проверяет визитки за вас |
| **Zero Trust** | Архитектурный подход: никакого неявного доверия, проверка каждого запроса | Аэропорт: проверка на каждом этапе -- регистрация, досмотр, гейт, паспортный контроль |
| **Token Propagation** | Передача токена пользователя через цепочку микросервисов | Передача эстафетной палочки: каждый бегун несёт тот же предмет |
| **Token Exchange** | Обмен одного токена на другой с другим audience/scope (RFC 8693) | Обмен валюты: доллары превращаются в евро, но покупательная способность сохраняется |
| **Audience (aud)** | Claim в JWT, указывающий для какого сервиса предназначен токен | Адрес на конверте: письмо для конкретного получателя |
| **DPoP** | Demonstration of Proof-of-Possession -- привязка токена к ключу клиента (RFC 9449) | Именной билет с фотографией: работает только для владельца |
| **App Attestation** | Аппаратное подтверждение, что запрос исходит от легитимного приложения на неповреждённом устройстве | Заводская пломба на приборе: доказывает, что никто не вскрывал корпус |

---

## Prerequisites

| Тема | Зачем нужна | Ссылка |
|------|-------------|--------|
| AuthN vs AuthZ | Базовое понимание аутентификации и авторизации, роли, scopes | [[authentication-authorization]] |
| Sessions, JWT, токены | Механика JWT (header, payload, signature), refresh tokens, opaque tokens | [[auth-sessions-jwt-tokens]] |
| TLS/HTTPS | Транспортная безопасность, сертификаты, PKI | [[security-https-tls]] |

---

## Историческая справка

История API-аутентификации -- это история усложнения угроз. Каждый новый паттерн появлялся как ответ на ограничения предыдущего, когда масштаб и критичность API-взаимодействий перерастали возможности существующих механизмов.

**1996 -- HTTP Basic Auth для API.** Первые веб-API использовали тот же механизм, что и браузеры: `Authorization: Basic base64(user:pass)`. Пароль в каждом запросе. Без HTTPS -- катастрофа. С HTTPS -- терпимо, но хранение пароля на стороне клиента и отсутствие возможности ограничить права делали подход хрупким.

**2006 -- API Keys (Amazon S3).** Amazon запустил S3 -- первый массовый облачный API. Для идентификации клиентов использовались API keys: статические строки, привязанные к аккаунту. Это был переломный момент: API key -- не пароль пользователя, а идентификатор приложения. Его можно отозвать, не меняя пароль. Но API key не имел expiration и scope -- утечка ключа означала полный доступ.

**2005-2013 -- AWS Signature v2 → v4.** Amazon понял, что bearer-подход (отправка секрета в каждом запросе) ненадёжен. Вместо этого: каждый запрос подписывается производным ключом. Signature v4 (2013) -- четыре раунда HMAC, привязка к дате/региону/сервису. Стандарт, используемый по сей день.

**2012 -- OAuth 2.0 Bearer tokens для API.** RFC 6749 стандартизировал bearer tokens: динамические, scoped, с expiration. Идеально для третьесторонних интеграций. Но bearer token -- "токен на предъявителя": кто украл -- тот и использует.

**2017 -- Istio 0.1 (service mesh с mTLS).** Google, IBM и Lyft выпустили Istio -- service mesh, автоматизирующий mTLS между сервисами в Kubernetes. Аутентификация стала задачей инфраструктуры, а не приложения.

**2020 -- NIST SP 800-207 Zero Trust Architecture.** Формализация принципа "never trust, always verify". Не технология, а архитектурная парадигма: каждый запрос проверяется независимо от сетевого расположения.

**2024 -- DPoP (RFC 9449).** Proof-of-Possession для bearer tokens: токен привязан к криптографическому ключу клиента. Украденный токен бесполезен без ключа.

```
Эволюция API-аутентификации:

1996    2006     2013      2012     2017     2020     2024
 │       │        │         │        │        │        │
 ▼       ▼        ▼         ▼        ▼        ▼        ▼
Basic   API     AWS Sig   OAuth   Service   Zero    DPoP
Auth    Keys    v4        2.0     Mesh      Trust   (PoP)
 │       │        │         │     (mTLS)    (NIST)    │
 │       │        │         │        │        │        │
 ▼       ▼        ▼         ▼        ▼        ▼        ▼
Пароль  Статич.  Подпись   Динамич. Инфра-   Архи-   Привязка
в каждом ключ    запроса   токен    структ.  тектура токена
запросе  без     без       со       авто-    без     к ключу
         scope   передачи  scoped   mTLS     implicit клиента
                 секрета   + exp             trust

Тренд: от "доверяй по умолчанию" → к "проверяй всегда"
```

Мы разобрали, КАК эволюционировали подходы. Теперь разберём каждый паттерн детально, начиная с простейшего.

---

## API Keys: простейший метод

### Механизм работы

API key -- это статическая строка (обычно 32-64 символа), которую клиент отправляет с каждым запросом. Сервер сверяет ключ с хранилищем и определяет, какому приложению/проекту принадлежит запрос. Есть два способа передачи: заголовок `X-API-Key: <key>` (предпочтительно) или query-параметр `?api_key=<key>` (опасно -- попадает в логи, Referer, историю браузера).

API key -- это не токен аутентификации в строгом смысле. Это идентификатор проекта, аналог номера читательского билета в библиотеке. Библиотекарь знает, что билет 4217 принадлежит отделу физики, но не знает, КТО конкретно пришёл с этим билетом. API key идентифицирует приложение, но не пользователя.

**Аналогия: ключ-карта от парковки.** У каждого арендатора офисного здания есть ключ-карта от парковки. Карта открывает шлагбаум, но охранник не знает, кто именно сидит за рулём. Если карту потеряли -- любой может въехать. Если карту нужно заблокировать -- охранник вычёркивает номер из списка. Карта не ограничивает, на какие этажи парковки можно заезжать (нет scope).

### Когда API keys достаточны

API keys оправданы в трёх сценариях. Первый: публичные API с rate limiting, где данные не чувствительны. Google Maps API, погодные API, геокодирование -- ключ нужен для учёта потребления и защиты от злоупотреблений, не для защиты данных. Второй: внутренние инструменты с низкими требованиями к безопасности, где сложность OAuth неоправданна. Третий: когда "пользователь" -- это проект или приложение, а не человек, и пользовательский контекст не нужен.

### Свойства безопасности

API key не имеет встроенного механизма expiration -- ключ действует, пока его не отзовут вручную. У ключа нет scope -- он даёт доступ ко всему, что определено сервером для данного проекта (если сервер не реализует custom scope logic). API key -- это shared secret: если он утёк, злоумышленник получает полный доступ до момента ротации. И главное: API key передаётся в каждом запросе -- это значит, что компрометация одного запроса (перехват, логирование) раскрывает ключ навсегда.

### Стратегия ротации: dual-key

Ротация API key без даунтайма -- задача нетривиальная. Если у приложения один ключ, момент замены -- окно, в которое либо старый ключ уже не работает, либо новый ещё не развёрнут. Решение: dual-key (два активных ключа одновременно).

Алгоритм: приложение хранит два ключа -- primary и secondary. Оба валидны на сервере одновременно. При ротации: (1) создать новый ключ → (2) переключить приложение на новый ключ → (3) убедиться, что трафик идёт по новому ключу → (4) удалить старый ключ. В любой момент времени хотя бы один ключ валиден. Даунтайм -- ноль.

> **Ключевая идея:** Dual-key -- это паттерн, применимый не только к API keys. Та же логика используется для ротации TLS-сертификатов, database credentials, signing keys. Принцип: новое валидно ДО того, как старое становится невалидным.

### Мониторинг и anomaly detection

API key без мониторинга -- это ключ от квартиры, оставленный под ковриком. Даже если ключ не украден, вы не узнаете об этом без наблюдения. Минимальный набор сигналов для мониторинга: необычный географический источник (ключ всегда использовался из eu-west-1, а сейчас пришёл запрос из ap-southeast-1), аномальный объём запросов (обычно 100 req/min, внезапно 10,000 req/min), доступ к неожиданным endpoints (ключ использовался для `/api/maps`, а сейчас вызывает `/api/billing`).

Rate limiting per key -- первая линия обороны. Если ключ скомпрометирован и используется для DDoS, rate limiter ограничивает ущерб. Но rate limiting не заменяет ротацию: скомпрометированный ключ нужно отозвать, а не просто замедлить.

### Когда API key НЕ достаточен

Если нужны пользовательские permissions (не app-level, а user-level) -- API key не работает. Если нужен token expiration -- API key не имеет встроенного механизма. Если нужен scope-based access control -- API key не поддерживает scopes. Если нужна привязка к конкретному пользователю для audit trail -- API key идентифицирует приложение, а не человека. Во всех этих случаях правильный выбор -- OAuth 2.0 (→ [[auth-oauth2-oidc]]).

---

## Bearer Tokens: OAuth 2.0 для API

От статических ключей перейдём к динамическим токенам. Bearer token -- следующая ступень: он скоупирован, ограничен по времени и привязан к конкретному контексту (пользователь + приложение + права).

### Механизм

Клиент отправляет токен в заголовке `Authorization: Bearer <token>`. Сервер валидирует: подпись (если JWT), expiration, audience, scope. Если всё корректно -- запрос авторизован. Bearer означает "на предъявителя": кто владеет токеном -- тот имеет доступ. Никаких дополнительных проверок личности предъявителя (в отличие от DPoP, который мы разберём позже).

### JWT как Bearer Token

Наиболее распространённый формат bearer token -- JWT. Сервер валидирует JWT локально: проверяет подпись публичным ключом, читает claims (exp, aud, scope), принимает решение. Не нужно обращаться к auth-серверу -- это ключевое преимущество для микросервисов, где каждый лишний сетевой вызов -- латентность. Но у JWT есть фундаментальный trade-off: выданный токен нельзя отозвать до истечения (подробности -- в [[auth-sessions-jwt-tokens]]).

### Opaque Bearer Token

Альтернатива: opaque token -- случайная строка без встроенных данных. Сервер обязан вызвать introspection endpoint auth-сервера (`POST /introspect`) для валидации. Плюс: можно мгновенно отозвать (удалить из хранилища). Минус: каждый запрос -- сетевой вызов к auth-серверу, что создаёт latency и single point of failure.

### DPoP: Proof-of-Possession (RFC 9449)

Классический bearer token -- "токен на предъявителя": кто украл токен, тот и пользуется. DPoP (Demonstration of Proof-of-Possession) решает эту проблему, привязывая токен к криптографическому ключу клиента. При запросе токена клиент генерирует ключевую пару (в идеале -- в аппаратном модуле: Secure Enclave на iOS, StrongBox на Android). Auth-сервер выдаёт токен, привязанный к публичному ключу клиента (thumbprint ключа включён в token binding). При каждом API-запросе клиент подписывает proof (DPoP proof JWT) своим приватным ключом и отправляет вместе с access token.

Сервер проверяет: (1) access token валиден, (2) DPoP proof подписан ключом, к которому привязан токен. Если злоумышленник перехватил access token, но не имеет приватного ключа клиента -- токен бесполезен. Это как именной билет с фотографией: недостаточно просто иметь билет -- нужно соответствовать фотографии.

DPoP стандартизирован в RFC 9449 (сентябрь 2023) и рекомендован FAPI 2.0 для финансовых API. OAuth 2.1 включает DPoP как рекомендованный механизм для повышения безопасности bearer tokens.

### Отличие Bearer Token от API Key

| Свойство | API Key | Bearer Token |
|----------|---------|-------------|
| Тип | Статический | Динамический |
| Уровень | Приложение | Пользователь + приложение |
| Expiration | Нет (ручная ротация) | Встроенный (exp claim) |
| Scope | Нет (all-or-nothing) | Да (read, write, admin) |
| Выдача | Вручную через консоль | Программно через OAuth flow |
| Стандарт | Нет единого стандарта | OAuth 2.0 (RFC 6749) |
| Proof-of-Possession | Нет | Возможно (DPoP, RFC 9449) |

---

## HMAC Signatures: верификация webhooks

### Проблема

Webhooks -- это server-to-server callbacks: когда событие происходит в системе A, она отправляет HTTP POST в систему B. Но как система B узнает, что запрос пришёл от легитимной системы A, а не от злоумышленника? Bearer tokens здесь не работают -- получатель не инициирует запрос и не может предоставить токен отправителю.

**Аналогия: сургучная печать.** В средневековой дипломатии отправитель запечатывал письмо сургучной печатью с уникальным оттиском перстня. Получатель знал форму печати отправителя. Если печать совпадала -- письмо подлинное. Если нет -- подделка. HMAC работает по тому же принципу: общий секрет (форма печати) известен обеим сторонам, но не передаётся по сети.

### Механизм HMAC

Отправитель и получатель предварительно обмениваются секретом (signing secret). При отправке webhook отправитель вычисляет `HMAC-SHA256(secret, request_body)` и включает результат в заголовок. Получатель вычисляет тот же HMAC с тем же секретом и телом запроса. Если подписи совпадают -- запрос подлинный: только обладатель секрета мог создать такую подпись.

Критический нюанс: сравнение подписей должно быть constant-time (одинаковое время выполнения независимо от того, совпадают строки или нет). Обычное `==` сравнение прерывается при первом несовпадающем символе, что позволяет timing attack -- злоумышленник побайтово подбирает подпись, замеряя время ответа.

Следующий пример демонстрирует серверную верификацию webhook с использованием HMAC и защитой от timing attack.

```kotlin
// Верификация webhook: HMAC + защита от replay
fun verifyWebhook(
    payload: ByteArray,
    signature: String,   // Из заголовка X-Signature
    timestamp: String,   // Из заголовка X-Timestamp
    secret: ByteArray
): Boolean {
    // Защита от replay: отклоняем старые запросы
    val age = System.currentTimeMillis() / 1000 - timestamp.toLong()
    if (age > 300) return false  // Старше 5 минут

    // HMAC включает timestamp для уникальности
    val message = "$timestamp.${String(payload)}"
    val expected = hmacSha256(secret, message.toByteArray())

    // Constant-time сравнение: защита от timing attack
    return MessageDigest.isEqual(expected, signature.decodeHex())
}
```

Этот код иллюстрирует три уровня защиты: (1) HMAC подтверждает подлинность отправителя, (2) timestamp предотвращает replay-атаки -- злоумышленник не может переиграть перехваченный запрос через час, (3) constant-time сравнение закрывает timing side-channel. Именно этот трёхслойный паттерн используют Stripe, GitHub, Shopify и другие крупные платформы.

### Паттерн Stripe

Stripe включает в заголовок `Stripe-Signature` и timestamp, и подпись: `t=1614556828,v1=HMAC-SHA256(timestamp.payload, signing_secret)`. Timestamp -- защита от replay. Получатель проверяет: (1) timestamp не старше 5 минут, (2) подпись совпадает. Если сменить signing secret -- все старые подписи мгновенно становятся невалидными.

### AWS Signature v4: золотой стандарт

AWS пошёл дальше простого HMAC body. Signature v4 подписывает не только тело, но и метод, URL, query-параметры, выбранные заголовки. Это означает: подпись привязана к конкретному запросу. Перехваченную подпись нельзя использовать для другого URL или с другими параметрами.

```
Цепочка подписи AWS Signature v4:

┌──────────────┐
│ Secret Key   │ "AWS4" + SecretAccessKey
└──────┬───────┘
       ▼
  HMAC(secret, date)          ← Привязка к дате
       ▼
  HMAC(dateKey, region)       ← Привязка к региону
       ▼
  HMAC(regionKey, service)    ← Привязка к сервису
       ▼
  HMAC(serviceKey, "aws4_request")  ← Контекст
       ▼
  signingKey
       ▼
  HMAC(signingKey, stringToSign)    ← Финальная подпись
       │
       │  stringToSign включает:
       │  - Алгоритм (AWS4-HMAC-SHA256)
       │  - Timestamp (ISO 8601)
       │  - Credential scope (date/region/service)
       │  - Hash канонического запроса:
       │      METHOD + URI + Query + Headers + PayloadHash
       │
       ▼
  Authorization: AWS4-HMAC-SHA256
    Credential=AKID/date/region/service/aws4_request,
    SignedHeaders=host;x-amz-date,
    Signature=<hex-signature>
```

Почему не просто bearer tokens? Подпись доказывает владение секретом без его передачи. Каждый запрос подписан независимо -- нет "сессии". Signing keys действительны 7 дней (привязка к дате). Подпись покрывает конкретный URL, заголовки и тело -- перехваченный запрос нельзя переиграть для другого endpoint.

---

## mTLS: Mutual TLS

### Концепция

Обычный TLS -- односторонний: клиент проверяет сертификат сервера ("я точно общаюсь с google.com, а не с фишинговым сайтом"). Сервер не проверяет клиента -- любой может подключиться. mTLS (mutual TLS) -- двусторонний: и клиент, и сервер предъявляют сертификаты друг другу. Оба подтверждают свою идентичность до начала обмена данными.

**Аналогия: пограничный переход между двумя странами.** На границе между Швейцарией и Австрией оба путешественника показывают паспорта пограничникам обеих сторон. Не только вы подтверждаете, что вы -- это вы. Страна, в которую вы въезжаете, тоже подтверждает, что она -- легитимная страна, а не декорация мошенников. В mTLS обе стороны "показывают паспорта" -- сертификаты, подписанные доверенным Certificate Authority.

### PKI-инфраструктура

В основе mTLS лежит PKI (Public Key Infrastructure). Certificate Authority (CA) -- корневой центр доверия, аналог государства, выдающего паспорта. Каждый сервис получает сертификат, подписанный CA. Процесс handshake при mTLS:

```
mTLS Handshake:

  Service A (клиент)                Service B (сервер)
       │                                  │
       │  1. ClientHello                   │
       │─────────────────────────────────▶│
       │                                  │
       │  2. ServerHello + сертификат B   │
       │     + запрос сертификата клиента │
       │◀─────────────────────────────────│
       │                                  │
       │  3. Проверить серт. B            │
       │     (подписан нашим CA?)         │
       │     ✓ Да → доверяем              │
       │                                  │
       │  4. Сертификат A                  │
       │─────────────────────────────────▶│
       │                                  │
       │     5. Проверить серт. A          │
       │        (подписан нашим CA?)       │
       │        ✓ Да → доверяем            │
       │                                  │
       │  6. Обе стороны верифицированы   │
       │     → TLS-канал установлен       │
       │◀════════════════════════════════▶│
       │     Зашифрованное соединение     │
```

Service A предъявляет сертификат -- Service B проверяет его против CA. Service B предъявляет сертификат -- Service A проверяет. Обе стороны подтверждены -- устанавливается зашифрованный канал. Идентичность встроена в транспортный уровень: приложению не нужно обрабатывать токены или ключи.

### Жизненный цикл сертификатов

Главная операционная сложность mTLS -- управление сертификатами. Жизненный цикл сертификата состоит из пяти фаз, каждая из которых может стать источником проблем.

**Создание:** сервис генерирует ключевую пару и Certificate Signing Request (CSR). CSR отправляется в CA (внутренний или внешний). CA подписывает CSR и возвращает сертификат. Важно: приватный ключ никогда не покидает сервис -- CA подписывает только публичную часть.

**Распространение:** сертификат и приватный ключ должны быть доступны сервису при запуске. Варианты: Kubernetes Secrets (просто, но secrets хранятся в etcd в base64, не зашифрованы по умолчанию), HashiCorp Vault (безопасно, но дополнительная зависимость), AWS ACM / GCP Certificate Manager (для облачных load balancer).

**Использование:** сервис загружает сертификат при старте и использует для TLS handshake. Hot reload (перезагрузка сертификата без перезапуска сервиса) -- желательная, но не всегда реализованная функция.

**Ротация:** самая критичная фаза. Сертификаты имеют срок действия (обычно 90 дней для Let's Encrypt, 1 год для внутренних CA). Забытая ротация = истёкший сертификат = каскадный отказ сервисов в 3 часа ночи. Автоматизация обязательна.

**Отзыв:** если приватный ключ скомпрометирован, сертификат нужно отозвать до истечения. Механизмы: CRL (Certificate Revocation List) -- список отозванных сертификатов, скачиваемый периодически; OCSP (Online Certificate Status Protocol) -- проверка статуса в реальном времени. На практике оба механизма ненадёжны: CRL обновляется с задержкой, OCSP -- дополнительная точка отказа.

В Kubernetes эту проблему решает cert-manager: автоматическая выдача и ротация сертификатов через Let's Encrypt или внутренний CA. Istio service mesh идёт дальше -- генерирует short-lived сертификаты (24 часа) для каждого pod автоматически. Короткий срок жизни сертификата снимает проблему отзыва: даже если ключ скомпрометирован, сертификат истечёт через сутки. Приложение вообще не знает про сертификаты -- sidecar proxy (Envoy) обрабатывает mTLS прозрачно.

### Когда использовать mTLS

mTLS оправдан в четырёх сценариях: service-to-service коммуникация внутри доверенной инфраструктуры, Zero Trust сети (каждый вызов аутентифицирован на транспортном уровне), финансовые API с высокими требованиями compliance (FAPI), и IoT-устройства с аппаратными сертификатами (TPM). Для публичных API mTLS не подходит: клиенты (мобильные приложения, браузеры) не могут управлять сертификатами.

---

## Service-to-Service Auth Patterns

Мы разобрали отдельные механизмы. Теперь посмотрим, как они комбинируются в конкретных архитектурных паттернах для межсервисной аутентификации.

### Client Credentials (OAuth 2.0)

Сервис аутентифицируется в auth-сервере с помощью `client_id` + `client_secret`, получает access token (обычно JWT). Использует токен для вызовов других сервисов. Это OAuth 2.0 Client Credentials Grant (→ [[auth-oauth2-oidc]]). Подходит, когда сервису нужна идентичность (для permissions и audit trail), но нет пользовательского контекста.

### Service Mesh (Istio/Linkerd)

Sidecar proxy (Envoy в Istio, linkerd-proxy в Linkerd) перехватывает весь сетевой трафик сервиса. Proxy автоматически устанавливает mTLS с proxy другого сервиса. Приложение отправляет обычный HTTP-запрос на `http://service-b:8080` -- sidecar прозрачно оборачивает его в mTLS. Код приложения не содержит ни одной строки, связанной с аутентификацией.

### Service Accounts

Платформенные идентичности: GCP Service Accounts, AWS IAM Roles for Services, Kubernetes ServiceAccounts. Платформа управляет credentials -- никаких статических секретов в конфигурации. GCP Workload Identity автоматически ассоциирует Kubernetes ServiceAccount с GCP Service Account. AWS IRSA (IAM Roles for Service Accounts) делает то же для EKS. Результат: pod получает temporary credentials без static secrets.

### Матрица решений

| Паттерн | Сложность | Безопасность | Когда использовать |
|---------|-----------|-------------|-------------------|
| Client Credentials | Низкая | Средняя | Стандартный service-to-service с OAuth |
| mTLS (ручной) | Высокая | Очень высокая | Regulated industries, без service mesh |
| Service Mesh | Средняя (ops) | Высокая | Kubernetes environments |
| Service Accounts | Низкая | Высокая | Cloud-native платформы (GCP, AWS, Azure) |

---

## Auth в микросервисах

### Token Propagation

Пользователь логинится, получает JWT. Frontend отправляет JWT в API Gateway. Gateway валидирует токен и передаёт его downstream-сервисам. Каждый сервис либо доверяет валидации gateway (проще, но gateway = single point of trust), либо валидирует JWT самостоятельно (безопаснее, но каждому сервису нужен публичный ключ auth-сервера).

Два подхода к propagation: **pass-through** -- тот же токен передаётся по цепочке без изменений; **token exchange** (RFC 8693) -- сервис обменивает полученный токен на новый с другим audience и/или scope. Exchange безопаснее: если Service A получил токен с `aud: service-a`, он обменивает его на токен с `aud: service-b` перед вызовом Service B. Service B принимает только токены со своим audience.

### Audience Restriction

Каждый сервис проверяет claim `aud` в JWT. Токен с `aud: payment-service` отклоняется `user-service`. Это предотвращает confused deputy attack: злоумышленник не может использовать токен, полученный от одного сервиса, для доступа к другому.

Следующий пример показывает middleware проверки audience в Kotlin-сервисе.

```kotlin
// Middleware: проверка audience в JWT
fun validateTokenForService(
    token: DecodedJWT,
    expectedAudience: String  // Идентификатор этого сервиса
): Boolean {
    val audiences = token.audience  // ["payment-service"]

    // Токен ДОЛЖЕН быть адресован именно этому сервису
    if (expectedAudience !in audiences) {
        log.warn("Rejected: aud=${audiences}, expected=$expectedAudience")
        return false  // Confused deputy prevention
    }

    // Дополнительно: проверить issuer
    if (token.issuer != TRUSTED_ISSUER) return false

    return true
}
```

Без этой проверки возникает confused deputy: сервис A получает токен от пользователя, вызывает сервис B с тем же токеном. Сервис B видит валидный JWT и выполняет запрос, хотя токен предназначался для сервиса A. Audience restriction разрывает эту цепочку.

### API Gateway как точка терминации auth

Gateway обрабатывает всю аутентификацию: валидация токенов, rate limiting, проверка scopes. Backend-сервисы получают pre-validated запросы с контекстом пользователя в headers (`X-User-Id`, `X-User-Role`). Сервисы проще: нет JWT-библиотек, нет ключей, нет логики валидации.

| Подход | Плюсы | Минусы |
|--------|-------|--------|
| Centralized (gateway) | Простые backend-сервисы, единая точка настройки auth policy | Gateway = single point of failure, доверие внутренним заголовкам |
| Distributed (каждый сервис) | Defense in depth, независимость сервисов | Дублирование логики, управление ключами |
| Гибрид | Gateway валидирует + сервисы проверяют audience | Баланс безопасности и сложности |

---

## Zero Trust Architecture

### "Never Trust, Always Verify"

Традиционная модель -- castle-and-moat: внутренняя сеть = доверенная. VPN = ты внутри замка. Всё внутри -- безопасно. Эта модель рушится, когда злоумышленник проникает внутрь (фишинг, скомпрометированный ноутбук) -- он получает доступ ко всему.

**Аналогия: аэропорт.** В аэропорту вас проверяют на каждом этапе. Регистрация -- паспорт + билет. Досмотр -- личные вещи. Паспортный контроль -- виза. Гейт -- посадочный талон. Вы не "доверенный" после первой проверки -- каждый этап верифицирует заново. Даже если вы прошли досмотр, это не означает, что вас пропустят на гейт другого рейса. Zero Trust работает так же: каждый запрос проверяется независимо от того, откуда он пришёл.

### Принципы NIST SP 800-207

NIST формализовал Zero Trust в пять ключевых принципов. (1) Все источники данных и вычислительные сервисы -- ресурсы, требующие защиты. (2) Вся коммуникация защищена независимо от сетевого расположения -- "внутренний" не значит "безопасный". (3) Доступ к ресурсам предоставляется per-session -- нет постоянного доступа. (4) Доступ определяется динамической политикой: идентичность, состояние устройства, поведение, время. (5) Организация мониторит и измеряет security posture всех активов.

На практике Zero Trust для API реализуется комбинацией: mTLS (transport-level identity) + JWT с audience restriction (application-level authorization) + device posture check (is the device managed? patched? encrypted?) + microsegmentation (service A может вызывать только service B и C, не D).

### Device Posture Check

Zero Trust не ограничивается проверкой идентичности вызывающего. Он проверяет контекст запроса: устройство, с которого сделан запрос. Управляемое ли устройство (corporate-managed)? Установлены ли последние патчи безопасности? Включено ли шифрование диска? Не рутовано ли / не jailbroken? Ответы на эти вопросы влияют на решение о доступе.

Инструменты: Google BeyondCorp Enterprise проверяет Chrome browser posture (extensions, версия, OS patches). CrowdStrike и Microsoft Defender for Endpoint предоставляют device health signals. Zscaler Private Access обеспечивает Zero Trust доступ с проверкой устройства. Результат: даже если credentials валидны, запрос с скомпрометированного устройства отклоняется.

### Microsegmentation

Вместо плоской сети, где каждый сервис может общаться с любым другим, -- гранулярные правила. Это принцип наименьших привилегий (least privilege), применённый к сетевому уровню. В Kubernetes: NetworkPolicies (L3/L4) ограничивают, какие pods могут общаться друг с другом на уровне IP и портов. Istio AuthorizationPolicies (L7) добавляют гранулярность: Service A может вызывать только `GET /api/users` у Service B, но не `DELETE /api/users`.

Если Service A скомпрометирован -- blast radius ограничен только разрешёнными вызовами. Без microsegmentation компрометация одного сервиса даёт доступ ко всей внутренней сети. С microsegmentation злоумышленник видит только те сервисы, с которыми скомпрометированный сервис имел право общаться.

---

## App Attestation

### Проблема мобильных API

Мобильные API имеют уникальную проблему: как убедиться, что запрос пришёл от вашего легитимного приложения на неповреждённом устройстве, а не от бота, скрипта или модифицированного клиента? API key можно извлечь из APK за 5 минут. Bearer token можно украсть на рутованном устройстве. Нужен механизм, привязанный к аппаратному обеспечению.

### iOS: App Attest

Apple App Attest использует Secure Enclave -- аппаратный модуль, изолированный от основной операционной системы. При первом запуске приложение генерирует ключевую пару в Secure Enclave. Apple подтверждает (attests), что ключ создан легитимным приложением на легитимном устройстве. Сервер верифицирует attestation через Apple's servers. При каждом критическом запросе приложение подписывает данные приватным ключом из Secure Enclave. Сервер проверяет подпись -- подтверждение, что запрос исходит от подлинного приложения.

### Android: Play Integrity

Google Play Integrity API (замена deprecated SafetyNet) возвращает три вердикта: device integrity (устройство не рутовано, bootloader заблокирован), app integrity (приложение установлено из Play Store, не модифицировано), account integrity (аккаунт Google в хорошем состоянии). Сервер получает подписанный Google verdict и принимает решение о доверии.

### Интеграция с серверной частью

App Attestation -- не замена user authentication, а дополнительный слой. Типичный flow для мобильного приложения: (1) пользователь аутентифицируется через OAuth 2.0 + PKCE, получает access token; (2) при критических операциях (платёж, смена пароля) приложение запрашивает attestation у платформы (App Attest на iOS, Play Integrity на Android); (3) сервер верифицирует и attestation, и access token; (4) если хотя бы одна проверка не прошла -- операция отклонена.

Следующий пример демонстрирует серверную проверку attestation-токена от Android Play Integrity API.

```kotlin
// Серверная верификация Play Integrity verdict
suspend fun verifyPlayIntegrity(
    integrityToken: String,
    expectedNonce: String
): IntegrityVerdict {
    // Декодирование через Google API (не локально!)
    val verdict = playIntegrityClient
        .decodeIntegrityToken(integrityToken)

    // Три уровня проверки
    val deviceOk = verdict.deviceIntegrity
        .contains("MEETS_DEVICE_INTEGRITY")  // Не рутован
    val appOk = verdict.appIntegrity
        .appRecognitionVerdict == "PLAY_RECOGNIZED"  // Из Play Store
    val nonceOk = verdict.requestDetails
        .nonce == expectedNonce  // Защита от replay

    return IntegrityVerdict(deviceOk, appOk, nonceOk)
}
```

Этот код проверяет три аспекта: целостность устройства (не рутовано, bootloader заблокирован), целостность приложения (установлено из Play Store, не модифицировано), и nonce (одноразовый токен, предотвращающий replay). Важно: декодирование integrity token происходит через Google API, а не локально -- это предотвращает подделку verdict на стороне клиента.

### Ограничения

Attestation подтверждает легитимность устройства и приложения в момент проверки. Оно не защищает от runtime-атак (инъекция кода в работающий процесс через Frida hooks, Xposed framework). Оно не гарантирует, что данные не будут перехвачены на скомпрометированном устройстве после attestation. Attestation -- один слой в defense-in-depth, не единственная защита.

Рекомендуемая комбинация для максимальной защиты мобильного API: OAuth 2.0 + PKCE (user auth) + App Attestation (app/device auth) + certificate pinning (transport security) + DPoP (token binding). Каждый слой защищает от конкретного вектора атаки, и компрометация одного слоя не означает полный доступ.

---

## Decision Matrix: какой паттерн выбрать

```
Какой API auth для вашего сценария?

Публичный API для разработчиков?
├── Только rate limiting           → API Key
└── Доступ к данным пользователя   → OAuth 2.0 + API Key (для идентификации app)

Внутренний microservice-to-service?
├── Kubernetes с mesh              → Service Mesh (автоматический mTLS)
├── Cloud-native (GCP/AWS)         → Service Accounts + Client Credentials
└── Regulated / финансы            → mTLS + Client Credentials + audit trail

Мобильное приложение → Backend?
├── Аутентификация пользователя    → OAuth 2.0 + PKCE
├── Верификация приложения         → App Attestation + Bearer Token
└── Максимальная защита            → OAuth 2.0 + PKCE + App Attestation + DPoP

Webhook receiver?
└── HMAC Signature Verification (Stripe/GitHub pattern)

Третьесторонняя интеграция?
├── Доступ от имени пользователя   → OAuth 2.0 Authorization Code
└── Без пользовательского контекста→ OAuth 2.0 Client Credentials
```

---

## Распространённые заблуждения

**"API keys -- это токены."** Нет. API key -- статический идентификатор приложения. Токен -- динамический, scoped, time-limited credential. API key не имеет expiration, не имеет scope, не привязан к пользователю. Путаница приводит к использованию API keys там, где нужен OAuth.

**"HTTPS достаточно для безопасности API."** HTTPS защищает транспорт (данные в пути зашифрованы), но не решает вопрос авторизации. HTTPS не проверяет, имеет ли вызывающий право на этот endpoint. HTTPS не ограничивает scope. HTTPS -- необходимое, но не достаточное условие.

**"Service mesh заменяет application-level auth."** Service mesh (Istio, Linkerd) обеспечивает transport-level security: mTLS, идентификация сервисов. Но mesh не знает бизнес-логику: "может ли Service A вызвать DELETE /users/42". Application-level authorization (RBAC, ABAC) по-прежнему необходим.

**"Zero Trust означает отсутствие доверия."** Нет. Zero Trust означает отсутствие неявного (implicit) доверия. Доверие есть, но оно явное, проверяемое, ограниченное по времени. Каждый запрос верифицируется -- это не "нет доверия", а "доверяй, но проверяй на каждом шаге".

---

## Подводные камни

**API key в URL query params.** Ключ попадает в серверные access logs, в Referer header при переходе на другой сайт, в историю браузера, в кэш прокси-серверов. Всегда передавайте API key в заголовке `X-API-Key`.

**Token propagation без audience validation.** Классический confused deputy: Service A передаёт токен Service B, Service B передаёт его Service C. Service C выполняет действие, думая, что запрос от пользователя напрямую. Audience restriction разрывает цепочку.

**Истечение mTLS-сертификатов.** Самая коварная ошибка в production: сертификат истекает, TLS handshake начинает отклоняться, сервисы теряют связь. Ошибка каскадно распространяется. TLS error messages криптичны ("handshake failure" без указания причины). Автоматическая ротация (cert-manager, Istio) -- обязательна.

**Service-to-service auth без audit trail.** Если сервисы аутентифицируют друг друга, но не логируют KTO вызвал ЧТО -- невозможно расследовать инциденты. Каждый межсервисный вызов должен логировать: source service identity, destination, action, timestamp.

---

## Когда НЕ применяется

**mTLS для публичных API.** Клиенты (мобильные приложения, браузеры, CLI-инструменты) не могут управлять сертификатами. PKI-инфраструктура для миллионов клиентов -- нереалистично. Для публичных API используйте OAuth 2.0 + bearer tokens.

**API keys для пользовательского access control.** API key не имеет понятия "пользователь". Он идентифицирует приложение, а не человека. Если нужны пользовательские permissions -- OAuth 2.0 с scopes.

**Zero Trust для маленькой команды с одним сервисом.** Полноценный Zero Trust (device posture, microsegmentation, continuous verification) -- значительные операционные затраты. Для монолита с одним сервисом за Nginx достаточно HTTPS + OAuth 2.0 + правильные CORS headers. Zero Trust оправдан при масштабе десятков сервисов и распределённой команды.

---

## Связь с другими темами

**[[authentication-authorization]]** -- обзорный хаб: AuthN vs AuthZ, OAuth flows, RBAC/ABAC. Текущий файл углубляет конкретные паттерны API auth, которые в обзоре упомянуты кратко.

**[[auth-sessions-jwt-tokens]]** -- механика JWT (header, payload, signature), sessions, opaque tokens, refresh tokens. Текущий файл опирается на эти знания, не повторяя их. Порядок чтения: sessions/JWT → текущий файл.

**[[auth-oauth2-oidc]]** -- OAuth 2.0 flows (Authorization Code, Client Credentials, PKCE). Текущий файл ссылается на Client Credentials для service-to-service и PKCE для мобильных API. Порядок чтения: OAuth → текущий файл.

**[[security-https-tls]]** -- TLS mechanics, certificate chain, PKI. Фундамент для понимания mTLS. Текущий файл не дублирует TLS-механику, а строит на ней.

**[[security-api-protection]]** -- rate limiting, input validation, API gateway patterns. Дополняет текущий файл: auth -- КТО может вызвать API, protection -- КАК защитить API от злоупотреблений.

**[[auth-authorization-models]]** -- RBAC/ABAC, применяемые к API endpoints. После аутентификации (текущий файл) следует авторизация (модели доступа).

---

## Источники и дальнейшее чтение

- **Rose, S. et al. (2020).** NIST SP 800-207: Zero Trust Architecture. NIST. -- Формальное определение Zero Trust. Не привязан к конкретным технологиям, описывает архитектурные принципы. Обязателен для тех, кто проектирует security architecture для крупных систем. Стоит читать ради понимания, ЧТО такое Zero Trust на самом деле (а не маркетинговое "купите наш product").

- **Madden, N. (2020).** API Security in Action. Manning. -- Практическое руководство от основ (HTTPS, tokens) до продвинутых тем (capability-based security, mTLS). Каждая глава содержит код и реальные сценарии. Стоит читать ради понимания связи между аутентификацией, авторизацией и audit trail для API.

- **Richer, J. & Sanso, A. (2017).** OAuth 2 in Action. Manning. -- Глубокое погружение в OAuth 2.0: не только flows, но и security considerations, token introspection, динамическая регистрация клиентов. Стоит читать ради понимания, ПОЧЕМУ OAuth спроектирован именно так -- какие атаки предотвращает каждый параметр.

- **AWS Documentation.** Signature Version 4 Signing Process. -- Эталонная документация по HMAC-подписи запросов. Подробно описывает canonical request, string-to-sign, signing key derivation. Стоит читать как пример промышленного стандарта подписи API-запросов.

- **Li, L. et al. (2021).** "A Systematic Study of the Consistency of Two-Factor Authentication User Journeys on Top-Ranked Websites." USENIX Security. -- Исследование реальных реализаций аутентификации на крупных сайтах. Показывает разрыв между спецификацией и практикой. Стоит читать ради понимания, что "правильная реализация" и "реальная реализация" -- часто разные вещи.

---

*Создано: 2026-02-11*
