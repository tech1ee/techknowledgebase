---
title: "OAuth 2.0, OpenID Connect и современные протоколы делегированной авторизации"
created: 2026-02-11
modified: 2026-02-11
type: deep-dive
status: published
confidence: high
tags:
  - topic/security
  - type/deep-dive
  - level/intermediate
related:
  - "[[authentication-authorization]]"
  - "[[auth-sessions-jwt-tokens]]"
  - "[[auth-enterprise-sso]]"
  - "[[auth-api-service-patterns]]"
  - "[[security-https-tls]]"
prerequisites:
  - "[[authentication-authorization]]"
  - "[[auth-sessions-jwt-tokens]]"
---

# OAuth 2.0, OpenID Connect и современные протоколы делегированной авторизации

OAuth решает "password anti-pattern" -- ваше приложение никогда не должно знать пароль пользователя от Google. Вместо передачи полных учётных данных OAuth создаёт систему ограниченных, отзываемых, привязанных к конкретному действию разрешений. Это фундаментальный сдвиг: от "дай мне свой пароль" к "разреши мне конкретное действие на ограниченное время".

---

## Зачем это знать

До появления OAuth существовала единственная модель интеграции между сервисами: приложение просило у пользователя логин и пароль от другого сервиса и использовало их напрямую. Хотите, чтобы сторонний почтовый клиент читал ваш Gmail? Отдайте ему пароль от Google. Сервис печати фотографий хочет доступ к Flickr? Введите учётные данные Flickr в форму этого сервиса.

Это создавало каскад проблем. Приложение получало полный доступ к аккаунту -- не "только чтение фотографий", а всё, что может делать владелец, включая смену пароля и удаление данных. Невозможно отозвать доступ одному приложению без смены пароля, что автоматически ломало все остальные интеграции. Компрометация любого из сторонних приложений означала полную компрометацию основного аккаунта.

> **Аналогия: ключи от квартиры.** Представьте, что вам нужно, чтобы курьер доставил посылку в квартиру, пока вас нет. Без OAuth единственный вариант -- дать курьеру копию вашего мастер-ключа. Этот ключ открывает все двери: входную, спальню, сейф. Вы не можете ограничить доступ только прихожей. Вы не можете отозвать ключ, не поменяв замок (что аннулирует ключи всех домочадцев). OAuth -- это электронный замок с разовыми кодами: курьер получает код, который работает один раз, открывает только входную дверь и перестаёт действовать через час.

OAuth решил эту проблему через концепцию **делегированной авторизации**: пользователь напрямую общается с сервисом, которому доверяет (Google, GitHub), и явно разрешает конкретному приложению конкретные действия. Приложение никогда не видит пароль -- оно получает ограниченный по времени и scope токен.

---

## Терминология

| Термин | Что это | Аналогия из реальной жизни |
|--------|---------|---------------------------|
| **Authorization Server** | Сервер, выдающий токены (Google, GitHub, Keycloak) | Паспортный стол: проверяет личность и выдаёт документы |
| **Resource Server** | API, защищающий данные (Google Photos API, GitHub API) | Банковское хранилище, куда пускают только по пропуску |
| **Client** | Приложение, запрашивающее доступ (ваше мобильное приложение) | Курьер, который просит разрешения войти |
| **Resource Owner** | Пользователь, владеющий данными | Владелец квартиры, решающий кого пустить |
| **Scope** | Набор запрашиваемых разрешений (read, write, email) | Список действий в нотариальной доверенности |
| **Grant Type** | Способ получения токена (Authorization Code, Client Credentials) | Тип доверенности: нотариальная, генеральная, разовая |
| **Authorization Code** | Одноразовый код, обмениваемый на токены | Извещение о посылке: бесполезно без паспорта |
| **PKCE** | Proof Key for Code Exchange -- защита от перехвата кода | Запечатанный конверт с ответом на контрольный вопрос |
| **ID Token** | JWT с информацией о пользователе (только OIDC) | Паспорт с фото и персональными данными |
| **Access Token** | Токен для доступа к ресурсам (короткоживущий) | Дневной пропуск в бизнес-центр |
| **Refresh Token** | Токен для получения нового access token (долгоживущий) | Постоянный пропуск, по которому выдают дневные |
| **Redirect URI** | URL, куда authorization server возвращает пользователя | Обратный адрес на конверте |
| **State** | Случайная строка для защиты от CSRF | Номер заявки, который вы сверяете при получении результата |
| **Nonce** | Одноразовое значение для защиты от replay-атак (OIDC) | Одноразовый штамп на документе: повторное использование заметно |

---

## Prerequisites

| Prerequisite | Что нужно знать | Почему |
|-------------|----------------|--------|
| [[authentication-authorization]] | Разница AuthN vs AuthZ, обзор способов аутентификации | OAuth -- протокол авторизации; OIDC добавляет аутентификацию. Без понимания разницы невозможно корректно применять оба |
| [[auth-sessions-jwt-tokens]] | JWT-формат, claims, подпись, механика access/refresh токенов | ID Token в OIDC и access tokens в OAuth -- это JWT; нужно понимать их структуру и ограничения |

---

## Историческая справка

История OAuth -- это история постепенного осознания того, что модель "доверь мне свой пароль" фундаментально несовместима с экосистемой, где десятки приложений интегрируются с одним сервисом.

**2006--2007: OAuth 1.0 (Blaine Cook, Twitter).** Блейн Кук, ведущий инженер Twitter, столкнулся с конкретной проблемой: сторонние приложения хотели публиковать твиты от имени пользователей, и единственным способом было хранение паролей. Вместе с Крисом Мессиной (Ma.gnolia) и Ларри Хальфом он разработал OAuth 1.0 -- протокол, требующий криптографическую подпись (HMAC-SHA1) на каждом запросе. Это было безопасно, но мучительно сложно: нормализация параметров, вычисление base string, подпись каждого HTTP-запроса вручную. Ошибка в одном символе -- запрос отклонён.

**2012: OAuth 2.0 (RFC 6749, Dick Hardt).** Дик Хардт и рабочая группа IETF радикально упростили протокол. Вместо криптографических подписей -- bearer tokens, где безопасность транспорта делегирована TLS. Вместо одного flow -- несколько grant types для разных сценариев. Это снизило порог входа, но вызвало критику: Эран Хаммер, один из авторов, покинул рабочую группу, назвав OAuth 2.0 "road to hell" за превращение протокола во framework с избыточной гибкостью.

**2014: OpenID Connect 1.0 (OpenID Foundation).** OAuth 2.0 решал авторизацию ("что можно делать"), но не аутентификацию ("кто ты"). OIDC добавил identity layer: ID Token (JWT с информацией о пользователе), UserInfo endpoint, стандартные scopes. "Login with Google" стало стандартизированным протоколом, а не проприетарной интеграцией.

**2015: PKCE (RFC 7636).** С распространением мобильных приложений обнаружилась уязвимость: public clients не могут хранить client_secret. PKCE добавил одноразовое криптографическое подтверждение, привязывающее запрос авторизации к обмену кода на токен.

**2020: OAuth 2.0 Security BCP (RFC 9700).** Ужесточение рекомендаций: запрет Implicit flow, обязательность PKCE, exact redirect URI matching, ограничения на refresh tokens.

**2024--2025: OAuth 2.1 (draft-ietf-oauth-v2-1-14).** Не новый протокол, а консолидация OAuth 2.0 + Security BCP + PKCE в один документ. Удалены Implicit и Password flows, PKCE обязателен для всех клиентов.

**2024: GNAP (RFC 9635).** Grant Negotiation and Authorization Protocol -- протокол следующего поколения, спроектированный с нуля без ограничений обратной совместимости.

```
Эволюция протоколов делегированной авторизации:

2007     2012      2014      2015     2020       2024-25
 │        │         │         │        │           │
 ▼        ▼         ▼         ▼        ▼           ▼
OAuth    OAuth     OIDC      PKCE    Security   OAuth 2.1
1.0      2.0       1.0       (RFC    BCP        (draft)
(crypto  (bearer   (identity 7636)   (RFC       + GNAP
 sigs)   tokens)   layer)            9700)      (RFC 9635)
 │        │         │         │        │
 │ Слишком │ Нет     │ Mobile  │ Implicit│
 │ сложно  │ AuthN   │ уязвимо │ опасен │
 ▼        ▼         ▼         ▼        ▼
 Каждый этап закрывал уязвимости предыдущего
```

---

## Authorization Code Flow: основной поток

Authorization Code Flow -- рекомендуемый способ получения токенов для всех приложений. Его ключевая особенность -- разделение на два канала: front-channel (через браузер пользователя) и back-channel (прямое серверное взаимодействие). Именно это разделение обеспечивает безопасность.

```
Authorization Code Flow (все участники):

  User      Browser/App   Client Server   Auth Server      Resource
  (человек)               (ваш backend)   (Google)         Server (API)
    │           │               │               │               │
    │ 1. "Login │               │               │               │
    │  with     │               │               │               │
    │  Google"  │               │               │               │
    │──────────▶│  2. Redirect  │               │               │
    │           │──────────────▶│               │               │
    │           │               │ 3. 302 →/authorize?           │
    │           │               │   client_id=abc               │
    │           │               │   redirect_uri=/callback      │
    │           │               │   scope=openid+email          │
    │           │               │   state=xyz123                │
    │           │               │   response_type=code          │
    │           │◀──────────────│               │               │
    │           │  4. Redirect в Auth Server    │               │
    │           │──────────────────────────────▶│               │
    │           │                               │               │
    │ 5. Логин  │◀──────────────────────────────│               │
    │  страница │                               │               │
    │──────────▶│──────────────────────────────▶│               │
    │           │                               │               │
    │ 6. Consent│◀──────────────────────────────│               │
    │  "Разрешить                               │               │
    │   доступ  │                               │               │
    │   к email"│                               │               │
    │──────────▶│──────────────────────────────▶│               │
    │           │                               │               │
    │           │  7. 302 → /callback?          │               │
    │           │     code=AUTH_CODE             │               │
    │           │     &state=xyz123             │               │
    │           │◀──────────────────────────────│               │
    │           │                               │               │
    │           │  8. GET /callback?code=...    │               │
    │           │──────────────▶│               │               │
    │           │               │               │               │
    │           │               │ 9. POST /token (back-channel) │
    │           │               │   code=AUTH_CODE               │
    │           │               │   client_secret=SECRET         │
    │           │               │──────────────▶│               │
    │           │               │               │               │
    │           │               │ 10. Response:  │               │
    │           │               │   access_token │               │
    │           │               │   refresh_token│               │
    │           │               │   id_token     │               │
    │           │               │◀──────────────│               │
    │           │               │                               │
    │           │               │ 11. GET /api/user              │
    │           │               │   Authorization: Bearer AT    │
    │           │               │──────────────────────────────▶│
    │           │               │                               │
    │           │               │ 12. 200 OK {user data}        │
    │           │               │◀──────────────────────────────│
```

### Каждый шаг в деталях

**Шаги 1--3: инициация.** Пользователь нажимает "Login with Google". Клиент формирует URL авторизации с параметрами: `response_type=code` (мы хотим код, не токен), `client_id` (публичный идентификатор), `redirect_uri` (куда вернуть -- должен точно совпадать с зарегистрированным), `scope` (запрашиваемые разрешения), `state` (случайная строка для CSRF-защиты). Браузер перенаправляется на authorization server.

**Шаги 4--6: аутентификация и consent.** Пользователь видит страницу логина authorization server -- не клиента. Пароль вводится на google.com, не на canva.com. После успешного входа -- consent screen: "Canva запрашивает доступ к вашему email (только чтение)". Пользователь видит конкретные scope и принимает решение.

**Шаг 7: возврат authorization code.** Authorization server перенаправляет браузер обратно на redirect_uri, добавляя в URL одноразовый authorization code и state. Code живёт обычно 10 минут и привязан к конкретному client_id и redirect_uri.

**Шаги 9--10: обмен кода на токены (back-channel).** Это ключевой момент: обмен происходит между серверами по HTTPS, без участия браузера. Client отправляет code, client_id, client_secret и redirect_uri. Authorization server проверяет всё и возвращает access_token, refresh_token и (при OIDC) id_token.

### Почему два шага: код, а потом токен?

Зачем промежуточный authorization code, если можно сразу вернуть access token? Причина -- в природе каналов. Front-channel (браузер) -- небезопасная среда: URL виден в истории, логах, заголовке Referer, расширениям браузера. Если access token окажется в URL, любой из этих векторов перехватит его.

Authorization code -- одноразовая, короткоживущая строка, бесполезная без client_secret. Обмен на токены идёт по back-channel -- HTTPS-запрос от сервера к серверу, не проходящий через браузер. Даже если code перехвачен, без secret он бесполезен.

> **Аналогия: получение посылки.** Когда вам приходит ценная посылка, почтальон не оставляет её у двери (front-channel -- небезопасно). Он оставляет извещение (authorization code) -- бумажку, которая сама по себе не имеет ценности. Чтобы получить посылку, вы идёте в отделение с извещением И паспортом (client_secret). Посылку (access token) выдают только после проверки обоих.

Следующий код показывает серверный обмен authorization code на токены -- шаги 9--10. Обратите внимание: `client_secret` передаётся только в серверном запросе.

```kotlin
// Обмен authorization code на токены (back-channel)
// client_secret НИКОГДА не попадает в браузер
suspend fun exchangeCodeForTokens(
    code: String,
    codeVerifier: String? = null  // Для PKCE
): TokenResponse {
    val response = httpClient.post("https://auth.example.com/token") {
        contentType(ContentType.Application.FormUrlEncoded)
        setBody(Parameters.build {
            append("grant_type", "authorization_code")
            append("code", code)
            append("redirect_uri", REDIRECT_URI)
            append("client_id", CLIENT_ID)
            append("client_secret", CLIENT_SECRET)
            codeVerifier?.let { append("code_verifier", it) }
        })
    }
    return response.body<TokenResponse>()
}
```

Этот запрос происходит исключительно между серверами. Браузер не участвует -- client_secret и полученные токены никогда не покидают серверную среду.

---

## PKCE: Proof Key for Code Exchange

### Проблема: клиенты без секрета

Authorization Code Flow работает, когда у приложения есть серверная часть с client_secret. Но мобильные приложения и SPA не могут хранить секреты: любой декомпилирует Android APK или откроет DevTools. Для таких клиентов client_secret -- иллюзия безопасности.

Без client_secret обмен кода на токен не защищён. Если злоумышленник перехватит authorization code (например, через вредоносное приложение, зарегистрировавшее тот же custom URI scheme на Android), он обменяет его на токены, потому что нечем подтвердить легитимность клиента.

PKCE (RFC 7636, произносится "pixy") решает проблему элегантно: вместо долговременного секрета клиент использует одноразовое криптографическое подтверждение.

### Механизм

Перед каждым запросом авторизации клиент делает три вещи. Первое: генерирует криптографически случайную строку -- `code_verifier` (43--128 символов). Второе: вычисляет SHA-256 хеш -- `code_challenge`. Третье: отправляет `code_challenge` с запросом авторизации, а `code_verifier` хранит локально.

При обмене кода на токен клиент отправляет оригинальный `code_verifier`. Authorization server вычисляет SHA-256 от полученного verifier и сравнивает с сохранённым challenge.

```
PKCE: защита от перехвата authorization code

  Легитимный клиент        Auth Server           Злоумышленник
        │                      │                       │
  1. verifier = random()       │                       │
  2. challenge =               │                       │
     SHA256(verifier)          │                       │
        │                      │                       │
  3. /authorize?               │                       │
     code_challenge=HASH       │                       │
     method=S256               │                       │
        │─────────────────────▶│ Сохраняет HASH        │
        │                      │                       │
  4. callback?code=CODE        │                       │
        │◀─────────────────────│                       │
        │                      │   Перехватил CODE!    │
        │                      │◀──────────────────────│
        │                      │                       │
  5. POST /token               │   POST /token         │
     code=CODE                 │   code=CODE           │
     code_verifier=ORIGINAL    │   (нет verifier!)     │
        │─────────────────────▶│◀──────────────────────│
        │                      │                       │
  6. SHA256(ORIGINAL)==HASH?   │   Нет verifier →      │
     ДА → токены               │   ОТКАЗ               │
        │◀─────────────────────│──────────────────────▶│
        │   access_token       │   403 Forbidden       │
```

> **Аналогия: запечатанный конверт.** Вы заказываете торт по телефону. Вместе с заказом называете хеш секретного слова: "контрольный код -- XK7F" (code_challenge). Когда курьер приезжает за тортом, он должен назвать само секретное слово, хеш которого даёт XK7F (code_verifier). Тот, кто подслушал заказ, знает только хеш -- из хеша восстановить слово невозможно (SHA-256 -- односторонняя функция).

В OAuth 2.1 PKCE обязателен для ВСЕХ клиентов, включая серверные. Это defense in depth: даже с client_secret PKCE защищает от authorization code injection.

Следующий код показывает генерацию PKCE-параметров на мобильном клиенте.

```kotlin
// Генерация PKCE code_verifier и code_challenge
// Вызывается ПЕРЕД каждым запросом авторизации
fun generatePkceChallenge(): PkceChallenge {
    val codeVerifier = ByteArray(32)
        .also { SecureRandom().nextBytes(it) }
        .let { Base64.encodeToString(
            it, Base64.URL_SAFE or Base64.NO_WRAP
        ) }
    val digest = MessageDigest.getInstance("SHA-256")
        .digest(codeVerifier.toByteArray(Charsets.US_ASCII))
    val codeChallenge = Base64.encodeToString(
        digest,
        Base64.URL_SAFE or Base64.NO_PADDING or Base64.NO_WRAP
    )
    return PkceChallenge(codeVerifier, codeChallenge)
}
```

Важно: `code_verifier` хранится только в памяти приложения на время авторизации. Он не записывается в SharedPreferences, не логируется и не отправляется по сети до момента обмена кода.

---

## Client Credentials Flow

Не все OAuth-взаимодействия вовлекают пользователя. Когда один сервис обращается к API другого сервиса (микросервис запрашивает данные, cron-задача обновляет кеш, CI/CD pipeline деплоит приложение), нет пользователя, который мог бы нажать "Разрешить".

Client Credentials Flow -- самый простой grant type. Клиент аутентифицируется напрямую с authorization server, используя client_id и client_secret. Никаких redirect URI, authorization codes или consent screen.

Типичные сценарии: backend-to-backend коммуникация, scheduled jobs, мониторинг. Ниже -- пример получения M2M-токена.

```kotlin
// Client Credentials: сервис аутентифицируется напрямую
// Нет пользователя -- только machine-to-machine
suspend fun getServiceToken(): String {
    val response = httpClient.post(tokenEndpoint) {
        contentType(ContentType.Application.FormUrlEncoded)
        setBody(Parameters.build {
            append("grant_type", "client_credentials")
            append("client_id", SERVICE_CLIENT_ID)
            append("client_secret", SERVICE_CLIENT_SECRET)
            append("scope", "reports:read analytics:write")
        })
    }
    // Кешировать до expires_in, НЕ запрашивать каждый раз
    return response.body<TokenResponse>().accessToken
}
```

Этот flow безопасен только при условии, что client_secret хранится в защищённой среде (переменная окружения, vault, secrets manager). Никогда не используйте Client Credentials в мобильных приложениях или SPA.

---

## Device Authorization Flow (RFC 8628)

### Устройства без браузера

Smart TV, CLI-инструменты, IoT-устройства, игровые приставки -- все имеют общую проблему: неудобно или невозможно вводить логин и пароль. Попробуйте набрать 16-символьный пароль пультом от телевизора.

Device Authorization Flow решает это через разделение: устройство получает короткий код, пользователь вводит его на другом устройстве (телефоне), где удобно аутентифицироваться. Устройство опрашивает (polling) authorization server, ожидая подтверждения.

```
Device Authorization Flow:

  Smart TV               Auth Server          Телефон пользователя
    │                        │                        │
    │  1. POST /device/code  │                        │
    │     client_id=tv_app   │                        │
    │───────────────────────▶│                        │
    │                        │                        │
    │  2. device_code=XYZW   │                        │
    │     user_code=WDJB-MJHT│                        │
    │     verification_uri=  │                        │
    │       https://g.co/auth│                        │
    │     interval=5 (сек)   │                        │
    │◀───────────────────────│                        │
    │                        │                        │
    │  3. На экране TV:       │                        │
    │     "Откройте g.co/auth│                        │
    │      Введите: WDJB-MJHT"                       │
    │                        │                        │
    │                        │  4. Пользователь       │
    │                        │     открывает URL      │
    │                        │◀───────────────────────│
    │                        │  5. Вводит WDJB-MJHT  │
    │                        │◀───────────────────────│
    │                        │  6. Логин + consent    │
    │                        │◀───────────────────────│
    │                        │                        │
    │  7. Polling каждые 5с: │                        │
    │     POST /token        │                        │
    │     device_code=XYZW   │                        │
    │───────────────────────▶│                        │
    │  "authorization_pending"│                        │
    │◀───────────────────────│                        │
    │     (повторяет...)      │                        │
    │───────────────────────▶│                        │
    │  8. access_token!       │                        │
    │◀───────────────────────│                        │
```

Этот flow знаком каждому, кто активировал Netflix или YouTube на Smart TV. Код намеренно короткий (4--8 символов, часто с разделителем) для удобства ввода.

---

## Почему Implicit и Password flows устарели

### Implicit Flow: токен в URL

Implicit Flow создан для SPA в 2012 году, когда CORS не был повсеместно поддержан и SPA не могли выполнять cross-origin POST для обмена кода на токен. Access token возвращался напрямую в URL fragment (`#access_token=...`), минуя серверный обмен.

Проблемы оказались фундаментальными, и каждая из них -- не теоретическая. URL fragment сохраняется в истории браузера -- любой, кто получит доступ к компьютеру, увидит токен. Вредоносные расширения могут читать URL текущей вкладки. При навигации на внешнюю страницу URL может утечь через заголовок Referer. JavaScript на странице (в том числе сторонний -- аналитика, рекламные скрипты) получает доступ к `window.location.hash`, содержащему токен.

Ещё два недостатка делают Implicit flow практически непригодным для современных приложений. Первый: refresh tokens не поддерживаются -- слишком опасно передавать долгоживущий токен через URL. При каждом истечении access token пользователь должен проходить авторизацию заново (обычно через скрытый iframe, что создаёт дополнительные уязвимости). Второй: нет механизма привязки токена к конкретному клиенту -- перехваченный токен может использовать любое приложение.

### Password Flow (ROPC): антипаттерн

Resource Owner Password Credentials Flow позволял приложению принимать логин и пароль пользователя и обменивать их на токен. Это противоречит самой сути OAuth: весь протокол создан для того, чтобы приложение НИКОГДА не видело пароль пользователя. ROPC был включён как компромисс для миграции legacy-систем, где пользователи привыкли вводить пароль в приложение.

На практике ROPC создаёт все проблемы, которые OAuth призван устранить. Приложение видит пароль -- и может его сохранить, отправить на свой сервер или использовать для полного доступа к аккаунту. Пользователь не видит consent screen и не знает, какие именно scope запрашиваются. MFA (многофакторная аутентификация) не поддерживается: flow предполагает, что логина и пароля достаточно. Authorization server не может отличить легитимный запрос от фишинговой атаки.

OAuth 2.1 формально удаляет оба flow. Для SPA -- Authorization Code + PKCE. Для legacy-приложений, которым "нужен" Password flow -- разработать полноценный Authorization Code Flow или использовать встроенный WebView (что тоже небезопасно, но менее катастрофично).

---

## OpenID Connect (OIDC): identity layer

### OAuth -- авторизация, OIDC -- аутентификация

OAuth 2.0 отвечает на вопрос "что этому приложению разрешено делать?", но не "кто этот пользователь?". Access token даёт доступ к ресурсам, но не содержит информации о пользователе. Это как пропуск в здание: он открывает дверь, но не говорит, КТО вы.

OpenID Connect добавляет identity layer поверх OAuth 2.0. OIDC не заменяет OAuth -- он расширяет его. Когда клиент запрашивает scope `openid`, authorization server возвращает помимо access token ещё и **ID Token** -- подписанный JWT с claims (утверждениями) о пользователе.

До OIDC разработчики использовали OAuth для аутентификации "кустарным" способом: получали access token, запрашивали с его помощью профиль пользователя у провайдера (Facebook Graph API, Google+ People API), и считали это аутентификацией. Проблема в том, что каждый провайдер реализовывал API по-своему, не было стандартных claims (полей с данными), и access token мог быть подставлен от другого клиента (token substitution attack). OIDC стандартизировал всю эту цепочку: формат токена, набор claims, endpoint для получения данных, и механизмы защиты.

### ID Token: структура и назначение

| Claim | Назначение | Пример |
|-------|-----------|--------|
| `iss` | Issuer -- кто выдал токен | `https://accounts.google.com` |
| `sub` | Subject -- уникальный ID пользователя | `110169484474386276334` |
| `aud` | Audience -- для какого клиента выдан | `your-app-client-id` |
| `exp` | Expiration -- когда истекает | `1707667200` |
| `iat` | Issued At -- когда выдан | `1707663600` |
| `nonce` | Одноразовое значение для replay protection | `abc123xyz` |
| `name` | Полное имя пользователя | `Алексей Иванов` |
| `email` | Email | `alex@example.com` |
| `email_verified` | Подтверждён ли email | `true` |

ID Token -- это не просто "набор данных о пользователе". Это криптографически подписанное утверждение authorization server о том, что конкретный пользователь прошёл аутентификацию в конкретный момент для конкретного клиента. Каждый claim имеет значение: `iss` позволяет клиенту убедиться, что токен пришёл от ожидаемого провайдера (а не подставлен); `aud` -- что токен выдан именно для этого клиента (а не украден у другого); `exp` -- что токен не устарел; `nonce` -- что это не replay предыдущей сессии.

Критически важное различие: **access token предназначен для Resource Server** (API), а **ID Token предназначен для Client** (вашего приложения). Отправлять ID Token как Bearer token в API-запросах -- нарушение протокола и уязвимость. ID Token содержит персональные данные пользователя (имя, email), которые не должны "гулять" по API-цепочке.

### Стандартные scopes OIDC

| Scope | Возвращаемые claims |
|-------|---------------------|
| `openid` | `sub` (обязательный для включения OIDC) |
| `profile` | `name`, `family_name`, `given_name`, `picture`, `locale` |
| `email` | `email`, `email_verified` |
| `phone` | `phone_number`, `phone_number_verified` |
| `address` | `address` (структурированный объект) |

Scope `openid` -- обязательный. Без него запрос обрабатывается как обычный OAuth 2.0, без ID Token.

### Nonce: защита от replay-атак

Параметр `nonce` -- одноразовое значение, которое клиент генерирует и отправляет с запросом авторизации. Authorization server включает это значение в ID Token (как claim). При получении ID Token клиент проверяет: nonce в токене совпадает с тем, который хранится в сессии.

Зачем это нужно? Предположим, злоумышленник перехватил ID Token из предыдущей сессии (через XSS, логи, или network sniffing). Он пытается "переиграть" его -- подставить клиенту, притворяясь пользователем. Без nonce клиент примет токен: подпись валидна, issuer правильный, срок не истёк. С nonce клиент сравнивает значение в токене с тем, что хранит в текущей сессии -- они не совпадут, потому что каждая сессия генерирует уникальный nonce. Replay-атака предотвращена.

### UserInfo Endpoint

Помимо ID Token, OIDC определяет UserInfo endpoint -- стандартизированный защищённый ресурс (GET /userinfo), возвращающий claims о пользователе в обмен на access token. UserInfo полезен в двух сценариях. Первый: когда ID Token минимален (содержит только `sub`) для уменьшения его размера -- полные данные запрашиваются отдельно. Второй: когда приложению нужны данные, которые не включены в ID Token по умолчанию (адрес, телефон).

Важное различие: ID Token проверяется по подписи (клиент доверяет криптографии). UserInfo endpoint защищён access token (клиент доверяет серверу). Для аутентификации достаточно ID Token. UserInfo -- дополнительный источник данных, а не замена ID Token.

---

## OIDC vs SAML: сравнение

| Характеристика | OIDC | SAML 2.0 |
|---------------|------|----------|
| **Формат данных** | JSON / REST | XML / SOAP |
| **Токен** | JWT (компактный) | XML Assertion (громоздкий) |
| **Транспорт** | HTTPS + JSON | HTTPS + XML |
| **Мобильные приложения** | Отлично | Крайне неудобен (XML parsing) |
| **SPA** | Нативная поддержка | Практически не используется |
| **Enterprise SSO** | Растёт | Доминирует (legacy) |
| **Сложность интеграции** | Низкая | Высокая |
| **Год появления** | 2014 | 2005 |
| **Типичное применение** | Consumer, mobile, modern enterprise | Legacy enterprise, government |

SAML остаётся стандартом в enterprise-среде из-за десятилетий инвестиций (Active Directory FS, Ping Identity). OIDC доминирует в consumer-сегменте и новых интеграциях. Подробное сравнение с enterprise-контекстом -- в [[auth-enterprise-sso]].

---

## OAuth 2.1: консолидация

OAuth 2.1 (draft-ietf-oauth-v2-1-14, октябрь 2025) -- не новый протокол, а кодификация best practices за 13 лет в один документ.

| Изменение | Было (OAuth 2.0) | Стало (OAuth 2.1) |
|-----------|------------------|--------------------|
| **PKCE** | Рекомендуется для public clients | Обязателен для ВСЕХ клиентов |
| **Implicit Flow** | Разрешён | Удалён |
| **Password Flow** | Разрешён | Удалён |
| **Redirect URI** | Частичное совпадение допускалось | Только exact match |
| **Refresh tokens** | Без ограничений | Ротация или sender-constrained |
| **Token в query string** | Допускалось | Запрещено |

Ни одно из этих изменений не является новым требованием -- все они были описаны в отдельных RFC и BCP документах за предыдущие годы. OAuth 2.1 просто делает их частью базовой спецификации, а не опциональными расширениями. Если вы уже следовали Security BCP (RFC 9700), ваша реализация уже совместима с OAuth 2.1.

Практическое следствие для разработчиков: если вы начинаете новый проект, ориентируйтесь на требования OAuth 2.1, даже если формально используете библиотеки, совместимые с OAuth 2.0. Разница минимальна в реализации, но существенна в безопасности.

---

## DPoP: Demonstrating Proof of Possession (RFC 9449)

### Проблема bearer-токенов

Bearer token -- "токен-предъявитель": любой, кто его имеет, может его использовать. Если access token утёк (через лог, XSS, перехват), злоумышленник получает тот же доступ, что и легитимный клиент. Bearer-модель работает как наличные деньги: кто нашёл -- тот и тратит.

DPoP (произносится "dee-pop") привязывает access token к конкретному клиенту через криптографическую пару ключей. Механизм работает в несколько шагов. Первый: клиент генерирует пару ключей (публичный + приватный). Второй: при запросе токена клиент создаёт DPoP proof -- подписанный JWT, содержащий публичный ключ, HTTP-метод, URL и временную метку. Третий: authorization server выдаёт access token, привязанный к публичному ключу (token type: "DPoP", а не "Bearer"). Четвёртый: при каждом API-запросе клиент формирует новый DPoP proof для конкретного method + URL и отправляет его вместе с access token. Пятый: resource server проверяет, что DPoP proof подписан ключом, который привязан к токену.

Если злоумышленник украдёт access token, он не сможет его использовать -- у него нет приватного ключа для создания валидного DPoP proof. Даже если DPoP proof перехвачен -- он привязан к конкретному HTTP-методу, URL и временной метке. Подставить его для другого запроса невозможно.

> **Аналогия: банковская карта с PIN.** Наличные деньги -- bearer token: кто нашёл, тот тратит. Банковская карта с PIN-кодом -- DPoP: даже если карту украли, без PIN она бесполезна. При каждой транзакции кассовый терминал требует PIN, доказывающий, что вы -- владелец карты. Более того, PIN для каждой транзакции привязан к конкретной сумме и магазину (аналог привязки DPoP proof к method + URL).

FAPI 2.0 (Financial-grade API) требует DPoP или mTLS client certificate binding для всех access tokens. Если вы интегрируетесь с Open Banking API (PSD2 в Европе, CDR в Австралии) -- sender-constrained tokens обязательны. В перспективе DPoP может стать стандартом для любых высокозащищённых API за пределами финансового сектора.

---

## Уязвимости OAuth и их митигация

Понимание уязвимостей OAuth -- не академическое упражнение. Каждая из описанных ниже атак была обнаружена и эксплуатирована в production-системах крупных компаний. Исследователи из Университета Трира (Fett, Kusters, Schmitz) формально проанализировали OAuth 2.0 в 2016 году и нашли ранее неизвестные уязвимости в реализациях Google, Facebook и Microsoft.

### Authorization Code Injection

**Атака:** злоумышленник получает authorization code (через фишинг, вредоносное приложение, social engineering) и подставляет его в callback легитимного клиента. Клиент обменивает чужой code на токены и получает доступ к аккаунту жертвы. **Митигация:** PKCE -- code_verifier привязывает код к оригинальному клиенту. Атакующий не знает code_verifier, который создал легитимный клиент, поэтому обмен code без правильного verifier невозможен.

### Redirect URI Manipulation (Open Redirect)

**Атака:** если authorization server допускает неточное сравнение redirect_uri, злоумышленник подставляет свой URL и перехватывает authorization code. Например, при проверке по префиксу `https://app.com`, атакующий использует `https://app.com.evil.com/callback`. **Митигация:** exact match redirect URI. Никакого partial matching, wildcards или дополнительных query-параметров. OAuth 2.1 делает это единственным допустимым вариантом.

### State/CSRF-атаки

**Атака:** злоумышленник начинает OAuth flow на своём устройстве, получает redirect URL с authorization code, и отправляет его жертве (через email, чат, QR-код). Жертва переходит по ссылке, callback срабатывает, и аккаунт жертвы привязывается к учётной записи злоумышленника. Теперь злоумышленник может войти в аккаунт жертвы через social login. **Митигация:** `state` -- криптографически случайная строка, привязанная к сессии пользователя, проверяемая при callback. Если state не совпадает -- flow отклоняется.

### Token Substitution (Confused Deputy)

**Атака:** злоумышленник получает access token от authorization server для своего вредоносного приложения (App A). Затем подставляет этот токен в легитимное приложение (App B), которое использует OAuth для аутентификации. App B доверяет токену и считает, что злоумышленник -- легитимный пользователь. **Митигация:** ID Token с audience (`aud`) claim. App B проверяет, что ID Token выдан именно для App B. Токен, выданный для App A, не пройдёт проверку.

### Mix-up Attack

**Атака:** в средах с несколькими authorization servers злоумышленник перенаправляет клиент к подконтрольному серверу, подменяя ответы. Клиент думает, что общается с легитимным провайдером, но отправляет authorization code злоумышленнику. **Митигация:** параметр `iss` в authorization response (RFC 9207); клиент сверяет issuer в ответе с ожидаемым.

### SSRF через Redirect URI

**Атака:** если authorization server выполняет серверные запросы к redirect URI (например, для валидации), злоумышленник указывает внутренний URL (`http://localhost/admin`, `http://169.254.169.254/metadata`). Сервер делает запрос к внутреннему ресурсу. **Митигация:** whitelist разрешённых redirect URI; запрет localhost, приватных IP-диапазонов и metadata-сервисов.

---

## Token Introspection (RFC 7662) и Revocation (RFC 7009)

### Introspection: проверка токена

Когда Resource Server получает opaque access token (не JWT), он не может самостоятельно проверить валидность. Token Introspection позволяет серверу ресурсов отправить токен на проверку в authorization server и получить ответ: активен ли, кому выдан, какие scopes, когда истекает.

Ниже -- пример проверки opaque token через introspection endpoint.

```kotlin
// Resource Server проверяет opaque token
// через Token Introspection endpoint
suspend fun introspectToken(token: String): TokenInfo {
    val response = httpClient.post(introspectionEndpoint) {
        contentType(ContentType.Application.FormUrlEncoded)
        basicAuth(RESOURCE_SERVER_ID, RESOURCE_SERVER_SECRET)
        setBody(Parameters.build {
            append("token", token)
        })
    }
    // {active: true, sub: "user_123", scope: "read", exp: ...}
    return response.body<TokenInfo>()
}
```

Introspection добавляет сетевой вызов к каждой проверке токена, увеличивая латентность на 1--5 мс (при локальном развёртывании authorization server) или 20--100 мс (при обращении к внешнему провайдеру). Для высоконагруженных API это может быть критично. Поэтому JWT-based access tokens (проверяемые локально по подписи, без сетевых вызовов) часто предпочтительнее.

Introspection полезен в двух сценариях. Первый: когда нужна гарантия real-time проверки отзыва -- JWT не может быть "отозван" до истечения (без дополнительной инфраструктуры). Второй: когда access token -- opaque string, и resource server не может проверить его самостоятельно.

### Revocation: отзыв токена

Token Revocation (RFC 7009) позволяет клиенту уведомить authorization server, что токен больше не нужен. Типичные сценарии: пользователь нажал "Выйти", сменил пароль, или обнаружил подозрительную активность. Клиент отправляет POST /revoke с `token` и `token_type_hint` (access_token или refresh_token).

Для JWT-based access tokens отзыв создаёт архитектурную проблему. JWT самодостаточен: resource server проверяет подпись и claims локально, без обращения к authorization server. Чтобы "отозвать" JWT, нужен blacklist -- централизованный список отозванных токенов, который resource server проверяет при каждом запросе. Это частично нивелирует stateless-преимущество JWT.

Практическое решение: отзывать не access token (пусть доживёт до expiration), а refresh token. При следующей попытке обновления клиент получит ошибку. Если access token живёт 15 минут, а refresh token отозван немедленно -- максимальное "окно уязвимости" составляет 15 минут. Для большинства приложений это приемлемый компромисс.

---

## GNAP: Grant Negotiation and Authorization Protocol (RFC 9635)

### Зачем нужен "OAuth 3"?

OAuth 2.0 проектировался в 2010--2012 годах для конкретного сценария: веб-приложение с серверной частью хочет получить доступ к REST API через браузерный redirect. С тех пор ландшафт изменился: IoT без браузеров, децентрализованные идентификаторы, взаимодействия без redirect, потребность в динамической регистрации клиентов.

GNAP (RFC 9635, 2024) спроектирован с нуля, без обратной совместимости с OAuth. Основные отличия.

**Динамические клиенты.** В OAuth 2.0 клиент должен быть предварительно зарегистрирован (client_id). GNAP позволяет клиенту представиться при первом запросе, предоставив публичный ключ. Предварительная регистрация не требуется.

**Гибкие interaction modes.** Вместо единственного redirect GNAP определяет несколько режимов: redirect (как OAuth), user code (как Device Flow), push notification, QR-code. Клиент и сервер согласовывают подходящий режим.

**Request-based модель.** OAuth 2.0 передаёт параметры в URL. GNAP использует JSON в back-channel, позволяя передавать сложные структуры и подписывать запросы.

**Криптографическая привязка по умолчанию.** В отличие от bearer tokens, GNAP изначально проектировался с sender-constrained tokens (аналог DPoP, встроенный в протокол).

**Единый протокол.** В мире OAuth identity (OIDC), device flow (RFC 8628), DPoP (RFC 9449) -- отдельные спецификации. GNAP интегрирует всё в один протокол.

Важно: GNAP на ранней стадии adoption. Есть reference implementations (Bespoke для Node.js), но нет production-ready библиотек для большинства платформ. Крупные провайдеры (Google, Microsoft, Auth0) не объявили поддержку. OAuth 2.0/2.1 + OIDC останутся доминирующим стеком на ближайшие годы. GNAP стоит изучать как направление, но не внедрять в production сегодня.

---

## Social Login: практические паттерны

### Google Sign-In

Google реализует полный OIDC. Scopes: `openid`, `profile`, `email`. Возвращает ID Token (JWT, подписанный RS256) с claims `sub`, `name`, `email`, `picture`. Google Subject ID (`sub`) -- стабильный идентификатор, привязанный к паре "пользователь + приложение". Это значит, что один и тот же пользователь будет иметь разные `sub` в разных приложениях -- Google обеспечивает pseudonymous идентификацию.

Discovery document доступен по `https://accounts.google.com/.well-known/openid-configuration`. Google "One Tap" -- UI-оптимизация, где пользователь видит popup вместо redirect, но протокол остаётся OIDC. ID Token верифицируется через JWKS endpoint на сервере, не на клиенте -- это критически важно.

### Apple Sign-In

Обязателен для iOS-приложений, предлагающих любой social login (App Store Guidelines 4.8). Особенности: Apple позволяет скрыть email (relay-адрес `@privaterelay.appleid.com`); `name` и `email` возвращаются только при первой авторизации -- при повторных только `sub`. Если не сохранили данные при первом Sign-In -- они потеряны.

### GitHub OAuth

GitHub использует OAuth 2.0 без полного OIDC. Для данных пользователя -- дополнительный запрос к `https://api.github.com/user`. Email может быть скрыт -- нужен отдельный запрос к `/user/emails`.

### Проблема коллизии email

Пользователь зарегистрировался через Google (alex@example.com). Через месяц входит через GitHub с тем же email. Это один и тот же пользователь? Автоматическая привязка аккаунтов по email опасна: если провайдер не верифицирует email (или пользователь GitHub добавил чужой email без подтверждения), злоумышленник может получить доступ к чужому аккаунту.

Безопасный подход состоит из трёх правил. Первое: всегда проверять claim `email_verified` -- если false, не использовать email для привязки. Второе: при попытке привязки нового провайдера к существующему аккаунту -- требовать подтверждение через уже подключённый провайдер или пароль. Третье: использовать `sub` (уникальный идентификатор провайдера), а не email, как primary key для связки аккаунтов.

Следующий код показывает серверную верификацию ID Token -- критически важный шаг, без которого аутентификация через social login небезопасна.

```typescript
// Верификация Google ID Token на сервере
// НИКОГДА не доверяйте данным с клиента без проверки
const { OAuth2Client } = require('google-auth-library');
const client = new OAuth2Client(GOOGLE_CLIENT_ID);

async function verifyGoogleIdToken(idToken: string) {
  const ticket = await client.verifyIdToken({
    idToken,
    audience: GOOGLE_CLIENT_ID,  // Токен выдан для НАШЕГО приложения
  });
  const payload = ticket.getPayload()!;
  return {
    googleId: payload.sub,       // Primary key для связки аккаунтов
    email: payload.email,
    emailVerified: payload.email_verified,
  };
}
```

Функция проверяет подпись (через JWKS), issuer, audience и срок действия. Провал любой проверки -- исключение. Без этой серверной валидации атакующий может подделать ID Token на клиенте.

---

## Распространённые заблуждения

**"OAuth -- это аутентификация."** Нет. OAuth 2.0 -- протокол авторизации. OIDC добавляет аутентификацию. Использование access token для идентификации без OIDC -- источник уязвимостей (token substitution).

**"JWT -- это всегда access token."** JWT -- формат (JSON Web Token), не тип токена. JWT может быть access token, ID Token, DPoP proof или чем угодно. Access token может быть JWT или opaque string. Эти понятия ортогональны.

**"OAuth нужен для всего."** Для монолита с server-side rendering и одной базой данных session-based authentication проще и безопаснее. OAuth оправдан при делегировании доступа к стороннему API или федеративной аутентификации.

**"Implicit flow -- нормальный вариант для SPA."** С 2020 года Implicit flow считается небезопасным (RFC 9700). Для SPA -- Authorization Code + PKCE с BFF (Backend for Frontend) или httpOnly cookie.

---

## Подводные камни

**State parameter.** Значение `state` должно быть криптографически случайным (не `state=123`) и привязанным к сессии. При callback клиент обязан проверить совпадение. Без этого -- CSRF-уязвимость.

**Redirect URI validation.** Authorization server должен требовать exact match. Частичное совпадение (`*.example.com`) позволяет создать поддомен и перехватить код. OAuth 2.1 делает exact match единственным вариантом.

**Хранение токенов на клиенте.** Access token в localStorage доступен из JavaScript (XSS). В sessionStorage теряется при закрытии вкладки. В httpOnly cookie защищён от JS, но подвержен CSRF. Подробный анализ -- в [[auth-sessions-jwt-tokens]].

**Scope creep.** Запрашивайте минимально необходимые scopes. `scope=openid email` вместо `scope=openid profile email phone address`. Пользователи чаще отклоняют consent screen с длинным списком.

**Refresh token rotation.** При ротации возникают race conditions: два параллельных запроса используют один refresh token. Решение: grace period (старый токен действителен несколько секунд) или replay detection (использование старого токена аннулирует всю цепочку).

---

## Когда НЕ применяется

**Простые веб-приложения с серверными сессиями.** Если у вас монолит с server-side rendering, пользователи логинятся через форму, данные в той же базе -- session-based authentication проще и надёжнее. OAuth -- избыточная сложность без пользы.

**Внутренние микросервисы.** Коммуникация внутри кластера (Kubernetes) лучше защищается mTLS или service mesh (Istio, Linkerd). OAuth добавляет лишний hop через authorization server. mTLS обеспечивает аутентификацию на транспортном уровне.

**Нет стороннего сервиса.** OAuth решает задачу делегирования доступа к ресурсам на стороннем сервисе. Если не интегрируетесь ни с каким внешним API и не предоставляете свой API сторонним клиентам -- OAuth не нужен.

---

## Связь с другими темами

**[[authentication-authorization]]** -- обзорный hub, покрывающий AuthN vs AuthZ, способы аутентификации, модели авторизации. Это prerequisite: без понимания разницы между аутентификацией и авторизацией OAuth и OIDC воспринимаются как одно и то же, что является распространённым заблуждением и источником уязвимостей.

**[[auth-sessions-jwt-tokens]]** -- детальный разбор JWT как формата, session-based authentication, стратегий хранения токенов. OAuth использует JWT для ID Token и (опционально) для access token. Понимание JWT claims, подписей и уязвимостей (alg=none, weak keys) напрямую применимо к токенам в OAuth/OIDC.

**[[auth-enterprise-sso]]** -- enterprise-контекст: SAML, Active Directory Federation Services, Okta. OIDC vs SAML -- ключевое решение при интеграции с корпоративными identity providers. OIDC побеждает в новых проектах, но SAML остаётся в legacy enterprise-среде.

**[[auth-api-service-patterns]]** -- OAuth в контексте API: Client Credentials для M2M, API gateways как OAuth enforcement point, стратегии валидации токенов (JWT verification vs introspection). Если текущий файл -- "как работает OAuth", то auth-api-service-patterns -- "как применять OAuth в архитектуре API".

**[[security-https-tls]]** -- TLS обязателен для всех OAuth flows. Bearer tokens безопасны только при зашифрованном транспорте. Без TLS authorization code, access token и client_secret перехватываются тривиально. Детали TLS handshake не дублируются здесь -- см. отдельный файл.

---

## Источники и дальнейшее чтение

**Hardt, D. (2012). RFC 6749: The OAuth 2.0 Authorization Framework.** Оригинальная спецификация OAuth 2.0. Сухой RFC-стиль, но необходима для точного понимания терминологии и flows. Раздел 10 (Security Considerations) -- обязательное чтение для тех, кто реализует OAuth. *Почему читать:* это первоисточник, на который ссылаются все остальные документы; неточности в понимании RFC ведут к уязвимостям в реализации.

**Sakimura, N., Bradley, J., Jones, M. et al. (2014). OpenID Connect Core 1.0.** Спецификация OIDC -- identity layer поверх OAuth 2.0. Описывает ID Token, UserInfo, discovery, стандартные claims и scopes. *Почему читать:* основной документ для реализации "Login with Google/Apple"; без него OIDC-интеграция основана на догадках и примерах, а не на спецификации.

**Richer, J. & Sanso, A. (2017). OAuth 2 in Action (Manning).** Практическое руководство с реализацией OAuth от начала до конца. Авторы -- активные участники IETF OAuth WG. *Почему читать:* книга объясняет не только "как", но и "почему" каждый элемент протокола спроектирован именно так; лучший переход от теории к практике.

**Lodderstedt, T., Fett, D., Parecki, A. et al. (2025). The OAuth 2.1 Authorization Framework (draft-ietf-oauth-v2-1-14).** Консолидация OAuth 2.0 + security best practices. *Почему читать:* показывает текущее направление развития протокола; если начинаете новый проект, ориентируйтесь на 2.1, а не на 2.0.

**Fett, D., Kusters, R. & Schmitz, G. (2016). "A Comprehensive Formal Security Analysis of OAuth 2.0." ACM CCS 2016.** Академический анализ, в котором авторы формально верифицировали безопасность OAuth 2.0 и обнаружили ранее неизвестные уязвимости (включая 307 redirect attack). *Почему читать:* формально доказывает, при каких условиях протокол безопасен, и объясняет, ПОЧЕМУ определённые меры обязательны, а не просто "рекомендованы".

---

*Создано: 2026-02-11*