---
title: "Enterprise SSO: SAML, Kerberos и федеративная аутентификация"
created: 2026-02-11
modified: 2026-02-11
type: deep-dive
status: published
confidence: high
tags:
  - topic/security
  - type/deep-dive
  - level/intermediate
related:
  - "[[authentication-authorization]]"
  - "[[auth-oauth2-oidc]]"
  - "[[auth-passwordless-mfa]]"
  - "[[auth-api-service-patterns]]"
prerequisites:
  - "[[auth-oauth2-oidc]]"
  - "[[authentication-authorization]]"
---

# Enterprise SSO: SAML, Kerberos и федеративная аутентификация

В корпорации со 100 внутренними сервисами сотрудник не может помнить 100 паролей. Single Sign-On решает эту проблему: один логин открывает доступ ко всему. Но за кажущейся простотой стоят протоколы с 35-летней историей -- Kerberos (1988), LDAP (1993), SAML (2005). Каждый из них отвечает на свой вопрос и несёт в себе архитектурные решения своей эпохи. Этот материал разбирает механику enterprise-аутентификации до уровня отдельных шагов протоколов, объясняя не только "как", но и "почему именно так".

---

## Зачем это знать

Даже если вы не enterprise-разработчик, рано или поздно вы столкнётесь с SSO. Кнопка "Войти через корпоративный аккаунт" в Jira, Slack, Figma -- это SAML или OIDC Federation. Когда вы открываете ноутбук в офисе и без повторного ввода пароля попадаете в корпоративную почту, файловый сервер и wiki -- это Kerberos. Когда HR добавляет нового сотрудника и его аккаунт автоматически появляется в 20 сервисах -- это SCIM поверх LDAP.

Понимание SSO-протоколов критично для трёх задач. Во-первых, отладка: "почему пользователь не может войти через SSO?" -- без знания SAML flow вы не прочитаете логи IdP. Во-вторых, интеграция: ваше приложение должно поддерживать "Login with Okta/Azure AD" -- это конкретная инженерная задача с конкретными подводными камнями (XML Signature Wrapping, certificate rotation, clock skew). В-третьих, безопасность: SAML signature wrapping attacks и Kerberos Golden Ticket -- это реальные векторы атак, которые эксплуатируются в production.

---

## Терминология

| Термин | Значение | Аналогия из жизни |
|--------|----------|-------------------|
| **SSO** | Single Sign-On -- один вход во все сервисы | Браслет в аквапарке: купил один билет, получил браслет, показываешь его на каждой горке |
| **SLO** | Single Logout -- выход из всех сервисов разом | Сдал браслет на выходе -- все горки закрыты для тебя |
| **IdP** | Identity Provider -- сервер, подтверждающий личность | Паспортный стол: единственное место, которому все доверяют |
| **SP** | Service Provider -- сервис, принимающий подтверждение | Аэропорт: не выдаёт паспорта, но проверяет их |
| **Assertion** | Утверждение IdP о пользователе (XML-документ в SAML) | Справка с печатью: "Этот человек -- Иванов, инженер, отдел R&D" |
| **SAML** | Security Assertion Markup Language -- XML-протокол SSO | Язык, на котором написана справка -- формальный, со штампами |
| **Kerberos** | Протокол сетевой аутентификации (MIT, 1988) | Система пропусков в закрытом городке: центральная проходная выдаёт пропуска |
| **KDC** | Key Distribution Center -- центр выдачи билетов Kerberos | Центральная проходная: знает всех жителей и все здания |
| **TGT** | Ticket-Granting Ticket -- "билет для получения билетов" | Удостоверение личности: с ним можно получить пропуск в любое здание |
| **Service Ticket** | Билет доступа к конкретному сервису | Пропуск в конкретное здание: открывает одну дверь |
| **LDAP** | Lightweight Directory Access Protocol -- протокол каталога | Телефонный справочник компании: ФИО, отдел, должность, телефон |
| **DN** | Distinguished Name -- уникальный путь записи в LDAP | Полный адрес: "Алиса Смит, отдел Разработки, компания Acme" |
| **Federation** | Доверие между организациями для взаимной аутентификации | Шенгенская зона: виза одной страны принимается в 27 других |
| **Trust Relationship** | Установленное доверие между IdP и SP | Договор между странами о взаимном признании паспортов |
| **Metadata** | XML-документ с настройками IdP/SP (сертификаты, URL) | Визитная карточка организации: адрес, телефон, печать |

---

## Prerequisites

| Тема | Зачем нужна | Ссылка |
|------|-------------|--------|
| OAuth 2.0 и OIDC | OIDC -- современная альтернатива SAML, сравнение протоколов | [[auth-oauth2-oidc]] |
| AuthN vs AuthZ | Базовые понятия: identity, access control, сессии, токены | [[authentication-authorization]] |
| HTTP и TLS | Redirect, POST, cookies, шифрование канала | Общие знания |
| Криптография | Цифровые подписи, сертификаты X.509, симметричное шифрование | [[security-cryptography-fundamentals]] |

---

## Историческая справка: от Kerberos до Passkeys в корпорациях

История enterprise-аутентификации -- это история масштабирования доверия. Каждый протокол появлялся как ответ на конкретную инфраструктурную проблему своей эпохи.

**1988 -- Kerberos (MIT Project Athena).** В MIT тысячи студентов и преподавателей использовали общие рабочие станции. Нужен был способ аутентифицировать пользователя один раз и давать доступ к файловым серверам, принтерам и email без повторного ввода пароля. Результат -- Kerberos, названный в честь Цербера (трёхголовый пёс, охраняющий вход в Аид) за три компонента протокола: клиент, сервер, KDC. Принципиальное решение: пароль никогда не передаётся по сети.

**1993 -- LDAP (RFC 1487).** X.500 Directory Service (стандарт ITU-T) был мощным, но невероятно сложным -- требовал полного OSI-стека. LDAP создали как "лёгкую" альтернативу, работающую поверх TCP/IP. Задача: единый каталог сотрудников, групп и ресурсов. Идея дерева DN (`cn=Alice,ou=Engineering,dc=company,dc=com`) оказалась настолько удачной, что живёт без изменений более 30 лет.

**2000 -- Active Directory (Windows 2000).** Microsoft объединил Kerberos и LDAP в единый продукт. Domain Controller стал одновременно KDC (Kerberos) и LDAP-сервером. Это превратило Windows-сети в полноценные SSO-инфраструктуры: залогинился на рабочей станции -- получил доступ ко всем ресурсам домена.

**2002 -- SAML 1.0 (OASIS).** Kerberos работал прекрасно внутри локальной сети, но интернет всё изменил. Компании начали использовать SaaS-приложения (Salesforce появился в 1999), и нужен был способ передавать identity через браузер между организациями. SAML решил эту задачу: XML-документ с утверждением "этот пользователь аутентифицирован", подписанный IdP и переданный через browser redirect.

**2005 -- SAML 2.0.** Объединение SAML 1.1, Liberty Alliance ID-FF и Shibboleth. Стал стандартом де-факто для enterprise SSO и остаётся им по сей день. По данным Okta (2025), более 80% enterprise SSO-интеграций используют SAML 2.0.

**2014 -- OpenID Connect.** Современная альтернатива SAML на базе OAuth 2.0. JSON вместо XML, JWT вместо XML Assertion, REST вместо SOAP. Активно вытесняет SAML в новых интеграциях, но enterprise legacy -- мощная инерция.

**2020-е -- SCIM и Passkeys.** SCIM (System for Cross-domain Identity Management) решает проблему provisioning: автоматическое создание и удаление аккаунтов. Passkeys в корпоративном контексте: FIDO2 security keys как phishing-resistant альтернатива паролю для SSO.

---

## Что такое SSO и как оно работает

Single Sign-On -- это архитектурный паттерн, при котором пользователь аутентифицируется один раз и получает доступ к множеству сервисов без повторного ввода учётных данных. Ключевое слово здесь -- "паттерн", а не протокол. SSO можно реализовать через SAML, OIDC, Kerberos или даже через shared cookies в одном домене. Протокол -- это способ реализации; SSO -- это цель.

**Аналогия: браслет в аквапарке.** Вы приходите в аквапарк, покупаете билет на кассе (аутентификация), и получаете водонепроницаемый браслет (token/assertion). На каждой горке контролёр проверяет браслет, а не просит покупать новый билет. Касса -- это IdP, горки -- это SP, браслет -- это SAML Assertion или Kerberos TGT. Если вы потеряли браслет, нужно вернуться на кассу. Если касса закрылась -- ни одна горка не работает (Single Point of Failure).

На высоком уровне SSO работает по одной схеме независимо от протокола:

```
┌──────────────────────────────────────────────────────────────┐
│                       SSO: общая схема                       │
│                                                              │
│  Пользователь ──> Сервис A (SP)                              │
│       |              |                                       │
│       |         "Не знаю тебя,                               │
│       |          спроси у IdP"                               │
│       |              |                                       │
│       v              v                                       │
│  Identity Provider (IdP)                                     │
│       |                                                      │
│  "Введи логин/пароль"                                        │
│  (только если ещё не залогинен)                              │
│       |                                                      │
│       v                                                      │
│  IdP выдаёт Assertion/Token                                  │
│       |                                                      │
│       |──> Сервис A: "Добро пожаловать!"                     │
│       |──> Сервис B: "Добро пожаловать!" (без пароля!)       │
│       |──> Сервис C: "Добро пожаловать!" (без пароля!)       │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

Принципиальный момент: после первой аутентификации IdP запоминает сессию пользователя (обычно через cookie на домене IdP). Когда пользователь переходит к Сервису B, SP перенаправляет его к IdP, IdP видит активную сессию и сразу выдаёт assertion без повторного запроса пароля. Для пользователя это выглядит как мгновенный вход.

SSO даёт три критических преимущества для enterprise. Во-первых, снижение password fatigue -- сотрудники помнят один пароль вместо двадцати, что уменьшает обращения в help desk на 30-50% (по данным Gartner). Во-вторых, централизованный контроль -- при увольнении сотрудника достаточно деактивировать его в IdP, и все сервисы становятся недоступны мгновенно. В-третьих, единая точка enforcement: MFA, conditional access, гео-фенсинг настраиваются в одном месте, а не в пятидесяти.

Но SSO создаёт и серьёзную проблему: Single Point of Failure. Если IdP скомпрометирован, атакующий получает доступ ко всем сервисам. Если IdP недоступен -- никто не может войти никуда. Именно поэтому IdP -- самый защищённый и отказоустойчивый компонент инфраструктуры.

---

## SAML 2.0: Security Assertion Markup Language

SAML -- доминирующий протокол enterprise SSO. Несмотря на возраст (20 лет), он остаётся стандартом для интеграции корпоративных приложений с identity-провайдерами. Причина живучести -- зрелость экосистемы: тысячи enterprise-приложений "из коробки" поддерживают SAML. SAML -- это не способ аутентификации сам по себе, а протокол передачи результатов аутентификации от IdP к SP.

### Архитектура: три роли

SAML определяет три роли. **Principal** -- пользователь, который хочет получить доступ. **Identity Provider (IdP)** -- сервис, хранящий учётные данные и выдающий assertions (Okta, Azure Entra ID, Keycloak). **Service Provider (SP)** -- приложение, принимающее assertions (Salesforce, Jira, Slack).

Доверие между IdP и SP устанавливается заранее через обмен **метаданными** -- XML-документами, содержащими сертификаты, URL endpoints и поддерживаемые bindings. Без этого предварительного обмена SSO не работает. Это как обмен дипломатическими верительными грамотами: прежде чем посольство заработает, страны должны обменяться документами и признать друг друга.

### Структура SAML Assertion

SAML Assertion -- это XML-документ, который IdP подписывает своим закрытым ключом. Он содержит три типа утверждений. **Authentication Statement**: "пользователь X аутентифицирован в момент T методом M" (например, паролем + MFA). **Attribute Statement**: "пользователь X имеет email Y, принадлежит группе Z, его роль -- admin". **Authorization Decision Statement**: "пользователь X имеет право выполнить действие A на ресурсе R" (используется крайне редко).

На практике SP интересуют первые два типа. Authentication Statement подтверждает, что пользователь "настоящий". Attribute Statement предоставляет данные для авторизации: email для создания аккаунта, группы для назначения ролей. Authorization Decision Statement почти никогда не встречается в реальных реализациях -- авторизация обычно происходит на стороне SP на основе атрибутов.

Ниже -- минимальная структура SAML Response, показывающая ключевые элементы. Обратите внимание на привязку к конкретному запросу и ограничение по времени.

```xml
<samlp:Response ID="_resp123" InResponseTo="_req456">
  <saml:Assertion ID="_assert789">
    <!-- Кто выдал assertion и когда -->
    <saml:Issuer>https://idp.company.com</saml:Issuer>
    <ds:Signature><!-- XML Digital Signature --></ds:Signature>
    <!-- Условия: для кого, до какого момента -->
    <saml:Conditions NotBefore="2026-02-11T10:00:00Z"
                     NotOnOrAfter="2026-02-11T10:05:00Z">
      <saml:AudienceRestriction>
        <saml:Audience>https://app.example.com</saml:Audience>
      </saml:AudienceRestriction>
    </saml:Conditions>
    <!-- Факт аутентификации и метод -->
    <saml:AuthnStatement AuthnInstant="2026-02-11T10:00:00Z">
      <saml:AuthnContext>
        <saml:AuthnContextClassRef>
          urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport
        </saml:AuthnContextClassRef>
      </saml:AuthnContext>
    </saml:AuthnStatement>
  </saml:Assertion>
</samlp:Response>
```

В этом примере `InResponseTo` привязывает ответ к конкретному запросу (защита от replay), `NotOnOrAfter` ограничивает время жизни (5 минут -- типичное значение), `AudienceRestriction` гарантирует, что assertion предназначен конкретному SP. XML Digital Signature покрывает всё содержимое assertion -- любое изменение инвалидирует подпись.

### SP-Initiated Flow: самый распространённый сценарий

В 90% случаев пользователь начинает с обращения к SP (открывает Salesforce, Jira, внутренний портал). Это называется SP-Initiated Flow. Разберём каждый шаг детально.

```
┌──────────────────────────────────────────────────────────────────┐
│                   SAML SP-INITIATED FLOW                         │
│                                                                  │
│  ┌──────┐          ┌──────────┐          ┌──────────┐           │
│  │ User │          │    SP    │          │   IdP    │           │
│  │      │          │(Salesforce)         │ (Okta)   │           │
│  └──┬───┘          └────┬─────┘          └────┬─────┘           │
│     │  1. GET /dashboard     │                │                 │
│     │───────────────────────>│                │                 │
│     │                        │                │                 │
│     │  2. 302 Redirect       │                │                 │
│     │<───────────────────────│                │                 │
│     │  + AuthnRequest (XML)  │                │                 │
│     │                        │                │                 │
│     │  3. GET /sso + AuthnRequest             │                 │
│     │────────────────────────────────────────>│                 │
│     │                        │                │                 │
│     │  4. Форма логина (если нет сессии)      │                 │
│     │<────────────────────────────────────────│                 │
│     │                        │                │                 │
│     │  5. POST login + password + MFA         │                 │
│     │────────────────────────────────────────>│                 │
│     │                        │                │                 │
│     │  6. HTML auto-submit form               │                 │
│     │     с SAMLResponse     │                │                 │
│     │<────────────────────────────────────────│                 │
│     │                        │                │                 │
│     │  7. POST /acs + SAMLResponse            │                 │
│     │───────────────────────>│  8. Валидация  │                 │
│     │                        │  подписи,      │                 │
│     │                        │  атрибутов     │                 │
│     │  9. 200 OK /dashboard  │                │                 │
│     │<───────────────────────│                │                 │
│     │                        │                │                 │
└──────────────────────────────────────────────────────────────────┘
```

**Шаги 1-2:** Пользователь открывает Salesforce. SP не знает, кто он, и генерирует AuthnRequest -- XML-документ с идентификатором запроса, URL для ответа (ACS URL) и информацией о себе. SP перенаправляет браузер на IdP, приложив AuthnRequest в URL (HTTP-Redirect binding): XML кодируется в Base64, сжимается Deflate-алгоритмом и добавляется как query parameter.

**Шаги 3-5:** Браузер попадает на IdP (Okta). Если у пользователя нет активной сессии на IdP, он видит форму логина. Вводит пароль, проходит MFA. Если сессия уже есть (пользователь ранее залогинился через другой SP) -- IdP пропускает этот шаг. Это и есть момент Single Sign-On: повторный ввод пароля не требуется.

**Шаги 6-7:** IdP создаёт SAML Response с Assertion, подписывает его закрытым ключом, и возвращает браузеру HTML-страницу с автоматически отправляемой формой (HTTP-POST binding). Почему не redirect? Потому что SAML Response слишком большой для URL -- XML с подписью и атрибутами может занимать десятки килобайт. Браузер POST-ом отправляет Response на ACS (Assertion Consumer Service) URL -- заранее зарегистрированный endpoint SP.

**Шаги 8-9:** SP валидирует XML-подпись с помощью публичного ключа IdP (из метаданных), проверяет `NotBefore`/`NotOnOrAfter`, `AudienceRestriction`, `InResponseTo`. Если всё корректно -- создаёт локальную сессию и показывает dashboard.

### IdP-Initiated Flow

В этом сценарии пользователь начинает с портала IdP (Okta Dashboard, Azure MyApps). Нажимает иконку приложения -- IdP сразу отправляет SAML Response на ACS URL SP без предварительного AuthnRequest. Разница с SP-Initiated: нет `InResponseTo` для валидации. Это делает flow менее безопасным -- SP не может привязать response к конкретному запросу и проверить state.

Тем не менее, IdP-Initiated Flow широко используется в корпоративных порталах, потому что он удобен: сотрудник открывает Okta Dashboard, видит плитки всех доступных приложений, кликает -- и попадает сразу в нужный сервис.

### Подпись и шифрование Assertions

Assertion **подписывается** закрытым ключом IdP. SP **верифицирует** подпись публичным ключом IdP (полученным через метаданные). Подпись обязательна -- без неё SP не может доверять содержимому assertion. Опционально assertion может быть зашифрован публичным ключом SP, чтобы обеспечить конфиденциальность (например, если assertion содержит sensitive-атрибуты вроде SSN или медицинских данных).

На практике шифрование используется реже, чем подпись, потому что транспорт уже защищён TLS. Но для regulated industries (здравоохранение, финансы) шифрование assertion -- часть compliance-требований. Важно понимать: подпись защищает целостность (никто не изменил assertion), шифрование защищает конфиденциальность (никто не прочитал assertion).

### SAML Bindings: способы передачи сообщений

Bindings определяют, как SAML-сообщения передаются по HTTP. **HTTP-Redirect** -- AuthnRequest кодируется в Base64, сжимается Deflate и передаётся как query parameter в URL. Подходит для небольших сообщений (AuthnRequest), но не для Response (ограничение длины URL ~8 KB). **HTTP-POST** -- сообщение передаётся в теле POST-запроса через auto-submitting HTML-форму. Используется для SAML Response, который слишком большой для URL. **SOAP (Artifact)** -- server-to-server коммуникация: SP получает artifact (короткую ссылку), и по back-channel запрашивает полный Response у IdP. Самый безопасный (assertion не проходит через браузер), но и самый сложный в реализации.

---

## Kerberos: протокол сетевой аутентификации

Kerberos решает задачу, с которой SAML не справляется: аутентификация внутри локальной сети без передачи пароля по каналу связи. В мире SAML пароль вводится на странице IdP (хотя и по TLS). В мире Kerberos пароль вообще не покидает клиентскую машину -- вместо него используется криптографическое доказательство знания пароля через symmetric key derivation.

### Три участника: "три головы Цербера"

Протокол назван в честь Цербера -- трёхголового пса из греческой мифологии, охраняющего вход в царство Аида. Три "головы" протокола: **Client** (пользователь), **KDC** (Key Distribution Center), **Service** (целевой сервер). KDC состоит из двух логических компонентов: **Authentication Server (AS)** -- проверяет начальную аутентификацию, и **Ticket-Granting Server (TGS)** -- выдаёт билеты к конкретным сервисам.

**Аналогия: доверенная курьерская служба.** Представьте город, где все здания закрыты и охраняются. Чтобы попасть в любое здание, нужно обратиться в центральное бюро пропусков (KDC). Шаг 1: вы приходите в бюро и доказываете свою личность, показывая паспорт (AS-REQ). Шаг 2: бюро выдаёт вам "общий пропуск" (TGT), действующий 8-10 часов -- целый рабочий день. Шаг 3: с общим пропуском вы идёте в другое окно бюро (TGS) и просите пропуск в конкретное здание. Шаг 4: получаете "пропуск в здание X" (Service Ticket), который запечатан так, что прочитать его может только охрана здания X. Вы не можете подделать или изменить пропуск -- вы просто передаёте его как есть.

### Kerberos Flow: шаг за шагом

```
┌──────────┐       ┌──────────────────────┐       ┌──────────┐
│  Client  │       │         KDC          │       │  Service │
│ (Алиса)  │       │  ┌─────┐  ┌─────┐   │       │(Файловый │
│          │       │  │ AS  │  │ TGS │   │       │ сервер)  │
└────┬─────┘       │  └──┬──┘  └──┬──┘   │       └────┬─────┘
     │              │     │       │       │            │
     │ 1. AS-REQ:   │     │       │       │            │
     │ "Я Алиса"    │     │       │       │            │
     │ + timestamp   │     │       │       │            │
     │──────────────────> │       │       │            │
     │              │     │       │       │            │
     │ 2. AS-REP:   │     │       │       │            │
     │ TGT + session │     │       │       │            │
     │ key (для TGS) │     │       │       │            │
     │<────────────────── │       │       │            │
     │              │     │       │       │            │
     │ [Расшифровывает    │       │       │            │
     │  session key своим │       │       │            │
     │  паролем]    │     │       │       │            │
     │              │     │       │       │            │
     │ 3. TGS-REQ:  │     │       │       │            │
     │ TGT + "дай билет   │       │       │            │
     │ к файловому серверу"│       │       │            │
     │───────────────────────────> │       │            │
     │              │     │       │       │            │
     │ 4. TGS-REP:  │     │       │       │            │
     │ Service Ticket│     │       │       │            │
     │ + session key │     │       │       │            │
     │<──────────────────────────  │       │            │
     │              │     │       │       │            │
     │ 5. AP-REQ: Service Ticket                       │
     │────────────────────────────────────────────>    │
     │              │     │       │       │  Расшифро-  │
     │              │     │       │       │  вывает     │
     │ 6. AP-REP: подтверждение (mutual auth)          │
     │<────────────────────────────────────────────    │
     │              │     │       │       │            │
```

**Шаг 1 (AS-REQ):** Алиса отправляет AS своё имя и зашифрованный timestamp (pre-authentication). Пароль не передаётся! Timestamp зашифрован ключом, производным от пароля Алисы. Это защита от offline brute-force: без правильного ключа KDC не ответит.

**Шаг 2 (AS-REP):** AS находит Алису в базе, проверяет pre-auth (расшифровывает timestamp ключом Алисы из базы). Если timestamp корректен -- генерирует TGT (зашифрован ключом `krbtgt`, который знает только KDC) и session key (зашифрован ключом Алисы). Только Алиса может расшифровать session key. TGT она расшифровать не может -- просто хранит его.

**Шаг 3 (TGS-REQ):** Алиса хочет доступ к файловому серверу. Она отправляет TGT и authenticator (timestamp, зашифрованный session key) в TGS. Authenticator доказывает, что запрос от того же пользователя, которому выдан TGT -- session key знает только Алиса и KDC.

**Шаг 4 (TGS-REP):** TGS расшифровывает TGT ключом `krbtgt`, извлекает session key, проверяет authenticator. Если всё верно -- генерирует Service Ticket, зашифрованный ключом файлового сервера, и новый session key для коммуникации с сервером.

**Шаг 5 (AP-REQ):** Алиса предъявляет Service Ticket файловому серверу. Сервер расшифровывает его своим ключом и видит: "KDC подтверждает, что это Алиса, аутентификация произошла в 10:05".

**Шаг 6 (AP-REP, mutual authentication):** Сервер возвращает ответ, зашифрованный session key. Только легитимный сервер знает этот ключ (он был внутри Service Ticket). Это доказывает Алисе, что она общается с настоящим файловым сервером, а не с подставным.

Обратите внимание: пароль Алисы использовался только на шаге 1 для шифрования timestamp. Он никогда не передавался по сети. Это фундаментальное свойство Kerberos.

### Active Directory и Kerberos

В Windows-мире Kerberos -- протокол аутентификации по умолчанию с Windows 2000. Domain Controller выполняет роль KDC. Когда сотрудник логинится в Windows (Ctrl+Alt+Del, ввод пароля), машина получает TGT от Domain Controller. Далее при обращении к любому ресурсу домена -- файловому серверу, принтеру, SharePoint, Exchange -- автоматически запрашивается Service Ticket. Пользователь ничего не замечает.

Это и есть "настоящий" SSO -- бесшовный, невидимый, без redirects и XML. Пользователь один раз ввёл пароль при включении компьютера, и весь рабочий день обращается к десяткам сервисов без повторной аутентификации. Service Principal Names (SPN) в AD связывают сервисы с учётными записями: `HTTP/intranet.corp.com@CORP.COM` указывает, что HTTP-сервис на `intranet.corp.com` принадлежит конкретной AD-записи.

### Ограничения Kerberos

Несмотря на элегантность, у Kerberos есть существенные ограничения. **Синхронизация часов:** билеты содержат timestamps, допустимое расхождение -- обычно 5 минут. Если часы клиента и KDC разошлись -- аутентификация провалится с cryptic error message. NTP обязателен для всех машин в домене.

**Single Point of Failure:** KDC недоступен -- вся аутентификация останавливается. Решается репликацией: в AD несколько Domain Controllers, каждый является KDC. Но репликация вносит свои проблемы (consistency, split-brain).

**Не для интернета:** Kerberos спроектирован для LAN, где клиент и KDC находятся в одной сети. Через интернет работает плохо -- нужен VPN или SPNego/Negotiate. Для веб-приложений за пределами корпоративной сети используют SAML или OIDC.

**Delegation complexity:** передача прав от сервиса к сервису (когда веб-сервер обращается к базе данных от имени пользователя) реализуется через constrained или unconstrained delegation. Unconstrained delegation -- серьёзная уязвимость: скомпрометированный сервер может представиться любым пользователем к любому сервису.

---

## LDAP: Lightweight Directory Access Protocol

LDAP -- это не протокол аутентификации. Это протокол доступа к директории -- специализированной базе данных, оптимизированной для чтения и организованной как дерево. Но поскольку в директории хранятся учётные записи, LDAP стал неотъемлемой частью enterprise-аутентификации: IdP хранят пользователей в LDAP, VPN проверяет credentials через LDAP, WiFi-контроллеры аутентифицируют через RADIUS + LDAP.

### Структура LDAP-директории

LDAP организует данные как дерево (Directory Information Tree -- DIT). Каждый узел имеет Distinguished Name (DN) -- уникальный путь от корня дерева к записи.

**Аналогия: бумажный справочник компании.** Представьте большую организацию с тысячей сотрудников. Справочник организован по отделам: на верхнем уровне -- название компании, затем отделы (Engineering, Marketing, HR), внутри отделов -- сотрудники. DN сотрудника Алисы: `cn=Alice Smith,ou=Engineering,dc=company,dc=com`. Это как полный адрес: "Алиса Смит, отдел Разработки, компания Company.com". Вы можете искать по отделу (`ou=Engineering`), по имени (`cn=Alice*`), или по любому атрибуту (email, телефон, должность).

```
┌───────────────────────────────────────────────────────────┐
│               LDAP Directory Information Tree              │
│                                                           │
│                    dc=corp,dc=com                          │
│                    /            \                          │
│              ou=People        ou=Groups                    │
│             /    |    \          |    \                    │
│         cn=Alice cn=Bob cn=Carol cn=devs cn=admins        │
│                                                           │
│  DN для Alice:                                            │
│  cn=Alice Smith,ou=People,dc=corp,dc=com                  │
│                                                           │
│  Атрибуты Alice:                                          │
│  +-- cn: Alice Smith          (common name)               │
│  +-- sn: Smith                (surname)                   │
│  +-- mail: alice@corp.com                                 │
│  +-- uid: asmith                                          │
│  +-- userPassword: {SSHA}...  (хешированный)              │
│  +-- memberOf: cn=devs,ou=Groups,dc=corp,dc=com           │
│  +-- objectClass: inetOrgPerson                           │
└───────────────────────────────────────────────────────────┘
```

**dc** (domain component) -- компоненты доменного имени. `dc=corp,dc=com` соответствует `corp.com`. **ou** (organizational unit) -- подразделение. **cn** (common name) -- имя записи. DN читается справа налево: "Alice Smith в подразделении People домена corp.com". LDAP-записи определяются через **objectClass** -- схему, задающую набор обязательных и опциональных атрибутов. Например, `objectClass: inetOrgPerson` требует `cn` и `sn` (surname), и разрешает `mail`, `telephoneNumber`, `title`.

### LDAP Bind: аутентификация через LDAP

"Bind" -- это операция подключения к LDAP-серверу с учётными данными. Simple bind: клиент отправляет DN и пароль. Если LDAP-сервер принимает bind -- аутентификация успешна. Важный момент: пользователь обычно не знает свой DN (он вводит email или username), поэтому типичная аутентификация двухэтапная.

Ниже -- минимальный пример LDAP-аутентификации, показывающий двухэтапный процесс: сначала поиск DN, затем bind с паролем пользователя.

```python
import ldap3

# Шаг 1: bind под сервисным аккаунтом для поиска DN
server = ldap3.Server('ldaps://ldap.company.com', use_ssl=True)
svc = ldap3.Connection(server,
    user='cn=svc-auth,ou=Services,dc=company,dc=com',
    password='service_password')
svc.bind()

# Шаг 2: поиск DN пользователя по email
svc.search('dc=company,dc=com',
    '(mail=alice@company.com)', attributes=['cn', 'memberOf'])
user_dn = svc.entries[0].entry_dn

# Шаг 3: re-bind найденным DN — проверка пароля пользователя
user_conn = ldap3.Connection(server, user=user_dn, password='user_pwd')
if user_conn.bind():  # Успешный bind = пароль верный
    groups = svc.entries[0].memberOf  # Группы для авторизации
```

Критическое правило безопасности: всегда использовать LDAPS (LDAP over TLS, порт 636) или StartTLS. Plain LDAP (порт 389) передаёт пароль открытым текстом -- в 2026 году это грубая ошибка, которая гарантированно провалит security audit.

### LDAP vs Active Directory

Частый вопрос: "LDAP и Active Directory -- это одно и то же?". Нет. Active Directory использует LDAP как один из протоколов доступа наряду с Kerberos, DNS, NTLM и Group Policy. AD добавляет поверх LDAP: Kerberos-аутентификацию, групповые политики (GPO), репликацию между Domain Controllers, интеграцию с DNS. LDAP -- это протокол, Active Directory -- это продукт, который этот протокол использует. В Linux-мире чистый LDAP (OpenLDAP, 389 Directory Server) используется отдельно, без экосистемы AD.

---

## Федерация: доверие между организациями

Федерация расширяет SSO за пределы одной организации. Если SSO -- это "один логин для всех сервисов моей компании", то федерация -- "один логин для сервисов разных компаний, которые доверяют друг другу".

**Аналогия: Шенгенская зона.** 27 стран Евросоюза договорились признавать визы друг друга. Если у вас виза Германии -- вы можете пройти паспортный контроль во Франции, не получая отдельную французскую визу. Каждая страна (IdP) выдаёт свои визы (assertions), и все остальные страны (SP) их принимают. Для этого нужно предварительное соглашение (Trust Relationship) и обмен образцами виз и печатей (Metadata exchange).

### SAML Federation

В SAML-федерации несколько организаций обмениваются метаданными. Есть две топологии. **Hub-and-spoke:** центральный федеративный хаб (например, InCommon для университетов США) хранит метаданные всех участников. Каждый IdP и SP регистрируется в хабе, хаб распространяет агрегированные метаданные. Это масштабируется до тысяч участников. **Mesh:** каждая пара IdP-SP обменивается метаданными напрямую. Проще для малого числа участников, но количество связей растёт как O(n^2).

Реальные примеры федерации: **eduroam** -- студент одного университета подключается к Wi-Fi другого университета, используя учётные данные своего вуза. **InCommon** -- более 1200 участников в США. **Login.gov** -- единая аутентификация для государственных сервисов США. **B2B-партнёрства:** компания A интегрирует свой портал с IdP компании B, чтобы сотрудники B могли работать в системах A без создания отдельных аккаунтов.

### OIDC Federation

Более современный подход использует OpenID Connect Discovery и Dynamic Client Registration. Вместо XML-метаданных -- JSON-документы, доступные по стандартным URL (`/.well-known/openid-configuration`). Вместо предварительного обмена сертификатами -- автоматическое обнаружение. Стандарт OpenID Connect Federation (2023) формализует цепочки доверия через Federation Entities. Пока уступает SAML Federation по распространённости в образовании и госсекторе, но активно растёт в коммерческом B2B.

---

## Identity Providers: сравнение

| Провайдер | Тип | Протоколы SSO | Стоимость | Лучше для |
|-----------|-----|---------------|-----------|-----------|
| **Okta** | SaaS | SAML, OIDC, WS-Fed | $$$ | Enterprise, compliance, 7000+ интеграций |
| **Auth0** (Okta) | SaaS/PaaS | OIDC, SAML | $$ | Разработчики, B2C + B2B гибрид |
| **Keycloak** | Open-source | SAML, OIDC | Free (self-hosted) | Полный контроль, кастомизация |
| **Azure Entra ID** | SaaS | SAML, OIDC, WS-Fed | $$ (с M365) | Microsoft-экосистема |
| **Google Workspace** | SaaS | SAML, OIDC | $ (с Workspace) | Google-экосистема |
| **Ping Identity** | SaaS/On-prem | SAML, OIDC | $$$ | Гибридный enterprise, финансы |

Выбор IdP определяется несколькими факторами: существующая инфраструктура (Azure Entra ID -- естественный выбор для Microsoft-магазинов), требования compliance (SOC 2, FedRAMP), бюджет (Keycloak бесплатен, но требует эксплуатации) и количество готовых интеграций (Okta лидирует с 7000+ pre-built connectors).

---

## SAML vs OIDC: детальное сравнение

| Критерий | SAML 2.0 | OIDC |
|----------|----------|------|
| **Формат данных** | XML | JSON |
| **Транспорт** | HTTP-Redirect, HTTP-POST, SOAP | HTTP REST |
| **Формат токена** | XML Assertion | JWT (ID Token) |
| **Подпись** | XML Signature (XMLDsig) | JWS (JSON Web Signature) |
| **Мобильная поддержка** | Слабая (тяжёлый XML, большие payload) | Отличная (компактный JSON/JWT) |
| **Сложность** | Высокая (XML namespaces, canonicalization) | Средняя |
| **Зрелость** | 20+ лет в enterprise | 10+ лет, активно растёт |
| **Типичные use cases** | Enterprise legacy, госсектор | Современный web/mobile, B2C |
| **Экосистема библиотек** | Ограничена, часто устаревшая | Богатая, активно поддерживается |
| **Discovery** | Обмен метаданными вручную (XML) | `.well-known` endpoints (JSON) |

Главная разница -- в "весе" протокола. SAML несёт наследие XML-эры: namespaces, canonicalization (C14N), Enveloped Signatures. Одна ошибка в canonicalization -- и подпись невалидна. Отладка SAML-проблем требует глубокого понимания XML-стека. OIDC, построенный на JSON и JWT, значительно проще для разработчиков и инструментов.

На практике IdP (Okta, Entra ID) поддерживают оба протокола одновременно. Одно приложение может использовать SAML, другое -- OIDC, и оба работают через один IdP. Это позволяет постепенно мигрировать с SAML на OIDC без big-bang перехода.

---

## Дерево принятия решений

```
Какой SSO-протокол выбрать?

Есть legacy-системы с SAML?
+-- ДА --> Сохранить SAML, добавлять OIDC постепенно
+-- НЕТ --> Greenfield-проект?
    +-- ДА --> OIDC (современный, проще, лучше для mobile)
    +-- НЕТ --> Нужна интеграция с Windows AD?
        +-- ДА --> Kerberos (внутренняя сеть)
        |          + SAML/OIDC (внешние приложения)
        +-- НЕТ --> OIDC
```

Ключевой инсайт: выбор определяется не "что лучше", а "что уже есть у клиента и какой сценарий". Enterprise-продукт, претендующий на серьёзный рынок, обычно должен поддерживать и SAML, и OIDC.

---

## Типичные уязвимости и ошибки

**SAML Replay Attack.** Атакующий перехватывает SAML Response и отправляет его повторно. Защита: проверка `InResponseTo` (привязка к конкретному AuthnRequest), хранение использованных assertion ID (one-time use enforcement), жёсткий `NotOnOrAfter` (5 минут или меньше).

**Clock Skew.** SAML assertions содержат `NotBefore` и `NotOnOrAfter`. Если часы SP и IdP расходятся более чем на допустимый skew (обычно 2-3 минуты) -- все assertions будут отклонены. Решение: NTP-синхронизация на всех серверах. В Kerberos проблема ещё критичнее -- допуск по умолчанию 5 минут.

**Certificate Rotation.** IdP-сертификаты имеют срок действия (обычно 1-3 года). Когда сертификат истекает -- все SP перестают валидировать assertions. Это не "потом когда-нибудь" -- это "в ночь истечения тысячи людей не могут работать". Ротация должна быть запланирована: сначала IdP публикует новый сертификат в метаданных (оба сертификата активны), затем SP обновляют метаданные, затем старый сертификат удаляется.

**XML Signature Wrapping.** Класс атак, специфичный для SAML. Атакующий модифицирует структуру XML-документа так, что подпись по-прежнему валидна (покрывает оригинальный элемент), но SP обрабатывает модифицированный элемент. Причина: XPath для подписанного элемента и XPath для обработки могут указывать на разные узлы. Десятки CVE связаны с этой атакой. Защита: строгая валидация структуры XML, использование проверенных SAML-библиотек, запрет DTD и external entities.

**Kerberos Golden Ticket.** Если атакующий получает хеш учётной записи `krbtgt` (из Active Directory) -- он может генерировать TGT для любого пользователя с любыми привилегиями, включая несуществующих пользователей. Это полная компрометация домена. Защита: регулярная ротация пароля `krbtgt` (дважды -- у аккаунта два слота ключей), мониторинг аномальных TGT через решения типа Microsoft Defender for Identity.

**Single Logout (SLO).** Когда пользователь нажимает "Выйти" в одном SP -- должен ли он выйти из всех? SAML SLO пытается уведомить все SP, но если один SP недоступен в момент logout -- сессия остаётся активной. На практике полноценный global logout -- нерешённая проблема. Многие организации вместо SLO используют короткие session timeouts.

---

## SCIM: автоматическое управление пользователями

SCIM (System for Cross-domain Identity Management) решает задачу, которую SSO не покрывает: provisioning и deprovisioning. SSO отвечает на вопрос "как пользователю войти?", а SCIM -- "как создать и удалить аккаунт пользователя во всех сервисах?".

Когда HR нанимает нового сотрудника и добавляет его в IdP, SCIM автоматически создаёт аккаунты во всех подключённых SP (Slack, Jira, GitHub Enterprise, AWS). Когда сотрудник увольняется -- SCIM деактивирует все аккаунты. Без SCIM администратор вручную заходит в каждый из 50 сервисов и создаёт/удаляет аккаунты -- процесс, который занимает часы и неизбежно содержит ошибки.

SCIM -- это REST API для CRUD-операций над пользователями и группами, стандартизированный через RFC 7643 (Core Schema) и RFC 7644 (Protocol). IdP (Okta, Azure Entra ID) выступает как SCIM client, а SP (Slack, Jira) -- как SCIM server. Связка SSO + SCIM обеспечивает полный lifecycle management: создание аккаунта (SCIM) -> аутентификация (SSO) -> деактивация (SCIM).

---

## Распространённые заблуждения

> "SSO означает меньше безопасности -- одна точка входа = одна точка взлома"

Наоборот. SSO **повышает** безопасность: одна точка аутентификации означает одно место для MFA, одно место для мониторинга, одно место для enforcement политик. Без SSO каждый из 50 сервисов имеет свой логин, часто со слабым паролем и без MFA. С SSO -- один сильный пароль + MFA на IdP защищает все 50 сервисов. Это как разница между 50 дешёвыми замками и одним банковским сейфом.

> "SAML устарел, нужно срочно мигрировать на OIDC"

SAML 2.0 не устарел. Он зрел, стабилен и поддерживается всеми enterprise IdP. По данным Okta (2025), более 80% enterprise SSO-интеграций работают на SAML. Миграция с SAML на OIDC без бизнес-причины -- пустая трата ресурсов. Для новых интеграций OIDC предпочтительнее, но существующие SAML-интеграции работают надёжно и покрываются compliance-стандартами.

> "Kerberos -- это только для Windows"

Kerberos -- открытый стандарт (RFC 4120). Linux и macOS полноценно поддерживают Kerberos. MIT Kerberos, Heimdal -- свободные реализации. Mac в доменной среде Active Directory использует Kerberos для SSO. Kerberos -- это не продукт Microsoft, а протокол MIT, который Microsoft интегрировал в Active Directory.

> "SSO устраняет проблему паролей"

SSO сокращает количество паролей до одного, но этот единственный пароль становится критически важным. Компрометация SSO-пароля открывает доступ ко всем сервисам. Поэтому enterprise SSO почти всегда сопровождается MFA, а в 2025-2026 годах -- переходом на phishing-resistant методы (FIDO2, passkeys). SSO не устраняет проблему паролей -- он концентрирует её в одной точке, где можно применить максимальную защиту.

---

## Когда НЕ применяется

**Маленькая команда (< 20 человек, < 5 сервисов).** Overhead от настройки SSO-инфраструктуры (IdP, метаданные, сертификаты, ротация) не оправдан. Google Workspace OAuth или GitHub OAuth -- достаточно.

**Consumer-facing приложения (B2C).** Обычные пользователи не имеют корпоративного IdP. Используйте social login (Google, Apple Sign-In) через OIDC, а не enterprise SAML. SAML спроектирован для корпоративных сценариев.

**Stateless API-to-API коммуникация.** Серверные сервисы аутентифицируются через OAuth 2.0 client credentials, API keys или mTLS -- не через SAML assertions. SAML спроектирован для browser-based flows с redirect-ами. Для machine-to-machine взаимодействия он не подходит ни архитектурно, ни практически.

---

## Связь с другими темами

- [[auth-oauth2-oidc]] -- OIDC как современная альтернатива SAML для SSO; OAuth 2.0 как фундамент OIDC. Текущий файл сравнивает SAML и OIDC, а детали OIDC -- в auth-oauth2-oidc
- [[authentication-authorization]] -- hub-статья: AuthN vs AuthZ, обзор всех методов аутентификации и авторизации. Рекомендуется как prerequisite
- [[auth-passwordless-mfa]] -- MFA в контексте enterprise SSO: FIDO2 security keys для корпоративной аутентификации, TOTP в связке с IdP
- [[auth-api-service-patterns]] -- паттерны аутентификации для API и сервисов, включая SSO tokens для API-доступа и machine-to-machine auth

---

## Источники и дальнейшее чтение

1. **Neuman, C. et al. (2005). RFC 4120: The Kerberos Network Authentication Service (V5).** Полная спецификация Kerberos от авторов протокола. Зачем читать: это каноническое описание каждого шага аутентификации, формата сообщений и криптографических операций. Разделы 1-3 дают архитектурное понимание, раздел 5 -- формат сообщений. Технически сложный документ, но единственный первоисточник.

2. **Garman, J. (2003). *Kerberos: The Definitive Guide.* O'Reilly Media.** Зачем читать: переводит RFC 4120 на "человеческий" язык. Подробно разбирает Active Directory интеграцию, cross-realm authentication и delegation. Несмотря на возраст, фундаментальные концепции не изменились -- протокол тот же. Единственная книга, полностью посвящённая Kerberos.

3. **Hughes, J. & Maler, E. (2005). SAML 2.0 Technical Overview. OASIS Committee Draft.** Зачем читать: официальный технический обзор SAML 2.0, написанный понятнее, чем полная спецификация (Assertions and Protocols for SAML V2.0). Объясняет flows, bindings и profiles с диаграммами. Лучший стартовый документ для понимания SAML.

4. **Howes, T., Smith, M. & Good, G. (2003). *Understanding and Deploying LDAP Directory Services.* Addison-Wesley.** Зачем читать: исчерпывающее руководство по LDAP от Tim Howes -- одного из создателей протокола. Покрывает schema design, replication, security, naming conventions. Даёт понимание того, как устроены корпоративные директории изнутри.

5. **Shibboleth Project Documentation (shibboleth.net).** Зачем читать: Shibboleth -- эталонная реализация SAML SP и IdP, используемая тысячами университетов по всему миру. Документация содержит практические примеры конфигурации, troubleshooting-гайды и best practices, недоступные в абстрактных спецификациях OASIS. Незаменима для тех, кто реально настраивает SAML federation.

---

*Создано: 2026-02-11*