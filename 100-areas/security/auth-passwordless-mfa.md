---
title: "Passkeys, MFA и современная аутентификация: от паролей к беспарольному будущему"
created: 2026-02-11
modified: 2026-02-11
type: deep-dive
status: published
confidence: high
tags:
  - topic/security
  - type/deep-dive
  - level/intermediate
related:
  - "[[authentication-authorization]]"
  - "[[auth-sessions-jwt-tokens]]"
  - "[[auth-enterprise-sso]]"
  - "[[security-cryptography-fundamentals]]"
prerequisites:
  - "[[authentication-authorization]]"
  - "[[security-cryptography-fundamentals]]"
---

# Passkeys, MFA и современная аутентификация: от паролей к беспарольному будущему

81% утечек данных связаны с украденными или слабыми паролями (Verizon DBIR 2024). Пароли -- механизм аутентификации, изобретённый в 1961 году для многопользовательской системы MIT, -- до сих пор остаются главным способом входа в системы. Passkeys представляют собой крупнейший сдвиг в аутентификации за шесть десятилетий: замену shared secret на асимметричную криптографию с привязкой к домену. Этот материал проходит весь путь -- от хеширования паролей до беспарольного будущего.

---

## Зачем это знать

Пароли фундаментально сломаны. Не "неидеальны", не "требуют улучшения" -- сломаны на архитектурном уровне. Пароль -- это shared secret: он известен и пользователю, и серверу. Любой скомпрометированный endpoint уничтожает безопасность. Пароль фишится -- пользователь вводит его на поддельном сайте. Пароль переиспользуется -- утечка одного сервиса компрометирует десятки других. Пароль забывается -- средний пользователь управляет 100+ аккаунтами. Пароль утекает -- серверы взламываются, базы данных крадутся.

Индустрия активно движется от паролей. Google: 800M+ аккаунтов с включёнными passkeys (рост 352% за год). Microsoft: passkeys по умолчанию для новых аккаунтов с мая 2025. Apple: кросс-платформенная поддержка passkeys начиная с iOS 26. NIST SP 800-63-4 (июль 2025) рекомендует Argon2id для хеширования и phishing-resistant аутентификацию для уровня AAL2+.

Для разработчика понимание полного спектра -- от password hashing до passkeys -- это не факультативный навык. Если вы проектируете систему аутентификации сегодня и не учитываете passkeys, вы строите систему, которая устареет до запуска. Если вы не понимаете, почему MD5 -- катастрофа, вы не сможете оценить правильность решений в существующей кодовой базе.

---

## Терминология

| Термин | Что это | Аналогия из жизни |
|--------|---------|-------------------|
| **Password hash** | Результат одностороннего преобразования пароля | Отпечаток пальца: по нему невозможно восстановить палец, но можно проверить совпадение |
| **Salt** | Случайная строка, добавляемая к паролю перед хешированием | Уникальный серийный номер на каждом замке одной модели -- даже одинаковые ключи дают разные замки |
| **Pepper** | Секрет на уровне приложения, добавляемый к паролю | Секретный ингредиент повара -- хранится отдельно от рецепта, не в базе данных |
| **Key Derivation Function (KDF)** | Функция, превращающая пароль в криптографический ключ с контролируемой стоимостью | Замок с регулируемой сложностью: можно добавить штифтов, и каждая попытка подбора займёт дольше |
| **MFA** | Multi-Factor Authentication -- проверка двумя+ независимыми факторами | Вход в банковскую ячейку: нужен и ключ (have), и подпись (know) |
| **TOTP** | Time-Based One-Time Password -- одноразовый код, привязанный ко времени | Код на электронном табло: каждые 30 секунд новое число, прошлое бесполезно |
| **HOTP** | HMAC-Based One-Time Password -- код, привязанный к счётчику | Билет с номером в очереди: следующий всегда больше предыдущего |
| **WebAuthn** | W3C-стандарт аутентификации через публичные ключи в браузере | Электронная подпись: сервер проверяет, но никогда не видит приватный ключ |
| **FIDO2** | Набор стандартов (WebAuthn + CTAP2) для беспарольной аутентификации | Платёжный терминал + банковская карта: стандартизированный протокол взаимодействия |
| **Passkey** | Discoverable credential: WebAuthn-ключ, синхронизируемый между устройствами | Цифровой ключ от машины: работает с телефона, синхронизируется через облако, нельзя скопировать |
| **Authenticator** | Platform (встроенный: Touch ID) или roaming (внешний: YubiKey) | Встроенный замок в двери vs навесной замок, который можно принести с собой |
| **Credential** | Учётные данные, привязанные к конкретному origin | Пропуск в здание: работает только в конкретном бюро пропусков |
| **Challenge** | Случайные байты от сервера, которые authenticator подписывает | Контрольное слово: банк называет случайное число, вы доказываете, что имеете секрет |
| **Attestation** | Доказательство свойств authenticator при регистрации | Сертификат качества замка от производителя -- подтверждает, что это настоящий YubiKey |
| **Assertion** | Доказательство владения ключом при аутентификации | Подпись на документе -- подтверждение, что вы -- это вы, без раскрытия приватного ключа |
| **Phishing resistance** | Невозможность использования credential на поддельном домене | Ключ, который физически не вставляется в чужой замок -- форма замочной скважины уникальна |

---

## Prerequisites

| Prerequisite | Что нужно знать | Почему |
|-------------|----------------|--------|
| [[authentication-authorization]] | Разница AuthN vs AuthZ, обзор способов аутентификации, OAuth 2.0 flows | Текущий файл углубляет конкретные механизмы AuthN, не повторяя базовые концепции |
| [[security-cryptography-fundamentals]] | Хеширование, HMAC, асимметричное шифрование, цифровые подписи | Passkeys построены на ECDSA, TOTP на HMAC-SHA1, password hashing на KDF -- без криптографии всё остаётся "магией" |

---

## Историческая справка

История аутентификации -- это 64 года эскалации: каждое десятилетие атакующие находили способ обойти защиту, а защитники отвечали усложнением. Проследим эту цепочку от первого пароля до passkeys.

**1961 -- Первые компьютерные пароли (MIT CTSS).** Фернандо Корбато создаёт Compatible Time-Sharing System -- первую систему с множественным доступом. Нескольким пользователям нужен доступ к своим файлам на общем компьютере. Решение: текстовый файл с паролями, хранящимися открытым текстом. В 1966 году программный баг показал этот файл всем пользователям -- первая утечка паролей в истории компьютеров. Корбато впоследствии назвал пароли "своего рода кошмаром".

**1976 -- Unix crypt() (Роберт Моррис).** Роберт Моррис (отец автора "червя Морриса") реализует первое хеширование паролей в Unix. Пароль пропускается через модифицированный DES с 25 итерациями и 12-bit salt. Революционная идея: сервер хранит не пароль, а его хеш. При логине введённый пароль хешируется и сравнивается с хранимым значением. Исходный пароль невозможно восстановить из хеша математически.

**1999 -- bcrypt (Нильс Провос, Дэвид Мазьер).** Публикация "A Future-Adaptable Password Scheme" для OpenBSD. Ключевая идея: adaptive cost factor -- стоимость хеширования растёт вместе с ростом мощности оборудования. Каждое увеличение cost на 1 удваивает время вычисления. bcrypt включает встроенную salt и остаётся самым широко развёрнутым KDF спустя 27 лет.

**2009 -- scrypt (Колин Персиваль).** Первая широко известная memory-hard функция, разработанная для Tarsnap. Прорыв: для вычисления хеша нужна не только CPU-мощность, но и значительный объём оперативной памяти. GPU имеет тысячи ядер, но мало памяти на ядро -- memory-hardness делает GPU-атаки непрактично дорогими.

**2013-2015 -- Password Hashing Competition, Argon2.** Международное соревнование по аналогии с AES Competition. 24 алгоритма-кандидата. Победитель -- Argon2 (авторы: Бирюков, Дину, Ховратович из Люксембургского университета). Три варианта: Argon2d (data-dependent, устойчив к TMTO), Argon2i (data-independent, устойчив к side-channel), Argon2id (гибрид, рекомендованный для production).

**2012 -- Основание FIDO Alliance.** PayPal, Lenovo, Infineon и другие основывают FIDO (Fast IDentity Online) Alliance. Цель: открытые стандарты аутентификации без паролей. Мотивация проста -- пароли стали главным вектором атак, и индустрии нужна фундаментально другая архитектура.

**2019 -- WebAuthn W3C Recommendation.** WebAuthn становится официальным веб-стандартом. Браузеры получают нативный API для публично-ключевой аутентификации. Проблема: credential привязан к одному физическому устройству -- потеря устройства = потеря доступа ко всем WebAuthn-аккаунтам.

**2022 -- Apple, Google, Microsoft анонсируют passkeys.** Три платформы синхронно объявляют поддержку synced passkeys -- WebAuthn credentials, синхронизируемых через облачные хранилища. Это решает проблему привязки к устройству и делает беспарольную аутентификацию практичной для массового пользователя.

**2024-2025 -- Passkeys становятся mainstream.** Google: 800M+ аккаунтов, 2.5B аутентификаций. Microsoft: passkeys по умолчанию (май 2025). FIDO Alliance: 15B+ аккаунтов поддерживают passkeys.

**2025, июль -- NIST SP 800-63-4.** Обновлённые гайдлайны цифровой идентификации: Argon2id рекомендован для password hashing. SMS OTP не рекомендован для AAL2+. Phishing-resistant аутентификация обязательна для AAL3 и рекомендована для AAL2. Passkeys и WebAuthn квалифицируются для AAL2 и AAL3.

```
Эволюция аутентификации (1961-2025):

1961    1976     1999    2009    2015     2019     2022     2025
 │       │        │       │       │        │        │        │
 ▼       ▼        ▼       ▼       ▼        ▼        ▼        ▼
CTSS    Unix    bcrypt  scrypt  Argon2  WebAuthn Passkeys  NIST
plain   crypt()  adapt-  memory  PHC     W3C     synced   SP800
text    (DES)   ive     hard    winner   Rec     creds    -63-4
 │               cost                     │
 │                                        │
Shared secret (пароли)           Public-key crypto (passkeys)
─────────────────────           ─────────────────────────────
Сервер знает секрет             Сервер знает только публичный ключ
Фишится                         Привязано к домену (origin)
Переиспользуется                Уникально для каждого сервиса
```

Мы прошли 64 года эволюции. Теперь разберём каждый слой в деталях -- начнём с фундамента: как правильно хранить пароли, если ваша система их всё ещё использует.

---

## Password Hashing: защита паролей при хранении

### Почему MD5/SHA -- катастрофа

Криптографические хеш-функции общего назначения -- MD5, SHA-1, SHA-256 -- проектировались для скорости. Это их прямое назначение: быстро вычислить хеш файла для проверки целостности, быстро подписать сообщение. Но скорость -- враг безопасности паролей.

Цифры: RTX 4090 вычисляет ~70 миллиардов MD5-хешей в секунду. SHA-256: ~22 миллиарда в секунду. Пароль из 8 символов (полный charset: 95 ASCII-символов) -- это ~6.6 квадриллионов комбинаций. При 22 миллиардах SHA-256 в секунду полный перебор занимает ~3.5 дня. Для MD5 -- менее суток. Это не "теоретическая" атака -- это реальность, доступная любому с одной видеокартой за $1600.

Аналогия из жизни: представьте дверной замок, который можно пробовать открывать со скоростью 70 миллиардов ключей в секунду. Не имеет значения, насколько сложная форма у ключа -- при такой скорости любой замок конечной сложности будет подобран. KDF (Key Derivation Functions) решают эту проблему, заставляя замок "ждать" между попытками -- как если бы после каждой неудачной попытки механизм замка намеренно замедлялся на четверть секунды.

### Argon2id: победитель PHC, рекомендация NIST

Argon2id -- гибридный вариант Argon2, рекомендованный NIST SP 800-63-4 (июль 2025) и OWASP. Он объединяет защиту от side-channel атак (свойство Argon2i: data-independent доступ к памяти в первой половине вычислений) с максимальной устойчивостью к time-memory trade-off атакам (свойство Argon2d: data-dependent доступ во второй половине).

Ключевое свойство Argon2id -- memory-hardness. Для вычисления одного хеша алгоритм требует значительный объём оперативной памяти (рекомендация OWASP: 64 MB минимум). Это делает параллельные атаки на GPU и ASIC непрактично дорогими. GPU NVIDIA RTX 4090 имеет 16384 ядра, но только 24 GB видеопамяти. При 64 MB на хеш можно параллельно вычислять не более 375 хешей -- вместо миллиардов при использовании SHA-256. Разница в эффективности атаки: шесть порядков.

Три параметра определяют стоимость Argon2id: **memory** -- объём RAM на каждое вычисление (OWASP: 64 MB+), **time** -- количество проходов по памяти (рекомендация: 3+), **parallelism** -- число потоков (обычно 1-4 для серверных приложений). Увеличение memory -- самый эффективный рычаг: GPU имеет много ядер, но ограниченную память, и именно это делает memory-hard функции эффективной защитой.

Аналогия: представьте сейф, для открытия которого нужна не только отмычка (CPU), но и большой рабочий стол (RAM). Взломщик может принести тысячу отмычек (ядра GPU), но если каждая отмычка требует отдельный стол размером с комнату -- параллельный взлом становится физически невозможным. У вас тысяча отмычек, но только три комнаты.

Следующий фрагмент показывает настройку Argon2id -- обратите внимание на комментарии к каждому параметру.

```kotlin
// Argon2id: почему именно эти параметры
val argon2Config = Argon2Config(
    type = Argon2Type.ARGON2_ID,  // Гибрид: устойчив к side-channel + TMTO
    memoryCostKB = 65536,          // 64 MB RAM -- делает GPU-атаку дорогой
    timeCost = 3,                  // 3 итерации -- баланс: ~300ms на сервере
    parallelism = 1,               // 1 поток -- предотвращает DoS при пиках
    hashLength = 32,               // 256-bit выход
    saltLength = 16                // 128-bit уникальная случайная соль
)
// OWASP 2025: 64MB/3 итерации -- минимум для production
// Время хеширования: 200-500ms (тюнить под конкретное железо)
```

Каждый параметр -- компромисс. Больше памяти -- лучше защита, но выше нагрузка на сервер при пиках логинов. Больше итераций -- дольше перебор для атакующего, но и дольше ожидание для пользователя. Практическое правило: настройте параметры так, чтобы одно хеширование занимало 200-500 мс на вашем production-сервере. Слишком быстро -- слабая защита. Слишком медленно -- DoS на login endpoint.

### bcrypt: проверенный временем стандарт (1999)

bcrypt, основанный на шифре Blowfish, ввёл революционную концепцию adaptive cost factor. Параметр cost (work factor) определяет число итераций по формуле 2^cost. Cost 10 = 1024 итерации (~100 мс). Cost 12 = 4096 итераций (~250 мс). Cost 14 = 16384 итерации (~1 сек). Каждое увеличение cost на 1 удваивает время. Через 10 лет, когда оборудование станет вдвое быстрее, достаточно увеличить cost на 1 -- и уровень защиты восстановлен.

bcrypt включает 16-байтовую salt как часть выходного формата: `$2b$12$salt22chars.hash31chars`. Разработчику не нужно отдельно управлять salt -- это устраняет целый класс ошибок. Ограничение: bcrypt обрабатывает максимум 72 байта пароля. Для большинства реальных паролей это не проблема (72 ASCII-символа -- очень длинный пароль), но при работе с Unicode (символ UTF-8 может занимать до 4 байт) или при использовании passphrase следует знать об этом лимите. Распространённый паттерн: `bcrypt(SHA-256(password))` -- SHA-256 нормализует длину, bcrypt обеспечивает cost factor.

### scrypt: memory-hard предшественник Argon2 (2009)

scrypt стал первой широко известной memory-hard функцией. Три параметра: N (CPU/memory cost, степень 2, обычно 2^14 до 2^20), r (block size, обычно 8), p (parallelism, обычно 1). scrypt менее гибок, чем Argon2 -- параметры взаимосвязаны нелинейно, и нельзя независимо управлять памятью и временем. Но scrypt проверен 15+ годами эксплуатации в production (Tarsnap, Litecoin, множество web-приложений) и остаётся надёжным выбором.

### PBKDF2: устаревший, но живой (2000)

PBKDF2 (Password-Based Key Derivation Function 2) -- HMAC-based KDF, стандартизированный в NIST SP 800-132. Единственный настраиваемый параметр -- число итераций (OWASP 2025: 600,000 для HMAC-SHA-256). Критический недостаток: PBKDF2 не memory-hard. Каждая итерация требует минимум RAM, что позволяет GPU атаковать с полной параллельностью. PBKDF2 остаётся в compliance-требованиях (FIPS 140-2) и используется в legacy-системах, но для новых проектов не рекомендуется.

### Сравнение KDF

| Свойство | Argon2id | bcrypt | scrypt | PBKDF2 |
|----------|----------|--------|--------|--------|
| **Год** | 2015 | 1999 | 2009 | 2000 |
| **Memory-hard** | Да (настраиваемо) | Нет (4 KB) | Да (настраиваемо) | Нет |
| **GPU/ASIC устойчивость** | Высокая | Средняя | Высокая | Низкая |
| **NIST 2025 рекомендация** | Да (primary) | Допустим | Допустим | Допустим (legacy) |
| **Max password length** | Неограничен | 72 байта | Неограничен | Неограничен |
| **Гибкость параметров** | Высокая (3 оси) | Низкая (1 ось) | Средняя (2 оси) | Низкая (1 ось) |
| **Рекомендуемые параметры** | m=64MB, t=3, p=1 | cost=12 | N=2^17, r=8, p=1 | 600K iter (SHA-256) |
| **Рекомендация** | Новые системы | Существующие системы | Допустим | Только для compliance |

От хранения паролей перейдём к политикам -- NIST SP 800-63-4 перевернул многие устоявшиеся практики.

---

## Password Policies: революция NIST SP 800-63-4 (июль 2025)

В июле 2025 года NIST опубликовал SP 800-63-4 -- обновлённые гайдлайны цифровой идентификации. Многие рекомендации противоречат тому, что индустрия делала десятилетиями.

**Минимум 8 символов -- БЕЗ требований к сложности.** NIST больше не требует обязательных спецсимволов, цифр, заглавных букв. Исследования показали: complexity requirements приводят к предсказуемым паттернам. Пользователи пишут `P@ssw0rd!`, `Summer2025!`, `Company1!` -- формально соответствует требованиям, фактически угадывается за минуты.

**Проверка против базы утечек.** Каждый новый пароль должен проверяться по спискам скомпрометированных паролей (Have I Been Pwned API: 900M+ утёкших паролей). Пароль `correcthorsebatterystaple` формально отличный (25 символов), но он утёк -- и потому небезопасен.

**Никакой принудительной ротации.** Периодическая смена паролей (каждые 90 дней) была стандартом десятилетия. NIST говорит: это вредно. Пользователи при ротации создают последовательности: `Password1`, `Password2`, `Password3`. Атакующий, знающий один пароль из цепочки, легко предскажет следующий. Менять пароль нужно только при подозрении на компрометацию.

**Разрешить paste в поля паролей.** Запрет вставки из буфера обмена мешал менеджерам паролей -- единственному инструменту, который реально повышает безопасность для массового пользователя. NIST явно требует разрешить paste.

**Никаких security questions.** "Девичья фамилия матери", "Название первой школы" -- ответы угадываемы, фишимы и гуглятся через социальные сети. NIST официально признал security questions небезопасным механизмом.

**SMS не рекомендован для AAL2+.** SMS OTP уязвим к SIM-swapping и перехвату через SS7. Для уровней аутентификации AAL2 и выше NIST рекомендует phishing-resistant методы: passkeys, hardware security keys.

> **Ключевая идея:** NIST 800-63-4 -- это отказ от security theater (видимость безопасности) в пользу evidence-based security. Complexity requirements *выглядели* безопасно, но на практике делали пароли слабее. Принудительная ротация *выглядела* как усиление, но создавала предсказуемые паттерны.

---

## Password Reset: безопасное восстановление доступа

Восстановление пароля -- одна из самых уязвимых точек любой системы аутентификации. Даже если пароль хеширован Argon2id и защищён MFA, слабый reset flow обнуляет все усилия.

**Email-токены** -- стандартный подход. Сервер генерирует криптографически случайный токен (256+ бит энтропии), хранит его в хешированном виде (чтобы утечка БД не дала готовые reset-ссылки), отправляет ссылку на email. Токен ограничен по времени (15-30 минут) и одноразовый. Критически важно: после успешного reset все существующие сессии пользователя должны быть инвалидированы.

**Recovery codes** -- одноразовые коды, генерируемые при настройке MFA. Пользователь получает 8-10 кодов и хранит их в безопасном месте (менеджер паролей, распечатка в сейфе). Каждый код можно использовать один раз. Это "аварийный выход" при потере второго фактора -- телефона с TOTP, аппаратного ключа.

**Security questions -- DEPRECATED.** NIST SP 800-63-4 явно запрещает. Ответы на "Девичья фамилия матери?" и "Название первой школы?" -- гуглятся, фишатся или угадываются через социальные сети. Это security theater в чистом виде: создаёт иллюзию безопасности, но снижает её.

**Account recovery** при потере всех факторов -- нерешённая проблема индустрии. Варианты: identity verification через службу поддержки (дорого, медленно, уязвимо к социальной инженерии), trusted contacts (как у Apple -- доверенные контакты подтверждают вашу личность), задержка восстановления (24-72 часа, чтобы реальный владелец заметил попытку).

---

## MFA: Multi-Factor Authentication

### Факторы аутентификации

Идея MFA проста: одного фактора недостаточно. Если пароль украден -- нужен второй барьер. Безопасность MFA определяется не количеством шагов, а количеством *независимых* факторов из разных категорий.

```
Факторы аутентификации:

┌───────────────────┐  ┌───────────────────┐  ┌───────────────────┐
│   SOMETHING YOU   │  │   SOMETHING YOU   │  │   SOMETHING YOU   │
│      KNOW         │  │      HAVE         │  │       ARE         │
│    (знание)       │  │    (владение)     │  │   (биометрия)     │
├───────────────────┤  ├───────────────────┤  ├───────────────────┤
│ Пароль            │  │ Телефон (TOTP)    │  │ Отпечаток пальца  │
│ PIN-код           │  │ Hardware key      │  │ Face ID           │
│ Кодовое слово     │  │ Smart card        │  │ Голос             │
│                   │  │ Passkey device    │  │ Радужная оболочка │
├───────────────────┤  ├───────────────────┤  ├───────────────────┤
│ (+) Привычно      │  │ (+) Физическое    │  │ (+) Уникально     │
│ (-) Фишинг,       │  │     владение      │  │ (-) Нельзя сменить│
│     утечки,       │  │ (-) Потеря,       │  │     при утечке,   │
│     угадывание    │  │     кража         │  │     false reject  │
└───────────────────┘  └───────────────────┘  └───────────────────┘

Дополнительные факторы (emerging):
┌───────────────────┐  ┌───────────────────┐
│   SOMETHING YOU   │  │   SOMEWHERE YOU   │
│       DO          │  │       ARE         │
│   (поведение)     │  │   (локация)       │
├───────────────────┤  ├───────────────────┤
│ Паттерн набора    │  │ GPS-координаты    │
│ Скорость печати   │  │ IP-адрес          │
│ Жесты             │  │ Wi-Fi сеть        │
│ (-) Экспериментал.│  │ (-) Легко подделать│
└───────────────────┘  └───────────────────┘
```

Критически важно: два фактора одной категории -- это не MFA. Пароль + секретный вопрос = два фактора "знание", а не двухфакторная аутентификация. Настоящая MFA комбинирует разные категории: знание + владение, владение + биометрия.

| Комбинация | Пример | Уровень |
|-----------|--------|---------|
| Знание + владение | Пароль + TOTP с телефона | AAL2 (но не phishing-resistant) |
| Знание + биометрия | PIN + Face ID | AAL2 |
| Владение + биометрия | Passkey (устройство + Face ID) | AAL2-AAL3 (phishing-resistant) |
| Знание + знание | Пароль + секретный вопрос | НЕ MFA |

Аналогия: сейф с двумя замками *разного типа*. Один открывается ключом (владение), другой -- кодом (знание). Даже если вор узнал код, без физического ключа сейф не откроется. Два кодовых замка -- слабее, чем код + ключ: один метод атаки (подсмотреть) компрометирует оба.

### TOTP: Time-Based One-Time Password (RFC 6238)

TOTP -- самый распространённый второй фактор после SMS. Механизм элегантен: клиент и сервер делят общий секрет (обычно 160-320 бит, закодированный в Base32). Одноразовый код вычисляется из этого секрета и текущего времени.

Формула: `TOTP = Truncate(HMAC-SHA1(secret_key, floor(unix_timestamp / 30)))`. Результат HMAC -- 160-bit значение. Из него через dynamic truncation извлекаются 4 байта, которые преобразуются в 6-значный код через остаток от деления на 10^6. Каждые 30 секунд `floor(timestamp / 30)` увеличивается на 1 -- и код меняется.

Регистрация происходит через QR-код, содержащий URI формата `otpauth://totp/Service:user@email?secret=BASE32SECRET&issuer=Service`. Приложение (Google Authenticator, Authy, 1Password) сканирует QR, сохраняет секрет и начинает генерировать коды. Сервер принимает код из текущего 30-секундного окна и соседних (±1 окно), чтобы компенсировать рассинхронизацию часов (clock drift).

```
Механизм TOTP:

  Регистрация (однократно):
  ┌────────┐  QR с секретом (Base32)  ┌────────────────┐
  │ Сервер │ ────────────────────────▶ │ Authenticator  │
  │        │                           │ (Google Auth)  │
  └────────┘                           └────────────────┘
  Оба хранят: SECRET = "JBSWY3DPEHPK3PXP"

  Генерация кода (каждые 30 сек):

  unix_time = 1707500000
  time_step = floor(1707500000 / 30) = 56916666

  Authenticator:                    Сервер:
  HMAC-SHA1(secret, 56916666)      HMAC-SHA1(secret, 56916666)
  → truncate → "482901"            → truncate → "482901"

  Пользователь вводит: 482901
  Сервер проверяет:    482901 == 482901 → OK

  Сервер также принимает:
  - код для 56916665 (предыдущие 30 сек) -- clock drift
  - код для 56916667 (следующие 30 сек) -- clock drift
```

Следующий фрагмент иллюстрирует концепцию вычисления TOTP -- в production всегда используйте проверенную библиотеку (kotlinx-datetime, Apache Commons Codec).

```kotlin
// Концепция TOTP: HMAC от секрета + временного окна
fun generateTOTP(secretKey: ByteArray): String {
    val timeStep = System.currentTimeMillis() / 1000 / 30  // 30-сек окно
    val timeBytes = ByteBuffer.allocate(8)
        .putLong(timeStep).array()                         // 8-byte big-endian
    val hmac = Mac.getInstance("HmacSHA1").apply {
        init(SecretKeySpec(secretKey, "HmacSHA1"))
    }.doFinal(timeBytes)
    // Dynamic truncation: последний nibble → offset → 4 байта → 6 цифр
    val offset = hmac.last().toInt() and 0x0F
    val code = ((hmac[offset].toInt() and 0x7F) shl 24 or
        (hmac[offset + 1].toInt() and 0xFF shl 16) or
        (hmac[offset + 2].toInt() and 0xFF shl 8) or
        (hmac[offset + 3].toInt() and 0xFF)) % 1_000_000
    return code.toString().padStart(6, '0')  // Ведущие нули важны
}
```

Этот код показывает внутреннюю механику, но в реальных системах критичны дополнительные аспекты: rate limiting на проверку кодов (6 цифр = 1M комбинаций -- без rate limiting brute force тривиален), шифрование TOTP-секретов на сервере (если БД утечёт, атакующий не должен получить секреты в открытом виде) и корректная обработка clock drift.

### HOTP: counter-based одноразовые пароли (RFC 4226)

HOTP -- предшественник TOTP, использующий счётчик вместо времени: `HOTP = Truncate(HMAC-SHA1(secret, counter))`. Каждое использование увеличивает counter на 1. Проблема: если пользователь нажал кнопку на токене 5 раз, не введя коды, counter на клиенте ушёл вперёд. Сервер компенсирует это look-ahead window (проверяет следующие N значений), но при большом расхождении требуется ресинхронизация. TOTP избавлен от этой проблемы -- время является общим "счётчиком", не требующим синхронизации. HOTP встречается в аппаратных токенах без часов и в legacy-системах.

---

## WebAuthn/FIDO2: аутентификация на публичных ключах

Переход от паролей и TOTP к WebAuthn -- это не эволюция, а смена парадигмы. Пароль и TOTP -- shared secrets: обе стороны знают секрет. WebAuthn -- asymmetric crypto: сервер знает только публичный ключ, приватный ключ *никогда* не покидает устройство. Компрометация сервера не компрометирует аутентификацию.

### Архитектура

WebAuthn определяет три роли. **Relying Party (RP)** -- сервер, которому нужна аутентификация (ваш сайт, API). **Client** -- браузер, посредник между RP и authenticator, отвечающий за origin validation. **Authenticator** -- устройство или модуль, генерирующий и хранящий криптографические ключи.

Authenticators бывают двух типов. **Platform authenticator** -- встроен в устройство: Secure Enclave (iPhone), TPM (Windows), TEE (Android). Преимущество: всегда доступен, не нужно ничего носить с собой. Недостаток: привязан к конкретному устройству. **Roaming authenticator** -- внешнее устройство: YubiKey, Google Titan Key, SoloKeys. Подключается по USB, NFC или BLE. Преимущество: работает с любым компьютером. Недостаток: можно потерять.

### Регистрация (credential creation)

При регистрации authenticator генерирует новую пару ключей, привязанную к конкретному origin (домену). Сервер получает только публичный ключ.

```
WebAuthn: Регистрация (credential creation)

  Пользователь       Браузер (Client)       Authenticator          Сервер (RP)
       │                    │                     │                     │
       │  "Создать passkey" │                     │                     │
       │───────────────────▶│                     │                     │
       │                    │  1. POST /register  │                     │
       │                    │─────────────────────────────────────────▶│
       │                    │                     │   2. Challenge      │
       │                    │                     │   (32+ случайных   │
       │                    │◀─────────────────────────────────────────│   байт)
       │                    │                     │                     │
       │                    │  3. navigator       │                     │
       │                    │  .credentials       │                     │
       │                    │  .create(options)   │                     │
       │                    │────────────────────▶│                     │
       │                    │                     │                     │
       │  4. Подтвердить    │                     │                     │
       │  (Face ID / PIN)   │                     │                     │
       │───────────────────▶│                     │                     │
       │                    │  5. Новая пара      │                     │
       │                    │  ключей для origin  │                     │
       │                    │  "example.com"      │                     │
       │                    │◀────────────────────│                     │
       │                    │                     │                     │
       │                    │  6. Публичный ключ + attestation         │
       │                    │─────────────────────────────────────────▶│
       │                    │                     │  7. Сохранить       │
       │                    │                     │     публичный ключ │
       │                    │                     │     + credential ID │
       │                    │                     │                     │
       │                    │    Приватный ключ ОСТАЁТСЯ               │
       │                    │    на устройстве (Secure Enclave/TEE)    │
```

### Аутентификация (assertion)

При входе сервер отправляет challenge. Authenticator проверяет origin, находит credential для этого домена, подписывает challenge приватным ключом. Сервер проверяет подпись публичным ключом. Приватный ключ не раскрывается -- передаётся только подпись.

Серверная проверка assertion в TypeScript -- обратите внимание на проверку origin, которая обеспечивает phishing resistance.

```typescript
// Проверка assertion: origin binding -- основа phishing resistance
async function verifyAssertion(
  assertion: AuthenticatorAssertionResponse,
  storedCredential: StoredCredential
) {
  const clientData = JSON.parse(
    Buffer.from(assertion.clientDataJSON).toString()
  );
  // КРИТИЧЕСКАЯ ПРОВЕРКА: origin должен совпадать с нашим доменом
  if (clientData.origin !== 'https://example.com') {
    throw new Error('Origin mismatch — возможен phishing');
  }
  // Проверка подписи сохранённым публичным ключом
  const isValid = await crypto.subtle.verify(
    { name: 'ECDSA', hash: 'SHA-256' },
    storedCredential.publicKey,
    assertion.signature,     // Подпись приватным ключом (на устройстве)
    assertion.authenticatorData
  );
  if (!isValid) throw new Error('Invalid signature');
}
```

Проверка origin -- именно то свойство, которое делает WebAuthn phishing-resistant. Credential привязан к конкретному домену (`example.com`). Если пользователь зайдёт на `examp1e.com` (фишинговый сайт), authenticator не найдёт credential для этого origin и не подпишет challenge. Это не "сложно обойти" -- это *математически невозможно* в рамках протокола.

### Phishing resistance: почему это важно

Сравним phishing resistance разных методов. Пароль: пользователь вводит на любом сайте, который попросит -- нулевая привязка к домену. TOTP: 6-значный код не привязан к домену -- пользователь введёт его на фишинговом сайте так же легко, как на настоящем. Real-time phishing proxy (Evilginx2, Modlishka) перехватывает оба фактора одновременно. WebAuthn/Passkeys: credential привязан к origin -- authenticator физически отказывается подписывать challenge для чужого домена. Фишинг невозможен.

---

## Passkeys: WebAuthn для массового пользователя

### Что изменили passkeys

WebAuthn до passkeys имел критическую проблему: credential привязан к одному физическому устройству. Потерял телефон -- потерял все WebAuthn credentials. Купил новый ноутбук -- регистрация заново на каждом сайте. Для security-энтузиастов это допустимо. Для обычного пользователя -- барьер, убивающий adoption.

Passkeys -- это discoverable WebAuthn credentials, синхронизируемые через облачное хранилище. iCloud Keychain синхронизирует passkeys между всеми Apple-устройствами пользователя (end-to-end encrypted). Google Password Manager -- между Android-устройствами и Chrome. 1Password, Dashlane, Bitwarden -- кросс-платформенно. Криптография остаётся той же (ECDSA/Ed25519, origin binding), но UX становится сопоставим с автозаполнением паролей.

Аналогия из реального мира: цифровой ключ от автомобиля. Ваш цифровой ключ синхронизирован между iPhone, Apple Watch и телефоном супруга через iCloud. Потеряли телефон -- ключ остаётся на часах и в облаке. Купили новый телефон -- ключ появляется автоматически. Ключ нельзя скопировать вне экосистемы (end-to-end encrypted sync), нельзя использовать для другой машины (origin binding) и невозможно подделать (asymmetric crypto). Но при этом вы не думаете о криптографии -- просто подносите телефон к машине.

### Данные adoption (2025)

Passkeys перешли из "emerging technology" в mainstream. Google: 800M+ аккаунтов с passkeys, 352% рост год к году, 2.5B аутентификаций. Microsoft: passkeys по умолчанию для новых аккаунтов с мая 2025, рост использования 120%. Apple: расширенная кросс-платформенная поддержка в iOS 26. FIDO Alliance: 15B+ аккаунтов поддерживают passkey-аутентификацию, 1B+ людей активировали хотя бы один passkey.

Adoption по платформам неравномерен: ~55-60% на мобильных устройствах (встроенная биометрия делает UX бесшовным), ~20% на десктопе (меньше устройств с биометрией). Enterprise-сектор отстаёт: legacy-системы, compliance-требования, необходимость поддерживать сотни internal tools. Passkeys сосуществуют с паролями ещё минимум 5-7 лет.

### Conditional UI (Autofill)

Одна из причин успеха passkeys -- интеграция в привычный UX. Conditional UI позволяет браузеру показывать passkeys в том же autofill-dropdown, где появляются сохранённые пароли. Пользователю не нужно искать кнопку "Login with passkey" -- браузер предлагает passkey рядом с паролем. При наличии passkey он отображается первым, мотивируя пользователя к переходу.

Для разработчика интеграция требует `autocomplete="webauthn"` на поле ввода и вызова `navigator.credentials.get()` с флагом `mediation: "conditional"`. Браузер сам управляет UI -- не нужен custom passkey modal или отдельная кнопка.

---

## Magic Links

Magic link -- URL с криптографически случайным токеном, отправляемый на email пользователя. Механизм: сервер генерирует токен (256+ бит), сохраняет его хеш с привязкой к email и TTL (15-30 минут), отправляет ссылку `https://app.com/auth/verify?token=abc123`. Пользователь кликает -- сервер проверяет хеш токена, время, одноразовость. Токен использован -- удаляется.

UX-компромиссы: зависимость от доступа к email (нет email -- нет входа), задержка доставки (5-30 секунд, иногда минуты), плохо работает для мобильных приложений (переключение между email-клиентом и приложением, Universal Links/App Links помогают, но не всегда). Magic links популярны в SaaS (Slack, Notion, Medium) и хороши для low-frequency login, но не подходят для приложений с частым входом.

---

## Биометрическая аутентификация

### Критически важное различие

Самое опасное заблуждение о биометрии: "Face ID/Touch ID -- это аутентификация по лицу/отпечатку". Нет. Биометрические данные *не передаются серверу*. Биометрия используется локально для разблокировки криптографического ключа, а ключ аутентифицирует пользователя. Ваш отпечаток пальца не "путешествует" по сети -- он никогда не покидает Secure Enclave (iOS) или TEE (Android).

Это фундаментальное различие. Если бы отпечаток передавался серверу, утечка базы данных скомпрометировала бы биометрию навсегда -- нового пальца не вырастить. Но поскольку биометрия остаётся локальной, компрометация сервера не влияет на неё. Сервер хранит только публичный ключ, который бесполезен для атакующего.

### iOS: Face ID / Touch ID и Secure Enclave

На iOS биометрические данные обрабатываются в Secure Enclave -- отдельном процессоре с изолированной памятью, физически отделённом от основного CPU. Операционная система *не имеет доступа* к biometric templates. Приложение использует LAContext для запроса биометрии, результат -- разблокировка ключа в Keychain. Флаг `kSecAttrAccessibleWhenUnlockedThisDeviceOnly` гарантирует, что ключ не синхронизируется и не покидает устройство.

Face ID использует TrueDepth-камеру с инфракрасным проектором -- 30,000 точек создают карту глубины лица. Обмануть фотографией невозможно (нет глубины), 3D-маской -- тоже (материал отражает ИК-излучение иначе, чем живая кожа). Подробная платформенная реализация -- в [[ios-permissions-security]].

### Android: BiometricPrompt и классы биометрии

Android определяет три класса биометрии. **Class 3 (Strong):** hardware-backed, spoof-resistant, Spoofing Acceptance Rate < 7%. Включает качественные fingerprint-сканеры и Face Authentication с глубинной картой (Face Unlock на Pixel). Результат подписывается аппаратным ключом в TEE или StrongBox. **Class 2 (Weak):** convenience biometric, менее строгая проверка -- некоторые fingerprint-сканеры бюджетных устройств. **Class 1:** минимальная безопасность, непригодна для финансовых операций.

BiometricPrompt API унифицирует работу со всеми типами. Для криптографических операций используется KeyStore с `setUserAuthenticationRequired(true)` -- ключ заблокирован до прохождения биометрии. Liveness detection защищает от фотографий и 3D-моделей. Подробная платформенная реализация -- в [[android-permissions-security]].

---

## SMS OTP: почему этот метод уходит в прошлое

SMS OTP был первым массовым вторым фактором с начала 2010-х. Он лучше, чем ничего. Но его уязвимости настолько серьёзны, что NIST SP 800-63-4 явно не рекомендует SMS для AAL2+.

**SIM-swapping.** Атакующий звонит оператору, представляется жертвой и переводит номер на свою SIM-карту. Социальная инженерия, поддельные документы, подкуп сотрудников -- всё используется. После переноса номера все SMS приходят атакующему. FBI в 2024 году зарегистрировало более 68,000 обращений по SIM swap с убытками более $68M. Это не экзотическая атака -- это индустрия.

**SS7 protocol interception.** SS7 (Signaling System 7) -- протокол сигнализации телекоммуникационных сетей, разработанный в 1970-х, когда участниками были только государственные операторы. Сегодня доступ к SS7 можно получить за несколько тысяч долларов. Через SS7 перехватываются SMS, отслеживается местоположение абонента, перенаправляются вызовы. Атака не требует физического доступа к устройству жертвы.

**Регуляторное давление растёт.** ОАЭ: мандат об устранении SMS OTP к марту 2026 для всех государственных сервисов. Европейская PSD2 ужесточает требования к Strong Customer Authentication. NIST: SMS не рекомендован для AAL2+. Тренд однозначен.

SMS OTP остаётся допустимым для low-risk сценариев (подтверждение подписки, некритичные аккаунты). Но для финансов, здравоохранения, enterprise -- SMS больше не считается достаточным.

---

## NIST SP 800-63-4 (июль 2025): уровни аутентификации

NIST определяет три Authentication Assurance Level (AAL) -- уровня гарантий аутентификации. Для федеральных систем США это *требования*, для остальной индустрии -- де-факто стандарт.

| | AAL1 | AAL2 | AAL3 |
|---|---|---|---|
| **Факторы** | 1 (любой) | 2+ (MFA) | 2+ (один hardware-bound) |
| **Phishing-resistant** | Не требуется | РЕКОМЕНДОВАНО | ТРЕБУЕТСЯ |
| **Hardware authenticator** | Не требуется | Не требуется | ТРЕБУЕТСЯ |
| **Допустимые методы** | Пароль | Passkey, FIDO2 key + PIN | YubiKey с PIN, passkey + biometric |
| **SMS OTP** | Допустим | Не рекомендован | Недопустим |
| **Argon2id** | Рекомендован | Рекомендован | Рекомендован |
| **Примеры** | Форум, блог | Банкинг, SaaS, email | Гос. системы, оборонка, здравоохранение |

Главное изменение: для AAL2 теперь *рекомендована* phishing-resistant аутентификация. Passkeys/WebAuthn квалифицируются для AAL2 и AAL3. TOTP -- для AAL2 (но без phishing resistance). SMS OTP -- формально допустим только для AAL1. Это определяет архитектурные решения: если продукт обрабатывает финансовые данные, passkeys -- не "приятный бонус", а compliance-требование.

---

## Распространённые заблуждения

**"Биометрия -- это пароль."** Нет. Пароль -- shared secret, передаваемый серверу. Биометрия -- локальное подтверждение, разблокирующее криптографический ключ. Отпечаток не "путешествует" по сети. Компрометация сервера не раскрывает биометрию -- потому что её там никогда не было.

**"Длинные пароли всегда лучше."** Частично. Entropy (энтропия) важнее длины. Пароль `aaaaaaaaaaaaaaaa` (16 символов, ~0 бит энтропии) слабее, чем `k9#Lm2$x` (8 символов, ~52 бит). Но при равной случайности длина побеждает: каждый дополнительный символ из 95-символьного ASCII charset добавляет ~6.5 бит энтропии.

**"MFA делает пароль неважным."** Нет. Если первый фактор -- `123456`, а второй -- TOTP, real-time phishing proxy (Evilginx2) перехватывает оба фактора одновременно. MFA повышает планку, но не компенсирует катастрофически слабый первый фактор.

**"Passkeys заменяют все методы аутентификации."** Нет. Passkeys -- для человек-к-машине аутентификации. Machine-to-machine (service-to-service) использует API keys, mutual TLS, OAuth client credentials. CLI-инструменты используют Device Authorization Flow (RFC 8628). Shared accounts плохо совместимы с passkeys. Passkeys не универсальны.

**"SMS OTP достаточно для всего."** Нет. SIM-swapping и SS7 -- не теоретические угрозы, а ежедневная реальность. FBI: 68,000+ случаев SIM swap в 2024. Для финансов и здравоохранения SMS OTP недопустим по NIST и по здравому смыслу.

---

## Подводные камни

**Passkey account recovery.** Что если пользователь потерял ВСЕ устройства и не имеет доступа к облачному аккаунту? Это нерешённая проблема индустрии. Варианты: recovery codes (пользователи теряют их в 40%+ случаев), trusted contacts (Apple), identity verification через поддержку (дорого, уязвимо к социальной инженерии). Проектируйте recovery flow *до* запуска passkeys, не после.

**Biometric false rejection.** Мокрые пальцы не распознаются Touch ID. Face ID хуже работает с масками. Люди с определёнными заболеваниями кожи не могут использовать fingerprint. Accessibility -- не опция, а требование: всегда предоставляйте альтернативный метод (PIN, password).

**TOTP secret storage.** Если пользователь потерял телефон и не сохранил backup codes -- восстановление доступа превращается в кошмар для поддержки. На сервере TOTP-секреты должны храниться зашифрованными (не в открытом виде). При настройке MFA всегда генерируйте recovery codes и настоятельно рекомендуйте их сохранить.

**Password hashing DoS.** Argon2id с параметрами 64MB/3 итерации -- ~300ms CPU + 64MB RAM на один запрос. Если атакующий отправляет 1000 запросов на `/login` в секунду, это 64 GB RAM и 300 секунд CPU-time. Rate limiting на login endpoint обязателен. Также рассмотрите proof-of-work challenge перед хешированием.

---

## Когда НЕ применяется

Беспарольная аутентификация -- не серебряная пуля. Есть контексты, где passkeys и биометрия неприменимы или неуместны.

**Machine-to-machine.** Сервисы общаются между собой без участия человека. API keys, mutual TLS, OAuth client credentials, service accounts -- здесь нет "пользователя", который приложит палец. Passkeys здесь бессмысленны. Подробнее в [[auth-sessions-jwt-tokens]] (API-токены) и будущем [[auth-api-service-patterns]].

**Shared devices.** Киоски, терминалы в аэропортах, компьютеры в библиотеках. Биометрическая аутентификация на shared device создаёт риск: passkey может остаться на устройстве, доступном следующему пользователю. Для shared devices -- одноразовые коды или QR-based аутентификация через личный телефон.

**Headless/CLI environments.** Терминал без GUI не может показать биометрический prompt или QR-код passkey. Для CLI используется Device Authorization Flow (RFC 8628): пользователь получает URL и код, открывает URL на устройстве с GUI, вводит код и авторизуется. Passkey используется на этапе авторизации через браузер, но не напрямую в CLI.

---

## Связь с другими темами

**[[authentication-authorization]]** -- hub-файл, дающий обзор AuthN vs AuthZ, основные способы аутентификации, OAuth 2.0, RBAC/ABAC. Текущий материал углубляет конкретные механизмы подтверждения личности: password hashing, MFA, WebAuthn, passkeys. Рекомендуется как prerequisite -- без понимания общей картины детали теряют контекст.

**[[auth-sessions-jwt-tokens]]** -- разбирает, что происходит ПОСЛЕ аутентификации: как сохранять состояние (sessions vs JWT vs opaque tokens). Passkeys и MFA определяют, КАК пользователь подтверждает личность. Sessions и JWT определяют, КАК сервер помнит об этом подтверждении между запросами. Два файла -- две стороны одного процесса.

**[[auth-enterprise-sso]]** -- MFA и passkeys в enterprise-контексте: интеграция FIDO2 с SSO (SAML, OIDC), управление passkeys через MDM, compliance-требования (SOC 2, ISO 27001). Если вы строите B2B продукт -- enterprise SSO с passkey support будет требованием крупных клиентов.

**[[security-cryptography-fundamentals]]** -- криптографический фундамент всего в этом файле: хеш-функции (SHA-256, bcrypt, Argon2) для password hashing, HMAC-SHA1 для TOTP, ECDSA/Ed25519 для WebAuthn, public-key crypto для passkeys. Без понимания криптографических примитивов passkeys остаются "магией".

**[[android-permissions-security]]** и **[[ios-permissions-security]]** -- платформенная реализация биометрии и WebAuthn. BiometricPrompt + KeyStore + Credential Manager API на Android. LAContext + Secure Enclave + AuthenticationServices на iOS. Текущий файл описывает концепции и протоколы; платформенные файлы -- конкретный код, API и подводные камни.

---

## Источники

### Bonneau, J. et al. (2012). "The Quest to Replace Passwords: A Framework for Comparative Evaluation of Web Authentication Schemes"

Фундаментальная работа от Cambridge и Microsoft Research. Авторы определили 25 свойств (usability, deployability, security), по которым оцениваются все альтернативы паролям, и проанализировали 35 схем. Ни одна не превосходила пароли по всем критериям одновременно -- что объясняет, почему замена паролей заняла десятилетия. **Почему читать:** даёт framework для оценки любого метода аутентификации -- включая passkeys. Позволяет аргументированно сравнивать подходы вместо "мне кажется, что X лучше Y".

### Grassi, P. et al. (2025). NIST SP 800-63-4 "Digital Identity Guidelines"

Обновлённый национальный стандарт: рекомендации по password hashing (Argon2id), отказ от complexity requirements и принудительной ротации, уровни аутентификации (AAL1-3), требования к phishing-resistant MFA, запрет security questions. **Почему читать:** де-факто стандарт для всей индустрии. Если вы проектируете auth-систему и не знаете NIST 800-63, вы принимаете решения вслепую.

### Brand, C. et al. (2019). W3C Web Authentication: An API for accessing Public Key Credentials

W3C Recommendation, определяющая WebAuthn API -- протокол, на котором построены passkeys. **Почему читать:** техническая спецификация на уровне отдельных полей (`PublicKeyCredentialCreationOptions`, `AuthenticatorAttestationResponse`, origin validation). Необходима при реализации серверной части WebAuthn -- библиотеки абстрагируют детали, но при отладке и security review нужно понимать протокол.

### Provos, N. & Mazieres, D. (1999). "A Future-Adaptable Password Scheme"

Оригинальная статья о bcrypt. 8 страниц, одна ключевая идея (adaptive cost factor), 27 лет релевантности. **Почему читать:** образец элегантного инженерного мышления. Авторы в 1999 году предвидели рост вычислительных мощностей и заложили механизм адаптации. Принцип "design for the future" применим далеко за пределами password hashing.

### Biryukov, A., Dinu, D., Khovratovich, D. (2015). "Argon2: the memory-hard function for password hashing and other applications"

Описание победителя Password Hashing Competition. Объясняет, почему memory-hardness критична (GPU: много ядер, мало памяти), и как Argon2 достигает настраиваемого баланса между временем, памятью и параллелизмом. **Почему читать:** для обоснования выбора параметров Argon2id в production. Без понимания trade-offs между m, t и p настройка параметров превращается в гадание.

---

*Создано: 2026-02-11*