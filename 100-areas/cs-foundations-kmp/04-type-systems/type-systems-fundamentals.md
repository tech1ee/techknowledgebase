---
title: "Type Systems: фундамент типизации"
created: 2026-01-04
modified: 2026-02-10
type: concept
status: published
tags:
  - topic/cs-foundations
  - type/concept
  - level/intermediate
related:
  - "[[generics-parametric-polymorphism]]"
  - "[[variance-covariance]]"
  - "[[type-erasure-reification]]"
prerequisites:
  - "[[compilation-pipeline]]"
---

# Type Systems: фундамент типизации

> **TL;DR:** Type system — правила присвоения типов конструкциям языка. Static typing проверяет типы при компиляции (Kotlin, Java), dynamic — при выполнении (Python, JS). Strong/weak — про неявные преобразования. Kotlin: static + strong + nominal + null safety + smart casts. Понимание типов — основа для работы с generics и expect/actual в KMP.

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **Compilation Pipeline** | Когда происходит type checking | [[compilation-pipeline]] |

---

## Терминология

| Термин | Что это | Аналогия из жизни |
|--------|---------|-------------------|
| **Type System** | Правила присвоения типов | Система категоризации товаров в магазине |
| **Static Typing** | Типы проверяются при компиляции | Проверка документов на входе в здание |
| **Dynamic Typing** | Типы проверяются при выполнении | Проверка билета при посадке в самолёт |
| **Type Inference** | Автоматическое определение типов | Продавец угадывает размер по взгляду |
| **Type Soundness** | Гарантия отсутствия type errors | Сертификат качества: "ни один бракованный товар не пройдёт" |
| **Nominal Typing** | Совместимость по имени типа | Два человека с одинаковой фамилией не родственники |
| **Structural Typing** | Совместимость по структуре | Если ходит как утка и крякает — это утка |

---

## ЧТО такое тип: формально и интуитивно

### Интуитивное понимание

Тип — это **категория значений**, определяющая, какие операции с этими значениями допустимы. Число 42 — тип Int: его можно складывать, вычитать, сравнивать. Строка "hello" — тип String: её можно конкатенировать, искать в ней подстроки, узнать длину. Функция `{x -> x + 1}` — тип `(Int) -> Int`: её можно вызвать с аргументом Int.

Аналогия из реальной жизни: в аптеке каждое лекарство имеет **категорию** (таблетки, растворы, мази). Категория определяет, что можно с ним делать: таблетки — проглотить, раствор — ввести инъекцией, мазь — нанести на кожу. Если кто-то попытается "проглотить" мазь — это ошибка типа. Система типов аптеки (категоризация + правила) предотвращает такие ошибки.

### Формальное определение

Benjamin Pierce в "Types and Programming Languages" (TAPL) — библии систем типов — даёт такое определение:

> "A type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute."

Переведём по частям:
- **Tractable syntactic method** — метод, который работает автоматически, анализируя текст программы (не запуская её)
- **Proving the absence of certain program behaviors** — доказывает, что определённые плохие вещи **не произойдут**
- **Classifying phrases according to the kinds of values** — классифицирует выражения по типам значений, которые они вычисляют

Другими словами: система типов — это **автоматическое доказательство** того, что программа не совершит определённые ошибки. Не все ошибки — но определённый класс (type errors).

### Что именно тип "говорит" о значении

Тип отвечает на три вопроса:

**1. Какие значения допустимы?** Тип `Int` допускает -2147483648 ... 2147483647 (для 32-bit). Тип `Boolean` — только `true` и `false`. Тип `String?` — любая строка или `null`.

**2. Какие операции допустимы?** Для `Int`: сложение, вычитание, сравнение. Для `String`: конкатенация, substring, length. Для `Boolean`: AND, OR, NOT.

**3. Какое представление в памяти?** `Int` — 4 байта. `Long` — 8 байт. `Boolean` — 1 байт (на JVM). Компилятор использует эту информацию для выделения памяти и оптимизации.

> **Ключевая идея:** Тип — это не "тег" на значении. Это **контракт**: "значение будет в этих пределах, и с ним можно делать эти операции". Нарушение контракта — type error.

---

## ПОЧЕМУ типы важны

### Проблема: хаос без типов

Представь код без типов. Следующий пример на JavaScript показывает, что происходит, когда язык не контролирует типы операндов.

```javascript
// JavaScript: слабая динамическая типизация
function add(a, b) {
    return a + b;   // Оператор + работает по-разному для разных типов
}

add(5, 3)        // 8 — ожидаемо
add("5", 3)      // "53" — неожиданно! Число конвертировано в строку
add({}, [])      // "[object Object]" — ???
```

Без системы типов каждая из этих строк "работает" — но результат непредсказуем. В production это означает: тихие ошибки, данные повреждены, и ты узнаёшь об этом через неделю от пользователя.

### Четыре функции системы типов

**1. Безопасность (Safety).** Ловить ошибки до выполнения. Kotlin не позволит сложить String и Int — ошибка при компиляции, не в production. Это дешевле: баг, пойманный при компиляции, стоит минуты. Баг в production — часы и деньги.

**2. Документация (Documentation).** Типы описывают намерения программиста. `fun findUser(id: Long): User?` сообщает: "принимает Long, возвращает User или null". Это лучше любого комментария — комментарий может устареть, тип проверяется компилятором.

**3. Оптимизация (Optimization).** Компилятор знает размер и layout данных. `Int` — 4 байта, можно использовать регистр процессора. Без типов (как в Python) каждое значение — объект с метаданными, и каждая операция требует dynamic dispatch.

**4. Инструментальная поддержка (Tooling).** IDE autocomplete, рефакторинг, навигация — всё основано на типах. Когда ты пишешь `user.` и IDE показывает список методов — она смотрит на тип `user`. Без типов IDE не может предложить ничего осмысленного.

### История: от Russell до Kotlin

**1908 — Bertrand Russell.** Математик Russell обнаружил парадокс в наивной теории множеств: "Множество всех множеств, не содержащих себя — содержит ли оно себя?" (Если да — то нет, если нет — то да.) Этот парадокс разрушал основы математики. Решение Russell — **теория типов**: каждый объект имеет тип (уровень), и объект не может ссылаться на объекты своего же уровня. Это предотвращает самоссылающиеся определения.

**1940 — Alonzo Church.** Church создал **simply typed lambda calculus** — формальную систему с типами. Это математическая основа для всех типизированных языков: каждая функция имеет тип "вход → выход", и типы проверяются до вычисления.

**1958-1978 — Curry, Hindley, Milner.** Haskell Curry (1958), Roger Hindley (1969) и Robin Milner (1978) разработали алгоритм **type inference** — Algorithm W. Компилятор **сам** выводит типы без explicit аннотаций. Программист пишет `let x = 42`, компилятор знает: `x: Int`. Это легло в основу ML (1973) и Haskell (1990).

**1985 — Cardelli & Wegner.** Лука Карделли и Питер Вегнер опубликовали фундаментальную статью "On Understanding Types, Data Abstraction, and Polymorphism" — систематизацию видов полиморфизма и типизации. Эта работа до сих пор цитируется как базовый фреймворк для понимания систем типов.

**2011 — Kotlin.** JetBrains создали Kotlin с современной системой типов: null safety (тип `T?` vs `T`), smart casts, type inference, declaration-site variance. Взяли лучшее из академических исследований (Milner inference, Scala variance) и применили к практике JVM-разработки.

---

## Static vs Dynamic Typing: развёрнутое сравнение

### Когда проверяются типы

Фундаментальный вопрос: **когда** система типов проверяет, что операции над значениями допустимы?

**Static typing** отвечает: **до запуска** (compile-time). Компилятор анализирует исходный код, проверяет совместимость типов, и если находит ошибку — отказывается компилировать. Программа с type error **не может быть запущена**.

Аналогия: проверка документов **на входе** в здание. Охранник смотрит паспорт. Если паспорт не тот — ты не войдёшь. Всё проверяется до того, как ты окажешься внутри.

**Dynamic typing** отвечает: **при выполнении** (runtime). Интерпретатор выполняет код строку за строкой. Когда встречает операцию — проверяет, допустима ли она для данного значения. Если нет — crash в runtime.

Аналогия: проверка билета **при посадке** в самолёт. Ты прошёл регистрацию, прошёл безопасность, дошёл до гейта — и только тут выясняется, что у тебя билет на другой рейс. Поздно. С точки зрения программирования: ты уже в production, и ошибка типа всплывает у пользователя.

### Что это значит на практике: paragraph per aspect

**Обнаружение ошибок.** В static typing ошибка типа обнаруживается **мгновенно** — при написании кода (IDE подчёркивает красным) или при компиляции. В dynamic typing ошибка обнаруживается, когда выполнение дойдёт до проблемной строки. Если строка в редко вызываемом обработчике ошибок — баг может жить в production месяцами.

**Скорость разработки.** Dynamic typing позволяет быстрее начать: не нужно объявлять типы, не нужно "уговаривать" компилятор. Это преимущество в прототипировании и скриптах. Но на дистанции static typing выигрывает: меньше багов, лучше рефакторинг, безопаснее изменения. Исследование Hanenberg et al. (2014) показало, что static typing сокращает время отладки на 15-20%.

**Рефакторинг.** В static typing переименование метода — безопасная операция. IDE находит все вызовы и обновляет их. Компилятор гарантирует: если проект собирается — все вызовы корректны. В dynamic typing переименование — рискованная операция. IDE не знает точно, какие вызовы связаны (duck typing), и может пропустить. Баг всплывёт в runtime.

**Производительность.** Static typing позволяет **значительно** более агрессивную оптимизацию. Компилятор знает: `x: Int` — это 4 байта, можно положить в регистр, операция сложения — одна инструкция CPU. В dynamic typing `x` может быть чем угодно, и каждая операция требует проверки типа, boxing/unboxing, dynamic dispatch. Python в 10-100x медленнее C++ на вычислительных задачах — система типов — одна из главных причин.

**Выразительность.** Dynamic typing проще для metaprogramming и duck typing. Python decorator, который принимает любую функцию и возвращает обёрнутую — легко. В static typing аналог требует generics, higher-order functions, иногда reflection. Kotlin решает это smart casts и reified generics, но не полностью.

### Визуализация разницы

```
┌─────────────────────────────────────────────────────────────┐
│              STATIC vs DYNAMIC TYPING                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   STATIC (Kotlin):                                          │
│                                                             │
│   Source → [Compiler + Type Check] → Binary                │
│                    ↓                                        │
│               Error? STOP!                                  │
│                                                             │
│   Ошибка типа = программа не скомпилируется                │
│   Ошибка найдена ДО production                             │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   DYNAMIC (Python):                                         │
│                                                             │
│   Source → [Interpreter] → Execute line by line            │
│                                ↓                            │
│                           Error? CRASH!                     │
│                                                             │
│   Ошибка типа = программа падает В production              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Strong vs Weak Typing: ПОЧЕМУ это спектр

### Определение

**Strong typing:** Язык **не** делает неявных преобразований между несовместимыми типами. Если ты хочешь сложить строку и число — скажи **явно**, что хочешь: `int("5") + 2` или `"5" + str(2)`.

**Weak typing:** Язык **автоматически** конвертирует типы для выполнения операций. `"5" + 2` в JavaScript даёт `"52"` — JS сам решил, что число нужно конвертировать в строку.

### ПОЧЕМУ это спектр, а не бинарный выбор

Ни один язык не является "абсолютно strong" или "абсолютно weak". Даже в строго типизированном Kotlin есть неявное расширение числовых типов: `val x: Long = 42` работает, хотя 42 — это `Int`, а `x` — `Long`. Kotlin неявно конвертирует `Int → Long`, потому что это **безопасное** расширение (не теряется информация).

С другой стороны, даже JavaScript (канонически weak) не позволяет **всё**: `null.property` — TypeError. JavaScript слабо типизирован, но не анархически.

Cardelli & Wegner (1985) показали, что strength/weakness — это континуум, определяемый количеством и "прощаемостью" неявных преобразований:

```
STRONG ←──────────────────────────────────→ WEAK

Haskell  Python  Kotlin  Java  C#    C     JavaScript
  │        │       │      │     │     │        │
  │        │       │      │     │     │        └ "5"+2="52", true+true=2
  │        │       │      │     │     └ void* cast, integer overflow
  │        │       │      │     └ implicit numeric conversions
  │        │       │      └ widening primitives, autoboxing
  │        │       └ smart casts (controlled), numeric widening
  │        └ TypeError on "5"+2
  └ No implicit conversions at all
```

### Это НЕ то же самое, что static/dynamic!

Static/dynamic — про **когда** проверяются типы (compile vs runtime). Strong/weak — про **сколько** неявных преобразований допускается. Это ортогональные оси:

| Язык | Static/Dynamic | Strong/Weak |
|------|----------------|-------------|
| **Haskell** | Static | Very Strong |
| **Python** | Dynamic | Strong |
| **Kotlin** | Static | Strong |
| **Java** | Static | Mostly Strong |
| **C** | Static | Weak (pointer casts) |
| **JavaScript** | Dynamic | Weak |

Python — динамический, но строгий: не позволит `"5" + 2`, выбросит TypeError. C — статический, но слабый: позволяет `void*` cast к любому типу, целочисленное переполнение — undefined behavior. Эти два измерения **не связаны**.

---

## Nominal vs Structural vs Duck Typing

### Три способа определить: "совместимы ли типы?"

Когда компилятор встречает `fun greet(x: Named)` и вызов `greet(dog)` — он должен решить: "подходит ли `dog` для параметра `Named`?" Есть три подхода к этому вопросу.

**Nominal typing (по имени):** Типы совместимы, если **названы** одинаково или связаны наследованием. `Dog` и `Cat` могут иметь одинаковую структуру (`name: String`), но если `Dog` не наследует `Cat` — они несовместимы.

Аналогия: два человека с одинаковой фамилией Иванов — не родственники. Совпадение фамилии (структуры) не означает родство (совместимость). Родственники — только те, кто в семейном дереве (наследовании).

**Structural typing (по структуре):** Типы совместимы, если имеют одинаковую **структуру** — набор полей и методов. Неважно, как они называются — важно, что у них есть.

Аналогия: если у объекта есть поле `name: String` — он подходит туда, где ожидается `{ name: String }`. Неважно, это Dog, Cat или Robot.

**Duck typing (по поведению):** Проверка в **момент вызова**: есть ли нужный метод? "If it walks like a duck and quacks like a duck, then it must be a duck."

```
┌─────────────────────────────────────────────────────────────┐
│        КАК ОПРЕДЕЛЯЕТСЯ СОВМЕСТИМОСТЬ ТИПОВ                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   NOMINAL (Java, Kotlin):                                   │
│   "Типы совместимы, если НАЗВАНЫ одинаково или связаны     │
│    наследованием"                                           │
│                                                             │
│   STRUCTURAL (TypeScript, Go interfaces):                   │
│   "Типы совместимы, если СТРУКТУРА одинакова"              │
│                                                             │
│   DUCK (Python, JavaScript):                                │
│   "Типы совместимы, если нужные МЕТОДЫ существуют          │
│    в момент вызова"                                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### ПОЧЕМУ Kotlin выбрал nominal typing

JetBrains выбрали nominal typing для Kotlin по нескольким причинам:

**1. JVM совместимость.** JVM — nominal platform. Java использует nominal typing, и Kotlin должен seamlessly interop с Java-кодом. Structural typing потребовал бы дополнительного слоя трансляции.

**2. Ясность намерений.** Nominal typing заставляет программиста **явно** выразить отношение: `class Dog : Animal()`. Это документирует дизайн. Structural typing может привести к "случайной совместимости" — два типа совпали по структуре, но семантически они разные.

**3. Лучшие ошибки.** Если `Dog` не наследует `Animal`, ошибка ясна: "Dog is not a subtype of Animal". При structural typing ошибка может быть: "Missing method quack()" — менее информативна.

---

## Type Inference: КАК компилятор выводит типы

### Что это

Type inference — способность компилятора **автоматически определить** тип выражения без explicit аннотации от программиста. Ты пишешь `val x = 42`, компилятор знает: `x: Int`.

### КАК это работает: идея алгоритма

Алгоритм Hindley-Milner (Algorithm W, 1978) — основа type inference в большинстве языков. Упрощённо, он работает в три шага:

**Шаг 1: Генерация ограничений (constraints).** Для каждого выражения компилятор создаёт уравнение: "тип этого выражения = ?". Из `val x = 42` получаем: `type(x) = type(42)`. Из `42` знаем: `type(42) = Int`. Значит: `type(x) = Int`.

**Шаг 2: Распространение (propagation).** Ограничения распространяются по графу выражений. Если `fun add(a: Int, b: Int): Int` и `val result = add(x, 3)`, то из `add` знаем: result — Int. Если `x` передаётся как первый аргумент `add` — значит `x` тоже Int.

**Шаг 3: Унификация (unification).** Компилятор решает систему уравнений, объединяя (унифицируя) типы. Если `type(x) = T` и `T = Int`, то `type(x) = Int`. Если система уравнений не имеет решения — type error.

Аналогия: детектив собирает улики. "Подозреваемый ехал на красной машине" (ограничение 1). "Машина была седаном" (ограничение 2). "Седан был Toyota" (ограничение 3). Каждая улика сужает множество: красная → красный седан → красный Toyota седан. Если улики противоречат ("красная машина" и "синяя машина") — ошибка (type error).

```
┌─────────────────────────────────────────────────────────────┐
│                   TYPE INFERENCE                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   val x = 42                                                │
│       ↓                                                     │
│   42 — это Int literal (ограничение: type(42) = Int)       │
│       ↓                                                     │
│   x = 42, значит type(x) = type(42) = Int                  │
│       ↓                                                     │
│   val x: Int = 42   ← компилятор вывел тип                 │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   val list = listOf("a", "b")                               │
│       ↓                                                     │
│   "a", "b" — String literals                                │
│       ↓                                                     │
│   listOf<T> с String → T = String → List<String>            │
│       ↓                                                     │
│   val list: List<String>   ← выведено                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Bidirectional Inference в Kotlin

Kotlin умеет выводить типы **в обе стороны** — не только от выражения к переменной, но и от контекста использования к выражению. Следующий пример демонстрирует forward и backward inference.

```kotlin
// Forward: из выражения → в переменную
val numbers = listOf(1, 2, 3)  // List<Int>, тип выведен из аргументов

// Backward: из контекста → в лямбду
val transform: (String) -> Int = { it.length }
// Kotlin знает: it — это String, потому что тип transform уже объявлен
```

Forward inference — "стандартный" вывод: видим `listOf(1, 2, 3)` → выводим `List<Int>`. Backward inference — мощнее: Kotlin смотрит на ожидаемый тип `(String) -> Int` и **выводит**, что `it` в лямбде — `String`. Это позволяет писать компактный код без аннотаций.

---

## ПОЧЕМУ Kotlin выбрал свою систему типов

### Решения JetBrains и их мотивация

JetBrains создавали Kotlin как **прагматичный** язык для JVM. Каждое решение о системе типов — это trade-off:

**Null safety (T vs T?).** Проблема: NullPointerException — самый частый crash на Android и JVM. Тони Хоар назвал `null` "billion-dollar mistake" (1965). Решение Kotlin: **разделить nullable и non-nullable типы**. `String` — гарантированно не null. `String?` — может быть null. Компилятор проверяет при компиляции, что ты обработал null. Это убирает целый класс runtime ошибок.

**Smart casts.** Проблема: в Java после `if (obj instanceof String)` нужно явно кастить: `(String) obj`. Это дублирование — ты уже проверил, компилятор тоже знает, но заставляет писать cast. Решение Kotlin: после `if (obj is String)` компилятор автоматически "видит" `obj` как `String`. Информация из проверки используется для сужения типа.

**Declaration-site variance.** Проблема: в Java `List<Dog>` NOT IS-A `List<Animal>`, и каждый раз нужно писать `List<? extends Animal>`. Решение Kotlin: `interface List<out E>` — variance объявлена один раз, работает везде. Меньше boilerplate, меньше ошибок.

**Type inference.** Проблема: в Java `HashMap<String, List<Integer>> map = new HashMap<String, List<Integer>>()` — типы написаны дважды. Решение Kotlin: `val map = HashMap<String, List<Int>>()` — тип выводится из правой части. Или ещё короче: `val map = hashMapOf<String, List<Int>>()`.

---

## Kotlin Type System: практика

### Null Safety

Kotlin разделяет типы на **nullable** и **non-nullable**. Это не просто синтаксический сахар — это **два разных типа** в системе типов.

```kotlin
var name: String = "Alice"   // Non-nullable: null здесь НЕВОЗМОЖЕН
name = null  // Compile error! Null can not be a value of a non-null type

var nickname: String? = "Ali" // Nullable: null допустим
nickname = null  // OK
```

Компилятор отслеживает nullable/non-nullable статически. NPE ловится при компиляции, не в production.

### Smart Casts

Kotlin автоматически приводит типы после проверки. Следующий пример показывает, как smart cast автоматически сужает тип после `is`-проверки и null-проверки.

```kotlin
fun process(obj: Any) {
    if (obj is String) {
        println(obj.length)  // Smart cast: obj уже String, не Any
    }
}

fun handleNullable(name: String?) {
    if (name != null) {
        println(name.length)  // Smart cast: name уже String, не String?
    }
}
```

Smart cast работает, потому что компилятор **анализирует поток управления** (control flow analysis). После ветки `if (obj is String)` компилятор знает: в этой ветке `obj` — точно `String`. Это type narrowing — сужение типа на основе условия.

---

## Подводные камни

### Когда type inference мешает

Следующий пример показывает ситуацию, где type inference выводит неочевидный тип. Явная аннотация делает намерение программиста яснее.

```kotlin
// Неочевидный выведенный тип
val items = listOf(1, 2.0, "three")
// Тип: List<Any> — вероятно, не то что ты хотел

// Лучше explicit:
val items: List<Number> = listOf(1, 2.0, 3)
// Явно: только числа
```

Компилятор вывел `List<Any>`, потому что `Any` — ближайший общий предок `Int`, `Double` и `String`. Это технически правильно, но семантически бессмысленно. Правило: в public API всегда пиши типы явно.

### Распространённые ошибки

| Ошибка | Последствие | Решение |
|--------|-------------|---------|
| Путать static и strong | Неверные ожидания | Python — dynamic, но strong |
| Игнорировать nullable | `!!` везде → NPE | Используй safe calls `?.` |
| Over-reliance на inference | Непонятный код | Explicit типы в public API |
| Unsafe cast без проверки | ClassCastException | Используй `as?` или `is` |

### Распространённые заблуждения

**Миф:** "Static typing замедляет разработку"
**Реальность:** Начальная скорость ниже, но меньше багов и проще рефакторинг. На дистанции static typing выигрывает. Исследования показывают: проекты на static languages имеют на 15% меньше дефектов (Ray et al., 2014).

**Миф:** "Type inference = dynamic typing"
**Реальность:** Type inference — compile-time. Типы известны компилятору, просто не написаны явно. `val x = 42` — это `Int`, определённый при компиляции, не в runtime.

**Миф:** "Strong typing = больше кода"
**Реальность:** С type inference (Kotlin, Rust, Haskell) код **компактнее**, чем в слабо типизированном JS. `val x = 42` vs `var x = 42` — одинаково. Но Kotlin даёт гарантии, которых JS не даёт.

---

## Связь с другими темами

**[[generics-parametric-polymorphism]]** — generics расширяют систему типов, позволяя абстрагироваться от конкретного типа. `List<T>` — это применение parametric polymorphism к системе типов Kotlin. Без понимания основ типов (текущая статья) generics будут казаться "магией". Читай после текущей.

**[[variance-covariance]]** — variance определяет, как наследование типов "передаётся" через generics. Ковариантность и контравариантность — прямое следствие системы типов и subtyping. Requires: текущая статья + generics.

**[[type-erasure-reification]]** — что происходит с типами в runtime на JVM. Type erasure — trade-off backward compatibility, reification — Kotlin-специфичное решение. Requires: generics.

**[[compilation-pipeline]]** — type checking — одна из фаз компиляции. Понимание pipeline помогает осознать, **когда** и **как** применяются правила типов. Prerequisite для текущей статьи.

---

## Источники и дальнейшее чтение

- **Pierce, B. (2002). Types and Programming Languages (TAPL).** — Библия систем типов. От simply typed lambda calculus до System F и dependent types. Академична, но фундаментальна. Главы 1-3 доступны без математической подготовки.

- **Cardelli, L. & Wegner, P. (1985). On Understanding Types, Data Abstraction, and Polymorphism.** — Фундаментальная статья, систематизировавшая виды полиморфизма и типизации. Ввела терминологию, которой мы пользуемся до сих пор.

- **Milner, R. (1978). A Theory of Type Polymorphism in Programming.** — Оригинальная статья об Algorithm W для type inference. Заложила основы для ML, Haskell и всех языков с inference.

- **Kotlin Language Specification: Type System.** — Формальная спецификация системы типов Kotlin. Для тех, кто хочет точных определений, а не интуиции.

- **Hanenberg, S. et al. (2014). An empirical study of the impact of static typing on software maintainability.** — Эмпирическое исследование: static typing vs dynamic typing в реальных проектах.

---

*Проверено: 2026-02-10*
