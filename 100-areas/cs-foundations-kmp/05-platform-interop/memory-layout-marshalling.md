---
title: "Memory Layout и Marshalling: как данные хранятся и передаются"
created: 2026-01-04
modified: 2026-02-10
type: deep-dive
status: published
tags:
  - topic/cs-foundations
  - type/deep-dive
  - level/advanced
related:
  - "[[memory-model-fundamentals]]"
  - "[[abi-calling-conventions]]"
  - "[[ffi-foreign-function-interface]]"
prerequisites:
  - "[[memory-model-fundamentals]]"
  - "[[cpu-architecture-basics]]"
  - "[[ffi-foreign-function-interface]]"
---

# Memory Layout и Marshalling: как данные хранятся и передаются

> **TL;DR:** Memory layout определяет расположение данных в памяти. Alignment — требование размещения на адресах, кратных размеру типа (int на адресах кратных 4). Padding — "пустые" байты для выравнивания. C struct сохраняет порядок полей, JVM может переупорядочивать. Marshalling — преобразование данных между представлениями (Kotlin String → C char*). Endianness: little-endian (x86, младший байт первым), big-endian (network, старший первым).

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **Memory Model** | Stack vs heap, указатели | [[memory-model-fundamentals]] |
| **FFI** | Зачем передавать данные между языками | [[ffi-foreign-function-interface]] |

---

## Терминология

| Термин | Что это | Аналогия из жизни |
|--------|---------|-------------------|
| **Alignment** | Требование к адресу данных | Парковка: машины только в отведённых местах |
| **Padding** | Пустые байты для выравнивания | Пустые места на парковке между машинами |
| **Endianness** | Порядок байтов в числе | Порядок цифр в номере: 123 или 321 |
| **Marshalling** | Преобразование данных между форматами | Перевод документа на другой язык |
| **Blittable** | Тип с одинаковым layout везде | Универсальный штекер |

---

## Зачем это знать

Понимание memory layout — одна из тех тем, которые отделяют "программиста, пишущего код" от "программиста, понимающего, что происходит внутри компьютера". Почему `sizeof(struct)` не равен сумме размеров полей? Почему переупорядочивание полей в структуре может сэкономить мегабайты памяти? Почему один и тот же бинарный файл, записанный на Intel-машине, читается как мусор на старом PowerPC?

На практике ты столкнёшься с memory layout в трёх ситуациях. Первая — **FFI/interop**: когда Kotlin-код передаёт структуру в C-библиотеку, layout полей должен совпадать побайтно. Вторая — **оптимизация памяти**: на Android с ограниченной памятью object overhead в 12-16 байт на каждый объект JVM может превратить массив из миллиона Point(x, y) из ожидаемых 8 MB в 24 MB. Третья — **сетевые протоколы и файлы**: при записи бинарных данных на диск или отправке по сети ты обязан контролировать endianness и padding.

> **Ключевая идея:** Данные в памяти раскладываются не так, как ты ожидаешь. Между полями структуры есть "дыры" (padding), порядок байтов в числе зависит от процессора (endianness), а JVM-объекты содержат скрытый overhead. Понимание этого — ключ к эффективному использованию памяти и корректному межъязыковому взаимодействию.

---

## Историческая справка

Проблема memory layout восходит к самым ранним компьютерам. В 1960-х годах IBM System/360 установила требование alignment для типов данных: halfword (2 байта) должен лежать по чётному адресу, fullword (4 байта) — по адресу, кратному 4. Это было не прихотью инженеров, а hardware ограничением: шина памяти работала с фиксированной шириной, и невыровненный доступ требовал двух циклов вместо одного.

Проблема endianness получила своё название благодаря Дэнни Коэну (Danny Cohen), который в 1980 году написал шуточную статью "On Holy Wars and a Plea for Peace" — отсылку к "Путешествиям Гулливера" Джонатана Свифта. В книге лилипуты спорили, с какого конца разбивать яйцо — с тупого (big-end) или острого (little-end). Коэн проводил аналогию с компьютерными архитектурами, которые не могли договориться, с какого конца хранить многобайтовые числа: со старшего байта (big-endian: Motorola 68000, SPARC) или с младшего (little-endian: Intel x86). Эта статья закрепила термины "big-endian" и "little-endian" в компьютерной лексике.

Marshalling как формализованная концепция появился в контексте RPC (Remote Procedure Call) в 1980-х. Sun Microsystems создала XDR (External Data Representation) — стандарт сериализации данных для передачи между машинами с разной архитектурой. Задача была та же, что и сегодня при FFI: как передать структуру данных из одного "мира" в другой, когда представления отличаются.

Bryant и O'Hallaron в "Computer Systems: A Programmer's Perspective" (1-е издание 2003, 3-е издание 2015) дали, пожалуй, лучшее объяснение этих тем для практикующих программистов. Их подход — показать, как решения на уровне hardware влияют на код, который пишет программист, — стал стандартом для обучения systems programming.

---

## КАК данные хранятся в памяти

### Почему в памяти есть "дыры"

Представь парковку, где каждое место рассчитано на один тип транспорта: мотоцикл (1 место), легковая (2 места), грузовик (4 места). Правило: каждый транспорт должен начинать с позиции, кратной его размеру. Мотоцикл может встать куда угодно. Легковая — только на чётную позицию. Грузовик — только на позицию, кратную 4.

Если мотоцикл занял позицию 0, а за ним должна встать легковая — она не может встать на позицию 1 (нечётная). Она встаёт на позицию 2. Позиция 1 остаётся пустой. Это и есть **padding** — "дыра" в памяти, добавленная компилятором для соблюдения alignment.

Зачем эти правила? Потому что hardware оптимизировано для выровненных (aligned) чтений. Шина памяти процессора читает данные "словами" — блоками фиксированного размера (обычно 4 или 8 байт). Если 4-байтовый int лежит по адресу, кратному 4, он читается за один цикл. Если int лежит по адресу 3 — он пересекает границу между двумя "словами", и процессору нужно два чтения и склеивание результата.

## ПОЧЕМУ alignment важен

### Как CPU читает память

CPU не читает память побайтно — он читает "словами" (word), обычно 4 или 8 байт за раз:

```
┌─────────────────────────────────────────────────────────────┐
│                    CPU MEMORY ACCESS                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Память (каждая ячейка = 1 байт):                         │
│   ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐       │
│   │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │ A │ B │       │
│   └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘       │
│                                                             │
│   CPU читает 4-байтовыми словами:                          │
│   Word 0: байты 0-3                                        │
│   Word 1: байты 4-7                                        │
│   Word 2: байты 8-11                                       │
│                                                             │
│   ALIGNED int (по адресу 4):                               │
│   ┌───┬───┬───┬───┬───┬───┬───┬───┐                        │
│   │   │   │   │   │ I │ N │ T │   │  ← Один memory access  │
│   └───┴───┴───┴───┴───┴───┴───┴───┘                        │
│                   └───────────────┘                         │
│                      Word 1                                 │
│                                                             │
│   UNALIGNED int (по адресу 2):                             │
│   ┌───┬───┬───┬───┬───┬───┬───┬───┐                        │
│   │   │   │ I │ N │ T │   │   │   │  ← Два memory access!  │
│   └───┴───┴───┴───┴───┴───┴───┴───┘                        │
│           └───────┘───────┘                                 │
│            Word 0   Word 1                                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Цена unaligned access

| Платформа | Unaligned access |
|-----------|------------------|
| x86/x64 | Работает, но медленнее (2x cycles) |
| ARM (старые) | Hardware exception |
| ARM (новые) | Работает, но медленнее |
| SPARC, MIPS | Hardware exception |

**Вывод:** Компилятор добавляет padding для alignment, чтобы код был быстрым и портабельным.

---

## ЧТО такое padding

### Alignment правила

Каждый тип имеет своё требование к alignment:

| Тип | Размер | Alignment |
|-----|--------|-----------|
| `char` | 1 byte | 1 |
| `short` | 2 bytes | 2 |
| `int` | 4 bytes | 4 |
| `long` (64-bit) | 8 bytes | 8 |
| `double` | 8 bytes | 8 |
| `pointer` (64-bit) | 8 bytes | 8 |

**Правило:** Данные должны лежать по адресу, кратному их alignment.

### Padding в C struct

```c
struct Example {
    char a;     // offset 0, size 1
    int b;      // offset 4, size 4 (не 1!)
    char c;     // offset 8, size 1
};
// Размер: 12 байт (не 6!)
```

```
┌─────────────────────────────────────────────────────────────┐
│              STRUCT LAYOUT С PADDING                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   struct Example { char a; int b; char c; };               │
│                                                             │
│   Offset:  0   1   2   3   4   5   6   7   8   9  10  11   │
│          ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐ │
│          │ a │PAD│PAD│PAD│ b │ b │ b │ b │ c │PAD│PAD│PAD│ │
│          └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘ │
│                                                             │
│   Почему padding после 'a':                                │
│   - int b требует alignment 4                              │
│   - После 'a' следующий свободный адрес = 1               │
│   - 1 не кратно 4 → добавляем 3 байта padding             │
│   - b начинается с адреса 4                               │
│                                                             │
│   Почему padding после 'c' (tail padding):                 │
│   - Struct alignment = max(alignment полей) = 4           │
│   - Размер struct должен быть кратен 4                    │
│   - 9 не кратно 4 → добавляем 3 байта                     │
│   - Итоговый размер: 12                                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Оптимизация: порядок полей

```c
// ❌ Неоптимально: много padding (12 байт)
struct Bad {
    char a;    // 0
    // 3 bytes padding
    int b;     // 4-7
    char c;    // 8
    // 3 bytes padding
};

// ✅ Оптимально: минимум padding (8 байт)
struct Good {
    int b;     // 0-3
    char a;    // 4
    char c;    // 5
    // 2 bytes padding
};
```

**Правило:** Располагай поля от большего к меньшему размеру.

### Packed structs

```c
// Отключение padding (GCC/Clang)
struct __attribute__((packed)) Packed {
    char a;
    int b;
    char c;
};
// Размер: 6 байт (но unaligned access!)
```

**Когда использовать packed:**
- Сетевые протоколы с фиксированным форматом
- Чтение бинарных файлов
- Экономия памяти критична

**Риски:**
- Unaligned access → slower или exception
- Не портабельно

---

## Endianness: ПОЧЕМУ существуют оба порядка байтов

### Историческая причина

Почему вообще возникли два порядка? Это не случайность и не каприз инженеров. Big-endian и little-endian — результат разных инженерных компромиссов.

**Big-endian** (старший байт первым) — естественный порядок для человека. Число `0x12345678` хранится как `12 34 56 78` — так, как мы его пишем и читаем. Motorola выбрала этот порядок для своих процессоров 68000 (использовались в первых Macintosh), потому что он упрощал отладку: дамп памяти читался так же, как человек читает числа. Этот же порядок стал стандартом для сетевых протоколов (TCP/IP), потому что Internet разрабатывался на машинах с big-endian архитектурой.

**Little-endian** (младший байт первым) — удобен для hardware. Intel выбрал его для x86, потому что он даёт преимущество при арифметике: сложение чисел начинается с младших разрядов (как мы складываем в столбик), и little-endian позволяет начинать чтение с первого байта, не зная заранее длину числа. Кроме того, при конвертации между типами разной длины (например, int → short) в little-endian не нужно менять начальный адрес — short-представление начинается с того же адреса, просто занимает меньше байтов.

Аналогия: представь, что ты записываешь телефонный номер `+7-999-123-45-67`. Big-endian — записать слева направо, как обычно. Little-endian — записать справа налево: `76-54-321-999-7+`. Кажется безумием, но если ты машина, которая обрабатывает цифры с конца — это удобнее.

Сегодня спор практически решён: x86 и ARM (в стандартном режиме) используют little-endian, и это де-факто стандарт для потребительского hardware. Big-endian остался в сетевых протоколах (network byte order) и в некоторых специализированных процессорах. ARM поддерживает оба порядка (bi-endian), но по умолчанию работает в little-endian.

### Два мира

```
┌─────────────────────────────────────────────────────────────┐
│                    ENDIANNESS                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Число: 0x12345678                                         │
│                                                             │
│   LITTLE-ENDIAN (x86, ARM default):                        │
│   Младший байт первым                                       │
│   ┌──────┬──────┬──────┬──────┐                            │
│   │  78  │  56  │  34  │  12  │  ← Читаем справа налево    │
│   └──────┴──────┴──────┴──────┘                            │
│   Addr:  0      1      2      3                            │
│                                                             │
│   BIG-ENDIAN (Network byte order, старые SPARC):           │
│   Старший байт первым                                       │
│   ┌──────┬──────┬──────┬──────┐                            │
│   │  12  │  34  │  56  │  78  │  ← Читаем как пишем       │
│   └──────┴──────┴──────┴──────┘                            │
│   Addr:  0      1      2      3                            │
│                                                             │
│   Аналогия:                                                 │
│   - Little-endian: дата как 31.12.2025 (день первым)       │
│   - Big-endian: дата как 2025.12.31 (год первым)           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Когда endianness важен

| Сценарий | Важен? | Почему |
|----------|--------|--------|
| Локальные переменные | Нет | CPU сам знает свой endianness |
| Сетевые протоколы | Да | Network byte order = big-endian |
| Бинарные файлы | Да | Файл может быть создан на другой архитектуре |
| FFI между языками | Обычно нет | Если на одной машине, endianness одинаковый |

### Конвертация

```c
#include <arpa/inet.h>

uint32_t host_value = 0x12345678;

// Host to Network (big-endian)
uint32_t network_value = htonl(host_value);

// Network to Host
uint32_t back_to_host = ntohl(network_value);
```

---

## JVM Memory Layout

### Отличия от C

JVM управляет layout объектов сама:

```
┌─────────────────────────────────────────────────────────────┐
│                 JVM OBJECT LAYOUT                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Kotlin: data class Point(val x: Int, val y: Int)         │
│                                                             │
│   ┌─────────────────────────────────────────┐              │
│   │         OBJECT HEADER (12 bytes)        │              │
│   │ ┌─────────────────────────────────────┐ │              │
│   │ │ Mark Word (8 bytes)                 │ │              │
│   │ │ - Hash code, GC info, lock state    │ │              │
│   │ ├─────────────────────────────────────┤ │              │
│   │ │ Class Pointer (4 bytes, compressed) │ │              │
│   │ │ - Pointer to Point.class            │ │              │
│   │ └─────────────────────────────────────┘ │              │
│   ├─────────────────────────────────────────┤              │
│   │         INSTANCE DATA (8 bytes)         │              │
│   │ ┌─────────────────────────────────────┐ │              │
│   │ │ x: Int (4 bytes)                    │ │              │
│   │ ├─────────────────────────────────────┤ │              │
│   │ │ y: Int (4 bytes)                    │ │              │
│   │ └─────────────────────────────────────┘ │              │
│   ├─────────────────────────────────────────┤              │
│   │         PADDING (4 bytes)               │              │
│   │ (до кратности 8)                        │              │
│   └─────────────────────────────────────────┘              │
│                                                             │
│   Total: 24 bytes (а не 8 как в C struct!)                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### JVM может переупорядочивать поля

```kotlin
class Example {
    val a: Byte = 0
    val b: Int = 0
    val c: Byte = 0
}

// В C порядок сохранился бы: a, padding, b, c, padding = 12 bytes

// JVM может переупорядочить: b, a, c, padding = меньше padding
```

### Value Classes (Kotlin) и Project Valhalla

```kotlin
// Обычный класс — объект на heap с header
class Point(val x: Int, val y: Int)  // ~24 bytes

// Value class — инлайнится, без header
@JvmInline
value class UserId(val id: Long)  // 8 bytes, без overhead
```

**Project Valhalla (будущее Java):**
- Primitive classes без object header
- Flat arrays: `Array<Point>` хранит данные inline, не ссылки

---

## Marshalling: ПОЧЕМУ конвертация данных необходима

### Проблема: один и тот же "смысл", разное представление

Marshalling — одна из тех концепций, которые кажутся тривиальными ("просто конвертируй данные"), но на практике скрывают множество подводных камней.

Представь, что ты отправляешь рецепт торта другу в другую страну. В твоём рецепте: "200 граммов муки, 3 яйца, духовку на 180°C". Друг использует имперскую систему: ему нужны cups, ounces и Fahrenheit. Сам рецепт — тот же, но **представление** данных отличается. Без конвертации (marshalling) друг положит 200 ounces муки вместо 200 граммов — катастрофа.

В программировании то же самое. Строка "Hello" в Kotlin (JVM) — это объект на heap с заголовком, массивом UTF-16 символов, длиной, хэш-кодом. Строка "Hello" в C — это 6 байт подряд в памяти: `H e l l o \0`. Оба представляют одно и то же значение, но их бинарное представление совершенно разное. Marshalling — процесс преобразования одного представления в другое.

Почему нельзя просто передать указатель? Потому что:
1. **Разная кодировка** — UTF-16 vs UTF-8 vs ASCII. Символ "A" в UTF-16 занимает 2 байта (`0x0041`), в UTF-8 — 1 байт (`0x41`). Без конвертации C-функция прочитает каждый второй байт как нуль-терминатор и увидит строку длиной 1 символ.
2. **Разная структура** — Kotlin String содержит metadata (длина, хэш). C ожидает "голые" байты с `\0` в конце. Передача Kotlin-объекта в C-функцию — гарантированный crash.
3. **Разные heap** — JVM heap и native heap — разные области памяти, управляемые разными аллокаторами.

> **Ключевая идея:** Marshalling — это цена, которую мы платим за удобство абстракций каждого языка. Каждый язык представляет данные так, как удобно ему. Marshalling — конвертация между этими представлениями.

### Что такое marshalling

```
┌─────────────────────────────────────────────────────────────┐
│                    MARSHALLING                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   KOTLIN                                  C                 │
│   ──────                                  ─                 │
│   val name = "Alice"                      char* name        │
│                                                             │
│   Kotlin String:                          C char*:          │
│   ┌───────────────────┐                  ┌───────────────┐  │
│   │ Object Header     │                  │ 'A' │         │  │
│   │ char[] value      │    MARSHAL       │ 'l' │         │  │
│   │ offset            │ ───────────────▶ │ 'i' │         │  │
│   │ count             │                  │ 'c' │         │  │
│   │ UTF-16 encoded    │                  │ 'e' │         │  │
│   └───────────────────┘                  │ '\0'│ NULL    │  │
│                                          └───────────────┘  │
│                                          UTF-8, null-term   │
│                                                             │
│   Marshalling включает:                                     │
│   1. Конвертация кодировки (UTF-16 → UTF-8)                │
│   2. Добавление null terminator                            │
│   3. Копирование в native память                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Blittable vs Non-blittable типы

**Blittable** — типы с одинаковым layout в managed и native памяти:

| Тип | Blittable? | Почему |
|-----|------------|--------|
| `Int`, `Long`, `Float`, `Double` | Да | Одинаковое представление |
| `Boolean` | Зависит | C: может быть 1/4 bytes |
| `String` | Нет | Разное представление |
| `Array<Int>` | Нет | Header различается |
| Struct из blittable | Да | Если layout совпадает |

### Marshalling в разных FFI

**JNI:**
```c
// Получить C строку из Java String
const char* cstr = (*env)->GetStringUTFChars(env, jstr, NULL);
// Использовать...
(*env)->ReleaseStringUTFChars(env, jstr, cstr);
```

**Kotlin/Native cinterop:**
```kotlin
// Kotlin String → C string
val kotlinString = "Hello"
memScoped {
    val cString: CPointer<ByteVar> = kotlinString.cstr.ptr
    nativeFunction(cString)
}

// C string → Kotlin String
val cPointer: CPointer<ByteVar> = getNativeString()
val kotlinString = cPointer.toKString()
```

**P/Invoke (.NET):**
```csharp
// Автоматический marshalling
[DllImport("mylib")]
static extern void ProcessString(string s);

// Явный control
[DllImport("mylib")]
static extern void ProcessBytes(
    [MarshalAs(UnmanagedType.LPArray)] byte[] data,
    int length
);
```

---

## Практика: debugging memory layout

### Проверка размера и alignment в C

```c
#include <stdio.h>
#include <stddef.h>

struct Example {
    char a;
    int b;
    char c;
};

int main() {
    printf("Size: %zu\n", sizeof(struct Example));  // 12
    printf("Align: %zu\n", _Alignof(struct Example));  // 4

    printf("Offset a: %zu\n", offsetof(struct Example, a));  // 0
    printf("Offset b: %zu\n", offsetof(struct Example, b));  // 4
    printf("Offset c: %zu\n", offsetof(struct Example, c));  // 8
}
```

### JVM: JOL (Java Object Layout)

```kotlin
// Gradle: implementation("org.openjdk.jol:jol-core:0.17")

import org.openjdk.jol.info.ClassLayout

data class Point(val x: Int, val y: Int)

fun main() {
    println(ClassLayout.parseClass(Point::class.java).toPrintable())
}

// Output показывает точный layout объекта
```

---

## Подводные камни

### Распространённые ошибки

| Ошибка | Последствие | Решение |
|--------|-------------|---------|
| Игнорирование padding | sizeof() != sum(fields) | Использовать sizeof() |
| Packed struct по сети | Unaligned access на receiver | Использовать packed везде |
| Endianness в binary files | Мусорные данные на другой архитектуре | Явная конвертация |
| Marshalling без освобождения | Memory leak | Парные операции |

### Мифы и заблуждения

**Миф:** "Размер struct = сумма размеров полей"
**Реальность:** Padding может значительно увеличить размер. `sizeof(struct)` единственный способ узнать реальный размер.

**Миф:** "Endianness важен только для сетевого программирования"
**Реальность:** Важен для любых бинарных файлов, memory-mapped данных и кросс-платформенного кода.

**Миф:** "JVM объекты занимают столько же места, сколько данные"
**Реальность:** Object header добавляет 12-16 байт к каждому объекту плюс alignment до 8 байт.

---

## Распространённые заблуждения

**Заблуждение:** "Размер struct = сумма размеров полей"
**Реальность:** Padding может значительно увеличить размер. `sizeof(struct)` — единственный способ узнать реальный размер. Struct `{char a; int b; char c;}` занимает 12 байт, а не 6. Более того, порядок полей влияет на размер: `{int b; char a; char c;}` — всего 8 байт. Это одна из немногих оптимизаций, которую C-компилятор **не делает автоматически**, потому что стандарт C гарантирует сохранение порядка полей в struct.

**Заблуждение:** "Endianness важен только для сетевого программирования"
**Реальность:** Endianness важен для любых бинарных файлов, memory-mapped данных и кросс-платформенного кода. Если ты записал бинарный файл на x86 (little-endian) и пытаешься прочитать его на big-endian машине без конвертации — все числа будут искажены. Форматы файлов (PNG, WAV, ELF) явно специфицируют endianness, чтобы избежать этой проблемы.

**Заблуждение:** "JVM объекты занимают столько же памяти, сколько данные"
**Реальность:** Object header добавляет 12-16 байт к каждому объекту, плюс alignment до кратности 8 байт. `data class Point(val x: Int, val y: Int)` — 8 байт данных, но 24 байта реально. На миллионе объектов это 24 MB вместо 8 MB. Value classes и Project Valhalla адресуют эту проблему, но до их повсеместного внедрения overhead остаётся реальностью.

**Заблуждение:** "Marshalling — это просто копирование байтов"
**Реальность:** Для blittable типов (int, float, double) — да, это простое копирование. Но для строк — это конвертация кодировки (UTF-16 → UTF-8), добавление нуль-терминатора, аллокация native памяти. Для структур — это учёт padding, alignment, endianness. Marshalling сложной структуры с вложенными строками и массивами может занимать больше времени, чем сама операция, ради которой он делается.

---

## Связь с другими темами

**[[memory-model-fundamentals]]** — memory layout — это конкретизация модели памяти. Модель памяти объясняет, ЧТО такое stack и heap. Memory layout объясняет, КАК именно данные раскладываются внутри этих областей. Рекомендуется прочитать memory model сначала.

**[[abi-calling-conventions]]** — ABI определяет alignment и layout на уровне платформы. Знание ABI объясняет, ПОЧЕМУ alignment на x86 один (4 байта для int), а на ARM другой. ABI также определяет, как структуры передаются через регистры и стек.

**[[ffi-foreign-function-interface]]** — marshalling — центральная проблема FFI. Эта статья объясняет КАК данные раскладываются в памяти и ПОЧЕМУ marshalling необходим. FFI объясняет, В КАКОМ контексте marshalling происходит.

**[[cpu-architecture-basics]]** — alignment существует из-за того, как CPU обращается к памяти (word-aligned чтения, cache lines). Понимание CPU объясняет, ЗАЧЕМ padding нужен на hardware уровне.

---

## Источники и дальнейшее чтение

- Bryant, R. & O'Hallaron, D. (2015). *Computer Systems: A Programmer's Perspective*. — Глава 3 подробно разбирает data alignment и byte ordering (endianness) с примерами на реальном hardware. Глава 12 объясняет, как network byte order используется в socket programming. Лучший учебник для понимания связи hardware и software.
- Cohen, D. (1981). *On Holy Wars and a Plea for Peace* (IEN 137). — Историческая статья, давшая название проблеме endianness. Короткая и остроумная — обязательна к прочтению для контекста.
- [Eric S. Raymond: The Lost Art of Structure Packing](http://www.catb.org/esr/structure-packing/) — самое полное и практичное руководство по layout C-структур, padding и оптимизации размера. Объясняет правила, которые компилятор применяет, с конкретными примерами.
- [Aleksey Shipilev: JVM Anatomy Quarks #24](https://shipilev.net/jvm/anatomy-quarks/24-object-alignment/) — глубокий разбор layout JVM-объектов от ведущего разработчика OpenJDK. Показывает, как object header, alignment и compressed oops влияют на реальное потребление памяти.
- Patterson, D. & Hennessy, J. (2017). *Computer Organization and Design*. — Объясняет alignment с точки зрения hardware: почему шина памяти работает с выровненными адресами и какова цена unaligned access на разных архитектурах.

---

*Проверено: 2026-02-10*
