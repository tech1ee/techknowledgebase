---
title: "OS Fundamentals: что должен знать разработчик"
created: 2026-01-04
modified: 2026-02-10
type: deep-dive
status: published
tags:
  - topic/cs-foundations
  - type/deep-dive
  - level/intermediate
related:
  - "[[cpu-architecture-basics]]"
  - "[[processes-threads-fundamentals]]"
  - "[[memory-model-fundamentals]]"
prerequisites:
  - "[[cpu-architecture-basics]]"
---

# OS Fundamentals: что должен знать разработчик

> **TL;DR:** ОС управляет hardware и предоставляет абстракции программам. Kernel mode (ring 0) — полный доступ к hardware. User mode (ring 3) — ограниченный. System calls — контролируемый интерфейс user↔kernel (~100-1000 ns). Mode switch дешевле context switch (~1-10 μs). Virtual memory изолирует процессы. Каждый процесс видит своё адресное пространство 0x0...0xFFFFFFFF, но physical memory разная.

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **CPU Architecture** | Как CPU выполняет инструкции | [[cpu-architecture-basics]] |
| **Memory Model** | Stack, heap, адресация | [[memory-model-fundamentals]] |

---

## Терминология

| Термин | Что это | Аналогия из жизни |
|--------|---------|-------------------|
| **Kernel** | Ядро ОС, управляет всем | Администрация здания |
| **User space** | Где работают программы | Офисы в здании |
| **System call** | Запрос к kernel | Заявка в администрацию |
| **Process** | Запущенная программа | Сотрудник в офисе |
| **Virtual memory** | Иллюзия своей памяти | Номер комнаты (не физический адрес) |

---

## Зачем это знать

Операционная система — невидимый посредник между твоим кодом и hardware. Каждый раз, когда ты открываешь файл, создаёшь поток, выделяешь память, отправляешь сетевой запрос — ты обращаешься к ОС. И каждое такое обращение имеет цену: от 100 наносекунд для простого syscall до 10 микросекунд для context switch.

Для мобильного разработчика это критично. Android и iOS — полноценные операционные системы. Когда ты видишь "ANR" (Application Not Responding) на Android или freeze на iOS — это часто результат слишком частых обращений к ОС (I/O в main thread), неправильного управления процессами или непонимания того, как ОС распределяет CPU время.

Без понимания ОС ты не сможешь объяснить: почему `Thread.sleep(1)` спит не 1 миллисекунду, а 10-15 (гранулярность планировщика). Почему создание 10 000 потоков медленнее, чем 100 потоков с корутинами (стоимость context switch). Почему приложение крашится с "Too many open files" (лимит file descriptors). Всё это — вопросы ОС.

> **Ключевая идея:** ОС — арбитр между программами и hardware. Она не "помогает" — она **управляет**. Каждый ресурс (CPU, память, файлы, сеть) контролируется ОС, и понимание её правил — ключ к предсказуемому поведению программ.

---

## Историческая справка

Первые компьютеры (1940-50-е) не имели операционных систем. Программист загружал программу вручную (перфокарты), запускал, забирал результат. Машина выполняла одну программу от начала до конца.

В 1960-х появились **batch systems**: оператор загружал пачку программ, и компьютер выполнял их последовательно. Но CPU простаивал, ожидая ввод-вывод (чтение с ленты, печать). Это привело к идее **multiprogramming**: пока одна программа ждёт I/O, CPU переключается на другую.

**Unix** (1969, Ken Thompson и Dennis Ritchie, Bell Labs) стал революцией: первая ОС, написанная преимущественно на C (а не на ассемблере), с чёткой концепцией процессов, файловой системы и межпроцессного взаимодействия. Философия Unix — "всё есть файл" — до сих пор определяет дизайн Linux и macOS.

**Linux** (1991, Linus Torvalds) — свободная реализация Unix-подобной ОС. Сегодня Linux работает на 90%+ серверов, всех Android-устройствах и большинстве embedded-систем. Robert Love в книге "Linux Kernel Development" (2010) дал одно из лучших объяснений внутренних механизмов Linux для практикующих программистов.

Andrew Tanenbaum, автор учебника "Modern Operating Systems" (1-е издание 1992, 4-е издание 2014), создал Minix — учебную ОС, которая вдохновила Линуса Торвальдса на создание Linux. Его учебник до сих пор считается стандартным для изучения ОС в университетах.

---

## ПОЧЕМУ понимать ОС

### Проблема: "магические" ограничения

```kotlin
// Почему файл нельзя открыть?
val file = File("/etc/shadow")
file.readText()  // PermissionDeniedException

// Почему процесс крашится при доступе к памяти?
val ptr = 0x12345678.toCPointer<IntVar>()
ptr?.pointed?.value  // SIGSEGV

// Почему fork() создаёт копию?
// Почему есть лимит на open files?
```

Понимание ОС объясняет эти "магические" ограничения.

---

## ЧТО такое операционная система

### Две главные роли

```
┌─────────────────────────────────────────────────────────────┐
│                 ДВЕ РОЛИ ОС                                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. АБСТРАКЦИЯ HARDWARE                                   │
│      Программа:  file.read()                               │
│                     ↓                                       │
│      ОС:         syscall read → disk driver → hardware     │
│                                                             │
│      Программе не нужно знать:                             │
│      - Тип диска (SSD/HDD/NVMe)                            │
│      - Протокол (SATA/PCIe)                                │
│      - Физические адреса секторов                          │
│                                                             │
│   2. УПРАВЛЕНИЕ РЕСУРСАМИ                                  │
│      - CPU time между процессами                           │
│      - Memory allocation                                    │
│      - Доступ к устройствам                                │
│      - Файловая система                                     │
│      - Сеть                                                 │
│                                                             │
│   ОС — арбитр между программами и hardware                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Kernel Mode vs User Mode

### Два режима CPU

```
┌─────────────────────────────────────────────────────────────┐
│              PROTECTION RINGS (x86)                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│              ┌───────────────────────┐                     │
│              │                       │                     │
│              │      Ring 3           │ ← USER MODE         │
│              │   User Applications   │   - Ограниченные    │
│              │   (Kotlin, Python)    │     инструкции      │
│              │                       │   - Своя память      │
│              ├───────────────────────┤                     │
│              │                       │                     │
│              │      Ring 0           │ ← KERNEL MODE       │
│              │   Operating System    │   - Все инструкции   │
│              │   Kernel              │   - Вся память       │
│              │                       │   - Прямой доступ    │
│              └───────────────────────┘     к hardware      │
│                                                             │
│   Ring 1, 2 обычно не используются (гипервизоры иногда)   │
│                                                             │
│   Почему разделение:                                        │
│   - Изоляция: баг в программе не крашит всю систему        │
│   - Безопасность: программа не может читать чужую память   │
│   - Стабильность: kernel контролирует доступ к hardware    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Что можно в каждом режиме

| Операция | User Mode | Kernel Mode |
|----------|-----------|-------------|
| Вычисления (add, mul) | ✓ | ✓ |
| Доступ к своей памяти | ✓ | ✓ |
| Доступ к чужой памяти | ✗ | ✓ |
| I/O инструкции (in, out) | ✗ | ✓ |
| Изменение page tables | ✗ | ✓ |
| Disable interrupts | ✗ | ✓ |

---

## System Calls: КАК ОС управляет ресурсами

### Аналогия: ресепшн в отеле

Syscall — лучше всего понять через аналогию с отелем. Представь пятизвёздочный отель:

- **Гости** — твои программы (user space)
- **Ресепшн** — интерфейс syscall
- **Персонал (горничные, повара, электрики)** — ядро ОС (kernel)
- **Комнаты, еда, электричество** — ресурсы (файлы, память, сеть)

Гость не может сам пойти на кухню и приготовить еду. Он не может сам починить проводку. Он идёт на ресепшн, оставляет заявку (syscall), и персонал выполняет её. Это не ограничение — это **защита**: представь, что каждый гость ходит на кухню и готовит что хочет. Пожар на третий день гарантирован.

Так же работают syscalls: программа не может напрямую обращаться к диску, сетевой карте или другому оборудованию. Она просит kernel через строго определённый интерфейс. Kernel проверяет права (имеет ли гость право на room service?), выполняет операцию и возвращает результат.

Почему нельзя обойтись без syscalls? Потому что без посредника (kernel) одна программа могла бы прочитать файлы другой, захватить весь CPU, или повредить hardware. Syscall — это и защита, и абстракция одновременно.

Стоимость syscall — переключение из user mode в kernel mode (mode switch). Это ~100-1000 наносекунд, что кажется мелочью, но в tight loop из миллиона итераций — это 100-1000 миллисекунд дополнительных задержек. Поэтому библиотеки (libc, Java NIO) буферизируют операции: вместо 1000 отдельных read syscalls — один read на 1000 элементов.

### Как работают syscalls

```
┌─────────────────────────────────────────────────────────────┐
│                 SYSTEM CALL FLOW                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   USER SPACE                                                │
│   ──────────                                                │
│   val content = file.readText()                            │
│         │                                                   │
│         ▼                                                   │
│   libc: read(fd, buffer, size)                             │
│         │                                                   │
│         ▼                                                   │
│   syscall instruction (переход в kernel)                   │
│   ═══════════════════════════════════════                  │
│                                                             │
│   KERNEL SPACE                                              │
│   ────────────                                              │
│         │                                                   │
│         ▼                                                   │
│   1. Сохранить user регистры                               │
│   2. Переключить stack на kernel stack                     │
│   3. Найти handler по syscall number                       │
│         │                                                   │
│         ▼                                                   │
│   sys_read():                                               │
│   - Проверить права доступа                                │
│   - Найти файл по fd                                       │
│   - Читать данные через driver                             │
│   - Скопировать в user buffer                              │
│         │                                                   │
│         ▼                                                   │
│   4. Восстановить user регистры                            │
│   5. sysret instruction (возврат в user)                   │
│   ═══════════════════════════════════════                  │
│                                                             │
│   USER SPACE                                                │
│         │                                                   │
│         ▼                                                   │
│   content теперь содержит данные файла                     │
│                                                             │
│   Время: ~100-1000 ns (без I/O wait)                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Категории syscalls

| Категория | Syscalls | Что делают |
|-----------|----------|------------|
| **Файлы** | open, read, write, close | I/O с файлами |
| **Процессы** | fork, exec, exit, wait | Управление процессами |
| **Память** | mmap, brk, mprotect | Выделение памяти |
| **Сеть** | socket, connect, send, recv | Сетевой I/O |
| **Сигналы** | kill, signal, sigaction | Межпроцессная коммуникация |

### Пример: что происходит при open()

```kotlin
// Kotlin/Native
val fd = open("/tmp/test.txt", O_RDONLY)
```

Kernel выполняет:
1. Проверить права пользователя на файл
2. Найти inode файла в файловой системе
3. Создать file descriptor в таблице процесса
4. Вернуть номер fd пользователю

---

## Mode Switch vs Context Switch

### Разница

```
┌─────────────────────────────────────────────────────────────┐
│          MODE SWITCH vs CONTEXT SWITCH                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   MODE SWITCH (syscall):                                   │
│   ┌─────────────────────────────────────────┐              │
│   │ Process A                               │              │
│   │ ┌─────────┐    ┌─────────┐    ┌───────┐│              │
│   │ │  User   │───▶│ Kernel  │───▶│ User  ││              │
│   │ │  mode   │    │  mode   │    │ mode  ││              │
│   │ └─────────┘    └─────────┘    └───────┘│              │
│   └─────────────────────────────────────────┘              │
│   Тот же процесс, меняется только privilege level          │
│   Время: ~100-1000 ns                                      │
│                                                             │
│   ─────────────────────────────────────────────────────    │
│                                                             │
│   CONTEXT SWITCH (scheduler):                              │
│   ┌─────────────┐              ┌─────────────┐             │
│   │ Process A   │              │ Process B   │             │
│   │ ┌─────────┐ │   Switch     │ ┌─────────┐ │             │
│   │ │ Running │ │ ──────────▶  │ │ Running │ │             │
│   │ └─────────┘ │   Save A     │ └─────────┘ │             │
│   │  Saved     │   Load B     │             │             │
│   └─────────────┘              └─────────────┘             │
│   Полная смена контекста:                                  │
│   - Регистры                                               │
│   - Page tables (TLB flush)                                │
│   - Kernel stack                                           │
│   Время: ~1-10 μs                                          │
│                                                             │
│   Context switch ~10-100x дороже mode switch               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Когда происходит context switch

- Timer interrupt (time slice закончился)
- Процесс блокируется (I/O wait)
- Процесс завершается
- Более приоритетный процесс готов

### ЧТО происходит при context switch и ПОЧЕМУ это дорого

Context switch — одна из самых "дорогих" операций ОС. Чтобы понять почему, разберём, что именно происходит при переключении с процесса A на процесс B.

**Шаг 1: Сохранение состояния процесса A.** Kernel должен сохранить **все** регистры процессора (на x86-64 это 16 general-purpose регистров + flags + instruction pointer + сегментные регистры + FPU/SSE/AVX-регистры). Это ~1-2 KB данных, которые записываются в PCB (Process Control Block) процесса A.

**Шаг 2: Переключение адресного пространства.** Kernel загружает новый page table pointer (регистр CR3 на x86). Это мгновенная операция, но она имеет **катастрофические последствия** для кэша.

**Шаг 3: Сброс TLB (Translation Lookaside Buffer).** TLB — кэш трансляций виртуальных адресов в физические. После переключения page tables все записи TLB устаревают. Первые обращения к памяти процесса B будут TLB miss — каждый стоит ~10-100 ns, пока TLB не "прогреется" снова.

**Шаг 4: Восстановление состояния процесса B.** Загрузка всех регистров из PCB процесса B.

**Шаг 5: "Холодный" кэш.** Данные процесса A, которые были в L1/L2/L3 кэшах, бесполезны для процесса B. Кэш фактически "холодный" — первые обращения к данным процесса B будут cache miss. Это называется **cache pollution**, и это главная причина, почему context switch такой дорогой.

Аналогия: представь, что ты работаешь за столом, где все нужные документы разложены перед тобой. Context switch — это когда тебя просят встать, убрать все документы в шкаф, достать другой набор документов и начать другую задачу. Само перекладывание занимает минуту, но потом ещё 5 минут уходит на то, чтобы "войти в контекст" новой задачи — найти нужные страницы, вспомнить, на чём остановился.

> **Ключевая идея:** Прямая стоимость context switch — 1-10 микросекунд (сохранение/восстановление регистров, смена page table). Но **косвенная стоимость** (TLB flush + cache pollution) может составлять 100+ микросекунд. Именно поэтому 10 000 потоков с частым переключением медленнее, чем 100 потоков с корутинами.

Именно стоимость context switch объясняет, почему Kotlin coroutines и async/await эффективнее, чем потоки для I/O-bound задач. Корутины переключаются **внутри** одного потока ОС — без mode switch, без TLB flush, без cache pollution. Это переключение контекста на уровне приложения (~10-100 ns), а не на уровне ОС (~1-10+ μs).

---

## Virtual Memory: ПОЧЕМУ иллюзия необходима

### Проблема без виртуальной памяти

Представь коммунальную квартиру без дверей. Все живут в одном пространстве, все вещи лежат вместе. Один жилец случайно (или намеренно) испортил вещи другого. Никакой изоляции, никакой безопасности.

До виртуальной памяти так работали компьютеры: все программы видели одну и ту же физическую память. Если программа A писала по адресу 0x1000, а программа B тоже использовала адрес 0x1000 — одна из них перезаписывала данные другой. Crash, потеря данных, непредсказуемое поведение.

Виртуальная память решает эту проблему элегантно: каждый процесс получает **свою виртуальную адресную пространство**. Процесс A видит адреса 0x0000...0xFFFF, процесс B видит свои адреса 0x0000...0xFFFF, но физически это разные области RAM. Перевод виртуальных адресов в физические делает hardware (MMU — Memory Management Unit) при каждом обращении к памяти.

Аналогия: номера комнат в отеле. В каждом отеле есть комната 101. Но физически это разные комнаты в разных зданиях. Гость в отеле A не может случайно зайти в комнату 101 отеля B, даже если номера одинаковые.

Подробности реализации виртуальной памяти (page tables, TLB, page faults, demand paging) разобраны в [[os-memory-management]]. Здесь важно понять ЗАЧЕМ она нужна: изоляция, простота (каждый процесс "начинает" с адреса 0), гибкость (физическая память может быть фрагментирована) и возможность использовать больше памяти, чем есть физически (swap на диск).

### Каждый процесс думает, что один

```
┌─────────────────────────────────────────────────────────────┐
│                 VIRTUAL MEMORY                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   PROCESS A видит:          PROCESS B видит:               │
│   ┌────────────────┐        ┌────────────────┐             │
│   │ 0xFFFFFFFF     │        │ 0xFFFFFFFF     │             │
│   │ Kernel space   │        │ Kernel space   │             │
│   ├────────────────┤        ├────────────────┤             │
│   │ Stack          │        │ Stack          │             │
│   │       ↓        │        │       ↓        │             │
│   │                │        │                │             │
│   │       ↑        │        │       ↑        │             │
│   │ Heap           │        │ Heap           │             │
│   ├────────────────┤        ├────────────────┤             │
│   │ Data           │        │ Data           │             │
│   ├────────────────┤        ├────────────────┤             │
│   │ Code           │        │ Code           │             │
│   │ 0x00000000     │        │ 0x00000000     │             │
│   └────────────────┘        └────────────────┘             │
│          │                          │                       │
│          ▼                          ▼                       │
│   ┌─────────────────────────────────────────┐              │
│   │           PAGE TABLES                    │              │
│   │  Virtual → Physical mapping              │              │
│   └─────────────────────────────────────────┘              │
│                    │                                        │
│                    ▼                                        │
│   ┌─────────────────────────────────────────┐              │
│   │         PHYSICAL MEMORY (RAM)            │              │
│   │  ┌────┬────┬────┬────┬────┬────┬────┐   │              │
│   │  │ A  │ B  │ A  │ OS │ B  │ A  │ B  │   │              │
│   │  └────┴────┴────┴────┴────┴────┴────┘   │              │
│   └─────────────────────────────────────────┘              │
│                                                             │
│   A и B видят "свои" адреса, но physical memory разная     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Преимущества virtual memory

| Преимущество | Описание |
|--------------|----------|
| **Изоляция** | Процесс не может читать память другого |
| **Простота** | Программа думает, что память с 0x0 |
| **Flexibility** | Physical memory может быть fragmented |
| **Больше памяти** | Swap на диск, когда RAM полная |
| **Sharing** | Одна physical page для нескольких процессов (shared libs) |

---

## Process Management

### Что такое процесс

```
┌─────────────────────────────────────────────────────────────┐
│               PROCESS CONTROL BLOCK (PCB)                   │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌─────────────────────────────────────────┐              │
│   │ PID: 1234                               │              │
│   │ State: RUNNING | WAITING | READY | ...  │              │
│   ├─────────────────────────────────────────┤              │
│   │ Registers:                              │              │
│   │   RAX, RBX, ..., RIP, RSP, RFLAGS      │              │
│   ├─────────────────────────────────────────┤              │
│   │ Memory:                                 │              │
│   │   Page table pointer (CR3)              │              │
│   │   Virtual memory regions                │              │
│   ├─────────────────────────────────────────┤              │
│   │ Files:                                  │              │
│   │   fd 0 → stdin                          │              │
│   │   fd 1 → stdout                         │              │
│   │   fd 2 → stderr                         │              │
│   │   fd 3 → /tmp/file.txt                  │              │
│   ├─────────────────────────────────────────┤              │
│   │ Scheduling:                             │              │
│   │   Priority, time slice used, etc.       │              │
│   └─────────────────────────────────────────┘              │
│                                                             │
│   Kernel хранит PCB для каждого процесса                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Fork/Exec: создание процессов (Unix)

```
┌─────────────────────────────────────────────────────────────┐
│                    FORK + EXEC                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Parent (PID 100)           Child (PID 101)               │
│   ┌──────────────┐                                         │
│   │ Running code │                                         │
│   │      │       │                                         │
│   │  fork()      │                                         │
│   │      │       │                                         │
│   │      ├───────┼──────────▶ ┌──────────────┐            │
│   │      │       │            │ Копия parent │            │
│   │      │       │            │ (Copy-on-Write)│            │
│   │      ▼       │            │      │       │            │
│   │ fork() = 101 │            │ fork() = 0   │            │
│   │ (child PID)  │            │ (I am child) │            │
│   │      │       │            │      │       │            │
│   │   wait()     │            │  exec("/bin/ls")          │
│   │      │       │            │      │       │            │
│   │      │       │            │  ┌───────────┐            │
│   │      │       │            │  │ ls binary │            │
│   │      │       │            │  │ running   │            │
│   │      │       │            │  └───────────┘            │
│   │      │       │            │      │       │            │
│   │      │       │            │   exit(0)    │            │
│   │   continue   │◀───────────│              │            │
│   └──────────────┘                                         │
│                                                             │
│   fork(): создаёт копию процесса                           │
│   exec(): заменяет код новой программой                    │
│   wait(): ждёт завершения child                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Практика: наблюдение за процессами

### Linux команды

```bash
# Список процессов
ps aux

# Дерево процессов
pstree

# Открытые файлы процесса
lsof -p <pid>

# System calls процесса
strace -p <pid>

# Memory mapping
cat /proc/<pid>/maps
```

### Kotlin/Native: работа с процессами

```kotlin
import platform.posix.*

fun main() {
    val pid = fork()

    when {
        pid < 0 -> println("Fork failed")
        pid == 0 -> {
            // Child process
            println("Child: my PID is ${getpid()}")
            exit(0)
        }
        else -> {
            // Parent process
            println("Parent: child PID is $pid")
            waitpid(pid, null, 0)
            println("Parent: child finished")
        }
    }
}
```

---

## Подводные камни

### Распространённые ошибки

| Ошибка | Последствие | Решение |
|--------|-------------|---------|
| Слишком много syscalls | Performance overhead | Batch operations, буферизация |
| Zombie processes | Resource leak | wait() для children |
| File descriptor leak | "Too many open files" | Закрывать fd, use-after-close check |
| Игнорирование SIGCHLD | Zombies | Handle или ignore |
| I/O в main thread | ANR / UI freeze | Async I/O, worker threads |

### Распространённые заблуждения

**Заблуждение:** "Syscalls бесплатны — ОС всё оптимизирует"
**Реальность:** Каждый syscall — mode switch (~100-1000 ns). 10 000 мелких read() syscalls занимают 1-10 мс чистого overhead. Один read() на 10 000 элементов — ~100 ns overhead. Буферизация может ускорить I/O на порядок.

**Заблуждение:** "fork() копирует всю память процесса"
**Реальность:** Современные ОС используют Copy-on-Write (CoW): при fork() страницы памяти **не копируются**, а помечаются как shared. Копирование происходит только при попытке записи — и только для изменённых страниц. fork() процесса с 1 GB памяти занимает ~1 ms, а не секунды.

**Заблуждение:** "Context switch — это просто сохранение/восстановление регистров"
**Реальность:** Прямая стоимость (регистры) — малая часть. Основная стоимость — **косвенная**: TLB flush, cache pollution, pipeline flush. После context switch процессор работает медленнее на протяжении сотен микросекунд, пока кэши не "прогреются". Вот почему 10 000 потоков с частым переключением могут быть медленнее 100 потоков.

**Заблуждение:** "Virtual memory = swap, и это плохо"
**Реальность:** Swap (подкачка с диска) — лишь одна из функций виртуальной памяти. Основные функции — изоляция процессов, абстракция адресного пространства и shared memory. Виртуальная память работает даже когда swap отключён.

---

## Связь с другими темами

**[[cpu-architecture-basics]]** — ОС управляет CPU (scheduling), а CPU предоставляет механизмы для ОС (protection rings, MMU, timer interrupts). Без понимания CPU невозможно понять, ПОЧЕМУ mode switch и context switch имеют такую стоимость. Рекомендуется прочитать CPU сначала.

**[[processes-threads-fundamentals]]** — эта статья объясняет, КАК ОС управляет процессами на системном уровне. Processes-threads объясняет, КАК использовать процессы и потоки на уровне программиста — создание, синхронизация, типичные паттерны.

**[[memory-model-fundamentals]]** — виртуальная память — расширение модели памяти. Memory model объясняет stack и heap внутри одного процесса. Эта статья объясняет, как ОС создаёт иллюзию отдельного адресного пространства для каждого процесса. Подробности реализации (page tables, TLB) — в [[os-memory-management]].

**[[os-memory-management]]** — детальный разбор виртуальной памяти: page tables, page faults, demand paging, swapping, memory-mapped files. Если эта статья даёт overview ("ЗАЧЕМ виртуальная память"), то os-memory-management даёт deep dive ("КАК она реализована").

---

## Источники и дальнейшее чтение

- Tanenbaum, A. (2014). *Modern Operating Systems* (4th edition). — Стандартный учебник по операционным системам. Главы о процессах, виртуальной памяти и файловых системах написаны исключительно понятно, с историческим контекстом и примерами из реальных ОС (Linux, Windows). Лучшая книга для первого знакомства.
- Love, R. (2010). *Linux Kernel Development* (3rd edition). — Практическая книга о внутренностях Linux kernel. Главы о scheduling, system calls и memory management объясняют, как теоретические концепции из учебника Tanenbaum реализованы в реальной ОС. Отличное дополнение к теории.
- Silberschatz, A. et al. (2018). *Operating System Concepts* (10th edition). — Альтернативный учебник, хорош для сравнения подходов. Особенно сильны главы о синхронизации и deadlock.
- Bryant, R. & O'Hallaron, D. (2015). *Computer Systems: A Programmer's Perspective*. — Главы 8 (Exceptional Control Flow) и 9 (Virtual Memory) объясняют syscalls и виртуальную память с позиции программиста, не системного администратора. Практичный подход с примерами на C.

---

*Проверено: 2026-02-10*
