---
title: "OS Fundamentals: что должен знать разработчик"
created: 2026-01-04
modified: 2026-01-04
type: deep-dive
tags: [cs-foundations, appendix, os, kernel, syscall, processes]
related:
  - "[[cpu-architecture-basics]]"
  - "[[processes-threads-fundamentals]]"
  - "[[memory-model-fundamentals]]"
---

# OS Fundamentals: что должен знать разработчик

> **TL;DR:** ОС управляет hardware и предоставляет абстракции программам. Kernel mode (ring 0) — полный доступ к hardware. User mode (ring 3) — ограниченный. System calls — контролируемый интерфейс user↔kernel (~100-1000 ns). Mode switch дешевле context switch (~1-10 μs). Virtual memory изолирует процессы. Каждый процесс видит своё адресное пространство 0x0...0xFFFFFFFF, но physical memory разная.

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **CPU Architecture** | Как CPU выполняет инструкции | [[cpu-architecture-basics]] |
| **Memory Model** | Stack, heap, адресация | [[memory-model-fundamentals]] |

---

## Терминология

| Термин | Что это | Аналогия из жизни |
|--------|---------|-------------------|
| **Kernel** | Ядро ОС, управляет всем | Администрация здания |
| **User space** | Где работают программы | Офисы в здании |
| **System call** | Запрос к kernel | Заявка в администрацию |
| **Process** | Запущенная программа | Сотрудник в офисе |
| **Virtual memory** | Иллюзия своей памяти | Номер комнаты (не физический адрес) |

---

## ПОЧЕМУ понимать ОС

### Проблема: "магические" ограничения

```kotlin
// Почему файл нельзя открыть?
val file = File("/etc/shadow")
file.readText()  // PermissionDeniedException

// Почему процесс крашится при доступе к памяти?
val ptr = 0x12345678.toCPointer<IntVar>()
ptr?.pointed?.value  // SIGSEGV

// Почему fork() создаёт копию?
// Почему есть лимит на open files?
```

Понимание ОС объясняет эти "магические" ограничения.

---

## ЧТО такое операционная система

### Две главные роли

```
┌─────────────────────────────────────────────────────────────┐
│                 ДВЕ РОЛИ ОС                                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. АБСТРАКЦИЯ HARDWARE                                   │
│      Программа:  file.read()                               │
│                     ↓                                       │
│      ОС:         syscall read → disk driver → hardware     │
│                                                             │
│      Программе не нужно знать:                             │
│      - Тип диска (SSD/HDD/NVMe)                            │
│      - Протокол (SATA/PCIe)                                │
│      - Физические адреса секторов                          │
│                                                             │
│   2. УПРАВЛЕНИЕ РЕСУРСАМИ                                  │
│      - CPU time между процессами                           │
│      - Memory allocation                                    │
│      - Доступ к устройствам                                │
│      - Файловая система                                     │
│      - Сеть                                                 │
│                                                             │
│   ОС — арбитр между программами и hardware                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Kernel Mode vs User Mode

### Два режима CPU

```
┌─────────────────────────────────────────────────────────────┐
│              PROTECTION RINGS (x86)                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│              ┌───────────────────────┐                     │
│              │                       │                     │
│              │      Ring 3           │ ← USER MODE         │
│              │   User Applications   │   - Ограниченные    │
│              │   (Kotlin, Python)    │     инструкции      │
│              │                       │   - Своя память      │
│              ├───────────────────────┤                     │
│              │                       │                     │
│              │      Ring 0           │ ← KERNEL MODE       │
│              │   Operating System    │   - Все инструкции   │
│              │   Kernel              │   - Вся память       │
│              │                       │   - Прямой доступ    │
│              └───────────────────────┘     к hardware      │
│                                                             │
│   Ring 1, 2 обычно не используются (гипервизоры иногда)   │
│                                                             │
│   Почему разделение:                                        │
│   - Изоляция: баг в программе не крашит всю систему        │
│   - Безопасность: программа не может читать чужую память   │
│   - Стабильность: kernel контролирует доступ к hardware    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Что можно в каждом режиме

| Операция | User Mode | Kernel Mode |
|----------|-----------|-------------|
| Вычисления (add, mul) | ✓ | ✓ |
| Доступ к своей памяти | ✓ | ✓ |
| Доступ к чужой памяти | ✗ | ✓ |
| I/O инструкции (in, out) | ✗ | ✓ |
| Изменение page tables | ✗ | ✓ |
| Disable interrupts | ✗ | ✓ |

---

## System Calls: мост между мирами

### Как работают syscalls

```
┌─────────────────────────────────────────────────────────────┐
│                 SYSTEM CALL FLOW                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   USER SPACE                                                │
│   ──────────                                                │
│   val content = file.readText()                            │
│         │                                                   │
│         ▼                                                   │
│   libc: read(fd, buffer, size)                             │
│         │                                                   │
│         ▼                                                   │
│   syscall instruction (переход в kernel)                   │
│   ═══════════════════════════════════════                  │
│                                                             │
│   KERNEL SPACE                                              │
│   ────────────                                              │
│         │                                                   │
│         ▼                                                   │
│   1. Сохранить user регистры                               │
│   2. Переключить stack на kernel stack                     │
│   3. Найти handler по syscall number                       │
│         │                                                   │
│         ▼                                                   │
│   sys_read():                                               │
│   - Проверить права доступа                                │
│   - Найти файл по fd                                       │
│   - Читать данные через driver                             │
│   - Скопировать в user buffer                              │
│         │                                                   │
│         ▼                                                   │
│   4. Восстановить user регистры                            │
│   5. sysret instruction (возврат в user)                   │
│   ═══════════════════════════════════════                  │
│                                                             │
│   USER SPACE                                                │
│         │                                                   │
│         ▼                                                   │
│   content теперь содержит данные файла                     │
│                                                             │
│   Время: ~100-1000 ns (без I/O wait)                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Категории syscalls

| Категория | Syscalls | Что делают |
|-----------|----------|------------|
| **Файлы** | open, read, write, close | I/O с файлами |
| **Процессы** | fork, exec, exit, wait | Управление процессами |
| **Память** | mmap, brk, mprotect | Выделение памяти |
| **Сеть** | socket, connect, send, recv | Сетевой I/O |
| **Сигналы** | kill, signal, sigaction | Межпроцессная коммуникация |

### Пример: что происходит при open()

```kotlin
// Kotlin/Native
val fd = open("/tmp/test.txt", O_RDONLY)
```

Kernel выполняет:
1. Проверить права пользователя на файл
2. Найти inode файла в файловой системе
3. Создать file descriptor в таблице процесса
4. Вернуть номер fd пользователю

---

## Mode Switch vs Context Switch

### Разница

```
┌─────────────────────────────────────────────────────────────┐
│          MODE SWITCH vs CONTEXT SWITCH                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   MODE SWITCH (syscall):                                   │
│   ┌─────────────────────────────────────────┐              │
│   │ Process A                               │              │
│   │ ┌─────────┐    ┌─────────┐    ┌───────┐│              │
│   │ │  User   │───▶│ Kernel  │───▶│ User  ││              │
│   │ │  mode   │    │  mode   │    │ mode  ││              │
│   │ └─────────┘    └─────────┘    └───────┘│              │
│   └─────────────────────────────────────────┘              │
│   Тот же процесс, меняется только privilege level          │
│   Время: ~100-1000 ns                                      │
│                                                             │
│   ─────────────────────────────────────────────────────    │
│                                                             │
│   CONTEXT SWITCH (scheduler):                              │
│   ┌─────────────┐              ┌─────────────┐             │
│   │ Process A   │              │ Process B   │             │
│   │ ┌─────────┐ │   Switch     │ ┌─────────┐ │             │
│   │ │ Running │ │ ──────────▶  │ │ Running │ │             │
│   │ └─────────┘ │   Save A     │ └─────────┘ │             │
│   │  Saved     │   Load B     │             │             │
│   └─────────────┘              └─────────────┘             │
│   Полная смена контекста:                                  │
│   - Регистры                                               │
│   - Page tables (TLB flush)                                │
│   - Kernel stack                                           │
│   Время: ~1-10 μs                                          │
│                                                             │
│   Context switch ~10-100x дороже mode switch               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Когда происходит context switch

- Timer interrupt (time slice закончился)
- Процесс блокируется (I/O wait)
- Процесс завершается
- Более приоритетный процесс готов

---

## Virtual Memory: иллюзия своей памяти

### Каждый процесс думает, что один

```
┌─────────────────────────────────────────────────────────────┐
│                 VIRTUAL MEMORY                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   PROCESS A видит:          PROCESS B видит:               │
│   ┌────────────────┐        ┌────────────────┐             │
│   │ 0xFFFFFFFF     │        │ 0xFFFFFFFF     │             │
│   │ Kernel space   │        │ Kernel space   │             │
│   ├────────────────┤        ├────────────────┤             │
│   │ Stack          │        │ Stack          │             │
│   │       ↓        │        │       ↓        │             │
│   │                │        │                │             │
│   │       ↑        │        │       ↑        │             │
│   │ Heap           │        │ Heap           │             │
│   ├────────────────┤        ├────────────────┤             │
│   │ Data           │        │ Data           │             │
│   ├────────────────┤        ├────────────────┤             │
│   │ Code           │        │ Code           │             │
│   │ 0x00000000     │        │ 0x00000000     │             │
│   └────────────────┘        └────────────────┘             │
│          │                          │                       │
│          ▼                          ▼                       │
│   ┌─────────────────────────────────────────┐              │
│   │           PAGE TABLES                    │              │
│   │  Virtual → Physical mapping              │              │
│   └─────────────────────────────────────────┘              │
│                    │                                        │
│                    ▼                                        │
│   ┌─────────────────────────────────────────┐              │
│   │         PHYSICAL MEMORY (RAM)            │              │
│   │  ┌────┬────┬────┬────┬────┬────┬────┐   │              │
│   │  │ A  │ B  │ A  │ OS │ B  │ A  │ B  │   │              │
│   │  └────┴────┴────┴────┴────┴────┴────┘   │              │
│   └─────────────────────────────────────────┘              │
│                                                             │
│   A и B видят "свои" адреса, но physical memory разная     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Преимущества virtual memory

| Преимущество | Описание |
|--------------|----------|
| **Изоляция** | Процесс не может читать память другого |
| **Простота** | Программа думает, что память с 0x0 |
| **Flexibility** | Physical memory может быть fragmented |
| **Больше памяти** | Swap на диск, когда RAM полная |
| **Sharing** | Одна physical page для нескольких процессов (shared libs) |

---

## Process Management

### Что такое процесс

```
┌─────────────────────────────────────────────────────────────┐
│               PROCESS CONTROL BLOCK (PCB)                   │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌─────────────────────────────────────────┐              │
│   │ PID: 1234                               │              │
│   │ State: RUNNING | WAITING | READY | ...  │              │
│   ├─────────────────────────────────────────┤              │
│   │ Registers:                              │              │
│   │   RAX, RBX, ..., RIP, RSP, RFLAGS      │              │
│   ├─────────────────────────────────────────┤              │
│   │ Memory:                                 │              │
│   │   Page table pointer (CR3)              │              │
│   │   Virtual memory regions                │              │
│   ├─────────────────────────────────────────┤              │
│   │ Files:                                  │              │
│   │   fd 0 → stdin                          │              │
│   │   fd 1 → stdout                         │              │
│   │   fd 2 → stderr                         │              │
│   │   fd 3 → /tmp/file.txt                  │              │
│   ├─────────────────────────────────────────┤              │
│   │ Scheduling:                             │              │
│   │   Priority, time slice used, etc.       │              │
│   └─────────────────────────────────────────┘              │
│                                                             │
│   Kernel хранит PCB для каждого процесса                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Fork/Exec: создание процессов (Unix)

```
┌─────────────────────────────────────────────────────────────┐
│                    FORK + EXEC                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Parent (PID 100)           Child (PID 101)               │
│   ┌──────────────┐                                         │
│   │ Running code │                                         │
│   │      │       │                                         │
│   │  fork()      │                                         │
│   │      │       │                                         │
│   │      ├───────┼──────────▶ ┌──────────────┐            │
│   │      │       │            │ Копия parent │            │
│   │      │       │            │ (Copy-on-Write)│            │
│   │      ▼       │            │      │       │            │
│   │ fork() = 101 │            │ fork() = 0   │            │
│   │ (child PID)  │            │ (I am child) │            │
│   │      │       │            │      │       │            │
│   │   wait()     │            │  exec("/bin/ls")          │
│   │      │       │            │      │       │            │
│   │      │       │            │  ┌───────────┐            │
│   │      │       │            │  │ ls binary │            │
│   │      │       │            │  │ running   │            │
│   │      │       │            │  └───────────┘            │
│   │      │       │            │      │       │            │
│   │      │       │            │   exit(0)    │            │
│   │   continue   │◀───────────│              │            │
│   └──────────────┘                                         │
│                                                             │
│   fork(): создаёт копию процесса                           │
│   exec(): заменяет код новой программой                    │
│   wait(): ждёт завершения child                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Практика: наблюдение за процессами

### Linux команды

```bash
# Список процессов
ps aux

# Дерево процессов
pstree

# Открытые файлы процесса
lsof -p <pid>

# System calls процесса
strace -p <pid>

# Memory mapping
cat /proc/<pid>/maps
```

### Kotlin/Native: работа с процессами

```kotlin
import platform.posix.*

fun main() {
    val pid = fork()

    when {
        pid < 0 -> println("Fork failed")
        pid == 0 -> {
            // Child process
            println("Child: my PID is ${getpid()}")
            exit(0)
        }
        else -> {
            // Parent process
            println("Parent: child PID is $pid")
            waitpid(pid, null, 0)
            println("Parent: child finished")
        }
    }
}
```

---

## Подводные камни

### Распространённые ошибки

| Ошибка | Последствие | Решение |
|--------|-------------|---------|
| Слишком много syscalls | Performance overhead | Batch operations |
| Zombie processes | Resource leak | wait() для children |
| File descriptor leak | "Too many open files" | Закрывать fd |
| Игнорирование SIGCHLD | Zombies | Handle или ignore |

### Мифы и заблуждения

**Миф:** "Syscalls бесплатны"
**Реальность:** Каждый syscall — mode switch (~100-1000 ns). В tight loops это заметно.

**Миф:** "fork() копирует всю память"
**Реальность:** Copy-on-Write: страницы копируются только при записи.

---

## Куда дальше

**Если здесь впервые:**
→ Попробуй strace на своём приложении

**Если понял и хочешь глубже:**
→ Linux kernel documentation

**Практическое применение:**
→ Оптимизация I/O, понимание ограничений

---

## Источники

- [Wikipedia: System Call](https://en.wikipedia.org/wiki/System_call) — overview
- [Linux Kernel Labs: Syscalls](https://linux-kernel-labs.github.io/refs/heads/master/lectures/syscalls.html) — deep dive
- [Form3: Linux Fundamentals](https://www.form3.tech/blog/engineering/linux-fundamentals-user-kernel-space) — practical
- [The Skilled Coder: OS Fundamentals](https://theskilledcoder.com/posts/fundamental-concepts/operating-system-fundamentals/) — for developers

---

*Проверено: 2026-01-09*
