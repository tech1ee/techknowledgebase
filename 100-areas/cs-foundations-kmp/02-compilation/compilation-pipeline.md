---
title: "Compilation Pipeline: путь кода от текста до исполнения"
created: 2026-01-04
modified: 2026-01-04
type: deep-dive
tags: [cs-foundations, compilation, compiler, lexer, parser, ast, ir, optimization]
related:
  - "[[bytecode-virtual-machines]]"
  - "[[native-compilation-llvm]]"
  - "[[interpretation-jit]]"
---

# Compilation Pipeline: путь кода от текста до исполнения

> **TL;DR:** Компиляция — превращение текста программы в исполняемый код через цепочку этапов: разбить на слова (токены) → построить дерево структуры (AST) → проверить смысл (типы, scope) → создать промежуточный код (IR) → оптимизировать → сгенерировать машинный код. Для KMP критично: Kotlin компилирует один код в разные форматы (JVM bytecode, LLVM IR, JavaScript) через единый frontend (K2) и разные backend'ы.

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **Базовое программирование** | Понимать что такое код | Любой туториал |
| **Переменные и типы** | Понять type checking | Основы языка |

---

## Терминология

| Термин | Что это | Аналогия |
|--------|---------|----------|
| **Compiler** | Программа, переводящая код в другой формат | Переводчик книги |
| **Token** | Минимальная единица кода | Слово в предложении |
| **Lexer / Tokenizer** | Разбивает код на токены | Делит текст на слова |
| **Parser** | Строит структуру из токенов | Разбирает грамматику предложения |
| **AST** (Abstract Syntax Tree) | Дерево структуры программы | Схема предложения |
| **IR** (Intermediate Representation) | Промежуточный код между исходником и машинным | Черновик перевода |
| **SSA** (Static Single Assignment) | Форма IR где переменная присваивается один раз | Каждая запись — новая строка |
| **Frontend** | Часть компилятора до IR | Понимание исходного языка |
| **Backend** | Часть компилятора после IR | Генерация целевого кода |

---

## ПОЧЕМУ появились компиляторы

### До компиляторов: эпоха машинного кода

В 1940-х программисты писали программы напрямую в машинном коде — последовательности чисел, которые процессор понимает. Это выглядело примерно так:

```
10110000 01100001  ; MOV AL, 0x61 - записать число 97 в регистр
```

Каждая инструкция — число. Адреса памяти — числа. Даже данные — числа. Программист держал в голове что значит каждое число. Ошибки были неизбежны, отладка мучительна.

### 1952: Grace Hopper и первый компилятор

Grace Hopper, работая на компьютере UNIVAC, создала A-0 — первый компилятор. Идея была революционной: что если машина сама переведёт понятный человеку код в машинный?

Коллеги скептически отнеслись к идее. Компьютер — вычислительная машина, как он может "понимать" текст? Но Hopper доказала: компилятор — это просто программа, которая берёт один текст и производит другой.

```
┌─────────────────────────────────────────────────────────────────┐
│                    ИДЕЯ GRACE HOPPER                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   БЫЛО (машинный код):                                          │
│   10110000 01100001 11001101 00010000 ...                       │
│                                                                 │
│   СТАЛО (человеческий код):                                     │
│   PRINT "Hello"                                                 │
│                                                                 │
│   Компилятор: программа → машинный код                          │
│                                                                 │
│   "Я считала, что раз могу написать программу, значит           │
│    могу написать программу, которая пишет программы"            │
│                                    — Grace Hopper               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1957: FORTRAN и практическое применение

Первый широко используемый компилятор появился с языком FORTRAN (FORmula TRANslation). Джон Бэкус и его команда в IBM потратили 3 года на создание компилятора, который переводил математические формулы в машинный код.

Скептики утверждали: автоматически сгенерированный код будет медленнее ручного. Команда FORTRAN поставила задачу: код должен быть не хуже написанного вручную. И справились — FORTRAN-программы работали с такой же скоростью.

### Зачем нужны компиляторы сегодня

Компиляторы решают три фундаментальные проблемы:

**1. Абстракция над железом.** Программист думает о логике, не о регистрах процессора. Код `val x = a + b` работает на любом процессоре — компилятор адаптирует.

**2. Проверка ошибок до запуска.** Компилятор находит опечатки, несоответствия типов, отсутствующие переменные. Лучше узнать об ошибке при компиляции, чем когда программа упадёт у пользователя.

**3. Оптимизация.** Компилятор видит паттерны, которые человек может упустить. Он убирает лишний код, упрощает вычисления, переупорядочивает инструкции для скорости.

---

## ЧТО такое Compilation Pipeline

Компиляция — не одно действие, а конвейер (pipeline) этапов. Каждый этап берёт результат предыдущего и производит вход для следующего.

```
┌─────────────────────────────────────────────────────────────────┐
│                  COMPILATION PIPELINE                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Source Code                                                   │
│   "val x = 2 + 3"                                               │
│         │                                                       │
│         ▼                                                       │
│   ┌─────────────────┐                                           │
│   │ LEXICAL ANALYSIS│  → Токены: [val] [x] [=] [2] [+] [3]     │
│   └────────┬────────┘                                           │
│            ▼                                                    │
│   ┌─────────────────┐                                           │
│   │ SYNTAX ANALYSIS │  → AST: дерево структуры                  │
│   └────────┬────────┘                                           │
│            ▼                                                    │
│   ┌─────────────────┐                                           │
│   │SEMANTIC ANALYSIS│  → Проверены типы, разрешены имена       │
│   └────────┬────────┘                                           │
│            ▼                                                    │
│   ┌─────────────────┐                                           │
│   │  IR GENERATION  │  → Промежуточный код                      │
│   └────────┬────────┘                                           │
│            ▼                                                    │
│   ┌─────────────────┐                                           │
│   │  OPTIMIZATION   │  → Улучшенный IR                          │
│   └────────┬────────┘                                           │
│            ▼                                                    │
│   ┌─────────────────┐                                           │
│   │ CODE GENERATION │  → Машинный код / Bytecode                │
│   └─────────────────┘                                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Frontend и Backend

Компилятор делится на две части:

**Frontend** — понимает исходный язык:
- Lexer (разбивает на токены)
- Parser (строит AST)
- Semantic Analyzer (проверяет типы)
- IR Generator (создаёт промежуточный код)

**Backend** — генерирует целевой код:
- Optimizer (улучшает IR)
- Code Generator (создаёт машинный код)

Почему такое разделение? Представь: есть 5 языков и 5 платформ. Без разделения нужно 25 компиляторов (каждый язык для каждой платформы). С разделением — 5 frontend'ов + 5 backend'ов = 10 компонентов. Frontend генерирует общий IR, backend'ы его потребляют.

```
┌─────────────────────────────────────────────────────────────────┐
│                FRONTEND / BACKEND РАЗДЕЛЕНИЕ                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   FRONTENDS          COMMON IR           BACKENDS               │
│   ─────────         ─────────           ────────               │
│   Kotlin ───┐                      ┌─── JVM Bytecode           │
│   Java ─────┼───▶ [ IR ] ◀────────┼─── ARM Assembly            │
│   Scala ────┘                      └─── x86 Assembly           │
│                                                                 │
│   5 языков + 5 платформ = 10 компонентов                        │
│   (вместо 25 отдельных компиляторов)                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## КАК работает каждый этап

### 1. Lexical Analysis (Лексический анализ)

Первый этап: превратить поток символов в поток токенов. Токен — минимальная смысловая единица языка.

Возьмём код:
```kotlin
val count = 10 + 5
```

Lexer читает символ за символом и распознаёт:
- `val` — ключевое слово
- `count` — идентификатор (имя переменной)
- `=` — оператор присваивания
- `10` — числовой литерал
- `+` — оператор сложения
- `5` — числовой литерал

```
┌─────────────────────────────────────────────────────────────────┐
│                    LEXICAL ANALYSIS                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Исходный код:  "val count = 10 + 5"                           │
│                   ↓   ↓     ↓ ↓↓ ↓ ↓                            │
│                                                                 │
│   Токены:                                                       │
│   ┌─────────┬───────────┬──────┐                                │
│   │  Type   │   Value   │ Pos  │                                │
│   ├─────────┼───────────┼──────┤                                │
│   │ KEYWORD │   "val"   │  0   │                                │
│   │ IDENT   │  "count"  │  4   │                                │
│   │ ASSIGN  │    "="    │  10  │                                │
│   │ NUMBER  │   "10"    │  12  │                                │
│   │ PLUS    │    "+"    │  15  │                                │
│   │ NUMBER  │    "5"    │  17  │                                │
│   └─────────┴───────────┴──────┘                                │
│                                                                 │
│   Пробелы и переносы строк — убраны (не несут смысла)           │
│   Позиции — сохранены для сообщений об ошибках                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Как lexer различает токены?**

Lexer использует правила (обычно регулярные выражения):
- Если начинается с буквы и продолжается буквами/цифрами → идентификатор или ключевое слово
- Если состоит из цифр → число
- Если символ `+`, `-`, `*`, `/` → оператор

Порядок правил важен: `val` сначала проверяется как ключевое слово, и только если не подошло — как идентификатор.

### 2. Syntax Analysis (Синтаксический анализ)

Второй этап: построить дерево структуры программы — AST (Abstract Syntax Tree). Токены это слова, AST — предложение с грамматикой.

Parser проверяет: токены идут в правильном порядке? `val = 10 count` — неправильно, даже если все токены валидны.

```
┌─────────────────────────────────────────────────────────────────┐
│                       AST ДЛЯ "val count = 10 + 5"              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                    VariableDeclaration                          │
│                    ┌──────────────────┐                         │
│                    │ name: "count"    │                         │
│                    │ type: inferred   │                         │
│                    └────────┬─────────┘                         │
│                             │                                   │
│                             │ value                             │
│                             ▼                                   │
│                    BinaryExpression                             │
│                    ┌──────────────────┐                         │
│                    │ operator: "+"    │                         │
│                    └────────┬─────────┘                         │
│                      ┌──────┴──────┐                            │
│                      │             │                            │
│                      ▼             ▼                            │
│                 IntLiteral    IntLiteral                        │
│                 ┌───────┐    ┌───────┐                          │
│                 │ 10    │    │ 5     │                          │
│                 └───────┘    └───────┘                          │
│                                                                 │
│   AST отражает СТРУКТУРУ, не последовательность токенов         │
│   "10 + 5" и "5 + 10" — разные AST, хотя результат одинаковый   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Parse Tree vs AST:**

Parse tree сохраняет все грамматические детали (скобки, ключевые слова). AST — упрощённая версия, только существенная структура. Для `(10 + 5)` parse tree включает узлы для скобок, AST — нет.

### 3. Semantic Analysis (Семантический анализ)

Третий этап: проверить что программа имеет смысл. Синтаксически `val x: String = 42` корректно, но семантически — ошибка (42 не String).

Семантический анализ проверяет:
- **Type checking:** типы совпадают?
- **Scope resolution:** переменная объявлена перед использованием?
- **Overload resolution:** какую версию функции вызвать?

```
┌─────────────────────────────────────────────────────────────────┐
│                    SEMANTIC ANALYSIS                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   val x: Int = "hello"                                          │
│           │      │                                              │
│           │      └──── String литерал                           │
│           └────────── Ожидается Int                             │
│                                                                 │
│   ❌ Type mismatch: expected Int, found String                   │
│                                                                 │
│   ─────────────────────────────────────────────────────────     │
│                                                                 │
│   fun foo() {                                                   │
│       val y = x + 1  // x не объявлена                          │
│   }                                                             │
│                                                                 │
│   ❌ Unresolved reference: x                                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Symbol Table:**

Для семантического анализа компилятор ведёт Symbol Table — таблицу всех известных имён (переменных, функций, классов). При объявлении — добавляет, при использовании — ищет.

```kotlin
fun example() {
    val x = 10      // Symbol Table: добавить x: Int
    val y = x + 5   // Symbol Table: найти x → Ok, тип Int
    println(z)      // Symbol Table: найти z → Ошибка!
}
```

### 4. IR Generation (Генерация промежуточного кода)

После проверок компилятор создаёт промежуточное представление (IR). IR — код, который:
- Проще исходного языка (нет синтаксического сахара)
- Абстрактнее машинного кода (нет регистров конкретного процессора)

**Three-Address Code:**

Популярная форма IR, где каждая инструкция имеет максимум три операнда:

```
┌─────────────────────────────────────────────────────────────────┐
│            IR: THREE-ADDRESS CODE                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Исходный код:                                                 │
│   val result = (a + b) * (c - d)                                │
│                                                                 │
│   Three-address code:                                           │
│   t1 = a + b                                                    │
│   t2 = c - d                                                    │
│   result = t1 * t2                                              │
│                                                                 │
│   Каждая операция — отдельная инструкция                        │
│   Временные переменные (t1, t2) хранят промежуточные результаты │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**SSA (Static Single Assignment):**

Современные компиляторы (LLVM, GCC, Kotlin) используют SSA-форму IR. Правило: каждая переменная присваивается ровно один раз.

```
┌─────────────────────────────────────────────────────────────────┐
│                       SSA ФОРМА                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Обычный код:          SSA форма:                              │
│   ─────────────         ──────────                              │
│   x = 1                 x1 = 1                                  │
│   x = x + 2             x2 = x1 + 2                             │
│   x = x * 3             x3 = x2 * 3                             │
│                                                                 │
│   Каждое присваивание создаёт НОВУЮ версию переменной           │
│                                                                 │
│   Зачем?                                                        │
│   - Упрощает data-flow analysis                                 │
│   - Легко определить где переменная определена                  │
│   - Оптимизации проще реализовать                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

Для условных конструкций SSA использует φ-функции (phi):

```
if (cond)
    x = 1
else
    x = 2
use(x)
```

Становится:
```
if cond goto L1 else L2
L1: x1 = 1; goto L3
L2: x2 = 2; goto L3
L3: x3 = φ(x1, x2)  // выбирает x1 или x2 в зависимости от пути
use(x3)
```

### 5. Optimization (Оптимизация)

Компилятор улучшает IR, сохраняя семантику программы. Основные техники:

**Constant Folding (свёртка констант):**
```
// До:
t1 = 2 + 3
t2 = t1 * 4

// После:
t1 = 5      // 2 + 3 вычислено compile-time
t2 = 20     // 5 * 4 вычислено compile-time
```

**Dead Code Elimination (удаление мёртвого кода):**
```kotlin
// До:
fun example() {
    val x = compute()
    return 42
    val y = x + 1  // недостижимый код
}

// После:
fun example() {
    return 42
}
```

**Function Inlining (встраивание функций):**
```kotlin
// До:
inline fun square(n: Int) = n * n
val result = square(5)

// После:
val result = 5 * 5  // тело функции подставлено
```

Главное преимущество inlining не в устранении call overhead (он минимален). Inlining открывает возможности для других оптимизаций: после подстановки компилятор видит конкретные значения и может применить constant folding.

```
┌─────────────────────────────────────────────────────────────────┐
│               INLINING ВКЛЮЧАЕТ ДРУГИЕ ОПТИМИЗАЦИИ              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   fun double(x: Int) = x * 2                                    │
│   val result = double(5)                                        │
│                                                                 │
│   После inlining:                                               │
│   val result = 5 * 2                                            │
│                                                                 │
│   После constant folding:                                       │
│   val result = 10                                               │
│                                                                 │
│   Без inlining компилятор не знал бы что x = 5                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6. Code Generation (Генерация кода)

Последний этап: превратить оптимизированный IR в целевой формат.

Для Kotlin это может быть:
- **JVM Bytecode** — для Android и JVM
- **LLVM IR → Native binary** — для iOS через Kotlin/Native
- **JavaScript** — для Web
- **WASM** — для WebAssembly

Code generator занимается:
- **Instruction selection:** какие машинные инструкции использовать
- **Register allocation:** как распределить переменные по регистрам
- **Instruction scheduling:** в каком порядке выполнять инструкции

---

## Kotlin Compiler: K2 и Multiplatform

Kotlin использует архитектуру с единым frontend и несколькими backend'ами.

```
┌─────────────────────────────────────────────────────────────────┐
│                    KOTLIN COMPILER (K2)                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Source (.kt)                                                  │
│        │                                                        │
│        ▼                                                        │
│   ┌────────────┐                                                │
│   │ K2 FRONTEND│  PSI → FIR → Resolved FIR                     │
│   └─────┬──────┘                                                │
│         │                                                       │
│         ▼                                                       │
│   ┌────────────┐                                                │
│   │     IR     │  Backend IR (общий для всех платформ)          │
│   └─────┬──────┘                                                │
│         │                                                       │
│   ┌─────┼─────────────┬─────────────┬───────────┐               │
│   │     │             │             │           │               │
│   ▼     ▼             ▼             ▼           ▼               │
│ ┌────┐ ┌─────┐ ┌──────────┐ ┌────────┐ ┌──────────┐            │
│ │JVM │ │ JS  │ │  Native  │ │  WASM  │ │  ...     │            │
│ └────┘ └─────┘ └──────────┘ └────────┘ └──────────┘            │
│   │       │          │           │                              │
│   ▼       ▼          ▼           ▼                              │
│ .class   .js    executable     .wasm                           │
│                 (via LLVM)                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**K2 vs K1:**

K1 (старый frontend) использовал две структуры данных. K2 использует одну — FIR (Frontend Intermediate Representation). Результат:
- Компиляция в ~2 раза быстрее
- Улучшенный type inference
- Более точные smart casts

**Для KMP это означает:**

Один и тот же Kotlin-код компилируется в разные форматы. `commonMain` код проходит через K2 frontend один раз, затем backend'ы генерируют код для каждой платформы:

- **JVM backend:** JVM bytecode (`.class` файлы)
- **Native backend:** LLVM IR → машинный код для iOS/macOS/Linux
- **JS backend:** JavaScript код
- **WASM backend:** WebAssembly модули

---

## Подводные камни

### Типичные заблуждения

| Миф | Реальность |
|-----|------------|
| `-O3` намного быстрее `-O2` | Исследования показывают минимальную разницу. `-O3` может навредить из-за увеличения размера кода |
| `inline` гарантирует встраивание | `inline` в Kotlin/C++ влияет на linkage. Для гарантии нужен `@Suppress("NOTHING_TO_INLINE")` или `always_inline` |
| Компилятор создаёт оптимальный код | "Optimization" — неточное название. Компилятор улучшает, но не находит оптимум |
| Раздельная компиляция всегда быстрее | Линковка медленная. Для небольших проектов unity build (всё в один файл) может быть быстрее |

### Когда понимание pipeline важно

**Отладка ошибок компиляции:**
- Lexer error: "Unexpected character" → проблема с символами
- Parser error: "Unexpected token" → неправильная структура
- Semantic error: "Type mismatch" → логическая ошибка

**Performance debugging:**
- Если функция не inline'ится — проверь, не слишком ли она большая
- Если константы не сворачиваются — возможно, они не константы compile-time

**KMP специфика:**
- Ошибки могут проявляться на одной платформе и не на другой
- IR различается между backend'ами — одна оптимизация может работать на JVM, но не на Native

---

## Куда дальше

**Если понял pipeline:**
→ [[bytecode-virtual-machines]] — как работает JVM bytecode
→ [[native-compilation-llvm]] — как Kotlin/Native генерирует машинный код

**Для практики:**
```bash
# Посмотреть JVM bytecode
kotlinc Main.kt -include-runtime -d Main.jar
javap -c -p MainKt.class

# Посмотреть Kotlin IR
kotlinc -Xprint-ir Main.kt
```

**Глубже в теорию:**
→ [[interpretation-jit]] — JIT компиляция и tiered compilation

---

## Источники

- [Crafting Interpreters](https://craftinginterpreters.com) — лучший ресурс по компиляторам для начинающих
- [JetBrains: K2 Compiler](https://blog.jetbrains.com/kotlin/2024/05/celebrating-kotlin-2-0-fast-smart-and-multiplatform/) — официальный анонс K2
- [Common Misconceptions about Compilers](https://sbaziotis.com/compilers/common-misconceptions-about-compilers.html) — развенчание мифов
- [Cornell CS 4120: IR Notes](https://www.cs.cornell.edu/courses/cs4120/2023sp/notes/ir/) — академические материалы об IR

---

*Проверено: 2026-01-09*
