---
title: "Memory Safety: от багов к гарантиям"
created: 2026-01-04
modified: 2026-02-10
type: deep-dive
status: published
tags:
  - topic/cs-foundations
  - type/deep-dive
  - level/advanced
related:
  - "[[memory-model-fundamentals]]"
  - "[[garbage-collection-explained]]"
  - "[[reference-counting-arc]]"
prerequisites:
  - "[[memory-model-fundamentals]]"
  - "[[garbage-collection-explained]]"
  - "[[reference-counting-arc]]"
---

# Memory Safety: от багов к гарантиям

> **TL;DR:** Memory safety предотвращает классы багов: use-after-free, double-free, dangling pointers. Подходы: GC (pauses), Reference Counting (overhead), Ownership (compile-time, Rust). Rust: один owner, borrowing правила, borrow checker. Swift добавил Sendable/Actors для concurrency safety. Kotlin/Native использовал freeze (shared XOR mutable), новая модель проще. Для KMP критично: разные модели на разных targets требуют понимания ограничений.

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **Stack vs Heap** | Понять где происходят баги | [[memory-model-fundamentals]] |
| **GC** | Альтернатива ownership | [[garbage-collection-explained]] |
| **ARC** | iOS модель | [[reference-counting-arc]] |

---

## Терминология

| Термин | Что это | Аналогия |
|--------|---------|----------|
| **Use-After-Free** | Обращение к освобождённой памяти | Звонок на отключённый номер |
| **Double-Free** | Повторное освобождение памяти | Сдать ключи дважды |
| **Dangling Pointer** | Указатель на freed память | Адрес снесённого дома |
| **Buffer Overflow** | Запись за границы выделенного блока | Писать за полями бланка |
| **Ownership** | Единоличное владение ресурсом | Один хозяин вещи |
| **Borrowing** | Временное заимствование | Взять на время, вернуть |
| **Lifetime** | Время жизни ссылки | Срок аренды |
| **RAII** | Автоматическое освобождение в деструкторе | Уборка при выезде |

---

## ЧТО такое memory safety

### Определение

Memory safety — это свойство программы (или языка программирования), гарантирующее, что программа обращается только к той памяти, которая ей законно выделена, и только в течение того времени, когда эта память действительно принадлежит программе.

Проще говоря: ты можешь читать и писать только в свои комнаты, и только пока ты их арендуешь. Зашёл в чужую комнату — нарушение. Зашёл в свою бывшую комнату после окончания аренды — тоже нарушение.

Это определение кажется очевидным, но на практике его нарушение — источник 70% всех security-уязвимостей в крупном системном софте. Отчёт Microsoft за 2019 год показал: 70% CVE (Common Vulnerabilities and Exposures) в Windows — memory safety баги. Google сообщает аналогичные цифры для Chrome. NSA, CISA и Белый Дом рекомендовали переход на memory-safe языки в 2022-2024 годах.

### Виды нарушений memory safety

Нарушения делятся на две категории: **пространственные** (spatial) — обращение по неверному адресу, и **временные** (temporal) — обращение в неверное время.

**Пространственные нарушения:**

**Buffer Overflow** — запись данных за границы выделенного буфера. Это самая известная атака в истории компьютерной безопасности. Червь Морриса (1988), первый в истории интернет-червь, использовал именно buffer overflow в функции `gets()` программы fingerd.

Представь, что тебе выделили в тетради строки 5-10 для записей. Buffer overflow — это когда ты пишешь на строках 11, 12, 13... затирая чужие записи. Если на строке 12 был записан адрес возврата функции, атакующий может перенаправить выполнение программы на свой код.

**Out-of-Bounds Read** — чтение за границами массива. Heartbleed (2014), одна из крупнейших уязвимостей в OpenSSL, позволяла читать до 64 КБ памяти сервера. Пароли, приватные ключи, сессии — всё утекало из-за одной непроверенной длины буфера.

**Временные нарушения:**

**Use-After-Free** — обращение к памяти после её освобождения. Представь, что ты выселился из гостиничного номера, но вернулся ночью и залез через окно. В номере уже может жить кто-то другой. Ты можешь прочитать чужие документы (information leak) или подменить их (code execution).

**Double-Free** — повторное освобождение одной и той же области памяти. Как если бы ты дважды сдал ключи от номера на ресепшен. Система думает, что номер свободен, и выдаёт его двум разным гостям одновременно. Результат — коррупция данных.

**Dangling Pointer** — указатель на память, которая уже освобождена. Старый адрес, по которому уже никто не живёт. Любое обращение — undefined behavior.

```
┌─────────────────────────────────────────────────────────────────┐
│           КЛАССИФИКАЦИЯ MEMORY SAFETY НАРУШЕНИЙ                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ПРОСТРАНСТВЕННЫЕ (spatial)    ВРЕМЕННЫЕ (temporal)            │
│   ─────────────────────────    ────────────────────             │
│                                                                 │
│   Buffer Overflow               Use-After-Free                  │
│   (запись за границы)           (доступ после free)             │
│                                                                 │
│   Out-of-Bounds Read            Double-Free                     │
│   (чтение за границы)          (повторный free)                │
│                                                                 │
│   Null Pointer Deref            Dangling Pointer                │
│   (доступ через null)           (указатель на freed)            │
│                                                                 │
│   Stack Buffer Overflow         Use-After-Return                │
│   (запись за stack-буфер)       (возврат указателя на stack)    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

> **Ключевая идея:** Memory safety — не академическая прихоть. Это вопрос безопасности миллиардов пользователей. Большинство взломов, червей и эксплойтов за последние 30 лет эксплуатируют именно нарушения memory safety.

---

## Подходы к Memory Safety

### Три фундаментальных стратегии

Все языки программирования решают проблему memory safety одним из трёх способов. Каждый способ — это компромисс между безопасностью, производительностью и удобством. Нет "лучшего" подхода — есть подходящий для конкретной задачи.

**Стратегия 1: Автоматическое управление в runtime (GC)**

Язык берёт управление памятью на себя. Программист не может вызвать free(), не может получить "сырой" указатель, не может выйти за границы массива. Runtime проверяет всё.

Примеры: Java, Kotlin/JVM, Go, Python, JavaScript.

Преимущество: невозможны use-after-free, double-free, dangling pointer. Программист не думает о памяти вообще.

Цена: GC pauses, overhead памяти (3-6x от live data для оптимальной работы GC), bounds checking на каждое обращение к массиву (несколько тактов CPU).

**Стратегия 2: Полуавтоматическое управление (Reference Counting)**

Компилятор вставляет retain/release автоматически, но программист отвечает за разрыв циклов.

Примеры: Swift (ARC), Objective-C (ARC), Rust (Rc/Arc в ограниченных случаях).

Преимущество: детерминистичное освобождение, нет GC пауз, низкий overhead памяти.

Цена: retain cycles = memory leaks, overhead при каждом присваивании ссылки (atomic increment/decrement), программист должен думать о weak/unowned.

**Стратегия 3: Compile-time гарантии (Ownership)**

Компилятор доказывает безопасность на этапе компиляции. Если код компилируется — memory safety нарушения невозможны. Никакого runtime overhead.

Примеры: Rust (ownership + borrow checker).

Преимущество: нулевой runtime overhead, нет пауз, нет утечек (кроме явных через `mem::forget`).

Цена: крутая learning curve, "борьба с borrow checker", некоторые паттерны (графы, деревья с обратными ссылками) выражаются сложнее.

### Сравнение стратегий

| Критерий | GC (Java) | RC (Swift ARC) | Ownership (Rust) | Ручное (C) |
|----------|-----------|-----------------|-------------------|------------|
| **Safety** | Высокая | Высокая (кроме циклов) | Высокая | Низкая |
| **Runtime overhead** | GC pauses, memory overhead | Atomic inc/dec | Нет | Нет |
| **Compile-time overhead** | Нет | Минимальный | Высокий (borrow checker) | Нет |
| **Learning curve** | Низкий | Средний | Высокий | Средний |
| **Циклические структуры** | Автоматически | Ручной разрыв (weak) | Явное управление (Rc + Weak) | Ручное |
| **Ресурсы (файлы, сокеты)** | Finalize (непредсказуемо) | deinit (детерминистично) | Drop (детерминистично) | Ручное |
| **Области применения** | Серверы, Android, enterprise | iOS, macOS | Системы, embedded, WASM | Ядра ОС, драйверы |

Каждая строка этой таблицы заслуживает отдельного разбора.

**Safety:** GC и Ownership дают полные гарантии (разные механизмы, одинаковый результат). RC оставляет "дыру" — циклические ссылки. Ручное управление не даёт никаких гарантий.

**Runtime overhead:** GC имеет паузы и нуждается в запасной памяти. RC тратит несколько тактов на каждый retain/release. Ownership проверяет всё при компиляции — в runtime нет overhead. Ручное управление тоже без overhead, но ценой безопасности.

**Learning curve:** Это самый субъективный критерий, но данные реальных команд подтверждают: Rust требует значительно больше времени на освоение. Программисты, привыкшие к GC, начинают продуктивно писать на Java/Kotlin за недели. На Rust — за месяцы. Причина: borrow checker заставляет думать о памяти явно, чего GC-программисты не делали никогда.

---

## Ownership Model (Rust): формальная система безопасности

### Почему Rust — революция

До Rust было два варианта: либо безопасность с runtime overhead (GC/RC), либо производительность без безопасности (C/C++). Rust предложил третий путь: **безопасность через compile-time проверки**, без какого-либо runtime overhead.

Это стало возможным благодаря системе типов, вдохновлённой работами Бенджамина Пирса ("Types and Programming Languages", 2002) и исследованиями region-based memory management. Rust не изобрёл ownership — идеи существовали в академии десятилетиями. Заслуга Rust — в том, что он сделал эти идеи практичными и доступными.

### Три правила ownership

Система ownership в Rust строится на трёх правилах, которые выглядят простыми, но имеют глубокие последствия.

**Правило 1: Каждое значение имеет ровно одного владельца (owner).**

В реальной жизни у каждой вещи есть хозяин. Книга лежит на твоей полке — ты хозяин. Не "вы с соседом владеете ей совместно" (это создаёт споры) и не "она ничья" (тогда кто за ней следит?). Один объект — один владелец. Это устраняет неоднозначность: всегда ясно, кто отвечает за ресурс.

```rust
let s = String::from("hello");  // s — единственный владелец строки
```

**Правило 2: В любой момент может быть только один владелец.**

Когда ты передаёшь значение — оно **перемещается** (move), а не копируется. Оригинальная переменная больше недействительна. Как если бы ты передал другу книгу: она теперь у него, а не у тебя. Ты не можешь "передать" книгу и одновременно "оставить" её.

```rust
let s1 = String::from("hello");
let s2 = s1;  // Ownership перешёл к s2 (MOVE)
// println!("{}", s1);  // ОШИБКА КОМПИЛЯЦИИ! s1 больше не владеет
```

Почему это важно? Move предотвращает double-free. Если бы и s1, и s2 владели строкой, обе переменные попытались бы освободить одну память при выходе из scope. Double-free — corruption heap — crash.

**Правило 3: Когда владелец выходит из scope — значение освобождается.**

Это правило RAII (Resource Acquisition Is Initialization), но с гарантиями на уровне типов. Компилятор вставляет вызов `drop()` (аналог деструктора) в точке выхода владельца из scope. Не "когда-нибудь" (как GC), не "когда count обнулится" (как RC), а в точно определённой точке кода.

```rust
{
    let s = String::from("hello");
    // s используется
}  // s выходит из scope → drop() → память освобождена
```

### Move Semantics: почему присваивание — не копирование

В большинстве языков `let b = a` создаёт копию значения (для примитивов) или копию ссылки (для объектов). В Rust для heap-данных это **перемещение**: данные не копируются, указатель передаётся, оригинальная переменная инвалидируется.

```
┌─────────────────────────────────────────────────────────────────┐
│                    MOVE SEMANTICS                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   let s1 = String::from("hello");                               │
│                                                                 │
│   Stack:         Heap:                                          │
│   ┌─────────┐   ┌─────────────────┐                             │
│   │ s1      │──>│ "hello"         │                             │
│   │ ptr     │   │                 │                             │
│   │ len: 5  │   └─────────────────┘                             │
│   │ cap: 5  │                                                   │
│   └─────────┘                                                   │
│                                                                 │
│   let s2 = s1;  // MOVE!                                        │
│                                                                 │
│   Stack:         Heap:                                          │
│   ┌─────────┐                                                   │
│   │ s1      │   (invalid - moved from)                          │
│   │ ----    │                                                   │
│   └─────────┘                                                   │
│   ┌─────────┐   ┌─────────────────┐                             │
│   │ s2      │──>│ "hello"         │                             │
│   │ ptr     │   │                 │                             │
│   │ len: 5  │   └─────────────────┘                             │
│   │ cap: 5  │                                                   │
│   └─────────┘                                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

Move предотвращает double-free: только s2 освободит память. s1 больше не существует с точки зрения компилятора.

### Borrowing: использование без передачи владения

Move — слишком строгий для многих ситуаций. Если ты хочешь показать другу книгу, не обязательно её дарить. Можно дать почитать (borrow) и забрать обратно.

Rust различает два типа заимствования:

**Immutable borrow (&T)** — "можно посмотреть, нельзя менять". Можно создать сколько угодно одновременных immutable borrows. Это безопасно, потому что никто не модифицирует данные.

**Mutable borrow (&mut T)** — "можно менять, но только один". В каждый момент может существовать ровно один mutable borrow. Это предотвращает data races: если два потока одновременно пишут в одну переменную — undefined behavior. Один mutable borrow гарантирует эксклюзивный доступ.

### Правила заимствования

Эти правила — формальная основа memory safety в Rust:

1. В любой момент можно иметь **ЛИБО** одну mutable ссылку, **ЛИБО** любое количество immutable ссылок. Не оба одновременно.
2. Ссылки всегда должны быть **валидными** — нельзя создать ссылку на значение, которое может быть удалено.

Почему "или-или"? Это формализация принципа "readers-writer lock" из concurrency: много читателей безопасно, один писатель безопасен, читатель + писатель одновременно — гонка данных.

### Borrow Checker: компилятор как верификатор

Borrow checker — компонент компилятора Rust, который статически (при компиляции, без запуска программы) проверяет все правила ownership и borrowing. Если код не проходит проверку — он не скомпилируется.

Borrow checker анализирует **lifetimes** — временные интервалы, в течение которых ссылки валидны. Он гарантирует, что ни одна ссылка не переживёт данные, на которые указывает.

```
Borrow Checker: предотвращение dangling reference

  fn dangling() -> &String {
      let s = String::from("hello");   // s создан
      &s                                // ссылка на s
  }  // s удалён, но ссылка возвращается! → ОШИБКА КОМПИЛЯЦИИ

  Borrow checker видит:
  - s живёт до конца функции (scope = {})
  - Возвращаемая ссылка живёт ДОЛЬШЕ s (caller получит её)
  - ссылка outlives s → dangling → ЗАПРЕЩЕНО
```

В C/C++ аналогичный код скомпилируется (возможно с предупреждением), но приведёт к undefined behavior. В Rust — это ошибка компиляции. Программа не запустится, пока проблема не исправлена.

---

## ПОЧЕМУ Ownership подходит не всем

### Trade-offs системы ownership

Ownership — не серебряная пуля. Система решает проблему memory safety ценой других компромиссов, и для многих типов приложений эта цена слишком высока.

**1. Крутая learning curve.**

Rust требует от программиста явного мышления о владении, заимствовании и lifetime'ах. Для разработчика, который 10 лет писал на Java/Kotlin (где GC берёт всё на себя), это фундаментальный сдвиг в мышлении. По данным Rust Survey 2023, "difficulty of learning" — причина номер один, по которой люди прекращают изучать Rust.

Аналогия: ownership — как механическая коробка передач. Даёт полный контроль, но требует постоянного внимания. GC — как автомат: менее эффективен в пределе, но освобождает когнитивные ресурсы для решения бизнес-задач.

**2. Некоторые паттерны выражаются сложнее.**

Двусвязные списки, графы, деревья с обратными ссылками parent-child — всё это создаёт множественное владение, которое ownership запрещает. В Rust приходится использовать `Rc<RefCell<T>>` (reference counting + runtime borrow checking) или `unsafe` блоки. Это нивелирует преимущества ownership для данных структур.

Бьёрн Страуструп ("The C++ Programming Language") отмечал: "Ownership model works beautifully for trees. For graphs, you need garbage collection or manual management." Rust нашёл промежуточные решения (`Rc`, `Arena`), но они сложнее, чем простое создание объектов в GC-языке.

**3. Скорость разработки.**

Для быстрого прототипирования, CRUD-приложений, скриптов ownership — чрезмерная инженерия. Если приложение будет переписано через 6 месяцев, гарантии compile-time safety не оправдывают потраченного времени. GC-языки позволяют "сначала сделать, потом оптимизировать".

**4. Экосистема и наём.**

Найти Rust-разработчика сложнее и дороже, чем Java/Kotlin/Swift-разработчика. Библиотечная экосистема, хотя и растёт быстро, меньше, чем у JVM или npm. Для бизнес-критичных проектов это реальный фактор.

> **Ключевой принцип:** Выбирай модель памяти, которая соответствует constraints проекта. Для embedded и systems programming — Rust (ownership). Для мобильных приложений — Swift (ARC) и Kotlin (GC). Для серверов — Go/Java (GC). Нет универсального ответа.

---

## RAII: Resource Acquisition Is Initialization

### Идея

RAII — паттерн из C++, формализованный Страуструпом: ресурс привязан к объекту. Объект создан — ресурс захвачен. Объект уничтожен — ресурс освобождён.

В C++ деструктор вызывается автоматически при выходе из scope. Это позволяет управлять не только памятью, но и файлами, сокетами, мьютексами — любым ресурсом, требующим cleanup.

```cpp
class File {
    FILE* handle;
public:
    File(const char* name) {
        handle = fopen(name, "r");  // Ресурс захвачен при создании
    }
    ~File() {
        if (handle) fclose(handle);  // Ресурс освобождён при уничтожении
    }
};

void process() {
    File f("data.txt");
    // работаем с файлом
}  // Деструктор вызовется, файл закроется автоматически
```

Этот код показывает элегантность RAII: программист не может "забыть" закрыть файл, потому что закрытие привязано к выходу из scope. Даже при исключении деструктор вызывается.

### Проблема C++: RAII без borrow checker

RAII решает проблему утечки ресурсов, но не решает проблему dangling references. C++ позволяет скомпилировать код, который возвращает ссылку на локальный объект:

```cpp
std::string& dangerous() {
    std::string local = "hello";
    return local;  // Ссылка на объект, который будет уничтожен
}  // local уничтожен, ссылка — dangling
```

Компилятор может предупредить (warning), но не запретит (error). Rust добавляет borrow checker к RAII, превращая warning в error и делая dangling ссылки невозможными на уровне системы типов.

---

## Swift: ARC + Concurrency Safety

### ARC как основа

Swift использует Automatic Reference Counting (подробно в [[reference-counting-arc]]) для управления памятью. ARC даёт memory safety для одного потока: нет use-after-free, нет double-free.

### Sendable и Actors

Но memory safety в однопоточном мире недостаточна. В многопоточном коде data races — ещё один класс memory safety нарушений: два потока одновременно пишут в одну переменную. Swift 5.5+ добавил compile-time concurrency safety:

**Sendable:** маркер типов, безопасных для передачи между потоками. Если тип Sendable — его можно передать в другой поток без data race.

```swift
struct User: Sendable {  // Можно передавать между actors
    let id: Int          // let-поля безопасны (immutable)
    let name: String
}
```

**Actors:** изолируют mutable state. Actor гарантирует, что только один task выполняет его код в каждый момент. Это как mutex, но встроенный в систему типов.

```swift
actor BankAccount {
    private var balance: Int = 0

    func deposit(_ amount: Int) {
        balance += amount  // Безопасно — actor сериализует доступ
    }

    func getBalance() -> Int {
        return balance
    }
}

// Вызов из другого контекста — await указывает на переключение
let account = BankAccount()
await account.deposit(100)
```

Этот код демонстрирует, как Swift расширяет memory safety от управления временем жизни объектов (ARC) к управлению конкурентным доступом (actors). Компилятор проверяет isolation нарушения — попытка обратиться к actor-свойству без await не скомпилируется.

---

## Kotlin/Native Memory Model

### Старая модель: Freeze (shared XOR mutable)

Kotlin/Native (до 2021) использовал правило, вдохновлённое принципом ownership: **объект либо мутабельный и принадлежит одному потоку, либо иммутабельный и может быть разделён**.

```kotlin
// Объект мог быть:
// 1. Mutable и принадлежит одному потоку
// 2. Frozen (immutable) и доступен из любого потока

val data = mutableListOf("a", "b")
data.freeze()  // Теперь immutable НАВСЕГДА!
data.add("c")  // InvalidMutabilityException!
```

Это предотвращало data races: если объект разделён — он не может быть изменён. Но на практике freeze создавал много проблем: случайное замораживание графов объектов, невозможность использовать привычные паттерны (mutable state через dependency injection), необходимость в специальных concurrent-структурах данных.

### Новая модель (2021+): свобода и ответственность

Kotlin/Native перешёл на tracing GC и убрал обязательный freeze:

```kotlin
// Теперь можно разделять mutable state между потоками
val sharedList = mutableListOf<String>()
// Работает без freeze, но data races возможны!
```

Новая модель ближе к JVM: разработчик сам отвечает за синхронизацию (через Mutex, AtomicReference, coroutines и т.д.). Это проще в использовании, но перекладывает ответственность за data race safety на программиста.

---

## Практическое значение для KMP

### Разные модели на разных targets

```
┌─────────────────────────────────────────────────────────────────┐
│                KMP TARGETS MEMORY MODELS                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   JVM (Android)                                                 │
│   └── GC, thread-safe standard library                         │
│                                                                 │
│   Native (iOS)                                                  │
│   └── New GC model, Objective-C interop with ARC               │
│                                                                 │
│   JavaScript                                                    │
│   └── GC, single-threaded (mostly)                             │
│                                                                 │
│   WASM                                                          │
│   └── Linear memory, manual-ish                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Что это значит для разработчика

1. **Shared code должен быть thread-safe** — работает на всех targets
2. **iOS interop**: понимать ARC, weak references, retain cycles на границе Kotlin/Swift
3. **Concurrency**: использовать coroutines как абстракцию, скрывающую разницу моделей
4. **Тестировать на всех targets** — поведение может различаться (timing, finalization order)

---

## Подводные камни

### 1. Retain cycles (ARC)

```kotlin
// iOS interop: осторожно с циклическими ссылками
class Parent {
    var child: Child? = null
}

class Child {
    var parent: Parent? = null  // Retain cycle на iOS!
}
```

На JVM это не проблема (GC обрабатывает циклы). На iOS через Swift interop — memory leak. Решение: weak references на Swift стороне.

### 2. Data races без синхронизации

```kotlin
// Новая K/N модель НЕ защищает от data races:
var counter = 0
thread { counter++ }
thread { counter++ }
// counter может быть 1, 2, или что угодно
```

Решение: AtomicInt, Mutex, или coroutines.

### 3. Memory leaks в shared code

```kotlin
// Кэш без лимита — растёт бесконечно
object Cache {
    private val items = mutableMapOf<String, Data>()
    fun put(key: String, data: Data) {
        items[key] = data  // На всех платформах: GC не поможет
    }
}
```

Решение: LRU cache с ограничением размера, WeakReference.

### Мифы

**Миф:** GC решает все проблемы памяти.
**Реальность:** GC предотвращает use-after-free и double-free, но не memory leaks (удерживаемые ссылки) и не data races (конкурентный доступ). GC — один инструмент, не панацея.

**Миф:** Rust сложнее, чем стоит.
**Реальность:** Learning curve высокий, но для systems programming (ОС, браузеры, базы данных) баги memory safety стоят миллионы. Rust окупается на длинной дистанции. Для мобильных и веб-приложений — чаще всего не стоит усилий.

**Миф:** Kotlin/Native freeze делал код безопасным.
**Реальность:** Freeze предотвращал data races ценой неудобства. Новая модель удобнее, но требует явной синхронизации — как в Java.

---

## Связь с другими темами

### [[memory-model-fundamentals]] — Где происходят баги

Memory safety баги происходят на границе stack и heap: возврат указателя на stack-переменную (dangling), запись за границы heap-буфера (overflow), обращение к freed heap-блоку (use-after-free). Без понимания stack/heap из этого материала невозможно понять, почему эти баги существуют и что именно происходит при нарушении. Является prerequisite для данного материала.

### [[garbage-collection-explained]] — GC как одна из трёх стратегий

GC — первая стратегия memory safety в нашей классификации. Материал объясняет, как tracing GC устраняет use-after-free и double-free: программист не вызывает free() вообще. Также объясняет цену: STW паузы, overhead памяти. Понимание GC необходимо для сравнения с ownership-моделью. Читать перед данным материалом.

### [[reference-counting-arc]] — RC как вторая стратегия

ARC — вторая стратегия, находящаяся между GC и ownership. Детерминистична как ownership, но с overhead при каждом присваивании (как GC). Имеет проблему циклов (чего нет ни у GC, ни у ownership). Особенно важна для KMP, где iOS-target живёт в мире ARC. Читать перед данным материалом.

---

## Источники и дальнейшее чтение

- **Pierce, B. (2002). Types and Programming Languages (TAPL).** — фундаментальный учебник по системам типов, который объясняет теоретическую базу ownership. Главы о линейных типах (linear types) и аффинных типах (affine types) — это формальный фундамент, на котором построен borrow checker Rust. Для тех, кто хочет понять ownership не как "набор правил", а как математическую систему.

- **Stroustrup, B. (2013). The C++ Programming Language, 4th Edition.** — автор C++ объясняет RAII, move semantics и resource management. Главы 13-14 показывают, как C++ решает (и не решает) проблему memory safety. Полезно для понимания, почему Rust добавил borrow checker к RAII.

- **Klabnik, S. & Nichols, C. (2023). The Rust Programming Language.** — официальная книга по Rust ("The Book"). Главы 4-10 — лучшее объяснение ownership, borrowing, lifetimes. Написана для программистов, а не теоретиков.

- [Rust Book: Ownership](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html) — официальная документация
- [Stanford CS242: Rust Memory Safety](https://stanford-cs242.github.io/f18/lectures/05-1-rust-memory-safety.html) — академический взгляд
- [Kotlin: Immutability in Native](https://kotlinlang.org/docs/native-immutability.html) — freeze модель
- [Apple WWDC: Swift Actors](https://developer.apple.com/videos/play/wwdc2021/10133/) — actors и Sendable
- [verdagon: Memory Safety Approaches](https://verdagon.dev/grimoire/grimoire) — сравнение подходов

---

*Проверено: 2026-02-10*
