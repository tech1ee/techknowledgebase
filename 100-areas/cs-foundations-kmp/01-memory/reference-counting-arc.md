---
title: "Reference Counting и ARC: как Swift управляет памятью"
created: 2026-01-04
modified: 2026-02-10
type: deep-dive
status: published
tags:
  - topic/cs-foundations
  - type/deep-dive
  - level/intermediate
related:
  - "[[memory-model-fundamentals]]"
  - "[[garbage-collection-explained]]"
prerequisites:
  - "[[memory-model-fundamentals]]"
---

# Reference Counting и ARC: как Swift управляет памятью

> **TL;DR:** Reference Counting — подсчёт ссылок на объект: когда count = 0, объект удаляется. ARC (Automatic Reference Counting) в Swift автоматизирует этот процесс. Главная ловушка — retain cycles: объекты ссылаются друг на друга и никогда не освобождаются. Решение — weak и unowned ссылки. Для KMP критично: Kotlin/Native интегрируется с ARC при работе с iOS.

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **Stack vs Heap** | RC работает с heap-объектами | [[memory-model-fundamentals]] |
| **Garbage Collection** | Понять альтернативный подход | [[garbage-collection-explained]] |

---

## Терминология

| Термин | Что это | Аналогия |
|--------|---------|----------|
| **Reference Count** | Счётчик ссылок на объект | Сколько людей держат верёвку |
| **retain** | Увеличить счётчик (+1) | Взяться за верёвку |
| **release** | Уменьшить счётчик (-1) | Отпустить верёвку |
| **Retain Cycle** | Объекты ссылаются друг на друга | Замкнутый круг рукопожатий |
| **strong** | Обычная ссылка, увеличивает count | Крепкое рукопожатие |
| **weak** | Слабая ссылка, не увеличивает count | Взгляд на человека |
| **unowned** | Как weak, но не optional | Доверие что человек рядом |

---

## ПОЧЕМУ появился Reference Counting

### Исторический контекст: Collins и первая реализация (1960)

Reference counting появился в том же 1960 году, что и tracing GC Маккарти. George E. Collins опубликовал статью "A Method for Overlapping and Erasure of Lists", в которой предложил принципиально другой подход к автоматическому управлению памятью.

Идея Коллинза была проста и элегантна: каждый объект в памяти хранит счётчик — число ссылок, указывающих на него. Когда создаётся новая ссылка — счётчик увеличивается. Когда ссылка исчезает — уменьшается. Когда счётчик достигает нуля — объект немедленно удаляется.

Это принципиально отличается от tracing GC, который периодически обходит весь граф объектов. Reference counting работает "в реальном времени": объект удаляется в тот самый момент, когда последняя ссылка на него исчезает. Не через секунду, не при следующей сборке — прямо сейчас.

### До ARC: ручное управление памятью в Objective-C

В раннем Objective-C программисты вручную вызывали `retain` и `release`. Это называлось MRR (Manual Retain-Release).

Каждый вызов `alloc`, `new`, `copy` или `mutableCopy` создавал объект с count = 1. Программист был обязан вызвать `release` для каждого из этих вызовов. Забыл — memory leak. Вызвал лишний раз — crash.

```objc
// Objective-C до ARC: программист вручную управлял счётчиком
NSString *str = [[NSString alloc] init];  // count = 1
[str retain];                              // count = 2
[str release];                             // count = 1
[str release];                             // count = 0 → dealloc
```

Этот код показывает основной цикл: создание (alloc, count=1), увеличение (retain, count=2), уменьшение (release) и финальное удаление при count=0. На практике в сложных приложениях с сотнями объектов отследить все retain/release было мучительно.

### 2011: Apple вводит ARC

С iOS 5 и Xcode 4.2 Apple представила ARC. Компилятор (LLVM) сам вставляет retain/release в нужных местах. Разработчик больше не думает о count — код выглядит как будто память бесконечная.

```swift
// Swift с ARC — никаких ручных retain/release
var str: String? = "Hello"  // ARC вставляет retain
str = nil                    // ARC вставляет release → dealloc
```

ARC — не garbage collection. Это **compile-time оптимизация**: компилятор анализирует код и вставляет нужные вызовы. Никаких пауз во время работы программы. Никакого фонового потока, сканирующего память.

### Почему Apple выбрала ARC, а не GC

Apple экспериментировала с garbage collection на macOS (Objective-C GC, 2006-2012), но отказалась от него. Причины были фундаментальными:

- **Непредсказуемые паузы.** GC может запуститься в любой момент, что критично для UI. Пользователь проводит пальцем по экрану — и приложение замирает на 50 мс из-за GC. Это неприемлемо для iOS.
- **Больше памяти.** Исследования показывают, что GC эффективен при 3-6x доступной памяти относительно live data. На iPhone с ограниченной RAM это роскошь.
- **Детерминизм.** ARC даёт предсказуемое поведение: объект удаляется в тот момент, когда последняя ссылка исчезает. Программист может рассуждать о timing.

> **Ключевая идея:** Выбор ARC вместо GC — это не "Apple хочет быть не как все". Это продуманный инженерный компромисс: ARC даёт предсказуемость и низкий overhead ценой проблемы циклических ссылок, которую программист решает вручную.

---

## ЧТО такое Reference Counting

### Как это работает: пошаговый жизненный цикл

Чтобы по-настоящему понять reference counting, проследим за жизнью одного объекта от создания до удаления. Представь, что объект — это воздушный шар, а ссылки — нитки, за которые его держат люди.

Пока хоть один человек держит нитку — шар летает. Когда последний человек отпускает — шар улетает (объект удаляется). Никто не проверяет шары периодически — удаление происходит в момент, когда последняя нитка отпущена.

```
┌─────────────────────────────────────────────────────────────────┐
│           ЖИЗНЕННЫЙ ЦИКЛ ОБЪЕКТА С REFERENCE COUNTING          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Действие                    count    Состояние               │
│   ─────────────────────────   ─────    ─────────               │
│                                                                 │
│   let a = Person("Alice")     1        Создан                  │
│   ┌─────┐    ┌────────────┐                                    │
│   │  a ─┼───▶│ Person     │                                    │
│   └─────┘    │ count: 1   │                                    │
│              └────────────┘                                    │
│                                                                 │
│   let b = a                   2        Две ссылки              │
│   ┌─────┐    ┌────────────┐                                    │
│   │  a ─┼───▶│ Person     │                                    │
│   └─────┘    │ count: 2   │◀──┐                               │
│   ┌─────┐    └────────────┘   │                               │
│   │  b ─┼─────────────────────┘                               │
│   └─────┘                                                      │
│                                                                 │
│   a = nil                     1        Осталась одна           │
│   ┌─────┐    ┌────────────┐                                    │
│   │  a  │    │ Person     │◀──┐                               │
│   │ nil │    │ count: 1   │   │                               │
│   └─────┘    └────────────┘   │                               │
│   ┌─────┐                     │                               │
│   │  b ─┼─────────────────────┘                               │
│   └─────┘                                                      │
│                                                                 │
│   b = nil                     0        → DEALLOC               │
│   Счётчик = 0 → deinit() вызывается немедленно               │
│   Память освобождается                                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

Обрати внимание на ключевое свойство: **деаллокация детерминистична**. В момент `b = nil` объект удаляется немедленно. Не "когда-нибудь потом", не "при следующем цикле GC" — прямо в этой строке кода. Деструктор (`deinit` в Swift) вызывается синхронно.

Это радикально отличается от tracing GC, где момент удаления непредсказуем. Для ресурсов, требующих немедленного освобождения (файловые дескрипторы, сетевые соединения), детерминизм RC — огромное преимущество.

### Что хранится внутри объекта

Каждый объект в Swift содержит в своём заголовке (object header) не один, а два счётчика:

- **Strong reference count** — число strong ссылок. Когда достигает 0 — вызывается deinit, освобождается payload.
- **Weak reference count** — число weak ссылок. Когда достигает 0 — освобождается сам object header.

Почему два? Потому что weak ссылки должны быть обнулены (set to nil) при удалении объекта. Для этого runtime должен знать, где эти weak ссылки находятся. Object header с weak count хранит эту информацию и живёт, пока есть хоть одна weak ссылка, даже если объект "логически мёртв" (strong count = 0, deinit вызван).

### Три типа ссылок в Swift

Swift предоставляет три типа ссылок с разным поведением:

**Strong (по умолчанию):**
```swift
var person: Person? = Person()  // strong reference, count+1
```
Увеличивает count. Объект живёт пока есть хотя бы одна strong ссылка.

**Weak:**
```swift
weak var delegate: PersonDelegate?  // НЕ увеличивает count
```
Не увеличивает count. ARC автоматически обнуляет (nil) когда объект удаляется. Всегда optional.

**Unowned:**
```swift
unowned var parent: Parent  // НЕ увеличивает count, НЕ optional
```
Как weak, но не optional. Если объект удалён, а ты обращаешься к unowned — crash. Использовать только когда уверен в lifetime.

### Сравнение типов ссылок

```
┌─────────────────────────────────────────────────────────────────┐
│                    ТИПЫ ССЫЛОК В SWIFT                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Тип        count++?   Optional?   При dealloc объекта        │
│   ─────────────────────────────────────────────────────────    │
│   strong     Да         Опционально Ничего (ссылка держит)     │
│   weak       Нет        Обязательно Становится nil             │
│   unowned    Нет        Нет         CRASH при доступе          │
│                                                                 │
│   ─────────────────────────────────────────────────────────    │
│                                                                 │
│   Безопасность:  strong > weak > unowned                       │
│   Производительность: unowned > weak > strong                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## ПОЧЕМУ циклические ссылки — неразрешимая проблема для RC

### Объяснение через теорию графов

Retain cycle — не просто "баг" или "неудачный паттерн". Это **фундаментальное ограничение** reference counting, и его невозможно устранить внутри самого механизма RC. Чтобы понять почему, обратимся к теории графов.

Граф объектов в памяти — это ориентированный граф, где вершины — объекты, а рёбра — ссылки. Reference counting определяет "мёртвый" объект как вершину с входящей степенью 0 (нет входящих рёбер = нет ссылок на объект = count = 0).

Проблема: в цикле каждая вершина имеет входящую степень >= 1 (хотя бы одно входящее ребро от соседа по циклу). Это значит, что count никогда не достигнет 0, даже если весь цикл недостижим от корней.

```
Цикл в терминах теории графов:

    Корни (roots)
       │
       ╳  ← нет рёбер от корней к циклу
       │
    ┌──▼───┐         ┌────────┐
    │  A   │────────▶│   B    │
    │ in=1 │         │ in=1   │
    └──────┘         └───┬────┘
       ▲                 │
       │                 │
       └─────────────────┘

    A.count = 1 (ссылка от B)
    B.count = 1 (ссылка от A)

    Оба недостижимы от корней, но оба имеют count > 0.
    RC считает их "живыми". Утечка.

    Tracing GC проверяет достижимость от корней →
    A и B недостижимы → мусор. Нет проблемы.
```

Формально: reference counting — это **локальный** критерий (смотрит только на входящие рёбра конкретной вершины). Достижимость от корней — **глобальный** критерий (требует обхода всего графа). Локальный критерий не может обнаружить глобальное свойство "недостижимость". Это не недоработка — это математическое ограничение.

### Почему нельзя "просто" обнаружить циклы

Можно ли добавить к RC обнаружение циклов? Технически — да. Python это делает: основной механизм — RC, но дополнительно запускается cycle detector, который ищет недостижимые группы объектов. Но это, по сути, **мини-tracing GC** поверх RC. Мы получаем худшее от обоих миров: overhead RC при каждой операции с ссылками + периодические паузы на обнаружение циклов.

Apple в Swift сделала сознательный выбор: не добавлять cycle detector, а положить ответственность на разработчика. Программист должен знать, где возможны циклы, и разрывать их через weak/unowned.

---

## Retain Cycles: главная проблема RC

### Почему GC не нужны weak/unowned?

Tracing GC (как в Java) находит живые объекты от корней. Если два объекта ссылаются друг на друга, но недостижимы от корней — они мусор.

Reference Counting не умеет так. Он смотрит только на count. Если A → B и B → A, оба имеют count > 0, оба "живые". Но если никто извне не ссылается на них — это memory leak.

```
┌─────────────────────────────────────────────────────────────────┐
│                      RETAIN CYCLE                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│       ┌──────────┐          ┌──────────┐                       │
│       │ Person A │───────▶  │ Person B │                       │
│       │ count=1  │  strong  │ count=1  │                       │
│       └──────────┘          └──────────┘                       │
│              ▲                    │                             │
│              │      strong        │                             │
│              └────────────────────┘                             │
│                                                                 │
│   Никто извне не держит A и B, но count никогда не станет 0!   │
│   Результат: memory leak                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Типичные паттерны retain cycles

**1. Delegates:**
```swift
class ViewController {
    var tableView: TableView!

    func setup() {
        tableView = TableView()
        tableView.delegate = self  // VC → TableView → VC = cycle!
    }
}
```

**2. Closures:**
```swift
class ViewController {
    var handler: (() -> Void)?

    func setup() {
        handler = {
            self.doSomething()  // Closure захватывает self strongly
        }
        // VC → handler → VC = cycle!
    }
}
```

**3. Parent-Child:**
```swift
class Parent {
    var child: Child?
}

class Child {
    var parent: Parent?  // Если strong — cycle!
}
```

### Решение: разорвать цикл

Одна ссылка в цикле должна быть weak или unowned:

```swift
// Delegates — weak разрывает cycle
protocol TableViewDelegate: AnyObject {}

class TableView {
    weak var delegate: TableViewDelegate?  // weak → count не увеличивается
}

// Closures — capture list
handler = { [weak self] in
    self?.doSomething()  // self теперь optional
}

// Parent-Child — child слабо ссылается на parent
class Child {
    weak var parent: Parent?
}
```

**Конвенция Apple:** parent → child = strong, child → parent = weak. Это следует из иерархии владения: родитель "владеет" ребёнком, ребёнок лишь "знает" родителя.

---

## weak vs unowned: когда какой и ПОЧЕМУ

### Глубокое рассуждение о выборе

Оба типа — weak и unowned — не увеличивают reference count. Оба используются для разрыва циклов. Но они решают разные проблемы, и выбор между ними — это рассуждение о **lifetime (времени жизни)** объектов.

**weak — когда lifetime объекта-target неизвестен или может закончиться раньше.**

Представь аналогию: ты записал номер телефона знакомого на бумажке. Знакомый может поменять номер, уехать, перестать отвечать — ты не контролируешь его жизнь. Когда звонишь — сначала проверяешь: "Номер ещё работает?" (optional check). Если нет — ничего страшного, просто не звонишь.

Типичные сценарии для weak:
- **Delegate паттерн.** ViewController может быть закрыт в любой момент. TableView не контролирует lifetime VC.
- **Async callbacks.** Сетевой запрос может вернуться, когда экран уже закрыт.
- **Наблюдатели (observers).** Подписчик может отписаться и быть удалён.

**unowned — когда lifetime объекта-target гарантированно не короче lifetime ссылки.**

Аналогия: у тебя есть банковская карта. Карта привязана к счёту. Счёт не может быть закрыт, пока существует карта (банк это гарантирует). Тебе не нужно проверять "счёт ещё существует?" перед каждой транзакцией — он точно есть.

Типичные сценарии для unowned:
- **Кредитная карта → Клиент.** Карта не может существовать без клиента.
- **Замыкание, вызываемое синхронно.** Если closure выполняется прямо сейчас, self точно жив.
- **Child → Parent, когда parent всегда переживёт child.**

### ПОЧЕМУ unowned быстрее, чем weak

Weak ссылки требуют дополнительной работы от runtime:

1. **Регистрация.** Когда создаётся weak ссылка, runtime добавляет её в таблицу "weak ссылок на этот объект".
2. **Обнуление.** Когда объект удаляется, runtime проходит по таблице и обнуляет все weak ссылки (ставит nil).
3. **Проверка при доступе.** Каждое обращение к weak ссылке — optional unwrap.

Unowned ссылки не требуют ни регистрации, ни обнуления. Доступ к unowned — просто чтение указателя, как у strong ссылки. Если объект удалён — crash, но нет overhead при каждом доступе.

> **Правило безопасности:** Если сомневаешься — используй weak. unowned crash в продакшене сложно диагностировать, а overhead weak незначителен для 99% случаев.

### Когда weak

Используй weak когда объект может быть deallocated во время жизни ссылки:

```swift
// Async операции: VC может быть закрыт, пока идёт сетевой запрос
networkClient.fetch { [weak self] data in
    guard let self = self else { return }  // VC мог быть закрыт
    self.updateUI(with: data)
}
```

Этот код безопасно обрабатывает ситуацию, когда ViewController удалён до завершения сетевого запроса. Без `[weak self]` closure удерживала бы VC в памяти, даже если пользователь ушёл с экрана.

### Когда unowned

Используй unowned когда гарантирован lifetime — объект точно переживёт ссылку:

```swift
class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) { self.name = name }
}

class CreditCard {
    let number: String
    unowned let customer: Customer  // Карта не существует без клиента

    init(number: String, customer: Customer) {
        self.number = number
        self.customer = customer
    }
}
```

Здесь CreditCard всегда создаётся с Customer, и Customer владеет картой. Карта не может пережить клиента — unowned безопасен и быстрее weak.

---

## RC vs Tracing GC: сравнение с объяснением каждого trade-off

Понимание trade-offs между RC и GC критично для KMP-разработчика, потому что JVM-target использует tracing GC, а iOS-target живёт в мире ARC.

| Критерий | Reference Counting (ARC) | Tracing GC (JVM) | Объяснение |
|----------|-------------------------|------------------|------------|
| **Момент удаления** | Детерминистичный (при count=0) | Недетерминистичный (при GC cycle) | RC удаляет объект мгновенно. GC — "когда-нибудь". Для ресурсов (файлы, соединения) детерминизм критичен. |
| **Циклы** | НЕ обрабатывает (нужны weak/unowned) | Обрабатывает автоматически | Фундаментальное ограничение RC: локальный критерий не видит глобальной недостижимости. |
| **Паузы** | Нет больших пауз | Stop-the-World паузы | RC распределяет работу равномерно. GC накапливает и делает пакетно. Но RC может иметь "avalanche" при удалении большого графа. |
| **Throughput** | Ниже (overhead при каждом присваивании) | Выше (нет overhead при работе) | Каждое `a = b` в RC — это retain + release. В GC — просто запись указателя. |
| **Overhead памяти** | Низкий (только счётчик в header) | Высокий (GC эффективен при 3-6x live data) | GC нуждается в "запасной" памяти: место для копирования, worklist, метаданные. |
| **Предсказуемость latency** | Высокая | Низкая (зависит от GC timing) | Для UI-приложений (iOS) предсказуемость важнее throughput. Для серверов — наоборот. |
| **Потоковая безопасность** | Атомарные операции на счётчике | GC обрабатывает сам | Atomic increment/decrement на каждом retain/release — это несколько тактов CPU. В многопоточных приложениях — конкуренция за cache line. |
| **Сложность для разработчика** | Средняя (нужно думать о weak/unowned) | Низкая (GC делает всё) | RC перекладывает ответственность за циклы на программиста. GC берёт всё на себя, но забирает контроль. |

> **Ключевой инсайт:** Ни один подход не лучше другого абсолютно. RC оптимален для систем с ограниченной памятью и требованиями к предсказуемости (мобильные устройства, embedded). GC оптимален для серверов, где throughput важнее latency и памяти достаточно.

---

## Kotlin/Native и ARC: как они работают вместе

В KMP Kotlin-код компилируется в native для iOS. Kotlin/Native использует tracing GC, а Swift — ARC. Как они интегрируются?

### Kotlin → Swift

Когда Kotlin-объект передаётся в Swift, он оборачивается в специальную Swift-обёртку:

```
┌─────────────────────────────────────────────────────────────────┐
│             KOTLIN → SWIFT INTEROP                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Kotlin Side              Swift Side                           │
│   ┌──────────────┐         ┌──────────────────┐                │
│   │ KotlinObject │ ──────▶ │ SwiftWrapper     │                │
│   │ (GC tracked) │         │ (ARC tracked)    │                │
│   └──────────────┘         │ refCount: 1      │                │
│                            └──────────────────┘                │
│                                                                 │
│   ARC управляет SwiftWrapper                                   │
│   Kotlin GC видит что есть внешняя ссылка                      │
│   Объект не удаляется пока Swift держит wrapper                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Swift → Kotlin

Swift-объекты в Kotlin отслеживаются через "stable references":

```kotlin
// Kotlin видит Swift-объект через stable reference
val swiftDelegate: NSObject = ...

// Kotlin GC держит stable reference, которая предотвращает
// удаление Swift-объекта через ARC. Когда Kotlin отпускает
// stable ref — ARC может освободить объект
```

Этот механизм показывает, как два разных подхода к управлению памятью (tracing GC и RC) координируются на границе языков.

### Особенности interop

**Deinitialization timing:**
```swift
// По умолчанию deinit вызывается на main thread
class SwiftClass {
    deinit { print("deinit on \(Thread.current)") }
}
```

По умолчанию deinit вызывается на main thread. Можно изменить:
```properties
# gradle.properties
kotlin.native.binary.objcDisposeOnMain=false
```

**Сборка требует 2 GC cycles:**
Смешанные графы (Kotlin + Swift объекты) требуют двух проходов GC — сначала Kotlin, потом deinit Swift, потом опять Kotlin.

**autoreleasepool для loops:**
```kotlin
fun processMany() {
    repeat(1000) {
        autoreleasepool {
            callSwiftCode()  // Без autoreleasepool объекты копятся до конца цикла
        }
    }
}
```

Без autoreleasepool Swift-объекты, созданные внутри цикла, не освобождаются до завершения всего блока. autoreleasepool заставляет ARC освободить их после каждой итерации.

### Retain Cycles между языками

Kotlin GC обрабатывает циклы внутри Kotlin. ARC не обрабатывает циклы. Но если цикл проходит через оба языка — проблема:

```
Kotlin A → Swift B → Kotlin A

Ни Kotlin GC, ни ARC не могут разорвать!
```

**Решение:** weak ссылки на Swift стороне.

---

## Подводные камни

### Типичные ошибки

| Ошибка | Симптом | Решение |
|--------|---------|---------|
| Забыл [weak self] в closure | Memory leak, VC не освобождается | Добавить capture list |
| unowned на async операции | Crash | Использовать weak |
| Strong delegate | Cycle VC ↔ View | Weak delegate |
| Closure в NotificationCenter | Leak | [weak self] + removeObserver |

### Когда RC/ARC не подходит

- **Много циклических структур.** Графы, деревья с parent ссылками требуют внимания. Каждый цикл — потенциальная утечка.
- **Hot loops с объектами.** Частые retain/release могут создать overhead. Атомарные операции на счётчике не бесплатны.
- **Непредсказуемый lifetime.** Если сложно определить кто кого переживёт — weak/unowned выбор становится угадыванием.

### Распространённое заблуждение: "RC не имеет пауз"

RC детерминистичен, но это не значит "без задержек". Когда последняя ссылка на корень большого графа объектов исчезает, начинается **каскадное удаление**: объект A удаляется, его ссылка на B обнуляется, B.count = 0, B удаляется, его ссылка на C обнуляется... Это может занять значительное время, если граф содержит тысячи объектов.

Эта "лавина" (avalanche) удалений может заморозить UI не хуже STW паузы GC. Разница в том, что в RC программист может контролировать, когда это произойдёт (не удаляя корневую ссылку в критический момент), а GC запускается непредсказуемо.

### Debugging

**Memory Graph Debugger (Xcode):**
Debug → Debug Memory Graph показывает все объекты и ссылки. Retain cycles видны как изолированные группы.

**Instruments:**
- Leaks — находит утечки
- Allocations — показывает что живёт дольше положенного

**Kotlin/Native:**
```properties
# Включить GC логи
-Xruntime-logs=gc=info
```

---

## Связь с другими темами

### [[memory-model-fundamentals]] — Фундамент: где живут объекты

Reference counting работает с объектами в heap. Понимание heap-аллокации, free list, фрагментации — необходимая база. Без этого непонятно, что именно делает `dealloc`: возвращает блок памяти в free list аллокатора. Также важно понимание stack, потому что stack-переменные являются "корневыми" ссылками, увеличивающими reference count при создании. Рекомендуется как prerequisite.

### [[garbage-collection-explained]] — Альтернативный подход: tracing вместо counting

GC и RC — дуальные подходы. GC ищет живое (от корней), RC ищет мёртвое (count = 0). Понимание обоих даёт полную картину. Особенно важно для KMP: на JVM target работает tracing GC, на iOS target — взаимодействие с ARC. Разработчик, понимающий оба подхода, может писать shared-код, который эффективен на обеих платформах. Этот материал дополняет garbage-collection-explained, и лучше читать их последовательно.

---

## Источники и дальнейшее чтение

- **Collins, G.E. (1960). A Method for Overlapping and Erasure of Lists.** — оригинальная статья, предложившая reference counting. Удивительно короткая и элегантная. Показывает, как одна простая идея (считать ссылки) решает сложную проблему управления памятью.

- **Apple Documentation: Automatic Reference Counting.** — официальная документация Apple по ARC в Swift. Содержит точные правила для strong, weak, unowned ссылок, capture lists в closures и примеры retain cycles. Обязательное чтение для iOS-разработчика.

- **Jones, R. & Lins, R. (1996). Garbage Collection.** — главы 2 и 3 посвящены reference counting и его вариантам. Академически строгий анализ преимуществ и ограничений RC, включая доказательство невозможности обнаружения циклов без глобального обхода.

- [Swift Documentation: ARC](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting/) — официальная документация
- [Kotlin/Native ARC Integration](https://kotlinlang.org/docs/native-arc-integration.html) — interop с Swift
- [SwiftLee: Weak Self](https://www.avanderlee.com/swift/weak-self/) — практические советы
- [Cocoacasts: Reference Cycles](https://cocoacasts.com/what-are-strong-reference-cycles) — паттерны и решения

---

*Проверено: 2026-02-10*
