---
title: "Модель памяти: Stack и Heap"
created: 2026-01-04
modified: 2026-01-04
type: deep-dive
status: published
tags:
  - topic/cs-foundations
  - type/deep-dive
  - level/intermediate
related:
  - "[[garbage-collection-explained]]"
  - "[[reference-counting-arc]]"
  - "[[kmp-memory-management]]"
---

# Модель памяти: Stack и Heap

> **TL;DR:** Программа использует два типа памяти. Stack — быстрый, автоматический, но маленький; работает как стопка тарелок (последняя положенная — первая снятая). Heap — большой, гибкий, но медленный и требует уборки. Stack для временных данных внутри функции. Heap для данных, которые живут дольше одного вызова.

---

## Зачем это знать

Когда ты пишешь `val user = User("John")` в Kotlin, что происходит? Где хранится `user`? Где хранится сам объект `User`? Почему иногда программа падает с `StackOverflowError`, а иногда с `OutOfMemoryError`?

Без понимания модели памяти ты будешь:
- Не понимать, почему рекурсия "взрывается"
- Удивляться утечкам памяти
- Не понимать разницу между JVM и Kotlin/Native

Это фундамент. После этого материала Garbage Collection и ARC станут понятны.

---

## Терминология

| Термин | Что это | Аналогия |
|--------|---------|----------|
| **Stack** | Область памяти для локальных переменных и вызовов функций | Стопка тарелок: кладёшь сверху, берёшь сверху |
| **Heap** | Область памяти для объектов с динамическим временем жизни | Склад: ставишь куда хочешь, сам следишь за порядком |
| **Stack frame** | Блок памяти для одного вызова функции | Один лист в блокноте для одной задачи |
| **Stack pointer** | Указатель на текущую "верхушку" стека | Закладка "читать здесь" |
| **Allocation** | Выделение памяти | Бронирование места |
| **Deallocation** | Освобождение памяти | Освобождение места |
| **Fragmentation** | Дробление свободной памяти на мелкие куски | Дырки в сыре |

---

## ПОЧЕМУ память разделена на Stack и Heap

### Проблема: разные данные живут по-разному

Представь программу как офис. Есть два типа документов:

**Тип 1: Черновики.** Написал, использовал, выбросил. Нужны только пока работаешь над задачей. Таких — большинство.

**Тип 2: Договоры.** Подписал, положил в архив. Нужны долго, к ним обращаются разные отделы.

Хранить их одинаково — неэффективно. Черновики можно на стол, быстро взял и выбросил. Договоры — в шкаф, с каталогом.

Так же и с памятью:
- **Локальные переменные** — черновики. Нужны только внутри функции.
- **Объекты** — договоры. Могут передаваться между функциями, жить долго.

### Историческая справка

**1950-е, Fortran:** Вся память выделялась при компиляции. Размер массива? Укажи заранее. Рекурсия? Невозможна. Просто, но негибко.

**1958, ALGOL 60:** Появился stack. Функции могут вызывать друг друга, каждая получает свой "блок" памяти. Рекурсия стала возможной. Революция.

**1960-е, Lisp:** Появился heap. Данные могут жить дольше функции. Появился Garbage Collection — автоматическая уборка.

**1970-е, C:** Stack + Heap, но без GC. Программист сам управляет heap через `malloc`/`free`.

Сегодня эта модель — стандарт. JVM, .NET, Go, Rust, Kotlin/Native — все используют stack и heap.

---

## ЧТО такое Stack

### Принцип работы: LIFO

Stack работает по принципу LIFO — Last In, First Out. Последний вошёл — первый вышел.

```
Аналогия: стопка тарелок

     ┌─────────┐
     │ Тарелка │  ← Последняя положенная
     ├─────────┤
     │ Тарелка │
     ├─────────┤
     │ Тарелка │  ← Первая положенная
     └─────────┘

Можешь взять только верхнюю.
Чтобы достать нижнюю — сними все сверху.
```

Почему именно так? Потому что функции работают вложенно: `main()` вызывает `processUser()`, та вызывает `validateEmail()`. Когда `validateEmail()` завершается, её данные больше не нужны — снимаем "тарелку". Потом `processUser()` завершается — снимаем следующую.

### Stack Frame

Каждый вызов функции создаёт **stack frame** — блок памяти с:
- Параметрами функции
- Локальными переменными
- Адресом возврата (куда вернуться после завершения)

```
STACK при вызове validateEmail() из processUser() из main()

    Высокие адреса
    ┌─────────────────────┐
    │   main()            │ ← Первый вызов
    │   - args            │
    │   - user            │
    ├─────────────────────┤
    │   processUser()     │ ← Второй вызов
    │   - userId          │
    │   - result          │
    │   - return address  │
    ├─────────────────────┤
    │   validateEmail()   │ ← Текущий (верхушка)
    │   - email           │
    │   - isValid         │
    │   - return address  │
    └─────────────────────┘ ← Stack Pointer
    Низкие адреса

    Stack растёт ВНИЗ (от высоких адресов к низким)
```

### Почему Stack быстрый

1. **Простая арифметика.** Выделить память = сдвинуть указатель на N байт. Одна CPU-инструкция.

2. **Нет поиска.** Не нужно искать "свободное место". Следующий свободный адрес всегда известен.

3. **Кэш-friendly.** Данные расположены последовательно. CPU кэширует соседние области — быстрый доступ.

4. **Нет фрагментации.** Память всегда освобождается в обратном порядке. Никаких "дырок".

### Ограничения Stack

- **Фиксированный размер.** Обычно 1MB на поток. Превысил — `StackOverflowError`.
- **Только LIFO.** Нельзя освободить данные "из середины".
- **Локальный для потока.** Каждый поток имеет свой stack. Нельзя передать данные напрямую.

---

## ЧТО такое Heap

### Принцип работы: свободное размещение

Heap — это "склад". Ты просишь место, система находит свободный участок и даёт тебе адрес.

```
Аналогия: пляж

┌─────────────────────────────────────────┐
│  🏖️ ПЛЯЖ (Heap)                         │
│                                         │
│  [Занято]    [Свободно]    [Занято]     │
│     ↑                         ↑         │
│   Чьё-то        Можно      Чьё-то       │
│   полотенце    занять      полотенце    │
│                                         │
│  [Свободно]  [Занято]  [Свободно]       │
│                                         │
└─────────────────────────────────────────┘

- Ставишь вещи где хочешь (где есть место)
- Забираешь когда хочешь
- Если не уберёшь — будет захламлено
```

### Как работает выделение памяти

Когда ты пишешь `new User()` или `malloc(100)`:

1. **Поиск свободного блока.** Система просматривает список свободных участков.
2. **Выбор стратегии.** First-fit (первый подходящий), best-fit (наиболее подходящий по размеру), и т.д.
3. **Разделение блока.** Если блок больше нужного — делится на две части.
4. **Возврат адреса.** Ты получаешь указатель на выделенную память.

```
Пример: запрос 100 байт

ДО:
┌────────────────────────────────────┐
│ Занято (200) │ Свободно (500)     │
└────────────────────────────────────┘

ПОСЛЕ:
┌──────────────────────────────────────────┐
│ Занято (200) │ Новое (100) │ Свободно (400) │
└──────────────────────────────────────────┘
```

### Проблема: фрагментация

Со временем heap становится "дырявым":

```
После многих allocation/deallocation:

┌───┬─────┬───┬───────┬───┬─────┬───┐
│ X │     │ X │       │ X │     │ X │
└───┴─────┴───┴───────┴───┴─────┴───┘
    ↑         ↑           ↑
  50 байт  100 байт    75 байт свободно

Всего свободно: 225 байт
Но запросить 200 байт НЕЛЬЗЯ — нет непрерывного куска!

Это — внешняя фрагментация.
```

Есть ещё **внутренняя фрагментация**: система выделяет чуть больше, чем просили (для выравнивания или служебных данных).

### Почему Heap медленнее

1. **Поиск свободного места.** Нужно пройти по списку свободных блоков.
2. **Фрагментация.** Иногда нужно объединять соседние свободные блоки (coalescing).
3. **Thread safety.** Heap общий для всех потоков — нужна синхронизация.
4. **Менее кэш-friendly.** Объекты разбросаны по памяти — больше cache misses.

### Преимущества Heap

- **Гибкий размер.** Ограничен только доступной памятью.
- **Любой порядок освобождения.** Можно удалить объект из "середины".
- **Общий для потоков.** Объекты доступны из любого потока.
- **Долгоживущие данные.** Переживают завершение функции.

---

## КАК Stack и Heap работают вместе

### Типичный сценарий в JVM/Kotlin

```kotlin
fun createUser(name: String): User {
    val age = 25           // примитив → stack
    val user = User(name, age)  // объект → heap, ссылка → stack
    return user            // возвращаем ссылку
}
```

```
STACK                           HEAP
┌─────────────────┐            ┌─────────────────┐
│ createUser()    │            │                 │
│   name: ref ────┼────────────┼──→ "John"       │
│   age: 25       │            │                 │
│   user: ref ────┼────────────┼──→ User {       │
│                 │            │      name: ref  │
│                 │            │      age: 25    │
└─────────────────┘            │    }            │
                               └─────────────────┘
```

**Что где хранится:**

| Данные | Где | Почему |
|--------|-----|--------|
| `age = 25` (примитив) | Stack | Маленький, короткоживущий |
| `user` (ссылка) | Stack | Это просто адрес, 8 байт |
| `User(...)` (объект) | Heap | Может жить после завершения функции |
| `"John"` (строка) | Heap | Объект, переживает функцию |

### Что происходит при возврате из функции

1. Stack frame `createUser()` удаляется
2. Переменная `user` (ссылка) исчезает
3. Но объект `User` в heap остаётся!
4. Если возвращённую ссылку кто-то сохранит — объект живёт
5. Если никто не сохранит — объект станет "мусором" (для GC)

---

## Различия в разных платформах

### JVM (Android, Backend)

```
┌─────────────────────────────────────────┐
│                JVM                       │
├──────────────┬──────────────────────────┤
│    Stack     │         Heap             │
│  (per thread)│       (shared)           │
├──────────────┼──────────────────────────┤
│ - Примитивы  │ - Все объекты            │
│ - Ссылки     │ - Массивы                │
│ - Параметры  │ - Строки                 │
│              │                          │
│ Размер: -Xss │ Размер: -Xms, -Xmx       │
│ Default: 1MB │ Default: varies          │
├──────────────┴──────────────────────────┤
│ Управление heap: Garbage Collector      │
│ (G1, ZGC, Shenandoah)                   │
└─────────────────────────────────────────┘
```

### Kotlin/Native (iOS)

```
┌─────────────────────────────────────────┐
│           Kotlin/Native                  │
├──────────────┬──────────────────────────┤
│    Stack     │         Heap             │
│  (per thread)│       (shared)           │
├──────────────┼──────────────────────────┤
│ - Примитивы  │ - Все объекты            │
│ - Struct-ы   │ - Classes                │
│ - Параметры  │                          │
├──────────────┴──────────────────────────┤
│ Управление heap:                        │
│ - Tracing GC (с Kotlin 1.7.20)          │
│ - Ранее: ARC + freeze model             │
└─────────────────────────────────────────┘
```

### C/C++ (Native)

```
┌─────────────────────────────────────────┐
│              Native C/C++                │
├──────────────┬──────────────────────────┤
│    Stack     │         Heap             │
├──────────────┼──────────────────────────┤
│ - Локальные  │ - malloc() / new         │
│   переменные │ - Ручное управление      │
│ - Автоматич. │ - free() / delete        │
│   очистка    │                          │
├──────────────┴──────────────────────────┤
│ Управление heap: ПРОГРАММИСТ            │
│ Забыл free() = утечка памяти            │
│ Двойной free() = undefined behavior     │
└─────────────────────────────────────────┘
```

---

## Подводные камни

### 1. Stack Overflow

**Причина:** Слишком глубокая рекурсия или большие локальные массивы.

```kotlin
// ❌ Бесконечная рекурсия
fun infiniteLoop() {
    infiniteLoop() // Каждый вызов = новый stack frame
} // → StackOverflowError

// ❌ Слишком глубокая рекурсия
fun factorial(n: Long): Long {
    if (n <= 1) return 1
    return n * factorial(n - 1)
}
factorial(100000) // → StackOverflowError
```

**Решение:** Используй итерацию вместо глубокой рекурсии, или `tailrec` в Kotlin.

### 2. Возврат указателя на локальную переменную (C/C++)

```c
// ❌ ОПАСНО: возврат указателя на stack
int* dangerous() {
    int x = 42;
    return &x;  // x исчезнет после возврата!
}

int* p = dangerous();
*p = 10;  // Undefined behavior! Память уже не наша.
```

В Kotlin/Java этой проблемы нет — объекты на heap, ссылки безопасны.

### 3. Утечки памяти (Memory Leaks)

**Heap без GC (C/C++):**
```c
void leak() {
    int* p = malloc(1000);
    // Забыли free(p)!
    // Память занята, но недоступна
}
```

**Heap с GC (Java/Kotlin):** Утечки тоже возможны, если держишь ссылки на ненужные объекты.

```kotlin
// ❌ Утечка: список растёт бесконечно
object Cache {
    private val items = mutableListOf<Data>()

    fun add(data: Data) {
        items.add(data) // Никогда не очищается
    }
}
```

### 4. Миф: "Примитивы всегда на stack"

Это упрощение. На самом деле:

| Ситуация | Где хранится |
|----------|--------------|
| Локальная переменная `val x = 5` | Stack |
| Поле класса `class User(val age: Int)` | Heap (внутри объекта) |
| Элемент массива `intArrayOf(1,2,3)` | Heap (массив — объект) |
| Boxing `val x: Int? = 5` | Heap (обёртка Integer) |

### 5. Миф: "Heap всегда медленнее"

Современные аллокаторы очень оптимизированы:
- **Thread-local allocation buffers (TLAB)** в JVM — почти как stack
- **Bump-pointer allocation** — простое увеличение указателя
- **Escape analysis** — JIT может перенести объект на stack

---

## Куда дальше

**Если понял основы:**
→ [[garbage-collection-explained]] — как JVM автоматически убирает мусор из heap

**Если работаешь с iOS/Kotlin Native:**
→ [[reference-counting-arc]] — как работает подсчёт ссылок вместо GC

**Если хочешь применить к KMP:**
→ [[kmp-memory-management]] — практика управления памятью в кросс-платформенных проектах

---

## Ключевые выводы

1. **Stack** — быстрый, автоматический, LIFO. Для локальных переменных и вызовов функций.

2. **Heap** — гибкий, общий, требует управления. Для объектов с динамическим временем жизни.

3. **В JVM/Kotlin:** примитивы и ссылки на stack, объекты на heap. GC убирает мусор.

4. **В Kotlin/Native:** похожая модель, но другой сборщик мусора.

5. **StackOverflowError** = переполнение stack (рекурсия, большие локальные данные).

6. **OutOfMemoryError** = нехватка heap (много объектов, утечки).

---

## Источники

- [Baeldung: Stack and Heap](https://www.baeldung.com/cs/memory-stack-vs-heap) — техническое объяснение
- [CS225 Illinois: Stack and Heap Memory](https://courses.grainger.illinois.edu/cs225/fa2022/resources/stack-heap/) — академический курс
- [Microsoft: Memory Allocation History](https://learn.microsoft.com/en-us/archive/blogs/abhinaba/back-to-basics-memory-allocation-a-walk-down-the-history) — историческая справка
- [Kotlin Docs: Native Memory Manager](https://kotlinlang.org/docs/native-memory-manager.html) — официальная документация
- [Bitesize Engineering: Heaps and Stacks](https://www.bitesizedengineering.com/p/heaps-and-stacks-explained-like-youre-five) — аналогии

---

*Проверено: 2026-01-09*
