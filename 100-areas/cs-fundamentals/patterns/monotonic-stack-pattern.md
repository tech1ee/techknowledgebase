---
title: "Паттерн монотонного стека (Monotonic Stack)"
created: 2025-12-29
modified: 2026-01-06
type: deep-dive
status: published
difficulty: intermediate
confidence: high
cs-foundations:
  - stack-data-structure
  - monotonic-property
  - amortized-analysis
  - next-greater-smaller
  - contribution-technique
prerequisites:
  - "[[stacks-queues]]"
  - "[[arrays-strings]]"
tags:
  - topic/cs-fundamentals
  - type/deep-dive
  - level/intermediate
  - pattern
  - interview
related:
  - "[[sliding-window-pattern]]"
  - "[[two-pointers-pattern]]"
---

# Monotonic Stack Pattern

## TL;DR

Monotonic Stack решает задачи "следующий больший/меньший элемент" за O(n). **Ключевая идея: поддерживать монотонность стека** — элементы всегда возрастают или убывают. Превращает O(n²) вложенных циклов в O(n) однопроходный алгоритм. Оптимально для: гистограмм, температур, цен акций.

---

## Часть 1: Интуиция без кода

### Аналогия 1: Очередь к окну кинотеатра

Представь очередь людей, стоящих к окну кинотеатра. Каждый хочет видеть кассира. Но высокий человек **загораживает вид** всем, кто ниже и стоит за ним.

```
Очередь к окошку (→ направление взгляда):

Кассир ← [Петя 160см] [Маша 150см] [Вова 180см] [Аня 155см]
               ↑            ↑            ↑            ↑
           видит!     не видит     видит!      не видит
                      (Петя         (Вова        (Вова
                      загородил)    выше!)       загородил)
```

**Вопрос:** Для каждого человека — кто следующий, кто загородит ему вид?

```
Петя (160) → Вова (180) — первый, кто выше справа
Маша (150) → Петя (160) — первый, кто выше справа
Вова (180) → никто (он самый высокий)
Аня (155)  → никто (справа никого нет)
```

Это и есть **Next Greater Element** — найти первого "более высокого" справа.

---

### Аналогия 2: Метрика погоды — "когда станет теплее?"

Ты смотришь прогноз погоды на неделю:

```
День:        Пн  Вт  Ср  Чт  Пт  Сб  Вс
Температура: 23° 24° 22° 25° 21° 20° 26°
```

**Вопрос для каждого дня:** Через сколько дней будет теплее?

```
Пн (23°) → Вт (24°) = через 1 день
Вт (24°) → Чт (25°) = через 2 дня
Ср (22°) → Чт (25°) = через 1 день
Чт (25°) → Вс (26°) = через 3 дня
Пт (21°) → Вс (26°) = через 2 дня
Сб (20°) → Вс (26°) = через 1 день
Вс (26°) → никогда  = 0 (нет данных)
```

**Наивный подход:** Для каждого дня просмотреть все дни справа → O(n²).

**Монотонный стек:** Обрабатываем ОТ КОНЦА к началу. Храним в стеке "кандидатов на потепление". Когда видим новый день — убираем из стека все дни, которые холоднее (они уже не нужны!).

---

### Аналогия 3: Царь горы (King of the Hill)

Представь ряд столбов разной высоты. На каждый столб может встать человек. Правило: **ты видишь только тех, кто выше тебя и стоит после тебя**.

```
Высоты столбов: [3, 1, 4, 2, 5]

    5       ← "царь горы" — видит всё справа (никого)
  4
3   2
  1
│ │ │ │ │
3 1 4 2 5

Кто кого видит (Next Greater):
- Столб 3 → видит 4 (первый выше справа)
- Столб 1 → видит 4 (первый выше справа)
- Столб 4 → видит 5 (первый выше справа)
- Столб 2 → видит 5 (первый выше справа)
- Столб 5 → никого (он царь!)
```

**Ключевой инсайт:** Низкие столбы "прячутся" за высокими. Если появился высокий столб — все низкие слева больше не могут быть "следующим большим" ни для кого.

---

### Числовой пример без кода: Магия стека

**Задача:** Найти Next Greater Element для [2, 1, 2, 4, 3]

**Наивно (O(n²)):** Для каждого элемента просмотреть все справа.

**Монотонный стек (O(n)):** Идём справа налево, храним "кандидатов".

```
Шаг 1: i=4, arr[4]=3
  Стек: []
  Нет кандидатов → NGE[4] = -1
  Push 3 → Стек: [3]

Шаг 2: i=3, arr[3]=4
  Стек: [3]
  3 < 4 → 3 не может быть NGE для 4 или элементов левее
  Pop 3 → Стек: []
  Нет кандидатов → NGE[3] = -1
  Push 4 → Стек: [4]

Шаг 3: i=2, arr[2]=2
  Стек: [4]
  4 > 2 → 4 это кандидат!
  NGE[2] = 4
  Push 2 → Стек: [4, 2]

Шаг 4: i=1, arr[1]=1
  Стек: [4, 2]
  2 > 1 → 2 это кандидат!
  NGE[1] = 2
  Push 1 → Стек: [4, 2, 1]

Шаг 5: i=0, arr[0]=2
  Стек: [4, 2, 1]
  1 < 2 → Pop → Стек: [4, 2]
  2 <= 2 → Pop → Стек: [4]
  4 > 2 → NGE[0] = 4
  Push 2 → Стек: [4, 2]

Результат: [4, 2, 4, -1, -1]
```

**Почему O(n)?** Каждый элемент входит в стек ровно 1 раз и выходит максимум 1 раз. Итого: 2n операций.

---

### Визуализация: Инверсия перспективы

**Обычное мышление:** "Для элемента X — кто справа больше?"

**Мышление со стеком:** "Для каких элементов СЛЕВА Я являюсь следующим большим?"

```
Массив: [2, 1, 2, 4, 3]
         ↓  ↓  ↓  ↓  ↓

Когда обрабатываем 4:
  В стеке: [3] (индексы элементов, ждущих свой NGE)
  4 > 3 → Я (4) являюсь NGE для 3!
  Pop 3, записываем NGE[3] = 4

Когда обрабатываем 2 (первый):
  В стеке: [4, 2, 1]
  2 > 1 → Pop 1, NGE[1] = 2
  2 = 2 → Pop 2, NGE[2] = ...? (зависит от условия <= или <)
  4 > 2 → Я нашёл свой NGE! NGE[0] = 4
```

**Инсайт от [DEV.to](https://dev.to/alex_hunter_44f4c9ed6671e/monotonic-stacks-the-pattern-that-makes-next-greater-problems-easy-jd6):** "Вместо вопроса 'кто мой следующий больший?' спрашиваем 'для кого Я являюсь следующим большим?'"

---

## Часть 2: Почему Monotonic Stack сложный

### Типичные ошибки студентов

#### Ошибка 1: Путаница с типом стека

**Симптом:** "Получаю неправильные ответы, хотя логика кажется верной"

```
ПРАВИЛО:
┌────────────────────────────────────────────────────────┐
│ Ищем GREATER → поддерживаем DECREASING стек           │
│ Ищем SMALLER → поддерживаем INCREASING стек           │
└────────────────────────────────────────────────────────┘
```

**Почему?**

```
Decreasing stack: [7, 5, 3, 1]  (сверху 1)

Когда приходит 4:
  1 < 4 → Pop! Для 1 нашёлся NGE = 4
  3 < 4 → Pop! Для 3 нашёлся NGE = 4
  5 > 4 → Stop. 4 ждёт своего NGE.
  Стек: [7, 5, 4]
```

Decreasing стек "накапливает" элементы, ожидающие большего. Когда большой элемент появляется — все меньшие "разрешаются".

---

#### Ошибка 2: Хранение значений вместо индексов

**Симптом:** "Нашёл NGE, но не могу посчитать РАССТОЯНИЕ"

```
// ❌ ОШИБКА: храним значения
stack.push(nums[i])
// Проблема: как узнать, СКОЛЬКО ДНЕЙ до потепления?

// ✅ ПРАВИЛЬНО: храним индексы
stack.push(i)
// Теперь: distance = currentIndex - stack.peek()
```

**Задача Daily Temperatures:** Нужен ответ "через 3 дня", а не "будет 25°".

---

#### Ошибка 3: Неправильный порядок push/pop

**Симптом:** "NGE для элемента — это он сам"

```
// ❌ ОШИБКА: сначала push, потом pop
stack.push(i)
while (stack.top() < nums[i]) {
    stack.pop()  // Можем удалить только что добавленный!
}

// ✅ ПРАВИЛЬНО: сначала pop, потом push
while (stack.top() < nums[i]) {
    stack.pop()
}
stack.push(i)
```

---

#### Ошибка 4: Путаница с направлением обхода

**Два валидных подхода:**

```
СПРАВА НАЛЕВО (i = n-1 downTo 0):
  - Стек хранит "кандидатов на NGE справа"
  - Pop элементы <= текущего (они не могут быть NGE)
  - Вершина стека = NGE
  - Push текущий

СЛЕВА НАПРАВО (i = 0 to n-1):
  - Стек хранит "элементы, ждущие свой NGE"
  - Pop элементы < текущего (текущий — их NGE!)
  - Push текущий (он ждёт своего NGE)
```

**Оба дают O(n), но логика разная!** Выберите один и придерживайтесь.

---

#### Ошибка 5: Граничные условия

```
// ❌ ОШИБКА: не проверяем пустой стек
result[i] = nums[stack.peek()]  // NullPointerException!

// ✅ ПРАВИЛЬНО: проверяем
if (stack.isNotEmpty()) {
    result[i] = nums[stack.peek()]
} else {
    result[i] = -1  // Нет NGE
}
```

---

#### Ошибка 6: Строгое vs нестрогое неравенство

```
// nums = [2, 2, 2, 2]

// <= : все элементы выталкивают друг друга
// NGE = [-1, -1, -1, -1]

// < : равные элементы остаются
// NGE = [2, 2, 2, -1]  (или [-1,-1,-1,-1] в зависимости от задачи)
```

**Правило:** Читайте условие задачи! "Strictly greater" = `<`, "Greater or equal" = `<=`.

---

## Часть 3: Ментальные модели

### Модель 1: Стек как "зал ожидания"

**Суть:** Элементы в стеке — это "клиенты", ожидающие своего "обслуживания" (нахождения NGE).

```
Стек = Зал ожидания
Новый элемент = Новый специалист

Если новый специалист ЛУЧШЕ (больше):
  → Он "обслуживает" всех клиентов, которые ждали лучшего
  → Эти клиенты ВЫХОДЯТ (pop), их NGE найден

Если новый специалист ХУЖЕ (меньше):
  → Он сам встаёт в очередь ожидания (push)
```

```
Массив: [3, 1, 4, 2]

i=0: "Клиент" 3 → Зал: [3]
i=1: "Клиент" 1 → Зал: [3, 1]  (1 < 3, ждёт)
i=2: "Специалист" 4 приходит!
     1 < 4 → Pop! NGE[1] = 4
     3 < 4 → Pop! NGE[0] = 4
     4 встаёт в очередь → Зал: [4]
i=3: "Клиент" 2 → Зал: [4, 2]  (2 < 4, ждёт)

В конце: 4 и 2 не дождались → NGE = -1
```

---

### Модель 2: Amortized O(n) — "каждый элемент входит и выходит один раз"

**Вопрос:** Почему O(n), если внутри цикла есть while?

```
for (i in 0 until n) {          // n итераций
    while (stack.isNotEmpty() && condition) {
        stack.pop()              // Сколько раз?
    }
    stack.push(i)
}
```

**Анализ:**
- `push(i)` выполняется ровно n раз (по одному на элемент)
- `pop()` выполняется максимум n раз (каждый элемент удаляется максимум 1 раз)
- Итого: **2n операций = O(n)**

**Аналогия:** Турникет на стадионе. Каждый зритель входит один раз и выходит один раз. Сколько бы ни было зрителей в очереди на выход — всего выходов = всего зрителей.

---

### Модель 3: "Горизонт видимости"

**Для задачи гистограммы:**

```
heights = [2, 1, 5, 6, 2, 3]

Представь, что стоишь на каждом столбе и смотришь влево/вправо.
Твой "горизонт" ограничен первым столбом, который НИЖЕ тебя.

Столб h=5:
  ← Смотришь влево: первый меньший = 1 (индекс 1)
  → Смотришь вправо: первый меньший = 2 (индекс 4)
  Ширина = 4 - 1 - 1 = 2
  Площадь = 5 × 2 = 10
```

**Monotonic Stack находит "границы горизонта" за O(n).**

---

### Модель 4: Дуализм — Next Greater vs Previous Greater

```
┌─────────────────────────────────────────────────────────┐
│                    ДУАЛИЗМ NGE/PGE                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Next Greater Element (NGE):                            │
│    Обход: справа налево (или слева направо с pop-NGE)  │
│    Вопрос: "Кто справа больше меня?"                   │
│                                                         │
│  Previous Greater Element (PGE):                        │
│    Обход: слева направо                                │
│    Вопрос: "Кто слева больше меня?"                    │
│                                                         │
├─────────────────────────────────────────────────────────┤
│  Оба используют DECREASING stack для "Greater"         │
│  Оба используют INCREASING stack для "Smaller"         │
└─────────────────────────────────────────────────────────┘
```

---

### Модель 5: Шаблон для всех вариаций

**Универсальный шаблон (по [LeetCode Guide](https://leetcode.com/discuss/post/2347639/a-comprehensive-guide-and-template-for-m-irii/)):**

```
Параметры выбора:
1. Направление обхода: left→right или right→left
2. Тип стека: increasing или decreasing
3. Когда записывать: при push или при pop
4. Что хранить: индексы или значения

Комбинации:
┌──────────────┬───────────┬───────────────┬─────────────┐
│ Задача       │ Обход     │ Стек          │ Когда NGE?  │
├──────────────┼───────────┼───────────────┼─────────────┤
│ Next Greater │ R→L       │ Decreasing    │ При push    │
│ Next Greater │ L→R       │ Decreasing    │ При pop     │
│ Prev Greater │ L→R       │ Decreasing    │ При push    │
│ Next Smaller │ R→L       │ Increasing    │ При push    │
│ Next Smaller │ L→R       │ Increasing    │ При pop     │
│ Prev Smaller │ L→R       │ Increasing    │ При push    │
└──────────────┴───────────┴───────────────┴─────────────┘
```

---

### Практический совет: Начни с малого

**Рекомендация от [Hello Interview](https://www.hellointerview.com/learn/code/stack/monotonic-stack):** Трассируй на массивах длины 3-4, чтобы "почувствовать" push/pop.

```
Возьми nums = [3, 1, 2]

Нарисуй таблицу:
┌───┬──────┬───────────┬────────┬───────────────┐
│ i │ nums │ Стек до   │ Action │ Стек после    │
├───┼──────┼───────────┼────────┼───────────────┤
│ 2 │  2   │ []        │ push 2 │ [2]           │
│ 1 │  1   │ [2]       │ push 1 │ [2,1]         │
│ 0 │  3   │ [2,1]     │ pop 1  │ [2]           │
│   │      │ [2]       │ pop 2  │ []            │
│   │      │ []        │ push 3 │ [3]           │
└───┴──────┴───────────┴────────┴───────────────┘

NGE: [−1, 2, −1]
```

---

## Зачем это нужно?

**Реальная проблема:**

Массив из 1 миллиона температур. Для каждого дня найти, через сколько дней будет теплее. Наивный подход O(n²) ≈ 10^12 операций ≈ 15+ минут. Monotonic Stack: O(n) ≈ 1 миллисекунда.

**Где используется:**

| Область | Применение | Пример |
|---------|------------|--------|
| Финансы | Stock span | Дни роста акций |
| Метеорология | Temperature forecast | Дни до потепления |
| Визуализация | Histogram area | Максимальный прямоугольник |
| Water collection | Trapping rain water | Объём воды между столбами |
| Stock analysis | Price analysis | Maximum profit windows |

**Статистика:**
- 10-15% задач на интервью используют Monotonic Stack
- LeetCode: 50+ задач с этим паттерном
- "Largest Rectangle in Histogram" — классика FAANG

---

## Prerequisites (Что нужно знать)

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **Стек** | Monotonic Stack — это стек с дополнительным свойством | [[stacks-queues]] |
| **Массивы** | Работа с индексами и итерация | [[arrays-strings]] |
| **Big O нотация** | Понимание O(n) amortized | [[big-o-complexity]] |
| **CS: LIFO** | Last-In-First-Out — ключевое свойство стека | Структуры данных |
| **CS: Монотонность** | Свойство: элементы упорядочены (все возрастают или убывают) | Математика |

---

## Что это такое?

### Объяснение для 5-летнего

Представь очередь детей по росту. Новый ребёнок приходит и все, кто ниже него, уходят из очереди. В итоге в очереди дети стоят от высокого к низкому.

```
Очередь (от высокого к низкому):

Пришёл Петя (150 см):   [Петя-150]
Пришла Маша (140 см):   [Петя-150, Маша-140]
Пришёл Вова (160 см):   Петя и Маша уходят → [Вова-160]

Вова "вытеснил" всех, кто ниже!
```

### Формальное определение

**Monotonic Stack** — структура данных, поддерживающая инвариант: элементы в стеке всегда упорядочены (строго возрастают или строго убывают от дна к вершине).

**4 типа:**

```
1. Strictly Increasing (снизу вверх)
   [1, 3, 5, 7] — каждый следующий больше
   Используется для: Next Greater Element

2. Non-decreasing (≤)
   [1, 3, 3, 5] — равенство допускается

3. Strictly Decreasing
   [7, 5, 3, 1] — каждый следующий меньше
   Используется для: Next Smaller Element

4. Non-increasing (≥)
   [7, 5, 5, 3] — равенство допускается
```

**Правило выбора:**

```
Ищем Next Greater  → Decreasing Stack (убывающий)
Ищем Next Smaller  → Increasing Stack (возрастающий)
Ищем Previous Greater → Decreasing Stack (от начала)
Ищем Previous Smaller → Increasing Stack (от начала)
```

---

## Терминология

| Термин | Определение | Пример |
|--------|-------------|--------|
| **Monotonic** | Однонаправленно изменяющийся | Всегда растёт или убывает |
| **Next Greater Element (NGE)** | Первый элемент справа, который больше | [1,3,2,4]: NGE(3)=4 |
| **Next Smaller Element (NSE)** | Первый элемент справа, который меньше | [3,1,2]: NSE(3)=1 |
| **Previous Greater (PGE)** | Первый элемент слева, который больше | [1,3,2]: PGE(2)=3 |
| **Span** | Количество дней подряд с меньшим значением | Stock span |
| **Pop condition** | Условие удаления из стека | stack.top() < current |

---

## Как это работает?

### Next Greater Element

```
Вход: [2, 1, 2, 4, 3]
Ищем: для каждого элемента — первый справа, который больше

Используем: Decreasing Stack (храним индексы)

Проход справа налево:

i=4, arr[4]=3:  stack=[]        NGE[4]=-1     push(4) → [4]
i=3, arr[3]=4:  stack=[4]       arr[4]=3 < 4, pop
                stack=[]        NGE[3]=-1     push(3) → [3]
i=2, arr[2]=2:  stack=[3]       arr[3]=4 > 2  NGE[2]=4  push(2) → [3,2]
i=1, arr[1]=1:  stack=[3,2]     arr[2]=2 > 1  NGE[1]=2  push(1) → [3,2,1]
i=0, arr[0]=2:  stack=[3,2,1]   arr[1]=1 < 2, pop → [3,2]
                                arr[2]=2 ≤ 2, pop → [3]
                                arr[3]=4 > 2  NGE[0]=4  push(0) → [3,0]

Результат: NGE = [4, 2, 4, -1, -1]
```

**Визуализация:**

```
Массив: [2, 1, 2, 4, 3]
         ↓  ↓  ↓  ↓  ↓
NGE:    [4, 2, 4, -1,-1]

2 → 4 (первый справа > 2)
1 → 2 (первый справа > 1)
2 → 4 (первый справа > 2)
4 → -1 (нет элемента > 4)
3 → -1 (нет элемента справа)
```

### Largest Rectangle in Histogram

```
Вход: heights = [2, 1, 5, 6, 2, 3]

Идея: для каждого столбца найти ширину прямоугольника,
      где этот столбец — минимальная высота.

Для столбца с высотой h:
- левая граница = Previous Smaller Element
- правая граница = Next Smaller Element
- ширина = right - left - 1
- площадь = h × ширина

heights: [2, 1, 5, 6, 2, 3]
index:    0  1  2  3  4  5

PSE:     [-1, -1, 1, 2, 1, 4]  (индексы)
NSE:     [1,  6, 4, 4, 6, 6]   (индексы, 6 = конец)

Столбец 0 (h=2): width = 1 - (-1) - 1 = 1, area = 2×1 = 2
Столбец 1 (h=1): width = 6 - (-1) - 1 = 6, area = 1×6 = 6
Столбец 2 (h=5): width = 4 - 1 - 1 = 2, area = 5×2 = 10 ← максимум!
Столбец 3 (h=6): width = 4 - 2 - 1 = 1, area = 6×1 = 6
Столбец 4 (h=2): width = 6 - 1 - 1 = 4, area = 2×4 = 8
Столбец 5 (h=3): width = 6 - 4 - 1 = 1, area = 3×1 = 3

Максимум: 10
```

**Визуализация гистограммы:**

```
     █
   █ █
   █ █   █
   █ █ █ █
 █ █ █ █ █
 █ █ █ █ █
 2 1 5 6 2 3

Максимальный прямоугольник (h=5, w=2):
     ▓
   ▓ ▓
   █ █   █
   █ █ █ █
 █ █ █ █ █
 █ █ █ █ █
```

---

## Сложность операций

| Операция | Time | Space | Примечание |
|----------|------|-------|------------|
| Next Greater Element | O(n) | O(n) | Каждый элемент push/pop раз |
| Next Smaller Element | O(n) | O(n) | Аналогично |
| Largest Rectangle | O(n) | O(n) | Один проход |
| Trapping Rain Water | O(n) | O(n) | Или O(1) с two pointers |
| Daily Temperatures | O(n) | O(n) | Классическая NGE |

**Почему O(n)?**
- Каждый элемент добавляется в стек ровно 1 раз
- Каждый элемент удаляется из стека максимум 1 раз
- Итого: 2n операций = O(n)

---

## Реализация

### Next Greater Element (Kotlin)

```kotlin
/**
 * NEXT GREATER ELEMENT — для каждого элемента найти первый больший справа
 *
 * Идея: идём справа налево, храним в стеке "кандидатов на NGE".
 * Стек УБЫВАЮЩИЙ: вершина — наименьший кандидат.
 * Когда встречаем элемент больше вершины — вершина уже не может быть NGE
 * для элементов левее (они будут ≥ текущего), поэтому удаляем её.
 *
 * ПОШАГОВЫЙ ПРИМЕР: nums = [2, 1, 2, 4, 3]
 *
 * i=4: stack=[], result[4]=-1, push(4) → stack=[4]
 * i=3: nums[4]=3 < 4, pop → stack=[], result[3]=-1, push(3) → stack=[3]
 * i=2: nums[3]=4 > 2, result[2]=4, push(2) → stack=[3,2]
 * i=1: nums[2]=2 > 1, result[1]=2, push(1) → stack=[3,2,1]
 * i=0: nums[1]=1 ≤ 2, pop → [3,2], nums[2]=2 ≤ 2, pop → [3], result[0]=4
 *
 * Результат: [4, 2, 4, -1, -1]
 */
fun nextGreaterElement(nums: IntArray): IntArray {
    val n = nums.size
    val result = IntArray(n) { -1 }
    // Храним ИНДЕКСЫ, не значения — так можем вычислить расстояние
    val stack = ArrayDeque<Int>()

    // Идём справа налево: когда обрабатываем i, в стеке уже есть все
    // элементы справа от i. Стек содержит "кандидатов на NGE".
    for (i in n - 1 downTo 0) {
        // Убираем все элементы ≤ текущего — они НЕ МОГУТ быть NGE:
        // 1) Они меньше или равны nums[i]
        // 2) Для элементов левее nums[i] будет "ближе" и >= них
        while (stack.isNotEmpty() && nums[stack.peek()] <= nums[i]) {
            stack.pop()
        }

        // Если стек не пуст, вершина — первый элемент справа, который > nums[i]
        if (stack.isNotEmpty()) {
            result[i] = nums[stack.peek()]
        }

        // Добавляем текущий индекс — он может быть NGE для элементов левее
        stack.push(i)
    }

    return result
}
```

### Daily Temperatures (Kotlin)

```kotlin
/**
 * DAILY TEMPERATURES — сколько дней ждать до более тёплого дня?
 *
 * Идея: идём слева направо. В стеке храним индексы дней, для которых
 * ещё не нашли более тёплый день. Когда встречаем тёплый день —
 * он является ответом для всех дней в стеке с меньшей температурой.
 *
 * ПОШАГОВЫЙ ПРИМЕР: temperatures = [73, 74, 75, 71, 69, 72, 76, 73]
 *
 * i=0: stack=[], push(0) → [0]
 * i=1: 74 > 73, pop(0), result[0]=1, push(1) → [1]
 * i=2: 75 > 74, pop(1), result[1]=1, push(2) → [2]
 * i=3: 71 < 75, push(3) → [2,3]
 * i=4: 69 < 71, push(4) → [2,3,4]
 * i=5: 72 > 69, pop(4), result[4]=1; 72 > 71, pop(3), result[3]=2, push(5) → [2,5]
 * i=6: 76 > 72, pop(5), result[5]=1; 76 > 75, pop(2), result[2]=4, push(6) → [6]
 * i=7: 73 < 76, push(7) → [6,7]
 *
 * Результат: [1, 1, 4, 2, 1, 1, 0, 0]
 */
fun dailyTemperatures(temperatures: IntArray): IntArray {
    val n = temperatures.size
    // По умолчанию 0 — означает "более тёплого дня не будет"
    val result = IntArray(n)
    // Храним индексы дней, ожидающих более тёплого дня
    val stack = ArrayDeque<Int>()

    for (i in 0 until n) {
        // Пока текущая температура ВЫШЕ температуры дня на вершине стека —
        // значит, для того дня мы нашли ответ!
        while (stack.isNotEmpty() && temperatures[i] > temperatures[stack.peek()]) {
            val prevDay = stack.pop()
            // Разница индексов = количество дней ожидания
            result[prevDay] = i - prevDay
        }
        // Текущий день тоже ждёт более тёплого
        stack.push(i)
    }

    return result
}
```

### Largest Rectangle in Histogram (Kotlin)

```kotlin
/**
 * LARGEST RECTANGLE IN HISTOGRAM — найти максимальный прямоугольник
 *
 * Идея: для каждого столбца h найти, как далеко он может "расшириться"
 * влево и вправо (до столбцов ниже него). Ширина × высота = площадь.
 *
 * Используем ВОЗРАСТАЮЩИЙ стек:
 * - Когда встречаем столбец НИЖЕ вершины стека — столбец на вершине
 *   нашёл свою правую границу (текущий столбец)
 * - Левая граница = предыдущий элемент в стеке
 *
 * ПОШАГОВЫЙ ПРИМЕР: heights = [2, 1, 5, 6, 2, 3]
 *
 * i=0, h=2: push(0) → [0]
 * i=1, h=1: 1 < 2, pop(0), height=2, width=1, area=2, push(1) → [1]
 * i=2, h=5: push(2) → [1,2]
 * i=3, h=6: push(3) → [1,2,3]
 * i=4, h=2: 2 < 6, pop(3), height=6, width=1, area=6
 *           2 < 5, pop(2), height=5, width=2, area=10 ← МАКСИМУМ!
 *           push(4) → [1,4]
 * i=5, h=3: push(5) → [1,4,5]
 * i=6, h=0: выталкиваем всё, считаем оставшиеся площади
 *
 * Максимум: 10 (столбцы 5 и 6 высотой 5)
 */
fun largestRectangleArea(heights: IntArray): Int {
    val n = heights.size
    val stack = ArrayDeque<Int>()
    var maxArea = 0

    // Добавляем виртуальный столбец высоты 0 в конец — это "вытолкнет"
    // все оставшиеся столбцы из стека и мы посчитаем их площади
    for (i in 0..n) {
        val h = if (i == n) 0 else heights[i]

        // Если текущий столбец НИЖЕ вершины стека — столбец на вершине
        // нашёл свою ПРАВУЮ границу (дальше расшириться не может)
        while (stack.isNotEmpty() && h < heights[stack.peek()]) {
            val height = heights[stack.pop()]

            // Левая граница = следующий элемент в стеке (первый НИЖЕ него слева)
            // Если стек пуст — значит, этот столбец минимальный, ширина = i
            val width = if (stack.isEmpty()) i else i - stack.peek() - 1

            maxArea = maxOf(maxArea, height * width)
        }

        stack.push(i)
    }

    return maxArea
}
```

### Trapping Rain Water (Java)

```java
/**
 * TRAPPING RAIN WATER — сколько воды поместится между столбами?
 *
 * Идея со стеком: обрабатываем воду ПОСЛОЙНО (по горизонтали).
 * Когда находим столбец выше дна — можем "залить" слой воды.
 *
 * ПОШАГОВЫЙ ПРИМЕР: height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
 *
 *       █
 *   █   ██ █
 * █ ██ ████ █
 * 0 1 0 2 1 0 1 3 2 1 2 1
 *
 * Вода собирается в "впадинах" между высокими столбцами.
 * Стек хранит индексы столбцов в порядке убывания высоты.
 * Когда встречаем столбец выше вершины — "заливаем" воду в промежуток.
 */
public int trap(int[] height) {
    int n = height.length;
    if (n == 0) return 0;

    Deque<Integer> stack = new ArrayDeque<>();
    int water = 0;

    for (int i = 0; i < n; i++) {
        // Пока текущий столбец ВЫШЕ столбца на вершине стека —
        // можем "залить" слой воды над вершиной
        while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
            int bottom = stack.pop();  // Дно "бассейна"

            // Если стек пуст — нет левой стенки, вода вытечет
            if (stack.isEmpty()) break;

            int left = stack.peek();  // Левая стенка

            // Ширина бассейна = расстояние между стенками минус сами стенки
            int width = i - left - 1;

            // Высота воды ограничена МЕНЬШЕЙ из стенок минус дно
            // Вода не может быть выше, чем min(левая, правая стенка)
            int waterHeight = Math.min(height[i], height[left]) - height[bottom];

            water += width * waterHeight;
        }

        stack.push(i);
    }

    return water;
}
```

### Stock Span (Python)

```python
"""
STOCK SPAN — сколько дней подряд цена была ≤ текущей?

Идея: храним пары (цена, span). Когда приходит новая цена,
"поглощаем" все дни с ценой ≤ текущей, суммируя их span'ы.

ПОШАГОВЫЙ ПРИМЕР: prices = [100, 80, 60, 70, 60, 75, 85]

День 1: price=100, span=1, stack=[(100,1)]
День 2: price=80 < 100, span=1, stack=[(100,1), (80,1)]
День 3: price=60 < 80, span=1, stack=[(100,1), (80,1), (60,1)]
День 4: price=70 > 60, pop (60,1), span=1+1=2, stack=[(100,1), (80,1), (70,2)]
День 5: price=60 < 70, span=1, stack=[(100,1), (80,1), (70,2), (60,1)]
День 6: price=75 > 60, pop (60,1), span=2
              75 > 70, pop (70,2), span=4
              75 < 80, stop, stack=[(100,1), (80,1), (75,4)]
День 7: price=85 > 75, pop (75,4), span=5
              85 > 80, pop (80,1), span=6
              85 < 100, stop, stack=[(100,1), (85,6)]

Результат: [1, 1, 1, 2, 1, 4, 6]
"""
class StockSpanner:
    def __init__(self):
        # Храним пары (цена, span)
        # span = количество дней подряд с ценой ≤ этой (включая сам день)
        self.stack = []

    def next(self, price: int) -> int:
        span = 1  # Как минимум сам текущий день

        # Объединяем span'ы всех дней с ценой ≤ текущей
        # Эти дни "поглощаются" текущим днём
        while self.stack and self.stack[-1][0] <= price:
            span += self.stack.pop()[1]

        self.stack.append((price, span))
        return span
```

---

## Распространённые ошибки

### 1. Неправильный тип монотонности

```kotlin
// ❌ НЕПРАВИЛЬНО: возрастающий стек для Next Greater
while (stack.isNotEmpty() && nums[stack.peek()] < nums[i]) {
    // Это даёт Previous Smaller, не Next Greater!
}

// ✅ ПРАВИЛЬНО: убывающий стек для Next Greater
while (stack.isNotEmpty() && nums[stack.peek()] <= nums[i]) {
    stack.pop()
}
result[i] = if (stack.isEmpty()) -1 else nums[stack.peek()]
```

### 2. Хранение значений вместо индексов

```kotlin
// ❌ НЕПРАВИЛЬНО: теряем информацию о позиции
val stack = ArrayDeque<Int>()  // значения
stack.push(nums[i])
// Как узнать, на каком расстоянии NGE?

// ✅ ПРАВИЛЬНО: храним индексы
val stack = ArrayDeque<Int>()  // индексы
stack.push(i)
result[prevIdx] = i - prevIdx  // можем вычислить расстояние
```

### 3. Забыть обработать оставшиеся элементы

```kotlin
// ❌ НЕПРАВИЛЬНО: элементы в стеке без NGE не обработаны
for (i in 0 until n) {
    while (stack.isNotEmpty() && nums[i] > nums[stack.peek()]) {
        result[stack.pop()] = nums[i]
    }
    stack.push(i)
}
// Элементы в стеке остаются с result = 0, но не -1

// ✅ ПРАВИЛЬНО: явно инициализируем -1 или обрабатываем
// Инициализируем -1 заранее — элементы без NGE останутся с -1
val result = IntArray(n) { -1 }
```

### 4. Строгое vs нестрогое сравнение

```kotlin
// ❌ МОЖЕТ БЫТЬ НЕПРАВИЛЬНО в зависимости от задачи
while (stack.isNotEmpty() && nums[stack.peek()] < nums[i])  // строгое

// ✅ Для классического NGE (первый строго больший):
while (stack.isNotEmpty() && nums[stack.peek()] <= nums[i])  // нестрогое
// Нестрогое сравнение нужно для дубликатов: [2, 2, 3]
// Для первой 2 NGE = 3 (не вторая 2!), поэтому убираем равные тоже
```

### 5. Неправильное направление обхода

```kotlin
// Для Next Greater/Smaller: обычно слева направо (или справа налево)
// Для Previous Greater/Smaller: слева направо

// ❌ НЕПРАВИЛЬНО: обход в неправильном направлении
for (i in n - 1 downTo 0) {  // справа налево
    // Это для Next Greater, не Previous Greater
}

// ✅ ПРАВИЛЬНО для Previous Greater:
for (i in 0 until n) {  // слева направо
    while (stack.isNotEmpty() && nums[stack.peek()] <= nums[i]) {
        stack.pop()
    }
    previousGreater[i] = if (stack.isEmpty()) -1 else stack.peek()
    stack.push(i)
}
```

---

## Когда использовать

### Decision Tree

```
Задача о "следующем" или "предыдущем" элементе?
│
├─ YES: Monotonic Stack
│   │
│   ├─ Next Greater Element?
│   │   └─ Decreasing Stack, справа налево или слева направо с pop
│   │
│   ├─ Next Smaller Element?
│   │   └─ Increasing Stack
│   │
│   ├─ Площадь гистограммы?
│   │   └─ Increasing Stack + ширина между границами
│   │
│   ├─ Trapping Rain Water?
│   │   └─ Stack или Two Pointers
│   │
│   └─ Stock Span?
│       └─ Decreasing Stack с накоплением span
│
└─ NO: Другой паттерн
    │
    ├─ Диапазон значений? → Sliding Window
    ├─ Отсортированные данные? → Two Pointers
    └─ Запросы на отрезках? → Segment Tree
```

### Сравнение с альтернативами

| Задача | Monotonic Stack | Brute Force | Other |
|--------|-----------------|-------------|-------|
| Next Greater | O(n) | O(n²) | - |
| Largest Rectangle | O(n) | O(n²) | Divide & Conquer O(n log n) |
| Trapping Rain Water | O(n), O(n) space | O(n²) | Two Pointers O(n), O(1) |
| Sliding Window Max | O(n) deque | O(n×k) | Heap O(n log k) |

---

## Практика

### Концептуальные вопросы

1. **Почему убывающий стек для Next Greater?**
   - В убывающем стеке вершина — наименьший элемент
   - Когда приходит больший элемент, он "побеждает" вершину
   - Вершина нашла свой Next Greater — это текущий элемент

2. **Можно ли решить Largest Rectangle без стека?**
   - Да, Divide & Conquer: O(n log n) в среднем, O(n²) в худшем
   - Стек даёт гарантированный O(n)

3. **Почему Trapping Rain Water можно решить Two Pointers?**
   - Вода в позиции i = min(maxLeft, maxRight) - height[i]
   - Two pointers отслеживает maxLeft и maxRight за O(1) памяти

### LeetCode задачи

| # | Название | Сложность | Паттерн | Ключевая идея |
|---|----------|-----------|---------|---------------|
| 496 | Next Greater Element I | Easy | NGE | HashMap + Stack |
| 503 | Next Greater Element II | Medium | NGE + Circular | Двойной проход |
| 739 | Daily Temperatures | Medium | NGE | Индексы в стеке |
| 84 | Largest Rectangle in Histogram | Hard | PSE + NSE | Ширина между границами |
| 42 | Trapping Rain Water | Hard | Stack/Two Pointers | Послойное или column-by-column |
| 901 | Online Stock Span | Medium | Decreasing Stack | Накопление span |
| 907 | Sum of Subarray Minimums | Medium | NSE + PSE | Contribution technique |

### Порядок изучения

```
1. 496. Next Greater Element I (Easy) — базовый NGE
2. 739. Daily Temperatures (Medium) — NGE с индексами
3. 503. Next Greater Element II (Medium) — circular array
4. 84. Largest Rectangle (Hard) — PSE + NSE
5. 42. Trapping Rain Water (Hard) — stack или two pointers
6. 907. Sum of Subarray Minimums (Medium) — contribution
```

---

## Связанные темы

### Prerequisites (изучить до)
- **Stack** — базовая структура данных
- **Arrays** — работа с индексами
- **Two Pointers** — альтернативный подход для некоторых задач

### Unlocks (откроет путь к)
- **Monotonic Deque** — для Sliding Window Maximum
- **Segment Tree** — для range queries
- **Cartesian Tree** — связь со структурой гистограммы

---

## Мифы и заблуждения

| Миф | Реальность |
|-----|-----------|
| "Monotonic Stack сложный паттерн" | **Простой шаблон!** Один цикл, проверка top(), push/pop. После 3-4 задач становится рутиной |
| "Можно решить только NGE задачи" | **Широкое применение!** Histogram, Trapping Rain Water, Stock Span, Sum of Subarray Minimums — всё через Monotonic Stack |
| "Increasing vs Decreasing — неважно" | **Критично!** Next Greater → Decreasing stack. Next Smaller → Increasing stack. Перепутаешь — wrong answer |
| "O(n²) в худшем случае" | **Нет, O(n) amortized!** Каждый элемент push/pop РОВНО один раз. Суммарно 2n операций = O(n) |
| "Нужно хранить значения в стеке" | **Обычно индексы!** Хранение индексов позволяет вычислять расстояния, а значение получаем через arr[idx] |
| "Two Pointers лучше для гистограмм" | **Зависит!** Two Pointers проще для Trapping Rain Water, но Monotonic Stack универсальнее и работает для Largest Rectangle |
| "Circular array нельзя обработать" | **Можно!** Двойной проход: for i in range(2*n), работаем с i % n. Это имитирует circular массив |
| "Contribution technique слишком сложный" | **Стандартный паттерн!** Для каждого элемента находим: сколько подмассивов где он min/max. PSE × NSE = количество |

---

## CS-фундамент

| CS-концепция | Применение в Monotonic Stack |
|--------------|------------------------------|
| **Stack (LIFO)** | Основная структура. push() добавляет, pop() удаляет последний. O(1) операции |
| **Monotonic Property** | Инвариант стека: элементы всегда возрастают (или убывают). При нарушении — pop до восстановления |
| **Amortized O(n)** | Хотя внутри цикла есть while-pop, каждый элемент добавляется/удаляется максимум 1 раз. Суммарно O(2n) = O(n) |
| **Next Greater/Smaller Element** | Когда элемент выталкивает другой — он и есть NGE/NSE для вытолкнутого. Момент pop = момент нахождения ответа |
| **Contribution Technique** | Для каждого элемента: contribution = value × count_of_subarrays. Count = PSE_distance × NSE_distance |
| **Index vs Value Storage** | В стеке обычно индексы, не значения. Это позволяет вычислять расстояния: i - stack.top() |

---

## Источники

| # | Источник | Тип | Вклад |
|---|----------|-----|-------|
| 1 | [LeetCopilot](https://leetcopilot.dev/leetcode-pattern/monotonic-stack-queue/guide) | Guide | O(n²) → O(n) трансформация |
| 2 | [LeetCode Discuss](https://leetcode.com/discuss/post/2347639/a-comprehensive-guide-and-template-for-m-irii/) | Template | Выбор типа стека |
| 3 | [GeeksforGeeks](https://www.geeksforgeeks.org/next-greater-element/) | Tutorial | NGE алгоритм |
| 4 | [NeetCode](https://neetcode.io/roadmap) | Roadmap | Порядок задач |

---

## Куда дальше

→ **Расширение:** Monotonic Deque для Sliding Window Maximum
→ **Связанный паттерн:** [[sliding-window-pattern]] — часто комбинируется
→ **Вернуться к:** [[patterns-overview|Обзор паттернов]]

---

*Обновлено: 2026-01-08 — добавлены педагогические секции (интуиция монотонного стека, 6 типичных ошибок, 5 ментальных моделей)*
