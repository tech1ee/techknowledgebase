# Intervals Pattern

---
title: "Intervals Pattern"
created: 2025-12-29
updated: 2026-01-06
type: deep-dive
status: complete
difficulty: intermediate
confidence: high
cs-foundations:
  - sorting-by-start-end
  - sweep-line-algorithm
  - greedy-interval-scheduling
  - overlap-detection
  - merge-operation
prerequisites:
  - "[[sorting-algorithms]]"
  - "[[heaps]]"
  - "[[two-pointers-pattern]]"
related:
  - "[[greedy-algorithms]]"
tags:
  - pattern
  - intervals
  - merge
  - scheduling
  - interview
---

## TL;DR

Интервальные задачи решают проблемы с перекрывающимися диапазонами. **Ключевой подход: сортировка по началу + слияние**. Появляется в 15-20% интервью FAANG. Три типа: **merge** (объединение), **insert** (вставка), **scheduling** (расписание). Оптимально для: календарей, бронирований, планировщиков.

---

## Часть 1: Интуиция без кода

### Аналогия 1: Бронирование отеля

Представь, что ты управляешь маленьким отелем с **одним номером**. Гости присылают заявки:

```
Гость А: с 1 по 5 января
Гость Б: с 3 по 8 января
Гость В: с 10 по 15 января
```

**Проблема:** Гости А и Б хотят жить в одни дни (3, 4, 5 января). Как понять, сколько номеров нужно?

**Интуитивное решение:**
1. Выписываем все "события" на timeline
2. "Заезд" = +1 гость, "Выезд" = -1 гость
3. Находим момент с максимумом гостей

```
Январь:  1    3    5    8   10   15
         │    │    │    │    │    │
Гость А: ████████████▓▓▓▓
              │         │
Гость Б:     ████████████████████
                             │    │
Гость В:                    ████████████

День 3-5: живут ОБА гостя → нужно 2 номера
```

Это и есть **Meeting Rooms II** — считаем максимум одновременных "гостей".

---

### Аналогия 2: Раскраска временной шкалы

Представь, что у тебя лента бумаги, и ты красишь её маркерами:

```
Маркер 1: закрашиваем от 1 до 4
Маркер 2: закрашиваем от 2 до 6
Маркер 3: закрашиваем от 8 до 10

        1   2   3   4   5   6   7   8   9  10
        ████████████
            ████████████████
                                ██████████

После слияния:
        ████████████████████     ██████████
              [1, 6]                [8, 10]
```

**Merge Intervals** — это "склеивание" закрашенных участков в один непрерывный.

**Правило слияния:** Если конец одного интервала >= начала следующего — они склеиваются.

---

### Аналогия 3: Расписание уроков

```
Понедельник:
  09:00-10:30  Математика
  10:00-11:30  Физика
  12:00-13:30  История
  14:00-15:30  Литература

Вопрос: Можно ли всё успеть в одном классе?
```

**Визуальная проверка:**

```
09:00   10:00   11:00   12:00   13:00   14:00   15:00
  │       │       │       │       │       │       │
  ██████████████████  Математика
            ████████████████████  Физика
                          ██████████████████  История
                                      ████████████████  Литература
                    ↑
           КОНФЛИКТ!
```

Математика и Физика пересекаются (10:00-10:30). Нужно **2 кабинета**.

---

### Числовой пример без кода: Подсчёт комнат

**Входные данные:** встречи [[0,30], [5,10], [15,20]]

**Шаг 1: Преобразуем в события**

```
Встреча [0,30]:   событие (0, НАЧАЛО), событие (30, КОНЕЦ)
Встреча [5,10]:   событие (5, НАЧАЛО), событие (10, КОНЕЦ)
Встреча [15,20]:  событие (15, НАЧАЛО), событие (20, КОНЕЦ)
```

**Шаг 2: Сортируем события по времени**

```
t=0:   НАЧАЛО → комнат: 1
t=5:   НАЧАЛО → комнат: 2  ← МАКСИМУМ!
t=10:  КОНЕЦ  → комнат: 1
t=15:  НАЧАЛО → комнат: 2
t=20:  КОНЕЦ  → комнат: 1
t=30:  КОНЕЦ  → комнат: 0
```

**Ответ:** 2 комнаты (максимум одновременных встреч).

---

### Визуализация: Сортировка — ключ к решению

```
ДО СОРТИРОВКИ:
  [8,10]  [1,3]  [2,6]  [15,18]

     [8---10]
  [1--3]
     [2------6]
                    [15----18]

Перекрытия НЕ ОЧЕВИДНЫ — интервалы разбросаны

ПОСЛЕ СОРТИРОВКИ по началу:
  [1,3]  [2,6]  [8,10]  [15,18]

  [1--3]
     [2------6]
            [8---10]
                       [15----18]

Теперь ВИДНО: [1,3] и [2,6] пересекаются!
Можно идти СЛЕВА НАПРАВО и сливать соседей.
```

**Инсайт:** Сортировка превращает хаотичный набор в **упорядоченную последовательность**, где достаточно сравнивать только соседние элементы.

---

## Часть 2: Почему интервалы сложные

### Типичные ошибки студентов

#### Ошибка 1: Забыть отсортировать

**Симптом:** "Алгоритм работает на примерах, но WA на тестах"

```
Вход: [[1,4], [0,2], [3,5]]

БЕЗ сортировки:
  current = [1,4]
  [0,2]: 0 <= 4? ДА → merge → [0,4]
  [3,5]: 3 <= 4? ДА → merge → [0,5]
  Результат: [[0,5]]  ← НЕПРАВИЛЬНО!

С сортировкой: [[0,2], [1,4], [3,5]]
  current = [0,2]
  [1,4]: 1 <= 2? ДА → merge → [0,4]
  [3,5]: 3 <= 4? ДА → merge → [0,5]
  Результат: [[0,5]]  ← ПРАВИЛЬНО (но совпало случайно)
```

**Контрпример:**
```
Вход: [[3,5], [1,2], [6,8]]

БЕЗ сортировки:
  current = [3,5]
  [1,2]: 1 <= 5? ДА → merge → [1,5]  ← ОШИБКА! [1,2] и [3,5] НЕ пересекаются!
```

**Правило:** ВСЕГДА сортируй по началу интервала перед обработкой.

---

#### Ошибка 2: Неправильное условие перекрытия

**Вопрос:** Интервалы [1,5] и [5,10] — пересекаются или нет?

**Зависит от семантики задачи:**
- **Закрытые интервалы [1,5]:** 5 принадлежит обоим → пересекаются
- **Полуоткрытые [1,5):** 5 не входит в первый → НЕ пересекаются

**В большинстве задач LeetCode:** `<=` (закрытые интервалы, точка касания = перекрытие).

```
// ❌ ОШИБКА: строгое неравенство
if (next.start < current.end)  // пропустит [1,5] и [5,10]

// ✅ ПРАВИЛЬНО: нестрогое неравенство
if (next.start <= current.end)  // [1,5] и [5,10] сольются в [1,10]
```

---

#### Ошибка 3: Забыть последний интервал

**Классическая ошибка в Merge Intervals:**

```
for (i in 1..n-1) {
    if (overlap) merge()
    else result.add(current); current = next
}
return result  // ← ГДЕ ПОСЛЕДНИЙ current?!
```

**Проблема:** Последний интервал никогда не добавляется в result.

**Решение:**
```
for (...) { ... }
result.add(current)  // ОБЯЗАТЕЛЬНО добавляем в конце!
return result
```

---

#### Ошибка 4: Неправильный порядок событий в Sweep Line

**Вопрос:** Если встреча заканчивается в 10:00 и другая начинается в 10:00 — это 1 комната или 2?

```
События: (10, КОНЕЦ), (10, НАЧАЛО)

Порядок +1 перед -1:
  t=10: +1 → комнат: 2
  t=10: -1 → комнат: 1
  Максимум: 2 комнаты ← НЕПРАВИЛЬНО!

Порядок -1 перед +1:
  t=10: -1 → комнат: 0
  t=10: +1 → комнат: 1
  Максимум: 1 комната ← ПРАВИЛЬНО!
```

**Правило:** При одинаковом времени: сначала КОНЕЦ (-1), потом НАЧАЛО (+1).

```kotlin
events.sortWith(compareBy({ it.time }, { it.delta }))  // -1 < +1
```

---

#### Ошибка 5: Путаница с сортировкой по start vs end

**Разные задачи — разная сортировка:**

| Задача | Сортировка | Почему |
|--------|------------|--------|
| Merge Intervals | По start | Гарантирует, что соседи могут пересекаться |
| Meeting Rooms II | По start | Обрабатываем в хронологическом порядке |
| Non-overlapping Intervals | По end | Greedy: выбираем то, что освобождается раньше |
| Activity Selection | По end | Оставляем максимум места для следующих |

**Классическая путаница:**
```
// Non-overlapping Intervals (удалить минимум для устранения пересечений)
// ❌ ОШИБКА: сортировка по start
intervals.sortBy { it[0] }

// ✅ ПРАВИЛЬНО: сортировка по end (greedy)
intervals.sortBy { it[1] }
```

---

#### Ошибка 6: Сравнение O(n²) вместо O(n)

**Наивный подход:** Сравнить каждую пару интервалов.

```
for (i in 0..n-1) {
    for (j in i+1..n-1) {
        if (overlap(intervals[i], intervals[j])) ...
    }
}
```

**Проблема:** O(n²) — слишком медленно для n = 10⁵.

**Инсайт:** После сортировки достаточно сравнивать только **соседние** интервалы!

```
intervals.sortBy { it[0] }
for (i in 1..n-1) {
    if (overlap(intervals[i-1], intervals[i])) ...  // O(n)
}
```

---

## Часть 3: Ментальные модели

### Модель 1: Интервалы как события на timeline

**Суть:** Любой интервал [start, end] — это ДВА события:
- Событие "НАЧАЛО" в точке start
- Событие "КОНЕЦ" в точке end

```
Интервал [3, 7]:

Timeline:  0   1   2   3   4   5   6   7   8   9
                       ↑               ↑
                    START            END
                      +1              -1
```

**Применение:**
- **Meeting Rooms II:** считаем активные интервалы в каждой точке
- **Подсчёт перекрытий:** максимум активных = ответ
- **Покрытие диапазона:** суммируем "активные" участки

**Когда использовать:** Когда нужно знать "сколько интервалов активно в момент t".

---

### Модель 2: Сортировка создаёт порядок

**Инсайт:** Хаотичный набор интервалов → упорядоченная последовательность.

```
ДО: {[8,10], [1,3], [5,7], [2,4]}

    Не знаем, кто с кем может пересекаться.
    Наивно: проверить все пары O(n²).

ПОСЛЕ сортировки по start:
    [1,3], [2,4], [5,7], [8,10]

    Теперь: если [i] не пересекается с [i+1],
    то [i] не пересекается ни с кем после [i+1].

    Достаточно проверить только соседей O(n)!
```

**Принцип:** Сортировка по start гарантирует: `start[i] <= start[i+1]`.

Если `end[i] < start[i+1]` → интервалы НЕ пересекаются, и [i] можно "закрыть".

---

### Модель 3: Greedy по концу для максимизации

**Задача:** Выбрать максимум непересекающихся интервалов (Activity Selection).

**Greedy-принцип:** Всегда выбирай интервал, который заканчивается **раньше всех**.

```
Интервалы: [1,4], [2,3], [3,5], [4,6]

Сортировка по END:
  [2,3], [1,4], [3,5], [4,6]

Greedy выбор:
  1. Берём [2,3] (заканчивается в 3)
  2. [1,4] начинается в 1 < 3 — пропускаем
  3. [3,5] начинается в 3 >= 3 — берём!
  4. [4,6] начинается в 4 < 5 — пропускаем

Результат: 2 интервала ([2,3] и [3,5])
```

**Почему это оптимально?** Чем раньше заканчивается интервал, тем больше "места" для следующих.

---

### Модель 4: Heap как "комнаты с временем освобождения"

**Для Meeting Rooms II:**

```
Min-Heap хранит: времена окончания ЗАНЯТЫХ комнат.

peek() = время, когда освободится БЛИЖАЙШАЯ комната.

Если новая встреча начинается ПОСЛЕ peek():
  → Можно ПЕРЕИСПОЛЬЗОВАТЬ комнату (poll + add)

Если новая встреча начинается ДО peek():
  → Нужна НОВАЯ комната (только add)
```

**Визуализация:**

```
Встречи: [0,30], [5,10], [15,20]

[0,30]:  heap пуст → add(30) → heap = [30]
         Комнат: 1

[5,10]:  peek()=30 > 5 → нужна новая комната
         add(10) → heap = [10, 30]
         Комнат: 2

[15,20]: peek()=10 <= 15 → комната освободилась!
         poll() → heap = [30]
         add(20) → heap = [20, 30]
         Комнат: 2 (максимум)
```

---

### Модель 5: Три фазы для Insert Interval

**Структура алгоритма:**

```
Вставляем [newStart, newEnd] в отсортированный список

ФАЗА 1 (BEFORE):
  Добавляем все интервалы, которые ПОЛНОСТЬЮ ДО нового
  Условие: interval.end < newStart

ФАЗА 2 (MERGE):
  Сливаем все пересекающиеся с новым
  Условие: interval.start <= newEnd
  При merge: расширяем newStart/newEnd

ФАЗА 3 (AFTER):
  Добавляем все интервалы, которые ПОЛНОСТЬЮ ПОСЛЕ
  (просто копируем остаток)
```

**Пример:**

```
intervals = [[1,2], [3,5], [6,7], [8,10], [12,16]]
newInterval = [4,8]

ФАЗА 1: [1,2].end=2 < 4=newStart → добавляем [1,2]
        [3,5].end=5 >= 4 → СТОП

ФАЗА 2: [3,5].start=3 <= 8=newEnd → merge → new=[3,8]
        [6,7].start=6 <= 8 → merge → new=[3,8]
        [8,10].start=8 <= 8 → merge → new=[3,10]
        [12,16].start=12 > 10 → СТОП
        Добавляем merged [3,10]

ФАЗА 3: Добавляем [12,16]

Результат: [[1,2], [3,10], [12,16]]
```

---

## Зачем это нужно?

**Реальная проблема:**

Система бронирования переговорных комнат. 1000 встреч в день, нужно найти минимальное количество комнат. Наивный подход O(n²) — перебор пар. Intervals pattern с сортировкой и heap: O(n log n).

**Где используется:**

| Область | Применение | Пример |
|---------|------------|--------|
| Календари | Конфликты встреч | Google Calendar |
| Базы данных | Temporal queries | SQL OVERLAPS |
| Биоинформатика | Genome ranges | Gene overlap detection |
| Сети | IP ranges | CIDR блоки |
| Финансы | Trading sessions | Время торговых сессий |
| Операционные системы | Memory allocation | Сегменты памяти |

**Статистика:**
- 15-20% задач на интервью в FAANG
- LeetCode: 100+ задач с тегом Intervals
- Meeting Rooms II — одна из top-10 задач на интервью

---

## Prerequisites (Что нужно знать)

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **Сортировка** | Почти все interval алгоритмы начинаются с сортировки | [[sorting-algorithms]] |
| **Heap / Priority Queue** | Для Meeting Rooms II и scheduling задач | [[heaps]] |
| **Two Pointers** | Для interval intersection | [[two-pointers-pattern]] |
| **Big O нотация** | O(n log n) из-за сортировки | [[big-o-complexity]] |
| **CS: Comparator** | Сортировка по start vs по end — разные результаты | Основы сортировки |

---

## Что это такое?

### Объяснение для 5-летнего

Представь, что у тебя есть расписание уроков:
- Математика: 9:00-10:00
- Рисование: 9:30-11:00
- Музыка: 11:00-12:00

Математика и Рисование пересекаются! Можно ли успеть на оба? Нужно минимум 2 класса.

```
Время:    9:00    10:00   11:00   12:00
          |-------|
Матем.    █████████
          |---------------|
Рисов.            █████████████████
                          |-------|
Музыка                    █████████

Перекрытие: Математика ∩ Рисование (9:30-10:00)
→ Нужно 2 комнаты параллельно
```

### Формальное определение

**Interval** — это пара [start, end], где start ≤ end, представляющая непрерывный диапазон значений.

**Два интервала перекрываются**, если:
```
a.start < b.end AND b.start < a.end
```

**Эквивалентно**: max(a.start, b.start) < min(a.end, b.end)

**Типы задач:**

```
1. Merge Intervals
   [1,3] [2,6] [8,10] → [1,6] [8,10]

2. Insert Interval
   [1,3] [6,9] + insert [2,5] → [1,5] [6,9]

3. Meeting Rooms (count overlaps)
   [[0,30],[5,10],[15,20]] → need 2 rooms

4. Interval Intersection
   [0,2][5,10] ∩ [1,5][8,12] → [1,2][5,5][8,10]
```

---

## Терминология

| Термин | Определение | Пример |
|--------|-------------|--------|
| **Start** | Начало интервала | `interval[0]` |
| **End** | Конец интервала | `interval[1]` |
| **Overlap** | Пересечение | [1,5] ∩ [3,7] = [3,5] |
| **Merge** | Объединение | [1,5] ∪ [3,7] = [1,7] |
| **Gap** | Промежуток без покрытия | [1,3] и [5,7] имеют gap [3,5] |
| **Sweep Line** | Сканирующая линия | Алгоритм для подсчёта перекрытий |
| **Active Intervals** | Текущие активные | Интервалы в момент времени t |

---

## Как это работает?

### Паттерн 1: Merge Intervals

```
Вход: [[1,3],[2,6],[8,10],[15,18]]

Шаг 1: Сортировка по start
       [[1,3],[2,6],[8,10],[15,18]] (уже отсортировано)

Шаг 2: Итерация с проверкой overlap

       current = [1,3]

       Проверяем [2,6]: 2 <= 3? YES → merge → [1,6]
       Проверяем [8,10]: 8 <= 6? NO → добавляем [1,6], current = [8,10]
       Проверяем [15,18]: 15 <= 10? NO → добавляем [8,10], current = [15,18]

       Финал: добавляем [15,18]

Выход: [[1,6],[8,10],[15,18]]
```

**Визуализация:**

```
До:
[1----3]
   [2--------6]
                  [8---10]
                              [15----18]

После merge:
[1--------6]      [8---10]    [15----18]
```

### Паттерн 2: Meeting Rooms II (Sweep Line)

```
Вход: [[0,30],[5,10],[15,20]]

Шаг 1: Создаём события
       (0, +1)  - встреча начинается
       (5, +1)  - встреча начинается
       (10, -1) - встреча заканчивается
       (15, +1) - встреча начинается
       (20, -1) - встреча заканчивается
       (30, -1) - встреча заканчивается

Шаг 2: Сортируем по времени (при равенстве: -1 перед +1)
       (0,+1), (5,+1), (10,-1), (15,+1), (20,-1), (30,-1)

Шаг 3: Сканируем и считаем
       rooms=0 → (0,+1) → rooms=1
               → (5,+1) → rooms=2  ← максимум!
               → (10,-1) → rooms=1
               → (15,+1) → rooms=2
               → (20,-1) → rooms=1
               → (30,-1) → rooms=0

Выход: 2 комнаты
```

**Визуализация Sweep Line:**

```
Time:  0    5    10   15   20   30
       |    |    |    |    |    |
Room1: ████████████████████████████████  [0,30]
Room2:      █████      █████            [5,10], [15,20]

Active: 1    2    1    2    1    0
Max: 2
```

---

## Сложность операций

| Операция | Time | Space | Примечание |
|----------|------|-------|------------|
| Merge Intervals | O(n log n) | O(n) | Сортировка доминирует |
| Insert Interval | O(n) | O(n) | Один проход (если отсортировано) |
| Meeting Rooms II | O(n log n) | O(n) | Heap или sweep line |
| Interval Intersection | O(n + m) | O(min(n,m)) | Two pointers |
| Remove Covered | O(n log n) | O(n) | Сортировка + проход |

---

## Реализация

### Merge Intervals (Kotlin)

```kotlin
/**
 * MERGE INTERVALS — объединение перекрывающихся интервалов
 *
 * Алгоритм:
 * 1. Сортируем по началу (start) — тогда перекрытия будут "соседями"
 * 2. Проходим слева направо, сливая перекрывающиеся интервалы
 *
 * ПОШАГОВЫЙ ПРИМЕР: [[1,3], [2,6], [8,10], [15,18]]
 * После сортировки: [[1,3], [2,6], [8,10], [15,18]]
 *
 * current = [1,3]
 * [2,6]: 2 ≤ 3? ДА → merge → current = [1,6]
 * [8,10]: 8 ≤ 6? НЕТ → result.add([1,6]), current = [8,10]
 * [15,18]: 15 ≤ 10? НЕТ → result.add([8,10]), current = [15,18]
 * В конце: result.add([15,18])
 *
 * Результат: [[1,6], [8,10], [15,18]]
 */
fun merge(intervals: Array<IntArray>): Array<IntArray> {
    if (intervals.isEmpty()) return arrayOf()

    // Сортировка по start КРИТИЧНА: после неё все потенциальные перекрытия
    // для текущего интервала идут подряд
    intervals.sortBy { it[0] }

    val result = mutableListOf<IntArray>()
    var current = intervals[0]

    for (i in 1 until intervals.size) {
        val next = intervals[i]

        // Условие перекрытия: next начинается ДО того, как current закончился
        // Важно: нестрогое неравенство, т.к. [1,2] и [2,3] считаются перекрывающимися
        if (next[0] <= current[1]) {
            // Расширяем текущий интервал: берём максимум из концов
            current[1] = maxOf(current[1], next[1])
        } else {
            // Нет перекрытия → сохраняем текущий, начинаем новый
            result.add(current)
            current = next
        }
    }

    // ВАЖНО: последний интервал не добавляется в цикле — добавляем вручную
    result.add(current)

    return result.toTypedArray()
}
```

### Meeting Rooms II (Kotlin)

```kotlin
/**
 * MEETING ROOMS II — минимальное количество переговорок для всех встреч
 *
 * Идея с Min-Heap:
 * - Heap хранит времена окончания занятых комнат
 * - Корень heap = комната, которая освободится раньше всех
 * - Если новая встреча начинается после освобождения — переиспользуем комнату
 *
 * ПОШАГОВЫЙ ПРИМЕР: [[0,30], [5,10], [15,20]]
 *
 * После сортировки по start: [[0,30], [5,10], [15,20]]
 *
 * [0,30]: heap пуст → занимаем комнату → heap = [30]
 * [5,10]: peek()=30 > 5 → не можем переиспользовать → heap = [10, 30]
 * [15,20]: peek()=10 ≤ 15 → переиспользуем! poll() → heap = [30]
 *          добавляем 20 → heap = [20, 30]
 *
 * Размер heap = 2 → нужно 2 комнаты
 */
import java.util.PriorityQueue

fun minMeetingRooms(intervals: Array<IntArray>): Int {
    if (intervals.isEmpty()) return 0

    // Обрабатываем встречи в хронологическом порядке (по началу)
    intervals.sortBy { it[0] }

    // Min-heap хранит времена окончания ЗАНЯТЫХ комнат
    // Корень = самое раннее время освобождения
    val endTimes = PriorityQueue<Int>()

    for (interval in intervals) {
        val start = interval[0]
        val end = interval[1]

        // Проверяем: освободилась ли какая-то комната к началу этой встречи?
        // peek() ≤ start означает, что самая ранняя комната уже свободна
        if (endTimes.isNotEmpty() && endTimes.peek() <= start) {
            endTimes.poll()  // "Освобождаем" комнату (убираем старое время)
        }

        // Занимаем комнату: добавляем время окончания новой встречи
        endTimes.add(end)
    }

    // Размер heap = количество комнат, занятых "одновременно" в пиковый момент
    return endTimes.size
}
```

### Sweep Line подход (Kotlin)

```kotlin
/**
 * SWEEP LINE (Сканирующая прямая) — альтернатива heap
 *
 * Идея: представляем каждую встречу как два СОБЫТИЯ:
 * - Начало (+1): "занимаем комнату"
 * - Конец (-1): "освобождаем комнату"
 *
 * Сортируем события по времени и "сканируем" слева направо,
 * отслеживая текущее количество занятых комнат.
 *
 * ПОШАГОВЫЙ ПРИМЕР: [[0,30], [5,10], [15,20]]
 *
 * События: (0,+1), (5,+1), (10,-1), (15,+1), (20,-1), (30,-1)
 * Сортировка: при равном времени -1 идёт ПЕРЕД +1
 *
 * Сканируем:
 * (0,+1): rooms=1
 * (5,+1): rooms=2 ← максимум!
 * (10,-1): rooms=1
 * (15,+1): rooms=2
 * (20,-1): rooms=1
 * (30,-1): rooms=0
 *
 * Максимум: 2 комнаты
 */
fun minMeetingRoomsSweep(intervals: Array<IntArray>): Int {
    // Создаём события: +1 при начале встречи, -1 при окончании
    val events = mutableListOf<Pair<Int, Int>>()

    for ((start, end) in intervals) {
        events.add(start to 1)   // Начало = нужна ещё одна комната
        events.add(end to -1)    // Конец = освобождаем комнату
    }

    // Сортировка: по времени, при равенстве -1 перед +1
    // ВАЖНО: если встреча кончается в 10:00 и другая начинается в 10:00,
    // сначала освобождаем (-1), потом занимаем (+1) — одна комната!
    events.sortWith(compareBy({ it.first }, { it.second }))

    var rooms = 0
    var maxRooms = 0

    for ((_, delta) in events) {
        rooms += delta
        maxRooms = maxOf(maxRooms, rooms)
    }

    return maxRooms
}
```

### Insert Interval (Java)

```java
/**
 * INSERT INTERVAL — вставка нового интервала в отсортированный список
 *
 * Алгоритм "три фазы":
 * 1. BEFORE: добавляем интервалы, которые полностью ДО нового
 * 2. MERGE: сливаем все перекрывающиеся с новым
 * 3. AFTER: добавляем интервалы, которые полностью ПОСЛЕ нового
 *
 * ПОШАГОВЫЙ ПРИМЕР:
 * intervals = [[1,3], [6,9]], newInterval = [2,5]
 *
 * Фаза 1 (BEFORE): [1,3].end = 3 >= 2 = new.start → стоп
 * Фаза 2 (MERGE):
 *   [1,3]: 1 ≤ 5? ДА → merge → new = [min(2,1), max(5,3)] = [1,5]
 *   [6,9]: 6 ≤ 5? НЕТ → стоп
 *   Добавляем [1,5]
 * Фаза 3 (AFTER): добавляем [6,9]
 *
 * Результат: [[1,5], [6,9]]
 */
public int[][] insert(int[][] intervals, int[] newInterval) {
    List<int[]> result = new ArrayList<>();
    int i = 0;
    int n = intervals.length;

    // ФАЗА 1: добавляем все интервалы, которые заканчиваются ДО начала нового
    // Условие: intervals[i].end < newInterval.start → нет перекрытия
    while (i < n && intervals[i][1] < newInterval[0]) {
        result.add(intervals[i]);
        i++;
    }

    // ФАЗА 2: сливаем все перекрывающиеся интервалы
    // Условие перекрытия: intervals[i].start ≤ newInterval.end
    while (i < n && intervals[i][0] <= newInterval[1]) {
        // Расширяем newInterval, поглощая перекрывающийся интервал
        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
        i++;
    }
    result.add(newInterval);  // Добавляем merged интервал

    // ФАЗА 3: добавляем оставшиеся интервалы (они все после нового)
    while (i < n) {
        result.add(intervals[i]);
        i++;
    }

    return result.toArray(new int[result.size()][]);
}
```

### Interval List Intersections (Python)

```python
"""
INTERVAL LIST INTERSECTIONS — пересечения двух списков интервалов

Идея с Two Pointers:
- Два указателя: i для firstList, j для secondList
- На каждом шаге проверяем пересечение текущих интервалов
- Двигаем указатель того интервала, который заканчивается раньше

ПОШАГОВЫЙ ПРИМЕР:
firstList = [[0,2], [5,10], [13,23]]
secondList = [[1,5], [8,12], [15,24]]

i=0, j=0: [0,2] ∩ [1,5] = [max(0,1), min(2,5)] = [1,2] ✓
          2 < 5 → i++
i=1, j=0: [5,10] ∩ [1,5] = [5,5] ✓
          5 < 10 → j++
i=1, j=1: [5,10] ∩ [8,12] = [8,10] ✓
          10 < 12 → i++
...

Результат: [[1,2], [5,5], [8,10], [15,23]]
"""
def intervalIntersection(firstList: list, secondList: list) -> list:
    result = []
    i, j = 0, 0

    # Two pointers: каждый указатель продвигается НЕЗАВИСИМО
    while i < len(firstList) and j < len(secondList):
        a_start, a_end = firstList[i]
        b_start, b_end = secondList[j]

        # Пересечение: [max(начал), min(концов)]
        # Существует, если max(начал) ≤ min(концов)
        start = max(a_start, b_start)
        end = min(a_end, b_end)

        if start <= end:
            result.append([start, end])

        # Двигаем указатель интервала, который ЗАКАНЧИВАЕТСЯ раньше
        # Интуиция: этот интервал уже "исчерпан" для пересечений
        # с последующими интервалами другого списка
        if a_end < b_end:
            i += 1
        else:
            j += 1

    return result
```

---

## Распространённые ошибки

### 1. Забыть отсортировать

```kotlin
// ❌ НЕПРАВИЛЬНО: работает только для отсортированного входа
fun mergeBad(intervals: Array<IntArray>): List<IntArray> {
    val result = mutableListOf(intervals[0])
    for (i in 1 until intervals.size) {
        // Может пропустить перекрытия!
    }
    return result
}

// ✅ ПРАВИЛЬНО: всегда сортируем
fun mergeGood(intervals: Array<IntArray>): List<IntArray> {
    intervals.sortBy { it[0] }  // Без сортировки алгоритм не работает!
    // ...
}
```

### 2. Неправильное условие перекрытия

```kotlin
// ❌ НЕПРАВИЛЬНО: строгое неравенство
if (next[0] < current[1]) { ... }  // пропустит [1,2] и [2,3]

// ✅ ПРАВИЛЬНО: нестрогое неравенство
if (next[0] <= current[1]) { ... }  // [1,2] и [2,3] перекрываются
```

### 3. Забыть последний интервал

```kotlin
// ❌ НЕПРАВИЛЬНО: последний интервал потерян
for (i in 1 until intervals.size) {
    if (overlap) merge()
    else result.add(current)  // current обновляется, но не добавляется в конце
}
return result  // последний current потерян!

// ✅ ПРАВИЛЬНО: добавляем в конце
for (i in 1 until intervals.size) { ... }
result.add(current)  // Последний интервал не добавляется в цикле!
return result
```

### 4. Неправильный порядок событий в sweep line

```kotlin
// ❌ НЕПРАВИЛЬНО: сначала +1, потом -1
events.sortBy { it.first }
// При events [(5,+1), (5,-1)] получим rooms=1 вместо 0

// ✅ ПРАВИЛЬНО: сначала -1, потом +1
events.sortWith(compareBy({ it.first }, { it.second }))
// При events [(5,-1), (5,+1)] корректно: освобождаем, потом занимаем
```

### 5. Модификация входных данных

```kotlin
// ❌ НЕПРАВИЛЬНО: изменяем исходный массив
fun merge(intervals: Array<IntArray>): Array<IntArray> {
    intervals.sortBy { it[0] }  // мутирует вход!
    intervals[0][1] = maxOf(...)  // мутирует!
}

// ✅ ПРАВИЛЬНО: создаём копию
fun merge(intervals: Array<IntArray>): Array<IntArray> {
    val sorted = intervals.sortedBy { it[0] }
    var current = sorted[0].copyOf()  // копия!
}
```

---

## Когда использовать

### Decision Tree

```
Задача про диапазоны/интервалы?
│
├─ YES: Intervals Pattern
│   │
│   ├─ Объединить перекрывающиеся?
│   │   └─ Merge Intervals: sort + linear merge
│   │
│   ├─ Вставить новый интервал?
│   │   └─ Insert Interval: split into before/overlap/after
│   │
│   ├─ Сколько ресурсов нужно?
│   │   └─ Meeting Rooms II: heap или sweep line
│   │
│   ├─ Найти пересечения?
│   │   └─ Interval Intersection: two pointers
│   │
│   └─ Минимум интервалов для удаления?
│       └─ Non-overlapping: greedy по end
│
└─ NO: Другой паттерн
```

### Сравнение подходов

| Задача | Heap | Sweep Line | Two Pointers | Sort+Merge |
|--------|------|------------|--------------|------------|
| Merge Intervals | - | - | - | ✓ |
| Meeting Rooms II | ✓ | ✓ | - | - |
| Interval Intersection | - | - | ✓ | - |
| Insert Interval | - | - | - | ✓ |
| Non-overlapping | - | - | - | ✓ (greedy) |

---

## Практика

### Концептуальные вопросы

1. **Почему сортируем по start, а не по end?**
   - При сортировке по start гарантируем, что при проходе слева направо все потенциальные перекрытия для текущего интервала уже рассмотрены
   - Исключение: Non-overlapping Intervals — там greedy по end

2. **Когда sweep line лучше heap?**
   - Sweep line: когда нужна история изменений во времени
   - Heap: когда достаточно знать текущее состояние

3. **Можно ли решить Meeting Rooms II за O(n)?**
   - Нет, если интервалы не отсортированы (нужен O(n log n))
   - Да, если интервалы уже отсортированы и диапазон значений ограничен (counting sort)

### LeetCode задачи

| # | Название | Сложность | Паттерн | Ключевая идея |
|---|----------|-----------|---------|---------------|
| 56 | Merge Intervals | Medium | Sort+Merge | Сортировка по start |
| 57 | Insert Interval | Medium | Three-phase | Before/Overlap/After |
| 253 | Meeting Rooms II | Medium | Heap/Sweep | Min-heap для end times |
| 986 | Interval List Intersections | Medium | Two Pointers | max(starts), min(ends) |
| 435 | Non-overlapping Intervals | Medium | Greedy | Сортировка по end |
| 252 | Meeting Rooms | Easy | Sort+Check | Проверка перекрытий |
| 1288 | Remove Covered Intervals | Medium | Sort+Compare | Покрывающие интервалы |

### Порядок изучения

```
1. 252. Meeting Rooms (Easy) — базовая проверка перекрытий
2. 56. Merge Intervals (Medium) — классическое слияние
3. 57. Insert Interval (Medium) — вставка с слиянием
4. 253. Meeting Rooms II (Medium) — подсчёт параллельных
5. 986. Interval List Intersections (Medium) — two pointers
6. 435. Non-overlapping Intervals (Medium) — greedy подход
```

---

## Связанные темы

### Prerequisites (изучить до)
- **Sorting** — сортировка основа большинства interval алгоритмов
- **Heap/Priority Queue** — для Meeting Rooms II
- **Two Pointers** — для Interval Intersection

### Unlocks (откроет путь к)
- **Line Sweep Algorithm** — продвинутая техника для геометрии
- **Segment Tree** — запросы на диапазонах
- **Calendar Problems** — реальные приложения

---

## Мифы и заблуждения

| Миф | Реальность |
|-----|-----------|
| "Всегда сортируем по началу интервала" | **Зависит от задачи!** Merge — по началу. Non-overlapping Intervals — по концу. Greedy scheduling — по концу |
| "Перекрытие = start1 < end2" | **Точное условие:** `start1 < end2 AND start2 < end1`. Обе проверки нужны! |
| "Meeting Rooms II — просто подсчёт перекрытий" | **Нужен Heap!** Считаем максимум одновременных meeting'ов. Min-heap хранит end times |
| "Interval Intersection сложная задача" | **Two Pointers!** Для двух отсортированных списков: intersection = [max(starts), min(ends)]. Сдвигаем указатель с меньшим end |
| "Line Sweep — отдельный паттерн" | **Продвинутые интервалы!** Events (+1 at start, -1 at end), сортировка, подсчёт активных. Обобщение Meeting Rooms II |
| "O(n) возможно для интервалов" | **Обычно O(n log n)** из-за сортировки. Без сортировки работают только специальные случаи |
| "Insert Interval — просто вставка" | **Merge после вставки!** Нужно найти позицию, вставить, и смержить перекрывающиеся соседние |
| "Greedy не работает для интервалов" | **Работает!** Activity Selection (max non-overlapping): сортировка по end, greedy выбор. Доказуемо оптимально |

---

## CS-фундамент

| CS-концепция | Применение в Intervals |
|--------------|------------------------|
| **Sorting Comparator** | Сортировка по start: для merge. По end: для greedy scheduling. Влияет на корректность алгоритма |
| **Sweep Line Algorithm** | Events на timeline: +1 (start), -1 (end). Сортировка events, подсчёт активных в каждой точке |
| **Greedy Activity Selection** | Выбор max непересекающихся интервалов: сортировка по end, выбор первого совместимого. Доказательство через exchange argument |
| **Heap for Scheduling** | Min-heap хранит end times активных интервалов. При новом start: если heap.top() ≤ start → освободилось, иначе +1 комната |
| **Overlap Detection** | Два интервала [a,b] и [c,d] перекрываются ⟺ a < d AND c < b. Эквивалентно: NOT (b ≤ c OR d ≤ a) |
| **Merge Operation** | При перекрытии: new_interval = [min(start1, start2), max(end1, end2)]. Поглощение в объединённый |

---

## Источники

| # | Источник | Тип | Вклад |
|---|----------|-----|-------|
| 1 | [Medium — Merge Intervals](https://medium.com/@piyushkashyap045/master-the-merge-intervals-pattern-your-secret-weapon-for-coding-interviews-aec54eb9023b) | Tutorial | Паттерн слияния |
| 2 | [Design Gurus](https://medium.com/codex/grokking-the-coding-interview-pattern-merge-interval-6e6b1e9e038c) | Course | Grokking guide |
| 3 | [LeetCode Solutions](https://leetcode.com/problems/merge-intervals/) | Practice | Обсуждения |
| 4 | [GeeksforGeeks](https://www.geeksforgeeks.org/merging-intervals/) | Tutorial | Реализации |

---

## Куда дальше

→ **Связанный паттерн:** [[greedy-algorithms]] — greedy scheduling
→ **Продвинуто:** Line Sweep Algorithm для геометрии
→ **Вернуться к:** [[patterns-overview|Обзор паттернов]]

---

*Обновлено: 2026-01-08 — добавлены педагогические секции (интуиция интервалов, 6 типичных ошибок, 5 ментальных моделей)*
