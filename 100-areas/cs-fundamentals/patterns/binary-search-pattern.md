---
title: "Паттерн бинарного поиска (Binary Search)"
created: 2025-12-29
modified: 2026-01-06
type: deep-dive
status: published
difficulty: intermediate
confidence: high
cs-foundations:
  - logarithmic-complexity
  - monotonic-predicate
  - search-space-reduction
  - invariant-maintenance
  - lower-upper-bound
  - divide-and-conquer
prerequisites:
  - "[[arrays-strings]]"
  - "[[searching-algorithms]]"
  - "[[sorting-algorithms]]"
tags:
  - topic/cs-fundamentals
  - type/deep-dive
  - level/intermediate
  - pattern
  - interview
related:
  - "[[two-pointers-pattern]]"
  - "[[divide-and-conquer]]"
---

# Binary Search: Полное руководство для понимания

## Для кого этот материал?

Если ты слышал про "бинарный поиск" и думаешь, что это просто "поделить массив пополам" — этот материал для тебя. После прочтения ты будешь **понимать**, а не запоминать. Понимать — значит уметь восстановить алгоритм с нуля, зная только принцип.

---

## Часть 1: Интуиция без единой строчки кода

### Игра "Угадай число"

Представь: я загадал число от 1 до 100. Ты угадываешь, я отвечаю "больше" или "меньше".

**Глупая стратегия:** спрашивать по порядку.

```
Ты: 1?   Я: Больше
Ты: 2?   Я: Больше
Ты: 3?   Я: Больше
...
Ты: 73?  Я: Угадал!
```

В худшем случае — **100 попыток**. В среднем — 50.

**Умная стратегия:** каждый раз делить пополам.

```
Ты: 50?  Я: Больше  → число в [51, 100], убрали 50 вариантов!
Ты: 75?  Я: Меньше  → число в [51, 74], убрали ещё 25!
Ты: 62?  Я: Больше  → число в [63, 74]
Ту: 68?  Я: Больше  → число в [69, 74]
Ты: 71?  Я: Больше  → число в [72, 74]
Ты: 73?  Я: Угадал!
```

**6 попыток** вместо 73. Но главное не это.

**Главное: максимум 7 попыток для ЛЮБОГО числа от 1 до 100.**

Почему 7? Потому что 2^7 = 128 > 100. Каждый вопрос делит варианты пополам:
- После 1 вопроса: 50 вариантов
- После 2 вопросов: 25 вариантов
- После 3 вопросов: ~12 вариантов
- После 7 вопросов: 1 вариант

**Это и есть Binary Search — не конкретный алгоритм, а ПРИНЦИП: если можно отбросить половину вариантов — отбрасывай.**

---

### Словарь (или телефонный справочник)

Представь: нужно найти слово "Мангуст" в бумажном словаре на 1000 страниц.

**Глупо:** листать с первой страницы. "А... Б... В..." — дойдёшь до М минут через 10.

**Умно:** открыть примерно посередине.

1. Открываешь страницу 500. Видишь "Корова". М идёт после К → ищем во второй половине.
2. Открываешь страницу 750. Видишь "Папоротник". М идёт до П → ищем в [500, 750].
3. Открываешь страницу 625. Видишь "Лампа". М идёт после Л → ищем в [625, 750].
4. И так далее...

**Почему это работает?** Потому что словарь **отсортирован по алфавиту**. Если бы слова шли вперемешку, этот трюк не работал бы.

**Ключевой инсайт: Binary Search работает только когда данные УПОРЯДОЧЕНЫ.**

Упорядоченность означает, что если ты знаешь значение в одной точке, ты можешь сделать вывод обо всех точках слева или справа от неё.

---

### Почему это НАСТОЛЬКО быстро?

Давай посчитаем конкретно:

| Количество элементов | Линейный поиск (худший случай) | Binary Search (худший случай) |
|---------------------|-------------------------------|------------------------------|
| 100 | 100 проверок | 7 проверок |
| 1,000 | 1,000 проверок | 10 проверок |
| 1,000,000 | 1,000,000 проверок | 20 проверок |
| 1,000,000,000 | 1,000,000,000 проверок | 30 проверок |

**Миллиард элементов → 30 проверок.** Это не преувеличение, это математика.

Формула: log₂(n) проверок. Логарифм — это "сколько раз нужно поделить n пополам, чтобы получить 1".

```
log₂(1,000,000,000) ≈ 30
```

**Это фундаментальная причина, почему программисты так любят Binary Search: он превращает невозможное в тривиальное.**

---

## Часть 2: Главная сложность Binary Search

### Почему 90% программистов пишут его неправильно?

В 1946 году был опубликован первый алгоритм Binary Search. Первая **корректная** реализация появилась только в 1962 — через 16 лет! А в стандартной библиотеке Java баг в binary search нашли в 2006 году — через 9 лет после её выпуска.

**Алгоритм прост концептуально, но дьявол в деталях:**
- `<` или `<=` в условии цикла?
- `mid + 1` или просто `mid`?
- `hi = mid` или `hi = mid - 1`?

Одна ошибка в одном символе = бесконечный цикл или неправильный ответ.

### Корень проблемы: границы

Представь отрезок от 0 до 10. Ты ищешь какое-то значение внутри.

```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 ^                              ^
 lo                            hi
```

**Вопрос 1:** Включает ли `lo` сам элемент или "до" него?
**Вопрос 2:** Включает ли `hi` сам элемент или "после" него?

Есть два популярных подхода:

**Подход A: Закрытый интервал [lo, hi]**
- `lo = 0` означает "индекс 0 включён в поиск"
- `hi = 10` означает "индекс 10 включён в поиск"
- Условие цикла: `while (lo <= hi)` — потому что когда lo = hi, мы ещё не проверили этот элемент

**Подход B: Полуоткрытый интервал [lo, hi)**
- `lo = 0` означает "индекс 0 включён"
- `hi = 11` означает "индекс 11 НЕ включён"
- Условие цикла: `while (lo < hi)` — когда lo = hi, интервал пуст

**Нет "правильного" подхода — есть КОНСИСТЕНТНОСТЬ.** Выбери один и следуй ему везде.

---

## Часть 3: Ментальные модели для понимания

### Модель 1: "Зелёные и красные" (самая интуитивная)

Представь, что каждый элемент массива покрашен в цвет:
- **Зелёный** — НЕ подходит (условие ложно)
- **Красный** — подходит (условие истинно)

```
Массив:    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Условие:   >= 6
Цвета:     [З, З, З, З, З, К, К, К, К, К]
                        ↑
                   Граница (первый красный)
```

**Binary Search ищет ГРАНИЦУ между зелёным и красным.**

Правила просты:
1. Левый указатель `lo` всегда указывает на зелёный элемент
2. Правый указатель `hi` всегда указывает на красный элемент
3. Когда они встретятся — мы нашли границу

**Почему это работает?** Потому что массив **монотонный** по условию: сначала все зелёные, потом все красные. Не бывает "ЗКЗКЗК" вперемешку.

---

### Модель 2: "Пространство поиска" (для продвинутых задач)

Binary Search можно применять не только к массивам, но к любому **пространству поиска**, где:
1. Пространство упорядочено
2. Можно проверить условие для любой точки
3. Условие монотонно (переходит из "нет" в "да" или наоборот)

**Пример: найти квадратный корень числа**

Ищем √50. Пространство поиска: все числа от 0 до 50.

```
Проверяем 25: 25² = 625 > 50 → слишком много → ищем левее
Проверяем 12: 12² = 144 > 50 → слишком много → ищем левее
Проверяем 6:  6² = 36 < 50  → слишком мало  → ищем правее
Проверяем 7:  7² = 49 < 50  → ещё немного мало
Проверяем 8:  8² = 64 > 50  → уже много

Ответ: √50 ≈ 7 (целая часть)
```

**Здесь нет массива вообще!** Есть только пространство чисел и условие "x² <= 50".

---

### Модель 3: "Инвариант" (для правильности кода)

**Инвариант** — это условие, которое ВСЕГДА выполняется на протяжении всего алгоритма.

Для Binary Search инвариант звучит так:

> **"Ответ всегда находится в текущем диапазоне [lo, hi]"**

Каждый раз, когда мы обновляем `lo` или `hi`, мы должны **сохранять инвариант**.

```
Если arr[mid] < target:
    → target точно НЕ в [lo, mid]
    → значит target в [mid+1, hi]
    → lo = mid + 1 сохраняет инвариант ✓

Если arr[mid] >= target:
    → mid МОЖЕТ быть ответом (мы ищем первый >= target)
    → target в [lo, mid]
    → hi = mid сохраняет инвариант ✓
```

**Почему это важно?** Потому что если инвариант нарушится хоть раз — алгоритм даст неправильный ответ.

---

## Часть 4: Три типа задач Binary Search

### Тип 1: Найти конкретный элемент

**Задача:** В отсортированном массиве найти индекс элемента с значением 7.

```
Массив: [1, 3, 5, 7, 9, 11, 13]
Индекс:  0  1  2  3  4   5   6
```

**Алгоритм (словами):**
1. Смотрим на середину. mid = 3, arr[3] = 7. Это 7? Да! Нашли.
2. Если бы было меньше 7 — искали бы в правой половине.
3. Если бы было больше 7 — искали бы в левой половине.

**Код (минимальный, с объяснением каждой строки):**

```kotlin
fun search(arr: IntArray, target: Int): Int {
    var lo = 0              // Начало поиска — первый элемент
    var hi = arr.lastIndex  // Конец поиска — последний элемент

    // lo <= hi: пока есть хотя бы один элемент для проверки
    while (lo <= hi) {
        // Безопасное вычисление середины (избегаем переполнения)
        val mid = lo + (hi - lo) / 2

        when {
            arr[mid] == target -> return mid  // Нашли!
            arr[mid] < target -> lo = mid + 1 // Ответ правее — сдвигаем левую границу
            else -> hi = mid - 1              // Ответ левее — сдвигаем правую границу
        }
    }

    return -1  // Прошли весь массив — элемента нет
}
```

**Почему `lo <= hi`, а не `lo < hi`?**

Представь массив из одного элемента `[5]`, ищем 5.
- lo = 0, hi = 0
- Если условие `lo < hi`: 0 < 0 = false, цикл не выполнится, вернём -1
- Если условие `lo <= hi`: 0 <= 0 = true, проверим элемент, найдём!

**Почему `lo + (hi - lo) / 2`, а не `(lo + hi) / 2`?**

Математически это одно и то же. Но если lo = 2 миллиарда и hi = 2 миллиарда:
- `lo + hi` = 4 миллиарда > максимальное int (2.1 миллиарда) → переполнение!
- `lo + (hi - lo) / 2` = 2 миллиарда + 0 = 2 миллиарда ✓

---

### Тип 2: Найти границу (первый/последний элемент с условием)

**Задача:** В массиве `[1, 2, 4, 4, 4, 4, 5, 6]` найти ПЕРВУЮ четвёрку.

Это сложнее, чем просто "найти 4", потому что четвёрок несколько.

**Подход "зелёный-красный":**

```
Массив:    [1, 2, 4, 4, 4, 4, 5, 6]
Условие:   >= 4
Цвета:     [З, З, К, К, К, К, К, К]
                 ↑
            Первый красный = индекс 2
```

**Алгоритм (словами):**
1. Смотрим на середину. arr[3] = 4 >= 4? Да (красный).
2. Раз mid красный — граница либо тут, либо левее. hi = mid.
3. Смотрим на середину [0, 3]. arr[1] = 2 >= 4? Нет (зелёный).
4. Раз mid зелёный — граница правее. lo = mid + 1.
5. Продолжаем пока lo < hi...

**Код:**

```kotlin
fun lowerBound(arr: IntArray, target: Int): Int {
    var lo = 0
    var hi = arr.size  // НЕ lastIndex! Потому что ответ может быть "после всех элементов"

    while (lo < hi) {  // НЕ <=! Когда lo == hi, мы нашли границу
        val mid = lo + (hi - lo) / 2

        if (arr[mid] >= target) {
            // mid может быть ответом — НЕ исключаем его
            hi = mid
        } else {
            // mid точно НЕ ответ — исключаем
            lo = mid + 1
        }
    }

    return lo  // lo == hi = граница
}
```

**Почему тут `lo < hi`, а не `lo <= hi`?**

Потому что мы ищем не конкретный элемент, а **границу**. Когда lo == hi — это и есть граница. Проверять элемент не нужно.

**Почему `hi = mid`, а не `hi = mid - 1`?**

Потому что mid может быть ответом! Если arr[mid] >= target, то mid — кандидат на "первый красный". Нельзя его исключать.

**Почему `hi = arr.size`, а не `arr.lastIndex`?**

Если ВСЕ элементы < target, то ответ = "после последнего элемента" = arr.size.

```
arr = [1, 2, 3], target = 10
Все < 10, значит lowerBound = 3 (позиция для вставки)
```

---

### Тип 3: Binary Search на ответе

Это самый мощный, но и самый неочевидный паттерн.

**Задача:** Коко ест бананы. Есть кучки бананов [3, 6, 7, 11]. Охранник вернётся через 8 часов. Найди МИНИМАЛЬНУЮ скорость, чтобы съесть все бананы до возвращения охранника.

Скорость k означает: за час Коко съедает k бананов из одной кучки. Если в кучке меньше k — съедает всю кучку за час.

**Как думать об этой задаче:**

Давай переформулируем вопрос:

> "При скорости 1 успеет?"
> "При скорости 2 успеет?"
> ...
> "При скорости 11 успеет?"

Видишь паттерн? Ответы будут выглядеть так:

```
Скорость:  1   2   3   4   5   6   7   8   9  10  11
Успеет?:   Н   Н   Н   Д   Д   Д   Д   Д   Д   Д   Д
                   ↑
              Первое "Да" — минимальная скорость
```

**Это та же задача поиска границы!** Только вместо массива — диапазон скоростей, а вместо сравнения — проверка "успеет ли".

**Алгоритм:**
1. Минимальная возможная скорость = 1
2. Максимальная нужная скорость = max(кучки) = 11 (съесть самую большую за час)
3. Binary Search по скоростям, ищем первую, при которой успеет

**Код:**

```kotlin
fun minSpeed(piles: IntArray, hours: Int): Int {
    var lo = 1                  // Минимальная скорость
    var hi = piles.max()        // Максимальная нужная скорость

    while (lo < hi) {
        val mid = lo + (hi - lo) / 2

        if (canFinish(piles, hours, mid)) {
            // Успевает со скоростью mid — пробуем медленнее
            hi = mid
        } else {
            // Не успевает — нужно быстрее
            lo = mid + 1
        }
    }

    return lo
}

// Проверка: успеет ли съесть все кучки за hours часов со скоростью k?
fun canFinish(piles: IntArray, hours: Int, k: Int): Boolean {
    var totalHours = 0L  // Long чтобы избежать переполнения

    for (pile in piles) {
        // Сколько часов на эту кучку?
        // Формула: ceil(pile / k) = (pile + k - 1) / k
        totalHours += (pile + k - 1) / k
    }

    return totalHours <= hours
}
```

**Почему (pile + k - 1) / k?**

Это трюк для вычисления "округления вверх" без float:
- pile = 7, k = 3
- Обычное деление: 7 / 3 = 2 (округление вниз)
- Нужно: ceil(7/3) = 3 (чтобы съесть 7 бананов со скоростью 3, нужно 3 часа)
- Формула: (7 + 3 - 1) / 3 = 9 / 3 = 3 ✓

---

## Часть 5: Типичные ошибки и почему они возникают

### Ошибка 1: Бесконечный цикл при поиске максимума

**Задача:** Найти МАКСИМАЛЬНУЮ скорость, при которой что-то работает.

```
Скорость:  1   2   3   4   5   6   7   8   9  10
Работает?: Д   Д   Д   Д   Д   Н   Н   Н   Н   Н
                       ↑
                  Последнее "Да"
```

**Ловушка:** Код по аналогии с минимумом:

```kotlin
// ❌ НЕПРАВИЛЬНО — приводит к бесконечному циклу!
while (lo < hi) {
    val mid = lo + (hi - lo) / 2  // Округление вниз

    if (works(mid)) {
        lo = mid  // mid работает — пробуем больше
    } else {
        hi = mid - 1
    }
}
```

**Почему бесконечный цикл?**

Пусть lo = 5, hi = 6.
- mid = 5 + (6-5)/2 = 5 + 0 = 5 (округление вниз!)
- Если works(5) = true → lo = mid = 5
- Следующая итерация: lo = 5, hi = 6 → то же самое → БЕСКОНЕЧНО

**Решение:** Округлять mid ВВЕРХ при поиске максимума:

```kotlin
// ✓ ПРАВИЛЬНО
while (lo < hi) {
    val mid = lo + (hi - lo + 1) / 2  // +1 для округления вверх

    if (works(mid)) {
        lo = mid
    } else {
        hi = mid - 1
    }
}
```

Теперь при lo = 5, hi = 6:
- mid = 5 + (6-5+1)/2 = 5 + 1 = 6
- Если works(6) = false → hi = 5
- Следующая итерация: lo = 5, hi = 5 → выход из цикла ✓

---

### Ошибка 2: Off-by-one при выборе границ

**Задача:** Найти первый элемент >= target в массиве.

```kotlin
// ❌ НЕПРАВИЛЬНО
var hi = arr.lastIndex  // Что если target > всех элементов?

// ✓ ПРАВИЛЬНО
var hi = arr.size  // Позволяет вернуть "после последнего"
```

**Пример:**
- arr = [1, 2, 3], target = 10
- Ответ должен быть 3 (индекс для вставки)
- С `hi = arr.lastIndex = 2` максимальный ответ = 2 (неправильно)
- С `hi = arr.size = 3` ответ = 3 (правильно)

---

### Ошибка 3: Путаница `<` vs `<=` в условии цикла

**Правило:**
- `while (lo <= hi)` — когда ищем **конкретный элемент** и проверяем каждый
- `while (lo < hi)` — когда ищем **границу** и lo == hi означает "нашли"

**Почему путают?** Потому что обе версии могут работать для простых случаев. Баги появляются на граничных примерах.

---

### Ошибка 4: Забыли проверить результат

```kotlin
// ❌ Что если ответ не существует?
fun findTarget(arr: IntArray, target: Int): Int {
    var lo = 0
    var hi = arr.size

    while (lo < hi) {
        val mid = lo + (hi - lo) / 2
        if (arr[mid] >= target) hi = mid
        else lo = mid + 1
    }

    return lo  // А вдруг arr[lo] != target?
}

// ✓ ПРАВИЛЬНО — проверяем результат
fun findTarget(arr: IntArray, target: Int): Int {
    // ... binary search ...

    // Проверяем, что нашли именно target
    return if (lo < arr.size && arr[lo] == target) lo else -1
}
```

---

## Часть 6: Паттерны задач

### Паттерн "Rotated Array"

Массив был отсортирован, потом "повёрнут" (начало перенесли в конец).

```
Исходный:  [0, 1, 2, 3, 4, 5, 6, 7]
Повёрнут:  [4, 5, 6, 7, 0, 1, 2, 3]
                    ↑
               Точка разрыва
```

**Ключевой инсайт:** Одна из двух половин ВСЕГДА отсортирована.

```
[4, 5, 6, 7, 0, 1, 2, 3]
      ^mid
arr[lo]=4 <= arr[mid]=6 → левая часть [4,5,6,7] отсортирована

[4, 5, 6, 7, 0, 1, 2, 3]
               ^mid
arr[lo]=4 > arr[mid]=1 → правая часть [0,1,2,3] отсортирована
```

**Алгоритм поиска:**
1. Определи, какая половина отсортирована
2. Проверь, попадает ли target в отсортированную часть
3. Если да — ищи там, если нет — ищи в другой половине

---

### Паттерн "Peak Element"

Найти локальный максимум в массиве.

```
[1, 3, 5, 7, 6, 4, 2]
          ↑
         пик
```

**Ключевой инсайт:** Если arr[mid] < arr[mid+1], то пик СПРАВА. Если arr[mid] > arr[mid+1], то пик СЛЕВА (или это он).

Почему? Потому что мы "поднимаемся" в сторону большего соседа, и рано или поздно упрёмся в пик.

---

## Часть 7: Как подступиться к новой задаче

### Чек-лист для Binary Search

1. **Есть ли монотонность?** Можно ли разделить все варианты на "подходят" и "не подходят" так, чтобы все "подходящие" шли подряд?

2. **Что является пространством поиска?** Индексы массива? Значения ответа? Дни? Скорости?

3. **Какой тип задачи?**
   - Найти конкретное значение → стандартный BS
   - Найти первый/последний с условием → граница
   - Минимизировать/максимизировать → BS на ответе

4. **Какие границы?**
   - Минимальное возможное значение?
   - Максимальное возможное значение?

5. **Как проверить условие?** Можно ли за приемлемое время (обычно O(n) или лучше) проверить, работает ли конкретное значение?

---

## Мифы и заблуждения

| Миф | Реальность |
|-----|-----------|
| "Binary Search только для отсортированных массивов" | BS работает везде, где есть **монотонность**. Rotated arrays, peak finding, BS на ответе — массив может быть неотсортирован. Главное — возможность отбросить половину |
| "Один шаблон для всех задач" | Существуют минимум 3 разных шаблона: для поиска элемента (lo <= hi), для минимизации (lo < hi, hi = mid), для максимизации (lo < hi, mid с округлением вверх, lo = mid). Путаница между ними = баги |
| "Binary Search — простой алгоритм" | Концептуально прост, но деталях коварен. Даже опытные программисты ошибаются. Первая корректная реализация появилась через 16 лет после изобретения алгоритма |
| "`<` vs `<=` — неважно, обе работают" | Критически важно! `<=` для поиска элемента (проверяем каждый), `<` для границы (останавливаемся когда lo == hi). Перепутать = бесконечный цикл или пропуск ответа |
| "mid + 1 vs mid — косметика" | Если ищем первый (минимизация) — hi = mid, если последний (максимизация) — lo = mid. Ошибка ±1 = пропуск ответа или бесконечный цикл |
| "Integer overflow — теоретическая проблема" | В Java/Kotlin/C++ при больших массивах (lo + hi) может переполниться. Всегда используй `lo + (hi - lo) / 2` |
| "Если нашёл элемент — задача решена" | Часто нужен ПЕРВЫЙ или ПОСЛЕДНИЙ среди равных. "Найти любой" ≠ "найти первый". Нужны разные алгоритмы |
| "BS на ответе — это отдельный алгоритм" | Это тот же Binary Search, только пространство поиска — не массив, а диапазон возможных ответов. Принцип "отбрось половину" тот же |

---

## CS-фундамент

| Концепция | Как применяется в Binary Search |
|-----------|--------------------------------|
| **O(log n) сложность** | Каждая итерация делит пространство пополам: n → n/2 → n/4 → ... → 1. Количество шагов = log₂(n). Для миллиарда элементов — всего 30 шагов |
| **Монотонность** | Binary Search требует монотонный предикат: если условие верно для x, то верно для всех x' > x (или наоборот). Это позволяет отбрасывать половину |
| **Инвариант цикла** | Условие "ответ в [lo, hi]" должно выполняться на КАЖДОЙ итерации. Нарушение инварианта = неправильный результат |
| **Divide and Conquer** | Binary Search — частный случай: делим задачу пополам, решаем только одну половину, объединение тривиально |
| **Lower/Upper Bound** | Фундаментальные операции: lower_bound = первый >= x, upper_bound = первый > x. Позволяют находить диапазоны: все элементы от x до y = [lower(x), upper(y)) |
| **Search Space** | Абстракция: любое упорядоченное множество, по которому можно итерировать. Массив — частный случай. Можно искать по вещественным числам, датам, строкам |

---

## Куда дальше

→ **Потренироваться:** Начни с [704. Binary Search](https://leetcode.com/problems/binary-search/) (Easy), затем [34. Find First and Last Position](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/) (Medium), затем [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/) (Medium)

→ **Связанный паттерн:** [[two-pointers-pattern]] — тоже сужает пространство поиска, но с двух сторон одновременно

→ **Углублённое изучение:** [TopCoder Tutorial](https://www.topcoder.com/thrive/articles/Binary%20Search) — лучший материал по предикатам и монотонности

→ **Вернуться к:** [[patterns-overview|Обзор паттернов]]

---

## Связь с другими темами

**[[two-pointers-pattern]]** --- two pointers и binary search разделяют общую идею сужения пространства поиска, но применяют её по-разному. Binary search делит пространство пополам на каждом шаге (O(log n)), а two pointers сдвигает границы с двух сторон (O(n)). В некоторых задачах подходы взаимозаменяемы: поиск пары с заданной суммой в отсортированном массиве решается и через two pointers O(n), и через фиксацию одного элемента + binary search O(n log n). Выбор зависит от контекста: two pointers проще, binary search универсальнее для вложенных поисков.

**[[divide-and-conquer]]** --- binary search является частным случаем divide-and-conquer, где задача делится на две половины, но решается только одна. В классическом divide-and-conquer (merge sort, quick sort) обе половины обрабатываются рекурсивно, что даёт O(n log n). В binary search обработка одной половины даёт O(log n). Обобщение этой идеи --- "binary search on answer", где пространство поиска не массив, а диапазон возможных ответов, а check-функция за O(n) проверяет допустимость значения.

---

## Источники

| Источник | Вклад |
|----------|-------|
| [TopCoder Binary Search Tutorial](https://www.topcoder.com/thrive/articles/Binary%20Search) | Предикаты, монотонность, обобщённый подход |
| [Towards Data Science: Teaching Binary Search](https://towardsdatascience.com/teaching-binary-search-to-someone-who-has-no-technical-knowledge-bc21849e4af/) | Педагогический подход без жаргона |
| [Tyler Hou: Binary Search with Confidence](https://tylerhou.com/posts/binary-search-with-confidence/) | Цветовая ментальная модель, инварианты |
| [youcademy.org](https://youcademy.org/binary-search-algorithm/) | Аналогии словаря и игры в угадайку |
| [Calhoun.io](https://www.calhoun.io/lets-learn-algorithms-an-intro-to-binary-search/) | Прогрессивное построение интуиции |

---

*Проверено: 2026-01-06*
