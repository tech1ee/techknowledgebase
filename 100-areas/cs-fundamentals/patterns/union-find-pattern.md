---
title: "–ü–∞—Ç—Ç–µ—Ä–Ω Union-Find (Disjoint Set Union)"
created: 2025-12-29
modified: 2026-01-06
type: deep-dive
status: published
difficulty: intermediate
confidence: high
cs-foundations:
  - disjoint-set-data-structure
  - path-compression
  - union-by-rank
  - inverse-ackermann
  - connected-components
prerequisites:
  - "[[arrays-strings]]"
  - "[[recursion-fundamentals]]"
  - "[[graphs]]"
tags:
  - topic/cs-fundamentals
  - type/deep-dive
  - level/intermediate
  - pattern
  - interview
related:
  - "[[dfs-bfs-patterns]]"
  - "[[graphs]]"
---

# Union-Find Pattern (Disjoint Set Union)

## TL;DR

Union-Find –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç —Å–≤—è–∑–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Å –ø–æ—á—Ç–∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω—ã–º –≤—Ä–µ–º–µ–Ω–µ–º. **–î–≤–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏: path compression (—Å–∂–∞—Ç–∏–µ –ø—É—Ç–∏) –∏ union by rank**. –°–ª–æ–∂–Ω–æ—Å—Ç—å: O(Œ±(n)) ‚âà O(1) –Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—é, –≥–¥–µ Œ± ‚Äî –æ–±—Ä–∞—Ç–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ê–∫–∫–µ—Ä–º–∞–Ω–∞. –û–ø—Ç–∏–º–∞–ª—å–Ω–æ –¥–ª—è: —Å–≤—è–∑–Ω–æ—Å—Ç–∏ –≥—Ä–∞—Ñ–æ–≤, –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏, Kruskal MST, –¥–µ—Ç–µ–∫—Ü–∏–∏ —Ü–∏–∫–ª–æ–≤.

---

## –ß–∞—Å—Ç—å 1: –ò–Ω—Ç—É–∏—Ü–∏—è –±–µ–∑ –∫–æ–¥–∞

### –ê–Ω–∞–ª–æ–≥–∏—è 1: –î—Ä—É–∂–±–∞ –≤ —à–∫–æ–ª–µ

–ü—Ä–µ–¥—Å—Ç–∞–≤—å —à–∫–æ–ª—É —Å 10 —É—á–µ–Ω–∏–∫–∞–º–∏. –ö–∞–∂–¥—ã–π —É—á–µ–Ω–∏–∫ —Å–Ω–∞—á–∞–ª–∞ —Å–∞–º –ø–æ —Å–µ–±–µ ‚Äî "–æ–¥–∏–Ω–æ—á–∫–∞".

```
–ù–∞—á–∞–ª–æ –≥–æ–¥–∞ (–≤—Å–µ –æ—Ç–¥–µ–ª—å–Ω–æ):

  –ü–µ—Ç—è   –ú–∞—à–∞   –ö–æ–ª—è   –ê–Ω—è   –î–∏–º–∞   –í–∏–∫–∞   –°–∞—à–∞   –õ–µ–Ω–∞   –ú–∏—à–∞   –Æ–ª—è
   [0]    [1]    [2]   [3]    [4]    [5]    [6]    [7]    [8]    [9]

–ö–∞–∂–¥—ã–π ‚Äî "–∫–∞–ø–∏—Ç–∞–Ω" —Å–≤–æ–µ–π –≥—Ä—É–ø–ø—ã (—É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Å–µ–±—è)
```

–ü–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ —Ñ–æ—Ä–º–∏—Ä—É—é—Ç—Å—è –¥—Ä—É–∂–µ—Å–∫–∏–µ –≥—Ä—É–ø–ø—ã:

```
–°–æ–±—ã—Ç–∏–µ 1: –ü–µ—Ç—è –∏ –ú–∞—à–∞ –ø–æ–¥—Ä—É–∂–∏–ª–∏—Å—å
  ‚Üí –¢–µ–ø–µ—Ä—å –æ–Ω–∏ –≤ –æ–¥–Ω–æ–π –≥—Ä—É–ø–ø–µ, –ü–µ—Ç—è ‚Äî "–∫–∞–ø–∏—Ç–∞–Ω"

   –ü–µ—Ç—è‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ–ú–∞—à–∞
    ‚Üë
  –∫–∞–ø–∏—Ç–∞–Ω

–°–æ–±—ã—Ç–∏–µ 2: –ö–æ–ª—è –∏ –ê–Ω—è –ø–æ–¥—Ä—É–∂–∏–ª–∏—Å—å
  ‚Üí –û—Ç–¥–µ–ª—å–Ω–∞—è –≥—Ä—É–ø–ø–∞, –ö–æ–ª—è ‚Äî "–∫–∞–ø–∏—Ç–∞–Ω"

–°–æ–±—ã—Ç–∏–µ 3: –ú–∞—à–∞ –ø–æ–∑–Ω–∞–∫–æ–º–∏–ª–∞ –ê–Ω—é —Å –≥—Ä—É–ø–ø–æ–π
  ‚Üí union(–ú–∞—à–∞, –ê–Ω—è) ‚Üí –≥—Ä—É–ø–ø—ã –æ–±—ä–µ–¥–∏–Ω—è—é—Ç—Å—è!

        –ü–µ—Ç—è
       /    \
    –ú–∞—à–∞    –ö–æ–ª—è
              |
             –ê–Ω—è

–í–æ–ø—Ä–æ—Å: –ü–µ—Ç—è –∏ –ê–Ω—è –¥—Ä—É–∑—å—è?
‚Üí find(–ü–µ—Ç—è) = –ü–µ—Ç—è
‚Üí find(–ê–Ω—è) = –ê–Ω—è‚Üí–ö–æ–ª—è‚Üí–ü–µ—Ç—è = –ü–µ—Ç—è
‚Üí –û–¥–∏–Ω–∞–∫–æ–≤—ã–µ –∫–æ—Ä–Ω–∏ = –î–ê, –¥—Ä—É–∑—å—è!
```

**–ö–ª—é—á–µ–≤–æ–π –∏–Ω—Å–∞–π—Ç:** –î—Ä—É–∂–±–∞ —Ç—Ä–∞–Ω–∑–∏—Ç–∏–≤–Ω–∞. –ï—Å–ª–∏ A –¥—Ä—É–∂–∏—Ç —Å B, –∞ B –¥—Ä—É–∂–∏—Ç —Å C, —Ç–æ A –¥—Ä—É–∂–∏—Ç —Å C.

---

### –ê–Ω–∞–ª–æ–≥–∏—è 2: –û—Å—Ç—Ä–æ–≤–∞ –∏ –º–æ—Å—Ç—ã

```
–ù–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ ‚Äî 6 –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –æ—Å—Ç—Ä–æ–≤–æ–≤:

    [A]        [B]        [C]

    [D]        [E]        [F]

–ö–∞–∂–¥—ã–π –æ—Å—Ç—Ä–æ–≤ ‚Äî –æ—Ç–¥–µ–ª—å–Ω–∞—è —Å—Ç—Ä–∞–Ω–∞
–ù–∞—Å–µ–ª–µ–Ω–∏–µ –∫–∞–∂–¥–æ–≥–æ –æ—Å—Ç—Ä–æ–≤–∞ = 1
```

–°—Ç—Ä–æ–∏–º –º–æ—Å—Ç—ã (Union –æ–ø–µ—Ä–∞—Ü–∏–∏):

```
–°—Ç—Ä–æ–∏–º –º–æ—Å—Ç A-B:
    [A]‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[B]        [C]
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      1 —Å—Ç—Ä–∞–Ω–∞

–°—Ç—Ä–æ–∏–º –º–æ—Å—Ç D-E:
    [D]‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[E]        [F]
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      1 —Å—Ç—Ä–∞–Ω–∞

–°—Ç—Ä–æ–∏–º –º–æ—Å—Ç B-E (—Å–æ–µ–¥–∏–Ω—è–µ–º –¥–≤–µ —Å—Ç—Ä–∞–Ω—ã!):
    [A]‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[B]
         ‚îÇ
         ‚ïë  (–º–æ—Å—Ç)
         ‚îÇ
    [D]‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[E]        [C]    [F]
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         1 –±–æ–ª—å—à–∞—è —Å—Ç—Ä–∞–Ω–∞

–¢–µ–ø–µ—Ä—å: 3 —Å—Ç—Ä–∞–Ω—ã (ABDE, C, F)

–í–æ–ø—Ä–æ—Å: –ú–æ–∂–Ω–æ –ª–∏ –¥–æ–µ—Ö–∞—Ç—å –∏–∑ A –≤ E?
‚Üí –î–∞! A‚ÜíB‚ÜíE –∏–ª–∏ A‚ÜíB‚Üí... –µ—Å—Ç—å –ø—É—Ç—å
‚Üí find(A) = find(E) = –æ–±—â–∏–π "–∫–æ—Ä–µ–Ω—å"
```

**–ö–ª—é—á–µ–≤–æ–π –∏–Ω—Å–∞–π—Ç:** Union-Find –æ—Ç–≤–µ—á–∞–µ—Ç "–µ—Å—Ç—å –ª–∏ –ø—É—Ç—å?", –Ω–æ –Ω–µ –≥–æ–≤–æ—Ä–∏—Ç –∫–∞–∫–æ–π –∏–º–µ–Ω–Ω–æ –ø—É—Ç—å.

---

### –ê–Ω–∞–ª–æ–≥–∏—è 3: –≠–ª–µ–∫—Ç—Ä–∏—á–µ—Å–∫–∞—è —Å–µ—Ç—å

```
–ó–∞–¥–∞—á–∞: –ï—Å—Ç—å N –¥–æ–º–æ–≤. –ü—Ä–æ–≤–æ–¥–∞ —Å–æ–µ–¥–∏–Ω—è—é—Ç –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –¥–æ–º–∞.
–í–æ–ø—Ä–æ—Å: –í—Å–µ –ª–∏ –¥–æ–º–∞ –∏–º–µ—é—Ç —ç–ª–µ–∫—Ç—Ä–∏—á–µ—Å—Ç–≤–æ –æ—Ç —Å—Ç–∞–Ω—Ü–∏–∏?

–≠–ª–µ–∫—Ç—Ä–æ—Å—Ç–∞–Ω—Ü–∏—è –≤ –¥–æ–º–µ 0:

     [0]‚ö°‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[1]
      ‚îÇ        ‚îÇ
      ‚îÇ        ‚îÇ
     [2]      [3]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[4]
                       ‚îÇ
                      [5]

Union –æ–ø–µ—Ä–∞—Ü–∏–∏ (–ø—Ä–æ–≤–æ–¥–∞):
- union(0, 1)
- union(0, 2)
- union(1, 3)
- union(3, 4)
- union(4, 5)

–ü—Ä–æ–≤–µ—Ä–∫–∞: connected(0, 5)?
‚Üí find(0) = 0 (—Å—Ç–∞–Ω—Ü–∏—è)
‚Üí find(5) = 5‚Üí4‚Üí3‚Üí1‚Üí0 = 0
‚Üí –î–∞! –î–æ–º 5 –ø–æ–ª—É—á–∞–µ—Ç —ç–ª–µ–∫—Ç—Ä–∏—á–µ—Å—Ç–≤–æ ‚úì

–ù–æ —Å Path Compression –ø–æ—Å–ª–µ find(5):
     [0]‚ö°
    /|\ \ \
   1 2 3 4 5   ‚Üê –í—Å–µ –Ω–∞–ø—Ä—è–º—É—é –∫ —Å—Ç–∞–Ω—Ü–∏–∏!
```

**–ö–ª—é—á–µ–≤–æ–π –∏–Ω—Å–∞–π—Ç:** Path compression ‚Äî –∫–∞–∫ –ø—Ä–æ–∫–ª–∞–¥—ã–≤–∞–Ω–∏–µ "–ø—Ä—è–º—ã—Ö –ª–∏–Ω–∏–π" –∫ –∫–æ—Ä–Ω—é.

---

### –ß–∏—Å–ª–µ–Ω–Ω—ã–π –ø—Ä–∏–º–µ—Ä: –ü–æ—à–∞–≥–æ–≤—ã–π Union-Find

```
5 —ç–ª–µ–º–µ–Ω—Ç–æ–≤: 0, 1, 2, 3, 4

–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è:
  parent = [0, 1, 2, 3, 4]  ‚Üê –∫–∞–∂–¥—ã–π –Ω–∞ —Å–µ–±—è
  rank   = [0, 0, 0, 0, 0]  ‚Üê –≤—Å–µ –≤—ã—Å–æ—Ç—ã = 0

–í–∏–∑—É–∞–ª—å–Ω–æ:
  [0]   [1]   [2]   [3]   [4]   (5 –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –¥–µ—Ä–µ–≤—å–µ–≤)
```

**–û–ø–µ—Ä–∞—Ü–∏—è 1: union(0, 1)**

```
  find(0) = 0
  find(1) = 1
  rank[0] == rank[1] == 0
  ‚Üí parent[1] = 0, rank[0]++

  parent = [0, 0, 2, 3, 4]
  rank   = [1, 0, 0, 0, 0]

  –í–∏–∑—É–∞–ª—å–Ω–æ:
    [0]       [2]   [3]   [4]
     |
    [1]
```

**–û–ø–µ—Ä–∞—Ü–∏—è 2: union(2, 3)**

```
  find(2) = 2
  find(3) = 3
  rank[2] == rank[3] == 0
  ‚Üí parent[3] = 2, rank[2]++

  parent = [0, 0, 2, 2, 4]
  rank   = [1, 0, 1, 0, 0]

  –í–∏–∑—É–∞–ª—å–Ω–æ:
    [0]       [2]       [4]
     |         |
    [1]       [3]
```

**–û–ø–µ—Ä–∞—Ü–∏—è 3: union(1, 3)** (–æ–±—ä–µ–¥–∏–Ω—è–µ–º –¥–≤–µ –≥—Ä—É–ø–ø—ã!)

```
  find(1) = 1‚Üí0 = 0
  find(3) = 3‚Üí2 = 2
  rank[0] == rank[2] == 1
  ‚Üí parent[2] = 0, rank[0]++

  parent = [0, 0, 0, 2, 4]
  rank   = [2, 0, 1, 0, 0]

  –í–∏–∑—É–∞–ª—å–Ω–æ:
        [0]              [4]
       /   \
     [1]   [2]
            |
           [3]
```

**–û–ø–µ—Ä–∞—Ü–∏—è 4: find(3) —Å Path Compression**

```
  find(3):
    3 ‚Üí parent[3] = 2
    2 ‚Üí parent[2] = 0
    0 ‚Üí parent[0] = 0 (–∫–æ—Ä–µ–Ω—å!)

  –ü—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ: parent[3] = 0, parent[2] = 0

  parent = [0, 0, 0, 0, 4]

  –í–∏–∑—É–∞–ª—å–Ω–æ (–ø–æ—Å–ª–µ —Å–∂–∞—Ç–∏—è):
        [0]         [4]
      / | \
    [1][2][3]   ‚Üê –í—Å–µ –Ω–∞–ø—Ä—è–º—É—é –∫ 0!
```

---

### –ß—Ç–æ —Ç–∞–∫–æ–µ Path Compression –≤–∏–∑—É–∞–ª—å–Ω–æ

```
–î–û Path Compression:              –ü–û–°–õ–ï find(5):

        [0]                           [0]
         |                          / | \ \
        [1]                       [1][2][3][5]
         |                             |
        [2]                           [4]
         |
        [3]
         |
        [4]
         |
        [5]

find(5) –ø—Ä–æ—Ö–æ–¥–∏—Ç: 5‚Üí4‚Üí3‚Üí2‚Üí1‚Üí0
–ù–∞ –æ–±—Ä–∞—Ç–Ω–æ–º –ø—É—Ç–∏: parent[5]=0, parent[4]=0, parent[3]=0...

–†–µ–∑—É–ª—å—Ç–∞—Ç: –¥–µ—Ä–µ–≤–æ "—Å–ø–ª—é—â–∏–≤–∞–µ—Ç—Å—è"!
–°–ª–µ–¥—É—é—â–∏–π find(5): 5‚Üí0 (1 —à–∞–≥ –≤–º–µ—Å—Ç–æ 5)
```

---

## –ß–∞—Å—Ç—å 2: –ü–æ—á–µ–º—É —ç—Ç–æ —Å–ª–æ–∂–Ω–æ

### –¢–∏–ø–∏—á–Ω—ã–µ –æ—à–∏–±–∫–∏ —Å—Ç—É–¥–µ–Ω—Ç–æ–≤

#### –û—à–∏–±–∫–∞ 1: –ó–∞–±—ã–ª–∏ Path Compression

```kotlin
// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û ‚Äî O(n) –Ω–∞ –∫–∞–∂–¥—ã–π find –≤ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ
fun find(x: Int): Int {
    var curr = x
    while (parent[curr] != curr) {
        curr = parent[curr]
    }
    return curr
}

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û ‚Äî O(Œ±(n)) ‚âà O(1)
fun find(x: Int): Int {
    if (parent[x] != x) {
        parent[x] = find(parent[x])  // ‚Üê Path Compression!
    }
    return parent[x]
}

–°–ò–ú–ü–¢–û–ú: TLE (Time Limit Exceeded) –Ω–∞ –±–æ–ª—å—à–∏—Ö —Ç–µ—Å—Ç–∞—Ö
–†–ï–®–ï–ù–ò–ï: –î–æ–±–∞–≤—å –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É: parent[x] = find(parent[x])
```

#### –û—à–∏–±–∫–∞ 2: Union –±–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π –∫–æ—Ä–µ–Ω—å

```kotlin
// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û ‚Äî count –º–æ–∂–µ—Ç —Å—Ç–∞—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º!
fun union(x: Int, y: Int) {
    parent[find(x)] = find(y)
    count--  // –£–º–µ–Ω—å—à–∞–µ–º –¥–∞–∂–µ –µ—Å–ª–∏ x –∏ y —É–∂–µ —Å–≤—è–∑–∞–Ω—ã!
}

// –ü—Ä–∏–º–µ—Ä –ø—Ä–æ–±–ª–µ–º—ã:
// union(0, 1) ‚Üí count = 4
// union(0, 1) ‚Üí count = 3  ‚Üê –û—à–∏–±–∫–∞! –ù–∏—á–µ–≥–æ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å!

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û ‚Äî –ø—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ—Ä–Ω–∏ —Ä–∞–∑–Ω—ã–µ
fun union(x: Int, y: Int): Boolean {
    val rootX = find(x)
    val rootY = find(y)
    if (rootX == rootY) return false  // –£–∂–µ —Å–≤—è–∑–∞–Ω—ã!
    parent[rootX] = rootY
    count--
    return true
}

–°–ò–ú–ü–¢–û–ú: –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
–†–ï–®–ï–ù–ò–ï: –í—Å–µ–≥–¥–∞ –ø—Ä–æ–≤–µ—Ä—è–π rootX != rootY –ø–µ—Ä–µ–¥ union
```

#### –û—à–∏–±–∫–∞ 3: –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è parent

```kotlin
// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û ‚Äî –≤—Å–µ —É–∫–∞–∑—ã–≤–∞—é—Ç –Ω–∞ 0
val parent = IntArray(n)  // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤—Å–µ = 0

// –ü—Ä–æ–±–ª–µ–º–∞:
find(5) = 5‚Üí0 (–¥—É–º–∞–µ—Ç —á—Ç–æ 5 —É–∂–µ –≤ –≥—Ä—É–ø–ø–µ —Å 0!)

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û ‚Äî –∫–∞–∂–¥—ã–π —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Å–µ–±—è
val parent = IntArray(n) { it }  // parent[i] = i

// –ò–ª–∏:
val parent = IntArray(n)
for (i in 0 until n) parent[i] = i

–°–ò–ú–ü–¢–û–ú: –í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã "—É–∂–µ —Å–≤—è–∑–∞–Ω—ã" —Å —Å–∞–º–æ–≥–æ –Ω–∞—á–∞–ª–∞
–†–ï–®–ï–ù–ò–ï: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π parent[i] = i
```

#### –û—à–∏–±–∫–∞ 4: –ü—É—Ç–∞–Ω–∏—Ü–∞ —Å –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–µ–π 0-based vs 1-based

```kotlin
// –ó–∞–¥–∞—á–∞ –¥–∞—ë—Ç –≤–µ—Ä—à–∏–Ω—ã 1..n

// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û
val uf = UnionFind(n)
uf.union(1, 2)  // ArrayIndexOutOfBoundsException –ø—Ä–∏ n=2!

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û ‚Äî –º–∞—Å—Å–∏–≤ —Ä–∞–∑–º–µ—Ä–∞ n+1
val uf = UnionFind(n + 1)  // –ò–Ω–¥–µ–∫—Å—ã 0..n, –∏—Å–ø–æ–ª—å–∑—É–µ–º 1..n

–°–ò–ú–ü–¢–û–ú: ArrayIndexOutOfBoundsException
–†–ï–®–ï–ù–ò–ï: –ï—Å–ª–∏ –≤–µ—Ä—à–∏–Ω—ã 1..n, —Å–æ–∑–¥–∞–≤–∞–π –º–∞—Å—Å–∏–≤ —Ä–∞–∑–º–µ—Ä–∞ n+1
```

#### –û—à–∏–±–∫–∞ 5: –°—Ä–∞–≤–Ω–µ–Ω–∏–µ parent –≤–º–µ—Å—Ç–æ –∫–æ—Ä–Ω–µ–π

```kotlin
// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û ‚Äî —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω—ã—Ö —Ä–æ–¥–∏—Ç–µ–ª–µ–π
fun connected(x: Int, y: Int): Boolean {
    return parent[x] == parent[y]
}

// –ü—Ä–æ–±–ª–µ–º–∞:
// –ï—Å–ª–∏ 0‚Üí1, 1‚Üí2, 2‚Üí3 –∏ 0‚Üí1, 1‚Üí3
// parent[0] = 1, parent[1] = 3
// connected(0, 1) –≤–µ—Ä–Ω—ë—Ç false! (1 != 3)
// –ù–æ –æ–Ω–∏ –≤ –æ–¥–Ω–æ–π –≥—Ä—É–ø–ø–µ!

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û ‚Äî —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º –ö–û–†–ù–ò
fun connected(x: Int, y: Int): Boolean {
    return find(x) == find(y)
}

–°–ò–ú–ü–¢–û–ú: connected() –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç false –¥–ª—è —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
–†–ï–®–ï–ù–ò–ï: –í—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–π find() –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ—Ä–Ω—è
```

#### –û—à–∏–±–∫–∞ 6: –ó–∞–±—ã–ª–∏ –ø—Ä–æ 2D‚Üí1D –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ grid

```kotlin
// Grid m√ón, –Ω—É–∂–µ–Ω Union-Find

// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û ‚Äî –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ (row, col) –Ω–∞–ø—Ä—è–º—É—é
val uf = UnionFind(???)  // –ö–∞–∫–æ–π —Ä–∞–∑–º–µ—Ä? –ö–∞–∫ —Ö—Ä–∞–Ω–∏—Ç—å –ø–∞—Ä—ã?

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û ‚Äî –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ 1D –∏–Ω–¥–µ–∫—Å
val uf = UnionFind(m * n)
fun index(row: Int, col: Int) = row * n + col

// –ö–ª–µ—Ç–∫–∞ (2, 3) –≤ —Å–µ—Ç–∫–µ 4√ó5:
// index = 2 * 5 + 3 = 13

// –°–æ—Å–µ–¥–∏ –∫–ª–µ—Ç–∫–∏ (i, j):
// –í–≤–µ—Ä—Ö:  (i-1, j) ‚Üí (i-1) * n + j
// –í–Ω–∏–∑:   (i+1, j) ‚Üí (i+1) * n + j
// –í–ª–µ–≤–æ:  (i, j-1) ‚Üí i * n + (j-1)
// –í–ø—Ä–∞–≤–æ: (i, j+1) ‚Üí i * n + (j+1)

–°–ò–ú–ü–¢–û–ú: –ù–µ–ø–æ–Ω—è—Ç–Ω–æ –∫–∞–∫ —Ö—Ä–∞–Ω–∏—Ç—å 2D –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
–†–ï–®–ï–ù–ò–ï: index = row * cols + col
```

---

## –ß–∞—Å—Ç—å 3: –ú–µ–Ω—Ç–∞–ª—å–Ω—ã–µ –º–æ–¥–µ–ª–∏

### –ú–æ–¥–µ–ª—å 1: "–õ–µ—Å –ø–µ—Ä–µ–≤—ë—Ä–Ω—É—Ç—ã—Ö –¥–µ—Ä–µ–≤—å–µ–≤"

```
Union-Find ‚Äî —ç—Ç–æ –ª–µ—Å, –≥–¥–µ –∫–∞–∂–¥–æ–µ –¥–µ—Ä–µ–≤–æ = –æ–¥–Ω–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
–î–µ—Ä–µ–≤—å—è "–ø–µ—Ä–µ–≤—ë—Ä–Ω—É—Ç—ã": –¥–µ—Ç–∏ —É–∫–∞–∑—ã–≤–∞—é—Ç –Ω–∞ —Ä–æ–¥–∏—Ç–µ–ª–µ–π

   –û–±—ã—á–Ω–æ–µ –¥–µ—Ä–µ–≤–æ:        Union-Find –¥–µ—Ä–µ–≤–æ:
        A                       A
       / \                      ‚Üë
      B   C                    / \
     /                        B   C
    D                         ‚Üë
                              D

–í –æ–±—ã—á–Ω–æ–º: —Ä–æ–¥–∏—Ç–µ–ª—å –∑–Ω–∞–µ—Ç –¥–µ—Ç–µ–π
–í Union-Find: —Ä–µ–±—ë–Ω–æ–∫ –∑–Ω–∞–µ—Ç —Ä–æ–¥–∏—Ç–µ–ª—è

–ö–æ—Ä–µ–Ω—å ‚Äî —ç—Ç–æ "–ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª—å" –≤—Å–µ–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
find(x) = –ø–æ–¥–Ω—è—Ç—å—Å—è –¥–æ –∫–æ—Ä–Ω—è
union(x, y) = —Å–æ–µ–¥–∏–Ω–∏—Ç—å –¥–≤–∞ –∫–æ—Ä–Ω—è
```

### –ú–æ–¥–µ–ª—å 2: "–ì–µ–Ω–µ–∞–ª–æ–≥–∏—á–µ—Å–∫–æ–µ –¥—Ä–µ–≤–æ"

```
–ö–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç –ø–æ–º–Ω–∏—Ç —Å–≤–æ–µ–≥–æ "–ø—Ä–µ–¥–∫–∞" (parent)

–°–µ–º—å—è –ò–≤–∞–Ω–æ–≤—ã—Ö:         –°–µ–º—å—è –ü–µ—Ç—Ä–æ–≤—ã—Ö:
    –ò–≤–∞–Ω                    –ü—ë—Ç—Ä
     ‚Üë                       ‚Üë
    –ú–∞—Ä–∏—è                   –ê–Ω–Ω–∞
     ‚Üë                       ‚Üë
   –ê–ª–µ–∫—Å–µ–π                 –°–µ—Ä–≥–µ–π

–í–æ–ø—Ä–æ—Å: –ê–ª–µ–∫—Å–µ–π –∏ –°–µ—Ä–≥–µ–π —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏?
‚Üí –ü—Ä–µ–¥–æ–∫(–ê–ª–µ–∫—Å–µ–π) = –ò–≤–∞–Ω
‚Üí –ü—Ä–µ–¥–æ–∫(–°–µ—Ä–≥–µ–π) = –ü—ë—Ç—Ä
‚Üí –†–∞–∑–Ω—ã–µ –ø—Ä–µ–¥–∫–∏ = —Ä–∞–∑–Ω—ã–µ —Å–µ–º—å–∏!

union(–ú–∞—Ä–∏—è, –ê–Ω–Ω–∞) ‚Äî –±—Ä–∞–∫!
‚Üí –¢–µ–ø–µ—Ä—å –≤—Å–µ –æ–¥–Ω–∞ —Å–µ–º—å—è —Å –æ–±—â–∏–º "–ø—Ä–µ–¥–∫–æ–º"
```

### –ú–æ–¥–µ–ª—å 3: "–¶–≤–µ—Ç–∞ –∫—Ä–∞—Å–∫–∏"

```
–ö–∞–∂–¥–∞—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ ‚Äî —Å–≤–æ–π —Ü–≤–µ—Ç
find(x) = –∫–∞–∫–æ–≥–æ —Ü–≤–µ—Ç–∞ —ç–ª–µ–º–µ–Ω—Ç x?
union(x, y) = —Å–º–µ—à–∞—Ç—å —Ü–≤–µ—Ç–∞ (–≤—Å–µ —Å—Ç–∞–Ω–æ–≤—è—Ç—Å—è –æ–¥–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞)

–ù–∞—á–∞–ª–æ:       –ü–æ—Å–ª–µ union(0,1):    –ü–æ—Å–ª–µ union(2,3):
üî¥ üîµ üü¢ üü°      üî¥ üî¥ üü¢ üü°          üî¥ üî¥ üü¢ üü¢
0  1  2  3      0  1  2  3          0  1  2  3

–ü–æ—Å–ª–µ union(1,3):
üî¥ üî¥ üî¥ üî¥   ‚Üê –í—Å–µ –æ–¥–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞!
0  1  2  3

–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ü–≤–µ—Ç–æ–≤ = –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
```

### –ú–æ–¥–µ–ª—å 4: "–ü—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª–∏ –Ω–∞ —Å–æ–±—Ä–∞–Ω–∏–∏"

```
–í –∫–∞–∂–¥–æ–π –≥—Ä—É–ø–ø–µ –µ—Å—Ç—å –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª—å (–∫–æ—Ä–µ–Ω—å)
–í—Å–µ —Ä–µ—à–µ–Ω–∏—è –ø—Ä–∏–Ω–∏–º–∞—é—Ç—Å—è –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª–µ–º

–ì—Ä—É–ø–ø–∞ A: [–ü–µ—Ç—è*, –ú–∞—à–∞, –ö–æ–ª—è]    (* = –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª—å)
–ì—Ä—É–ø–ø–∞ B: [–ê–Ω—è*, –î–∏–º–∞]

–í–æ–ø—Ä–æ—Å –æ—Ç –ú–∞—à–∏: "–ú—ã —Å –î–∏–º–æ–π –≤ –æ–¥–Ω–æ–π –≥—Ä—É–ø–ø–µ?"
‚Üí –ü—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª—å –ú–∞—à–∏: –ü–µ—Ç—è
‚Üí –ü—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª—å –î–∏–º—ã: –ê–Ω—è
‚Üí –†–∞–∑–Ω—ã–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª–∏ = —Ä–∞–∑–Ω—ã–µ –≥—Ä—É–ø–ø—ã!

union(–ú–∞—à–∞, –î–∏–º–∞):
‚Üí –ì—Ä—É–ø–ø—ã –æ–±—ä–µ–¥–∏–Ω—è—é—Ç—Å—è
‚Üí –ù—É–∂–µ–Ω –Ω–æ–≤—ã–π –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª—å
‚Üí –í—ã–±–∏—Ä–∞–µ–º —Ç–æ–≥–æ, —á—å—è –≥—Ä—É–ø–ø–∞ –±–æ–ª—å—à–µ (union by rank)
```

### –ú–æ–¥–µ–ª—å 5: "–ò–Ω—Ç–µ—Ä–Ω–µ—Ç-–ø—Ä–æ–≤–∞–π–¥–µ—Ä—ã"

```
–ö–∞–∂–¥—ã–π –ø—Ä–æ–≤–∞–π–¥–µ—Ä ‚Äî –∫–æ—Ä–µ–Ω—å —Å–≤–æ–µ–π —Å–µ—Ç–∏
–ö–æ–º–ø—å—é—Ç–µ—Ä—ã –ø–æ–¥–∫–ª—é—á–µ–Ω—ã —á–µ—Ä–µ–∑ —Ü–µ–ø–æ—á–∫—É —Ä–æ—É—Ç–µ—Ä–æ–≤ –∫ –ø—Ä–æ–≤–∞–π–¥–µ—Ä—É

ISP_A                    ISP_B
  |                        |
Router1                  Router3
  |                        |
Router2                  PC_4
  |
PC_1, PC_2, PC_3

find(PC_2) = PC_2 ‚Üí Router2 ‚Üí Router1 ‚Üí ISP_A
‚Üí "–ö—Ç–æ —Ç–≤–æ–π –ø—Ä–æ–≤–∞–π–¥–µ—Ä?"

Path Compression = "–ø—Ä—è–º–æ–π –∫–∞–Ω–∞–ª –¥–æ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞"

–ü–æ—Å–ª–µ find(PC_2):
ISP_A ‚Üê PC_2  (–Ω–∞–ø—Ä—è–º—É—é!)

connected(PC_1, PC_4)?
‚Üí ISP_A ‚â† ISP_B
‚Üí –ù–µ—Ç —Å–≤—è–∑–∏ –º–µ–∂–¥—É –Ω–∏–º–∏
```

---

## –ó–∞—á–µ–º —ç—Ç–æ –Ω—É–∂–Ω–æ?

**–†–µ–∞–ª—å–Ω–∞—è –ø—Ä–æ–±–ª–µ–º–∞:**

–°–æ—Ü–∏–∞–ª—å–Ω–∞—è —Å–µ—Ç—å —Å 1 –º–∏–ª–ª–∏–∞—Ä–¥–æ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π. –ù—É–∂–Ω–æ –±—ã—Å—Ç—Ä–æ –æ—Ç–≤–µ—á–∞—Ç—å: "–°–≤—è–∑–∞–Ω—ã –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ A –∏ B?" –∏ –æ–±—ä–µ–¥–∏–Ω—è—Ç—å –≥—Ä—É–ø–ø—ã –¥—Ä—É–∑–µ–π. –ù–∞–∏–≤–Ω—ã–π BFS/DFS: O(V+E) –Ω–∞ –∫–∞–∂–¥—ã–π –∑–∞–ø—Ä–æ—Å. Union-Find: O(1) –∞–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ.

**–ì–¥–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è:**

| –û–±–ª–∞—Å—Ç—å | –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ | –ü—Ä–∏–º–µ—Ä |
|---------|------------|--------|
| –°–æ—Ü—Å–µ—Ç–∏ | Friend connections | Facebook friend graph |
| –°–µ—Ç–∏ | Network connectivity | –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∏–∑–æ–ª—è—Ü–∏–∏ —É–∑–ª–æ–≤ |
| –ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è | Image segmentation | Region merging |
| –ò–≥—Ä—ã | Percolation | –î–æ—Å—Ç–∏–∂–∏–º–æ—Å—Ç—å –≤ —Å–µ—Ç–∫–µ |
| –ì—Ä–∞—Ñ—ã | Minimum Spanning Tree | Kruskal's algorithm |
| –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä—ã | Type equivalence | Union types |

**–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:**
- 10-15% –∑–∞–¥–∞—á –Ω–∞ –≥—Ä–∞—Ñ—ã –∏—Å–ø–æ–ª—å–∑—É—é—Ç Union-Find
- Kruskal MST ‚Äî –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º —Å Union-Find
- Number of Islands, Accounts Merge ‚Äî —á–∞—Å—Ç—ã–µ –∑–∞–¥–∞—á–∏ –Ω–∞ –∏–Ω—Ç–µ—Ä–≤—å—é

---

## Prerequisites (–ß—Ç–æ –Ω—É–∂–Ω–æ –∑–Ω–∞—Ç—å)

| –¢–µ–º–∞ | –ó–∞—á–µ–º –Ω—É–∂–Ω–æ | –ì–¥–µ –∏–∑—É—á–∏—Ç—å |
|------|-------------|-------------|
| **–ú–∞—Å—Å–∏–≤—ã** | parent[] –∏ rank[] –º–∞—Å—Å–∏–≤—ã | [[arrays-strings]] |
| **–†–µ–∫—É—Ä—Å–∏—è** | –î–ª—è path compression (find) | [[recursion-fundamentals]] |
| **–ì—Ä–∞—Ñ—ã** | –ö–æ–Ω—Ü–µ–ø—Ü–∏—è —Å–≤—è–∑–Ω—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç | [[graphs]] |
| **CS: Tree –∫–∞–∫ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞** | Union-Find = –ª–µ—Å –¥–µ—Ä–µ–≤—å–µ–≤ | –°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö |
| **CS: Amortized Analysis** | O(Œ±(n)) ‚Äî –ø–æ—á—Ç–∏ O(1) amortized | –ê–Ω–∞–ª–∏–∑ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ |

---

## –ß—Ç–æ —ç—Ç–æ —Ç–∞–∫–æ–µ?

### –û–±—ä—è—Å–Ω–µ–Ω–∏–µ –¥–ª—è 5-–ª–µ—Ç–Ω–µ–≥–æ

–ü—Ä–µ–¥—Å—Ç–∞–≤—å –¥–µ—Ç—Å–∫–∏–π —Å–∞–¥, –≥–¥–µ –¥–µ—Ç–∏ –¥–µ—Ä–∂–∞—Ç—Å—è –∑–∞ —Ä—É–∫–∏. –ö–∞–∂–¥–∞—è –≥—Ä—É–ø–ø–∞ –¥–µ—Ç–µ–π ‚Äî —ç—Ç–æ "–∫–æ–º–∞–Ω–¥–∞". –£ –∫–∞–∂–¥–æ–π –∫–æ–º–∞–Ω–¥—ã –µ—Å—Ç—å "–∫–∞–ø–∏—Ç–∞–Ω" (—Ä–µ–±—ë–Ω–æ–∫, –∑–∞ –∫–æ—Ç–æ—Ä–æ–≥–æ –¥–µ—Ä–∂–∞—Ç—Å—è –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ —á–µ—Ä–µ–∑ —Ü–µ–ø–æ—á–∫—É —Ä—É–∫).

```
–ö–æ–º–∞–Ω–¥–∞ 1:     –ö–æ–º–∞–Ω–¥–∞ 2:
  –ü–µ—Ç—è           –ú–∞—à–∞
  ‚Üë   ‚Üë            ‚Üë
–í–æ–≤–∞  –ö–∞—Ç—è       –°–∞—à–∞

–í–æ–ø—Ä–æ—Å: –ü–µ—Ç—è –∏ –ö–∞—Ç—è –≤ –æ–¥–Ω–æ–π –∫–æ–º–∞–Ω–¥–µ?
‚Üí –ò–¥—ë–º –ø–æ —Ü–µ–ø–æ—á–∫–µ: –ö–∞—Ç—è ‚Üí –ü–µ—Ç—è, –ü–µ—Ç—è ‚Üí –ü–µ—Ç—è. –î–∞!

–í–æ–ø—Ä–æ—Å: –ü–µ—Ç—è –∏ –ú–∞—à–∞ –≤ –æ–¥–Ω–æ–π –∫–æ–º–∞–Ω–¥–µ?
‚Üí –ü–µ—Ç—è ‚Üí –ü–µ—Ç—è, –ú–∞—à–∞ ‚Üí –ú–∞—à–∞. –†–∞–∑–Ω—ã–µ –∫–∞–ø–∏—Ç–∞–Ω—ã ‚Äî —Ä–∞–∑–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã!

–û–±—ä–µ–¥–∏–Ω—è–µ–º –∫–æ–º–∞–Ω–¥—ã: –ü–µ—Ç—è —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è "–∫–∞–ø–∏—Ç–∞–Ω–æ–º" –ú–∞—à–∏
       –ü–µ—Ç—è
      ‚Üë ‚Üë  ‚Üë
  –í–æ–≤–∞ –ö–∞—Ç—è –ú–∞—à–∞
            ‚Üë
          –°–∞—à–∞
```

### –§–æ—Ä–º–∞–ª—å–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ

**Union-Find (Disjoint Set Union)** ‚Äî —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –Ω–µ–ø–µ—Ä–µ—Å–µ–∫–∞—é—â–∏–º–∏—Å—è –º–Ω–æ–∂–µ—Å—Ç–≤–∞–º–∏, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∞—è –æ–ø–µ—Ä–∞—Ü–∏–∏:
- **makeSet(x)** ‚Äî —Å–æ–∑–¥–∞—Ç—å –º–Ω–æ–∂–µ—Å—Ç–≤–æ –∏–∑ –æ–¥–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
- **find(x)** ‚Äî –Ω–∞–π—Ç–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª—è (–∫–æ—Ä–µ–Ω—å) –º–Ω–æ–∂–µ—Å—Ç–≤–∞
- **union(x, y)** ‚Äî –æ–±—ä–µ–¥–∏–Ω–∏—Ç—å –º–Ω–æ–∂–µ—Å—Ç–≤–∞, —Å–æ–¥–µ—Ä–∂–∞—â–∏–µ x –∏ y

**–ö–ª—é—á–µ–≤—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞:**
- –ö–∞–∂–¥–æ–µ –º–Ω–æ–∂–µ—Å—Ç–≤–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–æ –¥–µ—Ä–µ–≤–æ–º
- –ö–æ—Ä–µ–Ω—å –¥–µ—Ä–µ–≤–∞ ‚Äî –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª—å –º–Ω–æ–∂–µ—Å—Ç–≤–∞
- parent[x] —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ä–æ–¥–∏—Ç–µ–ª—è (–∏–ª–∏ –Ω–∞ —Å–µ–±—è –¥–ª—è –∫–æ—Ä–Ω—è)

**–î–≤–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:**

```
1. Path Compression (—Å–∂–∞—Ç–∏–µ –ø—É—Ç–∏)
   –ü—Ä–∏ find(x) –ø—Ä–∏—Ü–µ–ø–ª—è–µ–º –≤—Å–µ —É–∑–ª—ã –Ω–∞–ø—Ä—è–º—É—é –∫ –∫–æ—Ä–Ω—é
   –£–º–µ–Ω—å—à–∞–µ—Ç –≤—ã—Å–æ—Ç—É –¥–µ—Ä–µ–≤–∞

2. Union by Rank/Size
   –ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ–º –º–µ–Ω—å—à–µ–µ –¥–µ—Ä–µ–≤–æ –∫ –±–æ–ª—å—à–µ–º—É
   –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç –≤—ã—Å–æ—Ç—É –¥–æ O(log n)

–í–º–µ—Å—Ç–µ: O(Œ±(n)) ‚âà O(1) –Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—é
Œ±(n) ‚Äî –æ–±—Ä–∞—Ç–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ê–∫–∫–µ—Ä–º–∞–Ω–∞, ‚â§ 4 –¥–ª—è –≤—Å–µ—Ö –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏—Ö n
```

---

## –¢–µ—Ä–º–∏–Ω–æ–ª–æ–≥–∏—è

| –¢–µ—Ä–º–∏–Ω | –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ | –ü—Ä–∏–º–µ—Ä |
|--------|-------------|--------|
| **Representative (Root)** | –ö–æ—Ä–µ–Ω—å –¥–µ—Ä–µ–≤–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ | parent[root] == root |
| **Rank** | –í–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ –≤—ã—Å–æ—Ç—ã –ø–æ–¥–¥–µ—Ä–µ–≤–∞ | –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è union by rank |
| **Size** | –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –º–Ω–æ–∂–µ—Å—Ç–≤–µ | –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ rank |
| **Path Compression** | –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É–∑–ª–æ–≤ –∫ –∫–æ—Ä–Ω—é –ø—Ä–∏ find | parent[x] = find(parent[x]) |
| **Union by Rank** | –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –º–µ–Ω—å—à–µ–≥–æ –¥–µ—Ä–µ–≤–∞ –∫ –±–æ–ª—å—à–µ–º—É | if rank[x] < rank[y]: parent[x] = y |
| **Œ±(n)** | Inverse Ackermann function | ‚â§ 4 –¥–ª—è n < 10^600 |
| **Connected Components** | –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∫–æ—Ä–Ω–µ–π | –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–Ω–æ–∂–µ—Å—Ç–≤ |

---

## –ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç?

### –ë–∞–∑–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏

```
–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è: –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç ‚Äî —Å–≤–æ–π —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π —Ä–æ–¥–∏—Ç–µ–ª—å
parent = [0, 1, 2, 3, 4]  # parent[i] = i
rank   = [0, 0, 0, 0, 0]  # –≤—Å–µ —Ä–∞–Ω–≥–∏ = 0

Union(0, 1):
  root0 = find(0) = 0
  root1 = find(1) = 1
  rank[0] == rank[1] ‚Üí parent[1] = 0, rank[0]++

  parent = [0, 0, 2, 3, 4]
  rank   = [1, 0, 0, 0, 0]

Union(2, 3):
  root2 = find(2) = 2
  root3 = find(3) = 3
  rank[2] == rank[3] ‚Üí parent[3] = 2, rank[2]++

  parent = [0, 0, 2, 2, 4]
  rank   = [1, 0, 1, 0, 0]

Union(1, 3):
  root1 = find(1) = 0
  root3 = find(3) = 2
  rank[0] == rank[2] ‚Üí parent[2] = 0, rank[0]++

  parent = [0, 0, 0, 2, 4]
  rank   = [2, 0, 1, 0, 0]
```

### Path Compression

```
–ë–µ–∑ path compression:
        0
       / \
      1   2
         / \
        3   4

find(3):
  3 ‚Üí 2 ‚Üí 0 (3 —à–∞–≥–∞)

–° path compression:
find(3):
  3 ‚Üí 2 ‚Üí 0 (3 —à–∞–≥–∞)
  –ù–û: parent[3] = 0, parent[2] = 0

        0
      / | \ \
     1  2  3  4

find(3) —Å–Ω–æ–≤–∞:
  3 ‚Üí 0 (1 —à–∞–≥!)
```

**–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è:**

```
–î–æ path compression:        –ü–æ—Å–ª–µ path compression:
      0                           0
     /|\                       /||\\\
    1 2 5                     1 2 3 4 5
     /|\
    3 4 6

find(6):                      find(6):
6‚Üí2‚Üí0 (2 —à–∞–≥–∞)               6‚Üí0 (1 —à–∞–≥)
+ —Å–∂–∞—Ç–∏–µ: parent[6]=0
```

---

## –°–ª–æ–∂–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–π

| –û–ø–µ—Ä–∞—Ü–∏—è | –ë–µ–∑ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π | –° –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è–º–∏ | –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ |
|----------|-----------------|-----------------|------------|
| makeSet | O(1) | O(1) | –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è |
| find | O(n) worst | O(Œ±(n)) | Œ±(n) ‚â§ 4 |
| union | O(n) worst | O(Œ±(n)) | –í–∫–ª—é—á–∞–µ—Ç find |
| connected | O(n) worst | O(Œ±(n)) | find(x) == find(y) |
| count components | O(n) | O(n) | –ü–µ—Ä–µ—Å—á—ë—Ç –∫–æ—Ä–Ω–µ–π |

**–ê–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑:**
- m –æ–ø–µ—Ä–∞—Ü–∏–π –Ω–∞ n —ç–ª–µ–º–µ–Ω—Ç–∞—Ö: O(m √ó Œ±(n))
- –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –ª–∏–Ω–µ–π–Ω–æ!

---

## –†–µ–∞–ª–∏–∑–∞—Ü–∏—è

### Union-Find Class (Kotlin)

```kotlin
/**
 * –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö Union-Find (Disjoint Set Union, DSU)
 *
 * –û–ü–ï–†–ê–¶–ò–ò:
 * - find(x): –Ω–∞–π—Ç–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª—è (–∫–æ—Ä–µ–Ω—å) –º–Ω–æ–∂–µ—Å—Ç–≤–∞ –¥–ª—è x
 * - union(x, y): –æ–±—ä–µ–¥–∏–Ω–∏—Ç—å –º–Ω–æ–∂–µ—Å—Ç–≤–∞, —Å–æ–¥–µ—Ä–∂–∞—â–∏–µ x –∏ y
 * - connected(x, y): –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, –≤ –æ–¥–Ω–æ–º –ª–∏ –º–Ω–æ–∂–µ—Å—Ç–≤–µ x –∏ y
 *
 * –î–í–ï –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:
 * 1. Path Compression (—Å–∂–∞—Ç–∏–µ –ø—É—Ç–∏) ‚Äî –ø—Ä–∏ find –≤—Å–µ —É–∑–ª—ã
 *    –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è—é—Ç—Å—è –Ω–∞–ø—Ä—è–º—É—é –∫ –∫–æ—Ä–Ω—é
 * 2. Union by Rank ‚Äî –º–µ–Ω—å—à–µ–µ –¥–µ—Ä–µ–≤–æ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ—Ç—Å—è –∫ –±–æ–ª—å—à–µ–º—É
 *
 * –í–º–µ—Å—Ç–µ –¥–∞—é—Ç –ø–æ—á—Ç–∏ O(1) –Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—é: O(Œ±(n)) –≥–¥–µ Œ± ‚Äî –æ–±—Ä–∞—Ç–Ω–∞—è
 * —Ñ—É–Ω–∫—Ü–∏—è –ê–∫–∫–µ—Ä–º–∞–Ω–∞, —Ä–∞—Å—Ç—ë—Ç –Ω–µ–≤–µ—Ä–æ—è—Ç–Ω–æ –º–µ–¥–ª–µ–Ω–Ω–æ (‚â§4 –¥–ª—è –≤—Å–µ—Ö
 * –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏—Ö n ‚â§ 10^600)
 *
 * –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–Ø PATH COMPRESSION:
 *
 * –î–æ find(4):          –ü–æ—Å–ª–µ find(4):
 *       1                    1
 *       |                  / | \
 *       2                 2  3  4
 *       |
 *       3
 *       |
 *       4
 */
class UnionFind(n: Int) {
    // parent[i] = i –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ i ‚Äî –∫–æ—Ä–µ–Ω—å —Å–≤–æ–µ–≥–æ –º–Ω–æ–∂–µ—Å—Ç–≤–∞
    // –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç ‚Äî —Å–∞–º —Å–µ–±–µ –∫–æ—Ä–µ–Ω—å
    private val parent = IntArray(n) { it }

    // rank ‚Äî –≤–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ –≤—ã—Å–æ—Ç—ã –ø–æ–¥–¥–µ—Ä–µ–≤–∞
    // –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è union by rank: –º–µ–Ω—å—à–µ–µ –∫ –±–æ–ª—å—à–µ–º—É
    private val rank = IntArray(n)

    // count ‚Äî –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–≤—è–∑–Ω—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
    // –£–º–µ–Ω—å—à–∞–µ—Ç—Å—è –ø—Ä–∏ –∫–∞–∂–¥–æ–º —É—Å–ø–µ—à–Ω–æ–º union
    var count = n
        private set

    /**
     * –ù–∞–π—Ç–∏ –∫–æ—Ä–µ–Ω—å –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Å path compression
     *
     * Path compression: –ø—Ä–∏ –∫–∞–∂–¥–æ–º find –≤—Å–µ —É–∑–ª—ã –Ω–∞ –ø—É—Ç–∏
     * –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è—é—Ç—Å—è –Ω–∞–ø—Ä—è–º—É—é –∫ –∫–æ—Ä–Ω—é
     *
     * –ü–†–ò–ú–ï–†: find(4) –≤ —Ü–µ–ø–æ—á–∫–µ 1‚Üí2‚Üí3‚Üí4
     * –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ: find(4)‚Üífind(3)‚Üífind(2)‚Üífind(1)=1
     * –ù–∞ –æ–±—Ä–∞—Ç–Ω–æ–º —Ö–æ–¥–µ: parent[2]=1, parent[3]=1, parent[4]=1
     */
    fun find(x: Int): Int {
        if (parent[x] != x) {
            // Path compression: –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ–º –Ω–∞–ø—Ä—è–º—É—é –∫ –∫–æ—Ä–Ω—é
            parent[x] = find(parent[x])
        }
        return parent[x]
    }

    /**
     * –û–±—ä–µ–¥–∏–Ω–∏—Ç—å –¥–≤–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Å union by rank
     *
     * Union by rank: –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ–º –¥–µ—Ä–µ–≤–æ —Å –º–µ–Ω—å—à–∏–º rank –∫ –±–æ–ª—å—à–µ–º—É
     * –≠—Ç–æ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –¥–µ—Ä–µ–≤—å—è —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏
     *
     * @return true –µ—Å–ª–∏ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ –±—ã–ª–∏ —Ä–∞–∑–Ω—ã–º–∏ –∏ –æ–±—ä–µ–¥–∏–Ω–µ–Ω—ã
     *         false –µ—Å–ª–∏ x –∏ y —É–∂–µ –≤ –æ–¥–Ω–æ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ
     */
    fun union(x: Int, y: Int): Boolean {
        val rootX = find(x)
        val rootY = find(y)

        // –ï—Å–ª–∏ —É–∂–µ –≤ –æ–¥–Ω–æ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ ‚Äî –æ–±—ä–µ–¥–∏–Ω—è—Ç—å –Ω–µ—á–µ–≥–æ
        if (rootX == rootY) return false

        // –ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ–º –¥–µ—Ä–µ–≤–æ —Å –º–µ–Ω—å—à–∏–º rank –∫ –±–æ–ª—å—à–µ–º—É
        when {
            rank[rootX] < rank[rootY] -> parent[rootX] = rootY
            rank[rootX] > rank[rootY] -> parent[rootY] = rootX
            else -> {
                // –ü—Ä–∏ —Ä–∞–≤–Ω—ã—Ö ranks –≤—ã–±–∏—Ä–∞–µ–º –ª—é–±–æ–µ, —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º rank
                parent[rootY] = rootX
                rank[rootX]++
            }
        }

        count--  // –î–≤–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Å—Ç–∞–ª–∏ –æ–¥–Ω–∏–º ‚Üí –Ω–∞ –æ–¥–Ω—É –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—É –º–µ–Ω—å—à–µ
        return true
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —Å–≤—è–∑–∞–Ω—ã –ª–∏ x –∏ y (–≤ –æ–¥–Ω–æ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ)
     */
    fun connected(x: Int, y: Int): Boolean = find(x) == find(y)
}
```

### Number of Islands (Kotlin)

```kotlin
/**
 * –ü–æ–¥—Å—á—ë—Ç –æ—Å—Ç—Ä–æ–≤–æ–≤ —á–µ—Ä–µ–∑ Union-Find
 *
 * –ò–î–ï–Ø:
 * 1. –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º 2D —Å–µ—Ç–∫—É –≤ 1D –º–∞—Å—Å–∏–≤: (i, j) ‚Üí i * n + j
 * 2. –î–ª—è –∫–∞–∂–¥–æ–π –∫–ª–µ—Ç–∫–∏ –∑–µ–º–ª–∏ –æ–±—ä–µ–¥–∏–Ω—è–µ–º –µ—ë —Å —Å–æ—Å–µ–¥—è–º–∏ (–≤–ø—Ä–∞–≤–æ, –≤–Ω–∏–∑)
 * 3. –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Å—Ç—Ä–æ–≤–æ–≤ = –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Å–≤—è–∑–Ω–æ—Å—Ç–∏ —Å—Ä–µ–¥–∏ –∑–µ–º–ª–∏
 *
 * –ü–û–ß–ï–ú–£ –¢–û–õ–¨–ö–û –í–ü–†–ê–í–û –ò –í–ù–ò–ó:
 * –ü—Ä–∏ –ø—Ä–æ—Ö–æ–¥–µ —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ, —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑:
 * - –°–æ—Å–µ–¥–∏ —Å–ª–µ–≤–∞ –∏ —Å–≤–µ—Ä—Ö—É —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã (–º—ã –∏—Ö —É–∂–µ union'–∏–ª–∏)
 * - –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –≤–ø—Ä–∞–≤–æ –∏ –≤–Ω–∏–∑, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è
 *
 * –ü–†–ò–ú–ï–†:
 * grid = [['1','1','0'],
 *         ['0','1','0'],
 *         ['0','0','1']]
 *
 * –ò–Ω–¥–µ–∫—Å—ã:  0  1  2
 *           3  4  5
 *           6  7  8
 *
 * union(0,1), union(1,4) ‚Üí –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ {0,1,4}
 * 8 –æ—Å—Ç–∞—ë—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ ‚Üí –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ {8}
 * –û—Å—Ç—Ä–æ–≤–∞: 2
 */
fun numIslands(grid: Array<CharArray>): Int {
    if (grid.isEmpty()) return 0

    val m = grid.size
    val n = grid[0].size
    val uf = UnionFind(m * n)

    // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ 2D –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤ 1D –∏–Ω–¥–µ–∫—Å
    fun index(i: Int, j: Int) = i * n + j

    var waterCount = 0

    for (i in 0 until m) {
        for (j in 0 until n) {
            if (grid[i][j] == '0') {
                waterCount++  // –í–æ–¥–∞ ‚Äî –æ—Ç–¥–µ–ª—å–Ω–æ, –Ω–µ —É—á–∞—Å—Ç–≤—É–µ—Ç –≤ union
                continue
            }

            // –û–±—ä–µ–¥–∏–Ω—è–µ–º —Å —Å–æ—Å–µ–¥—è–º–∏ —Å–ø—Ä–∞–≤–∞ –∏ —Å–Ω–∏–∑—É (–µ—Å–ª–∏ —Ç–∞–º –∑–µ–º–ª—è)
            if (i + 1 < m && grid[i + 1][j] == '1') {
                uf.union(index(i, j), index(i + 1, j))
            }
            if (j + 1 < n && grid[i][j + 1] == '1') {
                uf.union(index(i, j), index(i, j + 1))
            }
        }
    }

    // –û—Å—Ç—Ä–æ–≤–∞ = –≤—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –º–∏–Ω—É—Å "–ø—É—Å—Ç—ã–µ" –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –≤–æ–¥—ã
    return uf.count - waterCount
}
```

### Redundant Connection (Kotlin)

```kotlin
/**
 * –ù–∞–π—Ç–∏ –ª–∏—à–Ω–µ–µ —Ä–µ–±—Ä–æ, –æ–±—Ä–∞–∑—É—é—â–µ–µ —Ü–∏–∫–ª
 *
 * –ò–î–ï–Ø:
 * - –î–µ—Ä–µ–≤–æ —Å n –≤–µ—Ä—à–∏–Ω–∞–º–∏ –∏–º–µ–µ—Ç n-1 —Ä—ë–±–µ—Ä
 * - –ï—Å–ª–∏ –¥–∞–Ω–æ n —Ä—ë–±–µ—Ä, –æ–¥–Ω–æ –∏–∑ –Ω–∏—Ö ‚Äî –ª–∏—à–Ω–µ–µ (—Å–æ–∑–¥–∞—ë—Ç —Ü–∏–∫–ª)
 * - –î–æ–±–∞–≤–ª—è–µ–º —Ä—ë–±—Ä–∞ –ø–æ –ø–æ—Ä—è–¥–∫—É; –∫–æ–≥–¥–∞ union –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç false,
 *   —ç—Ç–æ –∑–Ω–∞—á–∏—Ç –≤–µ—Ä—à–∏–Ω—ã —É–∂–µ —Å–≤—è–∑–∞–Ω—ã ‚Üí —Ä–µ–±—Ä–æ —Å–æ–∑–¥–∞—ë—Ç —Ü–∏–∫–ª
 *
 * –ü–û–®–ê–ì–û–í–´–ô –ü–†–ò–ú–ï–† (edges = [[1,2], [1,3], [2,3]]):
 * union(1,2): uf = {1,2}, {3} ‚Üí true
 * union(1,3): uf = {1,2,3} ‚Üí true
 * union(2,3): 2 –∏ 3 —É–∂–µ –≤ –æ–¥–Ω–æ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ ‚Üí false!
 *             –†–µ–±—Ä–æ [2,3] —Å–æ–∑–¥–∞—ë—Ç —Ü–∏–∫–ª ‚Üí –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –µ–≥–æ
 */
fun findRedundantConnection(edges: Array<IntArray>): IntArray {
    val n = edges.size
    val uf = UnionFind(n + 1)  // –í–µ—Ä—à–∏–Ω—ã –Ω—É–º–µ—Ä—É—é—Ç—Å—è —Å 1, –ø–æ—ç—Ç–æ–º—É n+1

    for (edge in edges) {
        val (u, v) = edge

        // –ï—Å–ª–∏ union –≤–µ—Ä–Ω—É–ª false, –≤–µ—Ä—à–∏–Ω—ã —É–∂–µ —Å–≤—è–∑–∞–Ω—ã
        // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —ç—Ç–æ–≥–æ —Ä–µ–±—Ä–∞ —Å–æ–∑–¥–∞—Å—Ç —Ü–∏–∫–ª
        if (!uf.union(u, v)) {
            return edge  // –≠—Ç–æ –∏–∑–±—ã—Ç–æ—á–Ω–æ–µ —Ä–µ–±—Ä–æ
        }
    }

    return intArrayOf()  // –ù–µ –¥–æ–ª–∂–Ω–æ –ø—Ä–æ–∏–∑–æ–π—Ç–∏ –ø–æ —É—Å–ª–æ–≤–∏—é –∑–∞–¥–∞—á–∏
}
```

### Accounts Merge (Java)

```java
/**
 * –°–ª–∏—è–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–æ–≤ —á–µ—Ä–µ–∑ Union-Find
 *
 * –ó–ê–î–ê–ß–ê:
 * –ê–∫–∫–∞—É–Ω—Ç—ã = [–∏–º—è, email1, email2, ...]
 * –î–≤–∞ –∞–∫–∫–∞—É–Ω—Ç–∞ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç –æ–¥–Ω–æ–º—É —á–µ–ª–æ–≤–µ–∫—É, –µ—Å–ª–∏ —É –Ω–∏—Ö –æ–±—â–∏–π email.
 * –û–±—ä–µ–¥–∏–Ω–∏—Ç—å –≤—Å–µ –∞–∫–∫–∞—É–Ω—Ç—ã –æ–¥–Ω–æ–≥–æ —á–µ–ª–æ–≤–µ–∫–∞.
 *
 * –ò–î–ï–Ø:
 * 1. –ü—Ä–∏—Å–≤–∞–∏–≤–∞–µ–º –∫–∞–∂–¥–æ–º—É —É–Ω–∏–∫–∞–ª—å–Ω–æ–º—É email –∏–Ω–¥–µ–∫—Å
 * 2. –û–±—ä–µ–¥–∏–Ω—è–µ–º –≤—Å–µ email'—ã –æ–¥–Ω–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞ (–æ–Ω–∏ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç –æ–¥–Ω–æ–º—É —á–µ–ª–æ–≤–µ–∫—É)
 * 3. –ì—Ä—É–ø–ø–∏—Ä—É–µ–º email'—ã –ø–æ –∫–æ—Ä–Ω—é (–≤—Å–µ email'—ã —Å –æ–¥–Ω–∏–º –∫–æ—Ä–Ω—ë–º = –æ–¥–∏–Ω —á–µ–ª–æ–≤–µ–∫)
 *
 * –ü–†–ò–ú–ï–†:
 * accounts = [["John", "j1@mail", "j2@mail"],
 *             ["John", "j3@mail"],
 *             ["John", "j2@mail", "j4@mail"]]
 *
 * –®–∞–≥ 1: emailToIndex = {j1:0, j2:1, j3:2, j4:3}
 * –®–∞–≥ 2: union(0,1) –¥–ª—è 1-–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞
 *        union(1,3) –¥–ª—è 3-–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞ (j2 –∏ j4)
 *        ‚Üí {j1, j2, j4} –≤ –æ–¥–Ω–æ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ
 * –®–∞–≥ 3: –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ ‚Üí John: [j1, j2, j4], John: [j3]
 */
public List<List<String>> accountsMerge(List<List<String>> accounts) {
    // email ‚Üí —á–∏—Å–ª–æ–≤–æ–π –∏–Ω–¥–µ–∫—Å –¥–ª—è Union-Find
    Map<String, Integer> emailToIndex = new HashMap<>();
    // email ‚Üí –∏–º—è –≤–ª–∞–¥–µ–ª—å—Ü–∞ (–¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ)
    Map<String, String> emailToName = new HashMap<>();

    int index = 0;
    for (List<String> account : accounts) {
        String name = account.get(0);
        for (int i = 1; i < account.size(); i++) {
            String email = account.get(i);
            if (!emailToIndex.containsKey(email)) {
                emailToIndex.put(email, index++);
            }
            emailToName.put(email, name);
        }
    }

    UnionFind uf = new UnionFind(index);

    // –û–±—ä–µ–¥–∏–Ω—è–µ–º –≤—Å–µ email'—ã –∫–∞–∂–¥–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞
    // (–≤—Å–µ email'—ã –≤ –æ–¥–Ω–æ–º –∞–∫–∫–∞—É–Ω—Ç–µ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç –æ–¥–Ω–æ–º—É —á–µ–ª–æ–≤–µ–∫—É)
    for (List<String> account : accounts) {
        String firstEmail = account.get(1);
        int firstIndex = emailToIndex.get(firstEmail);

        for (int i = 2; i < account.size(); i++) {
            String email = account.get(i);
            uf.union(firstIndex, emailToIndex.get(email));
        }
    }

    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º email'—ã –ø–æ –∫–æ—Ä–Ω—é (–æ–¥–∏–Ω–∞–∫–æ–≤—ã–π –∫–æ—Ä–µ–Ω—å = –æ–¥–∏–Ω —á–µ–ª–æ–≤–µ–∫)
    Map<Integer, List<String>> rootToEmails = new HashMap<>();
    for (String email : emailToIndex.keySet()) {
        int root = uf.find(emailToIndex.get(email));
        rootToEmails.computeIfAbsent(root, k -> new ArrayList<>()).add(email);
    }

    // –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç: [–∏–º—è, email1, email2, ...] –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —á–µ–ª–æ–≤–µ–∫–∞
    List<List<String>> result = new ArrayList<>();
    for (List<String> emails : rootToEmails.values()) {
        Collections.sort(emails);  // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —É—Å–ª–æ–≤–∏—é –∑–∞–¥–∞—á–∏
        String name = emailToName.get(emails.get(0));
        emails.add(0, name);  // –ò–º—è –≤ –Ω–∞—á–∞–ª–æ —Å–ø–∏—Å–∫–∞
        result.add(emails);
    }

    return result;
}
```

### Kruskal MST (Python)

```python
def kruskal_mst(n: int, edges: list) -> tuple:
    """
    –ê–ª–≥–æ—Ä–∏—Ç–º –ö—Ä–∞—Å–∫–∞–ª–∞ –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è MST —á–µ—Ä–µ–∑ Union-Find

    –ò–î–ï–Ø (–∂–∞–¥–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º):
    1. –°–æ—Ä—Ç–∏—Ä—É–µ–º —Ä—ë–±—Ä–∞ –ø–æ –≤–µ—Å—É (–æ—Ç –º–µ–Ω—å—à–µ–≥–æ –∫ –±–æ–ª—å—à–µ–º—É)
    2. –ü–µ—Ä–µ–±–∏—Ä–∞–µ–º —Ä—ë–±—Ä–∞ –≤ –ø–æ—Ä—è–¥–∫–µ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—è –≤–µ—Å–∞
    3. –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–±—Ä–æ –≤ MST, –µ—Å–ª–∏ –æ–Ω–æ –Ω–µ —Å–æ–∑–¥–∞—ë—Ç —Ü–∏–∫–ª
    4. –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º—Å—è, –∫–æ–≥–¥–∞ –¥–æ–±–∞–≤–∏–ª–∏ n-1 —Ä—ë–±–µ—Ä

    –¶–∏–∫–ª –æ–ø—Ä–µ–¥–µ–ª—è–µ–º —á–µ—Ä–µ–∑ Union-Find:
    - –ï—Å–ª–∏ –≤–µ—Ä—à–∏–Ω—ã —É–∂–µ –≤ –æ–¥–Ω–æ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ ‚Üí —Ä–µ–±—Ä–æ —Å–æ–∑–¥–∞—Å—Ç —Ü–∏–∫–ª
    - –ï—Å–ª–∏ –≤ —Ä–∞–∑–Ω—ã—Ö ‚Üí –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å, –æ–±—ä–µ–¥–∏–Ω—è–µ–º –º–Ω–æ–∂–µ—Å—Ç–≤–∞

    n: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–µ—Ä—à–∏–Ω
    edges: [(weight, u, v), ...]
    Returns: (mst_weight, mst_edges)
    """
    # –°–æ—Ä—Ç–∏—Ä—É–µ–º —Ä—ë–±—Ä–∞ –ø–æ –≤–µ—Å—É ‚Äî –∂–∞–¥–Ω–æ –±–µ—Ä—ë–º —Å–∞–º—ã–µ –ª—ë–≥–∫–∏–µ
    edges.sort()

    parent = list(range(n))
    rank = [0] * n

    def find(x: int) -> int:
        if parent[x] != x:
            parent[x] = find(parent[x])  # Path compression
        return parent[x]

    def union(x: int, y: int) -> bool:
        root_x, root_y = find(x), find(y)
        if root_x == root_y:
            return False  # –£–∂–µ –≤ –æ–¥–Ω–æ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ = –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–æ–∑–¥–∞—Å—Ç —Ü–∏–∫–ª

        # Union by rank
        if rank[root_x] < rank[root_y]:
            parent[root_x] = root_y
        elif rank[root_x] > rank[root_y]:
            parent[root_y] = root_x
        else:
            parent[root_y] = root_x
            rank[root_x] += 1
        return True

    mst_weight = 0
    mst_edges = []

    for weight, u, v in edges:
        # –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–±—Ä–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω–æ –Ω–µ —Å–æ–∑–¥–∞—ë—Ç —Ü–∏–∫–ª
        if union(u, v):
            mst_weight += weight
            mst_edges.append((u, v, weight))

            # MST –¥–ª—è n –≤–µ—Ä—à–∏–Ω –∏–º–µ–µ—Ç —Ä–æ–≤–Ω–æ n-1 —Ä—ë–±–µ—Ä
            if len(mst_edges) == n - 1:
                break

    return mst_weight, mst_edges
```

---

## –†–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—ë–Ω–Ω—ã–µ –æ—à–∏–±–∫–∏

### 1. –ó–∞–±—ã—Ç—å path compression

```kotlin
// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û: O(n) –Ω–∞ –∫–∞–∂–¥—ã–π find
fun find(x: Int): Int {
    var curr = x
    while (parent[curr] != curr) {
        curr = parent[curr]
    }
    return curr
}

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û: O(Œ±(n)) —Å path compression
fun find(x: Int): Int {
    if (parent[x] != x) {
        parent[x] = find(parent[x])  // –°–∂–∏–º–∞–µ–º –ø—É—Ç—å: –≤—Å–µ —É–∑–ª—ã ‚Üí –Ω–∞–ø—Ä—è–º—É—é –∫ –∫–æ—Ä–Ω—é
    }
    return parent[x]
}
```

### 2. Union –±–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π –∫–æ—Ä–µ–Ω—å

```kotlin
// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û: count —É–º–µ–Ω—å—à–∞–µ—Ç—Å—è –¥–∞–∂–µ –∫–æ–≥–¥–∞ —ç–ª–µ–º–µ–Ω—Ç—ã —É–∂–µ —Å–≤—è–∑–∞–Ω—ã
fun union(x: Int, y: Int) {
    parent[find(x)] = find(y)
    count--  // –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ! –ú–æ–∂–µ—Ç —É–º–µ–Ω—å—à–∏—Ç—å count –ª–∏—à–Ω–∏–π —Ä–∞–∑
}

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û: –ø—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ—Ä–Ω–∏ —Ä–∞–∑–Ω—ã–µ
fun union(x: Int, y: Int): Boolean {
    val rootX = find(x)
    val rootY = find(y)
    if (rootX == rootY) return false  // –£–∂–µ —Å–≤—è–∑–∞–Ω—ã ‚Äî –æ–±—ä–µ–¥–∏–Ω—è—Ç—å –Ω–µ—á–µ–≥–æ
    parent[rootX] = rootY
    count--
    return true
}
```

### 3. –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è

```kotlin
// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û: –≤—Å–µ parent = 0
val parent = IntArray(n)  // –≤—Å—ë –∑–∞–ø–æ–ª–Ω–µ–Ω–æ –Ω—É–ª—è–º–∏!

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û: parent[i] = i (–∫–∞–∂–¥—ã–π —Å–∞–º —Å–µ–±–µ –∫–æ—Ä–µ–Ω—å)
val parent = IntArray(n) { it }
```

### 4. –ó–∞–±—ã—Ç—å –ø—Ä–æ 0-based vs 1-based –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—é

```kotlin
// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û: –≤–µ—Ä—à–∏–Ω—ã –Ω—É–º–µ—Ä—É—é—Ç—Å—è —Å 1, –Ω–æ –º–∞—Å—Å–∏–≤ —Å 0
val uf = UnionFind(n)
uf.union(1, 2)  // IndexOutOfBounds!

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û: —É—á–∏—Ç—ã–≤–∞–µ–º –Ω—É–º–µ—Ä–∞—Ü–∏—é
val uf = UnionFind(n + 1)  // –î–ª—è –≤–µ—Ä—à–∏–Ω 1..n –Ω—É–∂–µ–Ω –º–∞—Å—Å–∏–≤ —Ä–∞–∑–º–µ—Ä–∞ n+1
```

### 5. –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤–º–µ—Å—Ç–æ –∫–æ—Ä–Ω–µ–π

```kotlin
// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û: —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å–∞–º–∏ —ç–ª–µ–º–µ–Ω—Ç—ã
fun connected(x: Int, y: Int) = parent[x] == parent[y]  // –ù–µ–≤–µ—Ä–Ω–æ!

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û: —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º –∫–æ—Ä–Ω–∏
fun connected(x: Int, y: Int) = find(x) == find(y)
```

---

## –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å

### Decision Tree

```
–ó–∞–¥–∞—á–∞ –ø—Ä–æ —Å–≤—è–∑–Ω–æ—Å—Ç—å/–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫—É?
‚îÇ
‚îú‚îÄ YES: Union-Find
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–≤—è–∑–Ω—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç?
‚îÇ   ‚îÇ   ‚îî‚îÄ Union-Find + count
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤—è–∑–Ω–æ—Å—Ç–∏ –¥–≤—É—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤?
‚îÇ   ‚îÇ   ‚îî‚îÄ find(x) == find(y)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ –î–µ—Ç–µ–∫—Ü–∏—è —Ü–∏–∫–ª–∞ –≤ undirected –≥—Ä–∞—Ñ–µ?
‚îÇ   ‚îÇ   ‚îî‚îÄ union –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç false = —Ü–∏–∫–ª
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ Minimum Spanning Tree?
‚îÇ   ‚îÇ   ‚îî‚îÄ Kruskal's —Å Union-Find
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç–∏?
‚îÇ       ‚îî‚îÄ Union-Find + group by root
‚îÇ
‚îî‚îÄ NO: –î—Ä—É–≥–æ–π –ø–∞—Ç—Ç–µ—Ä–Ω
    ‚îÇ
    ‚îú‚îÄ –ü–æ—Ä—è–¥–æ–∫ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π? ‚Üí Topological Sort
    ‚îú‚îÄ –ö—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å? ‚Üí BFS/Dijkstra
    ‚îî‚îÄ SCC? ‚Üí Tarjan's/Kosaraju's
```

### Union-Find vs BFS/DFS

| –ö—Ä–∏—Ç–µ—Ä–∏–π | Union-Find | BFS/DFS |
|----------|------------|---------|
| –ú–Ω–æ–∂–µ—Å—Ç–≤–æ –∑–∞–ø—Ä–æ—Å–æ–≤ | O(Œ±(n)) –∫–∞–∂–¥—ã–π | O(V+E) –∫–∞–∂–¥—ã–π |
| –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ —Ä—ë–±—Ä–∞ | –û—Ç–ª–∏—á–Ω–æ (—Ç–æ–ª—å–∫–æ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ) | –ü–µ—Ä–µ—Å—á—ë—Ç |
| –£–¥–∞–ª–µ–Ω–∏–µ —Ä—ë–±–µ—Ä | –ü–ª–æ—Ö–æ (–Ω—É–∂–µ–Ω rollback) | OK |
| –ü–∞–º—è—Ç—å | O(n) | O(V+E) |
| –ö—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å | –ù–µ—Ç | BFS |
| MST | Kruskal's | Prim's |

---

## –ü—Ä–∞–∫—Ç–∏–∫–∞

### –ö–æ–Ω—Ü–µ–ø—Ç—É–∞–ª—å–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã

1. **–ü–æ—á–µ–º—É Œ±(n) –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞?**
   - Œ±(n) ‚Äî –æ–±—Ä–∞—Ç–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ê–∫–∫–µ—Ä–º–∞–Ω–∞
   - Œ±(10^80) ‚âà 4 (–∞—Ç–æ–º–æ–≤ –≤–æ –í—Å–µ–ª–µ–Ω–Ω–æ–π < 10^80)
   - –î–ª—è –ª—é–±–æ–≥–æ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–≥–æ n, Œ±(n) ‚â§ 4

2. **–ú–æ–∂–Ω–æ –ª–∏ —É–¥–∞–ª—è—Ç—å —Ä—ë–±—Ä–∞ –∏–∑ Union-Find?**
   - –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π UF –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —É–¥–∞–ª–µ–Ω–∏–µ
   - –î–ª—è offline –∑–∞–¥–∞—á: –æ–±—Ä–∞–±–æ—Ç–∫–∞ –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
   - –î–ª—è online: Link-Cut Trees (—Å–ª–æ–∂–Ω–µ–µ)

3. **Union by Size vs Union by Rank?**
   - Size: —Ç–æ—á–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
   - Rank: –≤–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ –≤—ã—Å–æ—Ç—ã
   - –û–±–∞ –¥–∞—é—Ç O(Œ±(n)), rank —á—É—Ç—å –ø—Ä–æ—â–µ

### LeetCode –∑–∞–¥–∞—á–∏

| # | –ù–∞–∑–≤–∞–Ω–∏–µ | –°–ª–æ–∂–Ω–æ—Å—Ç—å | –ü–∞—Ç—Ç–µ—Ä–Ω | –ö–ª—é—á–µ–≤–∞—è –∏–¥–µ—è |
|---|----------|-----------|---------|---------------|
| 200 | Number of Islands | Medium | Grid UF | 2D ‚Üí 1D –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—è |
| 547 | Number of Provinces | Medium | Basic UF | –ú–∞—Ç—Ä–∏—Ü–∞ —Å–º–µ–∂–Ω–æ—Å—Ç–∏ |
| 684 | Redundant Connection | Medium | Cycle detection | union returns false |
| 721 | Accounts Merge | Medium | String UF | email ‚Üí index |
| 990 | Satisfiability of Equality | Medium | Variable UF | a==b ‚Üí union |
| 1319 | Number of Operations | Medium | Count components | n - uf.count |
| 128 | Longest Consecutive | Medium | Alternative | –¢–∞–∫–∂–µ –º–æ–∂–Ω–æ HashSet |

### –ü–æ—Ä—è–¥–æ–∫ –∏–∑—É—á–µ–Ω–∏—è

```
1. 547. Number of Provinces (Medium) ‚Äî –±–∞–∑–æ–≤—ã–π UF
2. 200. Number of Islands (Medium) ‚Äî 2D grid
3. 684. Redundant Connection (Medium) ‚Äî cycle detection
4. 990. Satisfiability of Equality (Medium) ‚Äî string mapping
5. 721. Accounts Merge (Medium) ‚Äî complex grouping
6. 1319. Number of Operations (Medium) ‚Äî component counting
```

---

## –°–≤—è–∑–∞–Ω–Ω—ã–µ —Ç–µ–º—ã

### Prerequisites (–∏–∑—É—á–∏—Ç—å –¥–æ)
- **Arrays** ‚Äî parent/rank –º–∞—Å—Å–∏–≤—ã
- **Recursion** ‚Äî –¥–ª—è path compression
- **Graph Basics** ‚Äî –∫–æ–Ω—Ü–µ–ø—Ü–∏—è —Å–≤—è–∑–Ω–æ—Å—Ç–∏

### Unlocks (–æ—Ç–∫—Ä–æ–µ—Ç –ø—É—Ç—å –∫)
- **Kruskal's MST** ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ—Ç Union-Find
- **Dynamic Connectivity** ‚Äî Online/Offline –∑–∞–¥–∞—á–∏
- **Percolation** ‚Äî –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–æ–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ

---

## –ú–∏—Ñ—ã –∏ –∑–∞–±–ª—É–∂–¥–µ–Ω–∏—è

| –ú–∏—Ñ | –†–µ–∞–ª—å–Ω–æ—Å—Ç—å |
|-----|-----------|
| "Union-Find —Å–ª–æ–∂–Ω—ã–π" | **–ü—Ä–æ—Å—Ç–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞!** –î–≤–∞ –º–∞—Å—Å–∏–≤–∞ (parent, rank), –¥–≤–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ (find, union). 15 —Å—Ç—Ä–æ–∫ –∫–æ–¥–∞ |
| "DFS/BFS –≤—Å–µ–≥–¥–∞ –ª—É—á—à–µ" | **Union-Find –±—ã—Å—Ç—Ä–µ–µ –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–π —Å–≤—è–∑–Ω–æ—Å—Ç–∏!** –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ä—ë–±–µ—Ä + –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤—è–∑–Ω–æ—Å—Ç–∏ = O(Œ±(n)) |
| "Path compression –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞" | **–ñ–µ–ª–∞—Ç–µ–ª—å–Ω–∞!** –ë–µ–∑ –Ω–µ—ë O(log n), —Å –Ω–µ–π O(Œ±(n)). –ù–∞ –ø—Ä–∞–∫—Ç–∏–∫–µ —Ä–∞–∑–Ω–∏—Ü–∞ –Ω–µ–±–æ–ª—å—à–∞—è –¥–ª—è –º–∞–ª–µ–Ω—å–∫–∏—Ö n |
| "Union by rank –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω" | **–ú–æ–∂–Ω–æ –±–µ–∑ –Ω–µ–≥–æ!** –ù–æ —Ö—É–¥—à–∏–π —Å–ª—É—á–∞–π O(n) –±–µ–∑ rank. –° rank ‚Äî –≥–∞—Ä–∞–Ω—Ç–∏—è O(log n) –¥–∞–∂–µ –±–µ–∑ path compression |
| "Œ±(n) ‚Äî —ç—Ç–æ O(log n)" | **Œ±(n) < 5 –¥–ª—è –ª—é–±–æ–≥–æ —Ä–µ–∞–ª—å–Ω–æ–≥–æ n!** –û–±—Ä–∞—Ç–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ê–∫–∫–µ—Ä–º–∞–Ω–∞ —Ä–∞—Å—Ç—ë—Ç –Ω–µ–≤–µ—Ä–æ—è—Ç–Ω–æ –º–µ–¥–ª–µ–Ω–Ω–æ. –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ O(1) |
| "Union-Find —Ç–æ–ª—å–∫–æ –¥–ª—è –≥—Ä–∞—Ñ–æ–≤" | **–®–∏—Ä–µ!** String grouping (Accounts Merge), equality equations, image segmentation. –í–µ–∑–¥–µ –≥–¥–µ –µ—Å—Ç—å "–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞" |
| "–ù—É–∂–Ω–æ –æ—Ç–¥–µ–ª—å–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã" | **–ù–µ—Ç!** Count —É–º–µ–Ω—å—à–∞–µ–º –ø—Ä–∏ –∫–∞–∂–¥–æ–º —É—Å–ø–µ—à–Ω–æ–º union. components = n - successful_unions |
| "2D grid –Ω–µ–ª—å–∑—è –≤ Union-Find" | **–ú–æ–∂–Ω–æ!** 2D ‚Üí 1D: index = row * cols + col. –°–æ—Å–µ–¥–∏: (r¬±1, c), (r, c¬±1) |

---

## CS-—Ñ—É–Ω–¥–∞–º–µ–Ω—Ç

| CS-–∫–æ–Ω—Ü–µ–ø—Ü–∏—è | –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤ Union-Find |
|--------------|-------------------------|
| **Disjoint Set** | –ú–Ω–æ–∂–µ—Å—Ç–≤–∞ –±–µ–∑ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π. –≠–ª–µ–º–µ–Ω—Ç –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç —Ä–æ–≤–Ω–æ –æ–¥–Ω–æ–º—É –º–Ω–æ–∂–µ—Å—Ç–≤—É. –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π merge –∏ query |
| **Path Compression** | –ü—Ä–∏ find(x) –≤—Å–µ —É–∑–ª—ã –Ω–∞ –ø—É—Ç–∏ —É–∫–∞–∑—ã–≤–∞—é—Ç –Ω–∞–ø—Ä—è–º—É—é –Ω–∞ root. –£–ø–ª–æ—â–∞–µ—Ç –¥–µ—Ä–µ–≤–æ, —É—Å–∫–æ—Ä—è–µ—Ç –±—É–¥—É—â–∏–µ find |
| **Union by Rank** | –ú–µ–Ω—å—à–µ–µ –¥–µ—Ä–µ–≤–æ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ—Ç—Å—è –∫ –±–æ–ª—å—à–µ–º—É. rank = –≤–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ –≤—ã—Å–æ—Ç—ã. –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –¥–ª–∏–Ω–Ω—ã–µ —Ü–µ–ø–æ—á–∫–∏ |
| **Inverse Ackermann Œ±(n)** | Œ±(n) < 5 –¥–ª—è n < 10^80. –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞. –†–µ–∑—É–ª—å—Ç–∞—Ç –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ path compression + union by rank |
| **Forest Representation** | Union-Find = –ª–µ—Å –¥–µ—Ä–µ–≤—å–µ–≤. –ö–∞–∂–¥–æ–µ –¥–µ—Ä–µ–≤–æ = –æ–¥–Ω–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞. Root = representative —ç–ª–µ–º–µ–Ω—Ç |
| **Cycle Detection** | –ï—Å–ª–∏ find(u) == find(v) –î–û union ‚Üí –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ä–µ–±—Ä–∞ —Å–æ–∑–¥–∞—ë—Ç —Ü–∏–∫–ª. –û—Å–Ω–æ–≤–∞ Kruskal MST |

---

## –ò—Å—Ç–æ—á–Ω–∏–∫–∏

| # | –ò—Å—Ç–æ—á–Ω–∏–∫ | –¢–∏–ø | –í–∫–ª–∞–¥ |
|---|----------|-----|-------|
| 1 | [GeeksforGeeks](https://www.geeksforgeeks.org/dsa/union-by-rank-and-path-compression-in-union-find-algorithm/) | Tutorial | –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ |
| 2 | [CP-Algorithms](https://cp-algorithms.com/data_structures/disjoint_set_union.html) | Reference | –§–æ—Ä–º–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ |
| 3 | [Princeton Algorithms](https://algs4.cs.princeton.edu/15uf/) | Course | –¢–µ–æ—Ä–∏—è –∏ –ø—Ä–∞–∫—Ç–∏–∫–∞ |
| 4 | [TakeUForward](https://takeuforward.org/data-structure/disjoint-set-union-by-rank-union-by-size-path-compression-g-46) | Tutorial | –í–∏–¥–µ–æ –æ–±—ä—è—Å–Ω–µ–Ω–∏–µ |

---

## –ö—É–¥–∞ –¥–∞–ª—å—à–µ

‚Üí **–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ:** Kruskal's MST Algorithm
‚Üí **–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞:** [[dfs-bfs-patterns]] ‚Äî –¥–ª—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–π —Å–≤—è–∑–Ω–æ—Å—Ç–∏
‚Üí **–í–µ—Ä–Ω—É—Ç—å—Å—è –∫:** [[patterns-overview|–û–±–∑–æ—Ä –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤]]

---

*–û–±–Ω–æ–≤–ª–µ–Ω–æ: 2026-01-08 ‚Äî –¥–æ–±–∞–≤–ª–µ–Ω—ã –ø–µ–¥–∞–≥–æ–≥–∏—á–µ—Å–∫–∏–µ —Å–µ–∫—Ü–∏–∏ (–∏–Ω—Ç—É–∏—Ü–∏—è Union-Find: –¥—Ä—É–∂–±–∞/–æ—Å—Ç—Ä–æ–≤–∞/—ç–ª–µ–∫—Ç—Ä–æ—Å–µ—Ç—å, 6 —Ç–∏–ø–∏—á–Ω—ã—Ö –æ—à–∏–±–æ–∫, 5 –º–µ–Ω—Ç–∞–ª—å–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π)*
