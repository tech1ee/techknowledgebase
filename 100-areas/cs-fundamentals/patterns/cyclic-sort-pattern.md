---
title: "Паттерн циклической сортировки (Cyclic Sort)"
created: 2026-02-08
modified: 2026-02-08
type: deep-dive
status: published
difficulty: intermediate
confidence: high
cs-foundations:
  - in-place-algorithms
  - index-value-mapping
  - permutation-cycles
  - array-manipulation
  - constant-space
prerequisites:
  - "[[arrays-strings]]"
  - "[[sorting-algorithms]]"
  - "[[big-o-complexity]]"
tags:
  - topic/cs-fundamentals
  - type/deep-dive
  - level/intermediate
  - pattern
  - interview
related:
  - "[[sorting-algorithms]]"
  - "[[arrays-strings]]"
  - "[[hash-tables]]"
---

# Cyclic Sort Pattern

## TL;DR

Cyclic Sort — паттерн для массивов с числами в диапазоне [1, n] или [0, n-1]. **Ключевая идея:** каждое число ставится на "своё место" (число i на индекс i-1). После сортировки легко найти пропущенные/дублирующиеся элементы. **Сложность: O(n) время, O(1) память.** Идеален для: Find Missing Number, Find All Duplicates, First Missing Positive. Это "скрытая жемчужина" — мало кто знает, но решает целый класс задач!

---

## Часть 1: Интуиция без кода

> **Цель:** понять ИДЕЮ Cyclic Sort до любого кода.

### Ты уже знаешь этот паттерн

Этот паттерн встречается в повседневной жизни:

| Ситуация | Как это работает | Паттерн |
|----------|------------------|---------|
| **Расстановка книг на полке** | Книга №5 должна стоять на 5-м месте | Index = Value |
| **Нумерация в гардеробе** | Номерок 42 → вешалка 42 | Direct mapping |
| **Рассадка по билетам** | Билет место 7 → садись на место 7 | In-place placement |
| **Сортировка карточек 1-10** | Карточка 3 идёт на 3-ю позицию | Cyclic swap |

### Аналогия 1: Гардероб в театре

```
Представь гардероб с вешалками 1-5. Пришли пальто с номерками.

Вешалки:    [ _ ][ _ ][ _ ][ _ ][ _ ]
Позиции:      1    2    3    4    5

Пальто пришли в случайном порядке:
  Номерок 3, Номерок 1, Номерок 4, Номерок 5, Номерок 2

ЗАДАЧА: Развесить каждое пальто на СВОЮ вешалку.

СПОСОБ 1 (наивный):
  Для каждого пальто: найди нужную вешалку, повесь
  Если вешалка занята — ??? сложно!

СПОСОБ 2 (Cyclic Sort):
  Берёшь первое пальто (номерок 3)
  Оно должно быть на вешалке 3
  На вешалке 3 сейчас пальто с номерком 4
  МЕНЯЕШЬ ИХ местами!
  Теперь у тебя в руках пальто 4, а 3 на месте.
  Пальто 4 должно быть на вешалке 4...
  Продолжаешь пока текущее пальто не на своём месте.

После прохода: все пальто на своих вешалках!
```

### Аналогия 2: Музыкальные стулья наоборот

```
Есть 5 стульев и 5 игроков с номерами 1-5.
Все сидят на случайных стульях.
Нужно: каждый игрок на стуле со своим номером.

Стулья:   [3] [1] [5] [2] [4]   (кто где сидит)
Позиции:   0   1   2   3   4

Шаг 1: Смотрим позицию 0. Там игрок 3.
       Игрок 3 должен быть на позиции 2 (3-1=2).
       Меняем местами: [5] [1] [3] [2] [4]
                        ↑       ↑

Шаг 2: Теперь на позиции 0 игрок 5.
       Игрок 5 должен быть на позиции 4.
       Меняем: [4] [1] [3] [2] [5]
                ↑               ↑

Шаг 3: На позиции 0 игрок 4.
       Игрок 4 должен быть на позиции 3.
       Меняем: [2] [1] [3] [4] [5]
                ↑           ↑

Шаг 4: На позиции 0 игрок 2.
       Игрок 2 должен быть на позиции 1.
       Меняем: [1] [2] [3] [4] [5]
                ↑   ↑

Шаг 5: На позиции 0 игрок 1. Он на месте! Переходим к позиции 1.
       Все уже на местах!

Результат: [1] [2] [3] [4] [5]
```

### Аналогия 3: Поиск пропавшего ученика

```
В классе 5 парт с номерами 1-5.
Пришли ученики: 1, 2, 4, 5 (ученик 3 отсутствует).

СПОСОБ 1 (HashSet):
  Запомни всех пришедших
  Проверь, кого нет
  → O(n) памяти

СПОСОБ 2 (Cyclic Sort):
  Рассади каждого на СВОЮ парту:
    Ученик 1 → парта 1
    Ученик 2 → парта 2
    Ученик 4 → парта 4
    Ученик 5 → парта 5

  Парты: [1][2][_][4][5]
              ↑
          Парта 3 пуста!

  Ответ: ученик 3 отсутствует.
  → O(1) памяти!
```

### Главный инсайт: Почему это работает?

```
┌─────────────────────────────────────────────────────────────────┐
│                    КЛЮЧЕВОЕ НАБЛЮДЕНИЕ                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  УСЛОВИЕ: Массив содержит числа от 1 до n (или 0 до n-1)       │
│                                                                 │
│  СВОЙСТВО: Каждое число i МОЖЕТ быть на позиции i-1            │
│            (или i для диапазона 0 до n-1)                       │
│                                                                 │
│  ИДЕЯ:                                                          │
│    Вместо сортировки сравнениями (O(n log n))                  │
│    Просто СТАВЬ каждое число на своё место! (O(n))             │
│                                                                 │
│  ПОСЛЕ СОРТИРОВКИ:                                              │
│    nums[i] == i + 1 для всех i                                  │
│    ИЛИ nums[i] != i + 1 → значит i+1 пропущено/дублировано     │
│                                                                 │
│  ПРИМЕР:                                                        │
│    Вход: [3, 1, 5, 4, 2]                                        │
│    После Cyclic Sort: [1, 2, 3, 4, 5]                          │
│                                                                 │
│    Вход: [3, 1, 5, 4, 1] (есть дубликат, нет 2)                │
│    После Cyclic Sort: [1, 1, 3, 4, 5]                          │
│                              ↑                                  │
│                      nums[1] != 2, значит 2 пропущено          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Часть 2: Почему Cyclic Sort бывает сложен?

> **Цель:** понять типичные трудности и как их избежать.

### Когда применим Cyclic Sort?

**Cyclic Sort применим ТОЛЬКО если:**

| Условие | Пример | Альтернатива если нет |
|---------|--------|----------------------|
| Числа в диапазоне [1, n] или [0, n-1] | [3, 1, 2, 5, 4] | Обычная сортировка |
| Известен размер диапазона | n = 5, числа 1-5 | HashSet |
| Нужно найти аномалии (missing/duplicate) | Кто пропущен? | HashSet |
| Требуется O(1) память | Embedded systems | Если O(n) ok — HashSet |

### Типичные трудности

#### 1. Когда менять, а когда идти дальше?

```kotlin
// ЛОГИКА:
while (nums[i] != nums[correctIndex]) {
    swap(nums, i, correctIndex)  // Ставим на место
}
// Только когда текущий элемент на месте ИЛИ дубликат — идём дальше

// ПРИМЕР: [3, 1, 2]
// i=0: nums[0]=3, correctIndex=2
//      nums[0] != nums[2] (3 != 2), SWAP → [2, 1, 3]
// i=0: nums[0]=2, correctIndex=1
//      nums[0] != nums[1] (2 != 1), SWAP → [1, 2, 3]
// i=0: nums[0]=1, correctIndex=0
//      nums[0] == nums[0], STOP внутренний цикл, i++
```

#### 2. Диапазон [1, n] vs [0, n-1]

```kotlin
// Диапазон [1, n]:
// Число num должно быть на индексе num - 1
val correctIndex = nums[i] - 1

// Диапазон [0, n-1]:
// Число num должно быть на индексе num
val correctIndex = nums[i]

// ОШИБКА — перепутать:
val correctIndex = nums[i]  // Для [1,n] это НЕПРАВИЛЬНО!
// nums[i] = 5, correctIndex = 5, но массив длины 5 → IndexOutOfBounds!
```

#### 3. Обработка дубликатов

```kotlin
// БЕЗ проверки на дубликаты — бесконечный цикл!
while (nums[i] != i + 1) {
    swap(nums, i, nums[i] - 1)  // Если дубликат — вечный swap!
}

// ПРАВИЛЬНО — проверяй, не дубликат ли:
while (nums[i] != i + 1 && nums[i] != nums[nums[i] - 1]) {
    swap(nums, i, nums[i] - 1)
}
// Если nums[i] == nums[correctIndex] — это дубликат, пропускаем
```

#### 4. Числа вне диапазона

```kotlin
// First Missing Positive: числа могут быть отрицательными или > n

// ОШИБКА:
val correctIndex = nums[i] - 1  // Для -5: correctIndex = -6 → crash!

// ПРАВИЛЬНО — проверяй диапазон:
if (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {
    swap(nums, i, nums[i] - 1)
}
```

### Что отличает новичка от эксперта

| Новичок | Эксперт |
|---------|---------|
| Не проверяет дубликаты | Сравнивает nums[i] с nums[correctIndex] |
| Путает индексацию [1,n] и [0,n-1] | Явно пишет correctIndex = nums[i] - 1 |
| Не обрабатывает числа вне диапазона | Проверяет границы перед swap |
| Использует HashSet | Знает, что O(1) памяти возможно |

---

## Часть 3: Ментальные модели для Cyclic Sort

> **Цель:** дать разные способы ДУМАТЬ о паттерне.

### Модель 1: "Прямое отображение"

**Идея:** Число i должно быть на индексе i-1. Нет сортировки сравнениями!

```
┌─────────────────────────────────────────────────────────────────┐
│                    ПРЯМОЕ ОТОБРАЖЕНИЕ                           │
│                                                                 │
│   Число:   1  2  3  4  5                                        │
│            ↓  ↓  ↓  ↓  ↓                                        │
│   Индекс:  0  1  2  3  4                                        │
│                                                                 │
│   Формула: correctIndex = value - 1                             │
│                                                                 │
│   Вход:  [3, 1, 5, 4, 2]                                        │
│           ↓  ↓  ↓  ↓  ↓                                         │
│          [2][0][4][3][1]  ← куда должно попасть                 │
│                                                                 │
│   Просто ПЕРЕСТАВЬ каждый элемент на своё место!               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Модель 2: "Цепочка перестановок"

**Идея:** Один swap может запустить цепочку — продолжай пока не замкнётся.

```
┌─────────────────────────────────────────────────────────────────┐
│                    ЦЕПОЧКА ПЕРЕСТАНОВОК                         │
│                                                                 │
│   Вход: [3, 2, 1]                                               │
│                                                                 │
│   i=0: nums[0]=3, должен быть на индексе 2                     │
│         [3, 2, 1] → swap(0, 2) → [1, 2, 3]                     │
│          ↑     ↑                                                │
│                                                                 │
│   i=0: nums[0]=1, должен быть на индексе 0 ✓ УЖЕ НА МЕСТЕ!     │
│                                                                 │
│   Переходим к i=1, i=2 — всё на местах.                        │
│                                                                 │
│   ПРИМЕР С ЦЕПОЧКОЙ: [5, 4, 3, 2, 1]                           │
│                                                                 │
│   i=0: 5→idx4, swap → [1, 4, 3, 2, 5]                          │
│   i=0: 1→idx0 ✓                                                 │
│   i=1: 4→idx3, swap → [1, 2, 3, 4, 5]                          │
│   i=1: 2→idx1 ✓                                                 │
│   i=2: 3→idx2 ✓                                                 │
│   i=3: 4→idx3 ✓                                                 │
│   i=4: 5→idx4 ✓                                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Модель 3: "Поиск аномалий"

**Идея:** После сортировки любая "неправильная" позиция = аномалия.

```
┌─────────────────────────────────────────────────────────────────┐
│                      ПОИСК АНОМАЛИЙ                             │
│                                                                 │
│   После Cyclic Sort: nums[i] должен == i + 1                    │
│                                                                 │
│   ПРИМЕР: Найти пропущенное число                               │
│   Вход: [4, 3, 2, 6, 1] (n=5, но есть 6, нет 5)                │
│                                                                 │
│   После Cyclic Sort: [1, 2, 3, 4, 6]                           │
│                                    ↑                            │
│                        nums[4]=6, но должно быть 5             │
│                                                                 │
│   Аномалия на индексе 4 → пропущено число 5                    │
│                                                                 │
│   ПРИМЕР: Найти дубликат                                        │
│   Вход: [3, 1, 3, 2] (есть два 3, нет 4)                       │
│                                                                 │
│   После Cyclic Sort: [1, 2, 3, 3]                              │
│                              ↑                                  │
│                   nums[3]=3, но должно быть 4                   │
│                                                                 │
│   Аномалия: 3 повторяется, 4 пропущено                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Зачем это нужно?

**Реальная проблема:**

У тебя массив из миллиона ID пользователей (от 1 до 1000000). Нужно найти, какие ID не используются. Памяти мало — нельзя создать HashSet.

- **HashSet:** O(n) памяти = 4+ MB
- **Cyclic Sort:** O(1) памяти = 8 байт!

**Где используется:**

| Область | Применение | Пример |
|---------|------------|--------|
| **Базы данных** | Проверка последовательности ID | Gap detection в auto-increment |
| **Файловые системы** | Поиск свободных блоков | Bitmap альтернатива |
| **Сети** | Отслеживание packet sequence | TCP packet ordering |
| **Embedded** | Ресурсы ограничены | IoT устройства |
| **Тестирование** | Проверка покрытия тест-кейсов | Какие кейсы пропущены |

**Статистика:**
- Входит в "Grokking the Coding Interview" как Pattern #5
- LeetCode: 15+ задач с этим паттерном
- "Скрытая жемчужина" — многие не знают, но очень полезен

---

## Prerequisites (Что нужно знать)

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **Массивы** | Основная структура | [[arrays-strings]] |
| **In-place алгоритмы** | Концепция модификации без доп. памяти | [[sorting-algorithms]] |
| **Big O нотация** | Понимание O(1) space | [[big-o-complexity]] |
| **Swap операция** | Базовая операция паттерна | Основы программирования |

---

## Что это такое?

### Объяснение для 5-летнего

Представь, что у тебя 5 игрушечных машинок с номерами 1, 2, 3, 4, 5. Но они лежат не по порядку в коробке с ячейками.

Твоя задача: положить каждую машинку в ячейку с её номером!

```
Ячейки:    [_1_][_2_][_3_][_4_][_5_]

Машинки лежат: [3][1][5][4][2]

Берёшь машинку 3 из ячейки 1.
Смотришь: ячейка 3 занята машинкой 5.
Меняешь их местами!

[5][1][3][4][2]

Теперь в руках машинка 5.
Ячейка 5 занята машинкой 2.
Меняешь!

[2][1][3][4][5]

В руках машинка 2.
Ячейка 2 занята машинкой 1.
Меняешь!

[1][2][3][4][5]

Готово! Все машинки на своих местах!
```

### Формальное определение

**Cyclic Sort** — алгоритм сортировки для массивов с элементами из известного ограниченного диапазона [1, n] или [0, n-1], который размещает каждый элемент на его "правильную" позицию за один проход, достигая O(n) времени и O(1) памяти.

**Ключевые свойства:**
- **Ограниченный диапазон:** элементы от 1 до n (или от 0 до n-1)
- **Прямое отображение:** число i должно быть на индексе i-1
- **In-place:** не требует дополнительной памяти
- **Линейное время:** O(n) несмотря на вложенный while

**Варианты задач:**

```
1. Cyclic Sort (базовый)
   Вход: массив [1..n] в случайном порядке
   Выход: отсортированный массив

2. Find Missing Number
   Вход: массив [0..n], одно число пропущено
   Выход: пропущенное число

3. Find All Missing Numbers
   Вход: массив [1..n], возможны дубликаты
   Выход: все пропущенные числа

4. Find Duplicate
   Вход: массив [1..n], одно число дублируется
   Выход: дублирующееся число

5. Find All Duplicates
   Вход: массив [1..n], некоторые дублируются
   Выход: все дублирующиеся числа

6. First Missing Positive
   Вход: любой массив целых чисел
   Выход: первое пропущенное положительное число
```

---

## Терминология

| Термин | Определение | Пример |
|--------|-------------|--------|
| **Correct Position** | Позиция, где должен быть элемент | Для числа 5 → индекс 4 |
| **Cyclic Swap** | Обмен элемента с элементом на его правильной позиции | swap(i, nums[i]-1) |
| **Anomaly** | Элемент не на своём месте после сортировки | nums[i] != i + 1 |
| **In-place** | Без дополнительной памяти | O(1) space |
| **Range** | Диапазон возможных значений | [1, n] или [0, n-1] |
| **Missing** | Число из диапазона, отсутствующее в массиве | [1,3,3] → missing 2 |
| **Duplicate** | Число, встречающееся более одного раза | [1,2,2] → duplicate 2 |

---

## Как это работает?

### Задача 1: Базовый Cyclic Sort

```
Вход: [3, 1, 5, 4, 2]
Выход: [1, 2, 3, 4, 5]

Алгоритм:
  Для каждой позиции i:
    Пока nums[i] не на своём месте:
      Поменяй nums[i] с элементом на его правильной позиции

Пошаговая симуляция:

i = 0:
  nums = [3, 1, 5, 4, 2]
  nums[0] = 3, correct position = 2
  nums[0] != nums[2]? 3 != 5 → SWAP
  nums = [5, 1, 3, 4, 2]

  nums[0] = 5, correct position = 4
  nums[0] != nums[4]? 5 != 2 → SWAP
  nums = [2, 1, 3, 4, 5]

  nums[0] = 2, correct position = 1
  nums[0] != nums[1]? 2 != 1 → SWAP
  nums = [1, 2, 3, 4, 5]

  nums[0] = 1, correct position = 0
  nums[0] == i + 1? 1 == 1 → на месте, i++

i = 1, 2, 3, 4: все элементы уже на местах

Результат: [1, 2, 3, 4, 5]
```

### Задача 2: Find Missing Number

```
Вход: [3, 0, 1] (диапазон [0, n], n=3, пропущено одно)
Выход: 2

Алгоритм:
  1. Cyclic Sort (для [0, n-1] диапазона)
  2. Найди позицию, где nums[i] != i

Пошаговая симуляция:

i = 0:
  nums = [3, 0, 1]
  nums[0] = 3, но 3 >= n → пропускаем (вне диапазона для индексации)
  i++

i = 1:
  nums[1] = 0, correct position = 0
  nums[1] != nums[0]? 0 != 3 → SWAP
  nums = [0, 3, 1]

  nums[1] = 3 >= n → пропускаем
  i++

i = 2:
  nums[2] = 1, correct position = 1
  nums[2] != nums[1]? 1 != 3 → SWAP
  nums = [0, 1, 3]

  nums[2] = 3 >= n → пропускаем
  i++

После сортировки: [0, 1, 3]

Проверяем: nums[i] == i?
  nums[0] = 0 ✓
  nums[1] = 1 ✓
  nums[2] = 3 ≠ 2 → ПРОПУЩЕНО 2!

Ответ: 2
```

### Задача 3: Find All Duplicates

```
Вход: [4, 3, 2, 7, 8, 2, 3, 1] (диапазон [1, n], n=8)
Выход: [2, 3] (дубликаты)

Алгоритм:
  1. Cyclic Sort (с проверкой на дубликаты)
  2. Найди позиции, где nums[i] != i + 1

После Cyclic Sort: [1, 2, 3, 4, 3, 2, 7, 8]
                    ↑  ↑  ↑  ↑  ↑  ↑  ↑  ↑
                    1  2  3  4  ?  ?  7  8

Проверяем:
  nums[4] = 3 ≠ 5 → 3 дубликат
  nums[5] = 2 ≠ 6 → 2 дубликат

Ответ: [2, 3]
```

### Задача 4: First Missing Positive

```
Вход: [3, 4, -1, 1] (любые числа!)
Выход: 2 (первое пропущенное положительное)

Особенность: числа могут быть отрицательными или > n

Алгоритм:
  1. Cyclic Sort, но игнорируем числа <= 0 или > n
  2. Найди первую позицию, где nums[i] != i + 1

Пошаговая симуляция:

n = 4
i = 0:
  nums = [3, 4, -1, 1]
  nums[0] = 3, correct = 2
  3 > 0 && 3 <= 4 && nums[0] != nums[2]? → SWAP
  nums = [-1, 4, 3, 1]

  nums[0] = -1 <= 0 → пропускаем
  i++

i = 1:
  nums[1] = 4, correct = 3
  4 > 0 && 4 <= 4 && nums[1] != nums[3]? → SWAP
  nums = [-1, 1, 3, 4]

  nums[1] = 1, correct = 0
  1 > 0 && 1 <= 4 && nums[1] != nums[0]? → SWAP
  nums = [1, -1, 3, 4]

  nums[1] = -1 <= 0 → пропускаем
  i++

i = 2, 3: уже на местах

После сортировки: [1, -1, 3, 4]

Проверяем nums[i] == i + 1:
  nums[0] = 1 ✓
  nums[1] = -1 ≠ 2 → ПЕРВОЕ ПРОПУЩЕННОЕ = 2!

Ответ: 2
```

---

## Сложность операций

| Задача | Время | Память | Примечание |
|--------|-------|--------|------------|
| Cyclic Sort | O(n) | O(1) | Каждый элемент перемещается max 1 раз |
| Find Missing Number | O(n) | O(1) | Sort + scan |
| Find All Missing | O(n) | O(1)* | *Не считая output |
| Find Duplicate | O(n) | O(1) | Sort + scan |
| Find All Duplicates | O(n) | O(1)* | *Не считая output |
| First Missing Positive | O(n) | O(1) | Hardest! |

**Почему O(n), если есть вложенный while?**

```
Каждый элемент перемещается МАКСИМУМ ОДИН РАЗ!

Вход: [5, 4, 3, 2, 1]

Элемент 5: позиция 0 → 4 (1 перемещение)
Элемент 1: позиция 4 → 0 (1 перемещение)
Элемент 4: позиция 1 → 3 (1 перемещение)
Элемент 2: позиция 3 → 1 (1 перемещение)
Элемент 3: уже на месте (0 перемещений)

Всего: n-1 swap'ов для n элементов = O(n)

Даже если внутренний while выполняется несколько раз за одну итерацию,
СУММАРНОЕ количество swap'ов = n-1 максимум.
```

---

## Реализация

### Kotlin

```kotlin
// ═══════════════════════════════════════════════════════════════════════════
// БАЗОВЫЙ CYCLIC SORT
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Сортирует массив с числами [1, n] за O(n) времени и O(1) памяти.
 *
 * ИДЕЯ: Число i должно быть на индексе i-1.
 *       Меняем местами пока не окажется на своём месте.
 */
fun cyclicSort(nums: IntArray) {
    var i = 0
    while (i < nums.size) {
        val correctIndex = nums[i] - 1  // Число 3 → индекс 2

        if (nums[i] != nums[correctIndex]) {
            // Элемент не на месте — меняем
            nums.swap(i, correctIndex)
        } else {
            // Элемент на месте — идём дальше
            i++
        }
    }
}

private fun IntArray.swap(i: Int, j: Int) {
    val temp = this[i]
    this[i] = this[j]
    this[j] = temp
}

// ═══════════════════════════════════════════════════════════════════════════
// FIND MISSING NUMBER (LeetCode 268)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Находит пропущенное число в массиве [0, n].
 *
 * ПРИМЕР: [3, 0, 1] → 2 пропущено
 *
 * ИДЕЯ: Cyclic Sort для диапазона [0, n-1], затем найди где nums[i] != i.
 */
fun missingNumber(nums: IntArray): Int {
    var i = 0
    val n = nums.size

    // Cyclic Sort: число num должно быть на индексе num
    while (i < n) {
        val num = nums[i]
        if (num < n && nums[num] != num) {
            nums.swap(i, num)
        } else {
            i++
        }
    }

    // Найди пропущенное
    for (j in 0 until n) {
        if (nums[j] != j) return j
    }

    return n  // Пропущено n
}

// ═══════════════════════════════════════════════════════════════════════════
// FIND ALL MISSING NUMBERS (LeetCode 448)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Находит все пропущенные числа в массиве [1, n] с дубликатами.
 *
 * ПРИМЕР: [4, 3, 2, 7, 8, 2, 3, 1] → [5, 6]
 */
fun findDisappearedNumbers(nums: IntArray): List<Int> {
    var i = 0

    // Cyclic Sort с обработкой дубликатов
    while (i < nums.size) {
        val correctIndex = nums[i] - 1

        if (nums[i] != nums[correctIndex]) {
            nums.swap(i, correctIndex)
        } else {
            i++
        }
    }

    // Собираем пропущенные
    val result = mutableListOf<Int>()
    for (j in nums.indices) {
        if (nums[j] != j + 1) {
            result.add(j + 1)
        }
    }

    return result
}

// ═══════════════════════════════════════════════════════════════════════════
// FIND DUPLICATE (LeetCode 287)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Находит дублирующееся число в массиве [1, n] с n+1 элементами.
 *
 * ПРИМЕР: [1, 3, 4, 2, 2] → 2
 *
 * NOTE: Эту задачу также можно решить через Fast/Slow Pointers!
 */
fun findDuplicate(nums: IntArray): Int {
    var i = 0

    while (i < nums.size) {
        if (nums[i] != i + 1) {
            val correctIndex = nums[i] - 1

            if (nums[i] != nums[correctIndex]) {
                nums.swap(i, correctIndex)
            } else {
                // nums[i] == nums[correctIndex] — нашли дубликат!
                return nums[i]
            }
        } else {
            i++
        }
    }

    return -1
}

// ═══════════════════════════════════════════════════════════════════════════
// FIND ALL DUPLICATES (LeetCode 442)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Находит все дубликаты в массиве [1, n].
 *
 * ПРИМЕР: [4, 3, 2, 7, 8, 2, 3, 1] → [2, 3]
 */
fun findDuplicates(nums: IntArray): List<Int> {
    var i = 0

    // Cyclic Sort
    while (i < nums.size) {
        val correctIndex = nums[i] - 1

        if (nums[i] != nums[correctIndex]) {
            nums.swap(i, correctIndex)
        } else {
            i++
        }
    }

    // Собираем дубликаты
    val result = mutableListOf<Int>()
    for (j in nums.indices) {
        if (nums[j] != j + 1) {
            result.add(nums[j])
        }
    }

    return result
}

// ═══════════════════════════════════════════════════════════════════════════
// FIRST MISSING POSITIVE (LeetCode 41) — HARD!
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Находит первое пропущенное положительное число.
 *
 * ПРИМЕР: [3, 4, -1, 1] → 2
 *         [7, 8, 9, 11, 12] → 1
 *
 * КЛЮЧ: Игнорируем числа <= 0 и > n, применяем Cyclic Sort к остальным.
 */
fun firstMissingPositive(nums: IntArray): Int {
    val n = nums.size
    var i = 0

    while (i < n) {
        val num = nums[i]
        val correctIndex = num - 1

        // Проверяем: число в диапазоне [1, n] и не на своём месте?
        if (num in 1..n && nums[correctIndex] != num) {
            nums.swap(i, correctIndex)
        } else {
            i++
        }
    }

    // Находим первое несоответствие
    for (j in 0 until n) {
        if (nums[j] != j + 1) {
            return j + 1
        }
    }

    return n + 1  // Все [1, n] на местах → ответ n+1
}

// ═══════════════════════════════════════════════════════════════════════════
// FIND CORRUPT PAIR (Missing & Duplicate)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Находит пару (дубликат, пропущенное) в массиве [1, n].
 *
 * ПРИМЕР: [3, 1, 2, 5, 2] → [2, 4] (2 дубликат, 4 пропущено)
 */
fun findCorruptPair(nums: IntArray): IntArray {
    var i = 0

    while (i < nums.size) {
        val correctIndex = nums[i] - 1

        if (nums[i] != nums[correctIndex]) {
            nums.swap(i, correctIndex)
        } else {
            i++
        }
    }

    // Найди аномалию
    for (j in nums.indices) {
        if (nums[j] != j + 1) {
            return intArrayOf(nums[j], j + 1)  // [duplicate, missing]
        }
    }

    return intArrayOf(-1, -1)
}
```

### Python

```python
from typing import List

# ═══════════════════════════════════════════════════════════════════════════
# БАЗОВЫЙ CYCLIC SORT
# ═══════════════════════════════════════════════════════════════════════════

def cyclic_sort(nums: List[int]) -> None:
    """
    Сортирует массив с числами [1, n] за O(n) времени, O(1) памяти.
    """
    i = 0
    while i < len(nums):
        correct_index = nums[i] - 1

        if nums[i] != nums[correct_index]:
            nums[i], nums[correct_index] = nums[correct_index], nums[i]
        else:
            i += 1


# ═══════════════════════════════════════════════════════════════════════════
# FIND MISSING NUMBER (LeetCode 268)
# ═══════════════════════════════════════════════════════════════════════════

def missing_number(nums: List[int]) -> int:
    """
    Находит пропущенное число в массиве [0, n].

    Пример: [3, 0, 1] → 2
    """
    i, n = 0, len(nums)

    while i < n:
        num = nums[i]
        if num < n and nums[num] != num:
            nums[i], nums[num] = nums[num], nums[i]
        else:
            i += 1

    for j in range(n):
        if nums[j] != j:
            return j

    return n


# ═══════════════════════════════════════════════════════════════════════════
# FIND ALL MISSING NUMBERS (LeetCode 448)
# ═══════════════════════════════════════════════════════════════════════════

def find_disappeared_numbers(nums: List[int]) -> List[int]:
    """
    Находит все пропущенные числа в массиве [1, n].

    Пример: [4, 3, 2, 7, 8, 2, 3, 1] → [5, 6]
    """
    i = 0
    while i < len(nums):
        correct_index = nums[i] - 1

        if nums[i] != nums[correct_index]:
            nums[i], nums[correct_index] = nums[correct_index], nums[i]
        else:
            i += 1

    return [j + 1 for j in range(len(nums)) if nums[j] != j + 1]


# ═══════════════════════════════════════════════════════════════════════════
# FIND ALL DUPLICATES (LeetCode 442)
# ═══════════════════════════════════════════════════════════════════════════

def find_duplicates(nums: List[int]) -> List[int]:
    """
    Находит все дубликаты в массиве [1, n].

    Пример: [4, 3, 2, 7, 8, 2, 3, 1] → [2, 3]
    """
    i = 0
    while i < len(nums):
        correct_index = nums[i] - 1

        if nums[i] != nums[correct_index]:
            nums[i], nums[correct_index] = nums[correct_index], nums[i]
        else:
            i += 1

    return [nums[j] for j in range(len(nums)) if nums[j] != j + 1]


# ═══════════════════════════════════════════════════════════════════════════
# FIRST MISSING POSITIVE (LeetCode 41)
# ═══════════════════════════════════════════════════════════════════════════

def first_missing_positive(nums: List[int]) -> int:
    """
    Находит первое пропущенное положительное число.

    Пример: [3, 4, -1, 1] → 2
    """
    n = len(nums)
    i = 0

    while i < n:
        num = nums[i]
        correct_index = num - 1

        if 1 <= num <= n and nums[correct_index] != num:
            nums[i], nums[correct_index] = nums[correct_index], nums[i]
        else:
            i += 1

    for j in range(n):
        if nums[j] != j + 1:
            return j + 1

    return n + 1


# ═══════════════════════════════════════════════════════════════════════════
# FIND CORRUPT PAIR
# ═══════════════════════════════════════════════════════════════════════════

def find_corrupt_pair(nums: List[int]) -> List[int]:
    """
    Находит [дубликат, пропущенное] в массиве [1, n].

    Пример: [3, 1, 2, 5, 2] → [2, 4]
    """
    i = 0
    while i < len(nums):
        correct_index = nums[i] - 1

        if nums[i] != nums[correct_index]:
            nums[i], nums[correct_index] = nums[correct_index], nums[i]
        else:
            i += 1

    for j in range(len(nums)):
        if nums[j] != j + 1:
            return [nums[j], j + 1]

    return [-1, -1]
```

---

## Когда применять Cyclic Sort?

### Сигналы для распознавания

```
Используй Cyclic Sort, если:

✅ Массив содержит числа в диапазоне [1, n] или [0, n-1]
✅ "Найти пропущенное число"
✅ "Найти дубликат"
✅ "Найти все пропущенные/дубликаты"
✅ "First missing positive"
✅ Требуется O(1) дополнительной памяти
✅ Можно модифицировать входной массив

НЕ используй Cyclic Sort, если:

❌ Числа вне диапазона (негативные, > n) — используй HashSet
❌ Нельзя модифицировать массив — используй HashSet или битовую маску
❌ Диапазон неизвестен — используй сортировку или HashMap
❌ Нужна стабильная сортировка — Cyclic Sort не стабильна
```

### Шаблон решения

```
1. ОПРЕДЕЛИ диапазон:
   [1, n] → correctIndex = nums[i] - 1
   [0, n-1] → correctIndex = nums[i]

2. CYCLIC SORT:
   i = 0
   while i < n:
       correctIndex = nums[i] - 1  (или nums[i] для [0, n-1])

       if nums[i] в диапазоне AND nums[i] != nums[correctIndex]:
           swap(i, correctIndex)
       else:
           i++

3. НАЙДИ аномалии:
   for j in 0..n:
       if nums[j] != j + 1:  (или j для [0, n-1])
           // j+1 пропущено, nums[j] дубликат
```

---

## Частые ошибки и как их избежать

### Ошибка 1: Бесконечный цикл из-за дубликатов

```kotlin
// НЕПРАВИЛЬНО:
while (nums[i] != i + 1) {
    swap(i, nums[i] - 1)  // Бесконечный цикл если дубликат!
}

// ПРАВИЛЬНО:
while (nums[i] != i + 1 && nums[i] != nums[nums[i] - 1]) {
    swap(i, nums[i] - 1)
}
```

### Ошибка 2: Перепутать диапазон

```kotlin
// Для [1, n]:
val correctIndex = nums[i] - 1

// Для [0, n-1]:
val correctIndex = nums[i]

// НЕ перепутай! Для [1, n] без -1 будет IndexOutOfBounds.
```

### Ошибка 3: Не проверять границы для First Missing Positive

```kotlin
// НЕПРАВИЛЬНО:
val correctIndex = nums[i] - 1  // Для nums[i] = -5: correctIndex = -6!

// ПРАВИЛЬНО:
if (nums[i] in 1..n && nums[nums[i] - 1] != nums[i]) {
    swap(i, nums[i] - 1)
}
```

---

## Связанные паттерны

| Паттерн | Связь | Когда использовать вместо Cyclic Sort |
|---------|-------|--------------------------------------|
| [[hash-tables]] | Альтернатива для поиска | Когда O(n) память допустима |
| [[fast-slow-pointers-pattern]] | Альтернатива для Find Duplicate | Когда нельзя модифицировать массив |
| [[sorting-algorithms]] | Общая сортировка | Когда диапазон неизвестен |
| [[bit-manipulation]] | Битовые операции | XOR для missing number |

---

## Практические задачи

### Уровень: Лёгкий

| # | Задача | Ключевая идея |
|---|--------|---------------|
| 268 | [Missing Number](https://leetcode.com/problems/missing-number/) | Базовый Cyclic Sort [0, n] |
| 448 | [Find All Numbers Disappeared](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/) | Sort + scan |

### Уровень: Средний

| # | Задача | Ключевая идея |
|---|--------|---------------|
| 287 | [Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/) | Cyclic Sort или Fast/Slow |
| 442 | [Find All Duplicates](https://leetcode.com/problems/find-all-duplicates-in-an-array/) | Sort + collect duplicates |
| 645 | [Set Mismatch](https://leetcode.com/problems/set-mismatch/) | Find [duplicate, missing] |

### Уровень: Сложный

| # | Задача | Ключевая идея |
|---|--------|---------------|
| 41 | [First Missing Positive](https://leetcode.com/problems/first-missing-positive/) | Ignore out-of-range |
| 765 | [Couples Holding Hands](https://leetcode.com/problems/couples-holding-hands/) | Cyclic sort пар |

---

## Мифы и реальность

### Миф 1: "Cyclic Sort — это O(n²) из-за вложенного while"

**Реальность:**
Каждый элемент перемещается МАКСИМУМ 1 раз.
Суммарно n-1 swap → O(n).

### Миф 2: "HashSet проще и так же эффективен"

**Реальность:**
- HashSet: O(n) время, O(n) память
- Cyclic Sort: O(n) время, O(1) память

Для embedded систем или больших данных это КРИТИЧНО.

### Миф 3: "Cyclic Sort только для сортировки"

**Реальность:**
Основное применение — НЕ сортировка, а поиск аномалий:
- Missing numbers
- Duplicates
- First missing positive

### Миф 4: "Всегда можно заменить на XOR"

**Реальность:**
XOR работает только для:
- ОДНОГО пропущенного числа
- Без дубликатов

Cyclic Sort работает для ВСЕХ вариантов.

---

## Ключевые выводы

```
┌─────────────────────────────────────────────────────────────────┐
│                     CYCLIC SORT PATTERN                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  КОГДА:                                                         │
│  • Массив с числами [1, n] или [0, n-1]                         │
│  • Найти пропущенные / дубликаты                                │
│  • Требуется O(1) память                                        │
│                                                                 │
│  КАК:                                                           │
│  • Число i ставим на индекс i-1                                 │
│  • Меняем пока nums[i] != nums[correctIndex]                    │
│  • После сортировки: nums[i] != i+1 → аномалия                  │
│                                                                 │
│  СЛОЖНОСТЬ:                                                     │
│  • Время: O(n) — каждый элемент перемещается max 1 раз          │
│  • Память: O(1) — in-place                                      │
│                                                                 │
│  КЛЮЧЕВОЕ УСЛОВИЕ:                                              │
│  • Проверяй nums[i] != nums[correctIndex] чтобы избежать        │
│    бесконечного цикла при дубликатах!                           │
│                                                                 │
│  ПРОВЕРКА ПОНИМАНИЯ:                                            │
│  • Почему O(n), если есть вложенный while?                      │
│  • Как обработать числа вне диапазона?                          │
│  • Чем отличается [1,n] от [0,n-1]?                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```
