# Sliding Window Pattern

---
title: "Sliding Window Pattern"
created: 2025-12-29
updated: 2026-01-06
type: deep-dive
status: complete
difficulty: intermediate
confidence: high
cs-foundations:
  - amortized-analysis
  - incremental-computation
  - deque-data-structure
  - space-time-tradeoff
  - invariant-maintenance
  - monotonic-optimization
prerequisites:
  - "[[arrays-strings]]"
  - "[[hash-tables]]"
  - "[[two-pointers-pattern]]"
related:
  - "[[two-pointers-pattern]]"
  - "[[prefix-sum-pattern]]"
  - "[[monotonic-stack-pattern]]"
tags:
  - pattern
  - sliding-window
  - fixed-size
  - variable-size
  - monotonic-deque
  - interview
---

## TL;DR

Sliding Window поддерживает "окно" — непрерывный подмассив/подстроку — и сдвигает его по данным, избегая повторных вычислений. **Снижает O(n²) до O(n)**. Два типа: **Fixed-size** (сумма/макс k элементов) и **Variable-size** (найти оптимальный размер по условию). Monotonic Deque решает max/min в окне за O(n).

---

## Часть 1: Интуиция без кода

> **Цель:** понять ИДЕЮ Sliding Window до любого кода. Если ты понимаешь эти аналогии — ты уже понимаешь паттерн.

### Ты уже используешь Sliding Window каждый день

| Ситуация | Как ты это делаешь | Тип окна |
|----------|-------------------|----------|
| **Смотришь через окно поезда** | Видишь пейзаж фиксированного размера, который "скользит" | Fixed-size |
| **Читаешь текст с лупой** | Лупа покрывает несколько слов, двигается вдоль строки | Fixed-size |
| **Подсчитываешь расходы за неделю** | Окно 7 дней "скользит" по календарю | Fixed-size |
| **Ищешь тёплые дни подряд** | Расширяешь/сужаешь период пока условие выполняется | Variable-size |
| **Выбираешь фильм по длине** | Сначала смотришь длинные, потом сужаешь выбор | Variable-size |

### Аналогия 1: Гусеница на ветке

```
Variable-size окно = движение гусеницы:

Состояние 1: Расширение (expand)
    🌿──────────────────────────────🌿
         🐛═══════════►
         "Тянусь вперёд, собираю листья"

Состояние 2: Сжатие (shrink)
    🌿──────────────────────────────🌿
              ◄═══🐛
         "Подтягиваю хвост, отпускаю старые листья"

Гусеница расширяется и сжимается попеременно:
- Expand: голова движется вперёд (right++)
- Shrink: хвост догоняет (left++)
```

**Почему это работает:** Гусеница никогда не пятится назад! Голова всегда вперёд, хвост всегда вперёд. Каждая точка посещается максимум дважды → O(n).

### Аналогия 2: Камера с зумом

```
Ищем минимальный кадр, где видны ВСЕ друзья на фото:

Шаг 1: Zoom Out (expand) — расширяем кадр
┌──────────────────────────────────────┐
│  🧑  🧑            🧑    🧑          │
│         "Ищу всех друзей..."         │
│  🧑       🧑🧑       🧑               │
└──────────────────────────────────────┘

Шаг 2: Zoom In (shrink) — сужаем с левого края
┌────────────────────────────┐
│     🧑            🧑    🧑 │
│  "Все в кадре!            │
│    🧑🧑       🧑           │
└────────────────────────────┘
     "Теперь минимизирую кадр..."

Шаг 3: Продолжаем искать лучший кадр
         ┌─────────────────────┐
         │  🧑            🧑   │
         │     "Ещё меньше!"   │
         └─────────────────────┘
```

**Ключевой принцип:** Zoom out пока не увидишь всё нужное, zoom in пока всё ещё видно всё нужное.

### Аналогия 3: Электронная очередь в банке

```
Fixed-size Window (k=3): Всегда обслуживаем 3 человека

Момент 1:
  Вход → [🧑 🧑 🧑] 🧑 🧑 🧑 🧑 ← Очередь
         └──окно──┘
  "Обслуживаем первых трёх"

Момент 2:
  Вход → ✓ [🧑 🧑 🧑] 🧑 🧑 🧑 ← Очередь
            └──окно──┘
  "Первый ушёл, следующий зашёл"
  Затраты: +1 новый, -1 старый (а не пересчёт всех трёх!)

Момент 3:
  Вход → ✓ ✓ [🧑 🧑 🧑] 🧑 ← Очередь
               └──окно──┘
  "Окно скользит по очереди"
```

**Главная идея:** Вместо того чтобы каждый раз считать всех в окне заново, мы просто учитываем кто вошёл и кто вышел.

### Числовой пример БЕЗ кода

**Задача:** Найти максимальную сумму 3 подряд идущих элементов.

```
Массив: [2, 1, 5, 1, 3, 2]
         ↑     ↑
        [─k=3──]

НАИВНЫЙ СПОСОБ (плохо):
Окно 1: 2 + 1 + 5 = 8  (3 сложения)
Окно 2: 1 + 5 + 1 = 7  (3 сложения)
Окно 3: 5 + 1 + 3 = 9  (3 сложения)
Окно 4: 1 + 3 + 2 = 6  (3 сложения)
Итого: 12 сложений

SLIDING WINDOW (хорошо):
Окно 1: 2 + 1 + 5 = 8  (3 сложения — только первое окно!)
Окно 2: 8 - 2 + 1 = 7  (2 операции: вычли уходящий, добавили входящий)
Окно 3: 7 - 1 + 3 = 9  (2 операции)
Окно 4: 9 - 5 + 2 = 6  (2 операции)
Итого: 3 + 3×2 = 9 операций

Экономия: 25% для k=3
Для k=1000: 3000 → 1999 операций = 33% экономии
Для k=1000000: ~1000000× экономия!
```

### Главная формула

```
┌────────────────────────────────────────────────────┐
│                                                    │
│   новое_значение = старое_значение                 │
│                    + вклад_нового_элемента         │
│                    - вклад_уходящего_элемента      │
│                                                    │
│   Для суммы:  new_sum = old_sum + arr[right] - arr[left-1]
│   Для count:  new_count = old_count + 1 - 1        │
│   Для XOR:    new_xor = old_xor ^ new ^ old        │
│                                                    │
└────────────────────────────────────────────────────┘
```

---

## Часть 2: Почему Sliding Window бывает сложен?

### С чем борются новички

| Проблема | Почему возникает | Как преодолеть |
|----------|------------------|----------------|
| **Не узнают паттерн** | "Contiguous subarray" не всегда явно написано | Искать ключевые слова: longest, shortest, sum of k, at most k |
| **Путают Fixed и Variable** | Два разных шаблона под одним названием | Fixed: размер дан. Variable: ищем оптимальный размер |
| **Не знают когда shrink** | Условия сжатия неочевидны | Shrink когда окно невалидно (variable) или всегда после expand (fixed) |
| **Забывают обновить state** | При сжатии надо "откатить" изменения | Если добавили в HashMap — надо удалить при shrink |
| **Off-by-one ошибки** | Границы окна сбивают с толку | Всегда помнить: длина = right - left + 1 |

### Главная сложность: Два разных паттерна под одним именем

```
┌─────────────────────────────────────────────────────────────┐
│                    "SLIDING WINDOW"                         │
│                         │                                   │
│         ┌───────────────┴───────────────┐                   │
│         │                               │                   │
│    FIXED-SIZE                     VARIABLE-SIZE             │
│    (простой)                      (сложнее)                 │
│                                                             │
│  • Размер k дан                 • Размер меняется           │
│  • Всегда expand+shrink         • Expand пока можно         │
│  • Нет условия валидности       • Shrink когда нельзя       │
│  • Один шаблон для всех         • Два подтипа:              │
│                                   - Minimize (shrink valid) │
│                                   - Maximize (shrink invalid)│
└─────────────────────────────────────────────────────────────┘
```

**Почему это путает:** Студент читает "sliding window" и пытается применить шаблон Fixed-size к Variable-size задаче, или наоборот.

### Типичные ошибки с примерами

#### Ошибка 1: Shrink в неправильный момент

```
Задача: Найти длиннейшую подстроку без повторов
Строка: "abcabcbb"

❌ НЕПРАВИЛЬНО: Shrink сразу при обнаружении повтора
При right=3 (второй 'a'):
  "Вижу повтор, сжимаю окно на 1"
  left=1, window="bca"

Проблема: Мы не учли, что 'a' на позиции 0 УЖЕ не в нашем окне нужного размера!

✅ ПРАВИЛЬНО: Shrink до позиции ПОСЛЕ предыдущего вхождения символа
При right=3 (второй 'a'):
  lastIndex['a'] = 0
  left = max(left, lastIndex['a'] + 1) = max(0, 1) = 1
  Теперь window="bca" и 'a' не дублируется
```

#### Ошибка 2: Не обновляют state при shrink

```
Задача: Минимальное окно, содержащее все символы T
S = "ADOBECODEBANC", T = "ABC"

❌ НЕПРАВИЛЬНО:
while (have == required) {
    minLen = min(minLen, right - left + 1)
    left++  // Сдвинули, но НЕ обновили частоты!
}

Проблема: have остаётся == required даже когда символ уже не в окне

✅ ПРАВИЛЬНО:
while (have == required) {
    minLen = min(minLen, right - left + 1)

    leftChar = s[left]
    window[leftChar]--  // ОБНОВЛЯЕМ частоту

    if (leftChar in need && window[leftChar] < need[leftChar]) {
        have--  // ОБНОВЛЯЕМ have
    }
    left++
}
```

#### Ошибка 3: Путают Minimize и Maximize

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  MINIMIZE (найти минимальное валидное окно):                │
│  • Expand пока окно НЕвалидно                               │
│  • Shrink пока окно ВАЛИДНО (записываем ответ!)             │
│                                                             │
│  Пример: Minimum Window Substring                           │
│  "Расширяй пока не соберёшь все буквы,                      │
│   потом сжимай пока буквы ещё есть"                         │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  MAXIMIZE (найти максимальное валидное окно):               │
│  • Expand пока окно ВАЛИДНО (записываем ответ!)             │
│  • Shrink пока окно НЕвалидно                               │
│                                                             │
│  Пример: Longest Substring Without Repeating                │
│  "Расширяй пока нет повторов,                               │
│   при повторе сожми до уникальности"                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Почему O(n), если есть вложенный while?

Это самый частый вопрос, вызывающий путаницу:

```
for (right in 0 until n) {        // O(n) итераций
    // expand...

    while (invalid) {              // Ещё цикл?! O(n²)?
        // shrink...
        left++
    }
}
```

**Ответ: Amortized O(n)**

```
Каждый элемент:
• Входит в окно РОВНО 1 раз (при right++)
• Выходит из окна МАКСИМУМ 1 раз (при left++)

Суммарно: n входов + n выходов = 2n операций = O(n)

Визуализация:
right: ──────────────────────────────────►  (n шагов вправо)
left:  ──────────────────────────────────►  (n шагов вправо)

Оба указателя ТОЛЬКО движутся вправо!
Никогда не возвращаются назад.
```

---

## Часть 3: Ментальные модели для Sliding Window

### Модель 1: "Гусеница" (Caterpillar)

```
Идея: Окно = тело гусеницы, которое растягивается и сжимается

┌────────────────────────────────────────────────────────────┐
│                     EXPAND (голова вперёд)                 │
│                                                            │
│   [a] [b] [c] [d] [e] [f] [g] [h]                          │
│        └──●═══════●──┘                                     │
│          left    right                                     │
│                     ↓                                      │
│   [a] [b] [c] [d] [e] [f] [g] [h]                          │
│        └──●═══════════●──┘                                 │
│          left       right                                  │
│                                                            │
├────────────────────────────────────────────────────────────┤
│                     SHRINK (хвост догоняет)                │
│                                                            │
│   [a] [b] [c] [d] [e] [f] [g] [h]                          │
│        └──●═══════════●──┘                                 │
│          left       right                                  │
│                     ↓                                      │
│   [a] [b] [c] [d] [e] [f] [g] [h]                          │
│            └──●═══════●──┘                                 │
│              left   right                                  │
│                                                            │
└────────────────────────────────────────────────────────────┘

Когда использовать: Variable-size задачи
Мантра: "Тянусь вперёд, подтягиваю хвост"
```

### Модель 2: "Конвейерная лента" (Fixed-size)

```
Идея: Элементы движутся через окно фиксированного размера

┌────────────────────────────────────────────────────────────┐
│                                                            │
│        Вход                               Выход            │
│          │                                  │              │
│          ▼                                  ▼              │
│   ... → [?] → ┌───┬───┬───┐ → [?] → ...                    │
│               │ 3 │ 5 │ 2 │  ← окно k=3                    │
│               └───┴───┴───┘                                │
│               sum = 3+5+2 = 10                             │
│                                                            │
│   Следующий шаг:                                           │
│                                                            │
│          ▼                                  ▼              │
│   ... → [3] → ┌───┬───┬───┐ → [?] → ...                    │
│         out   │ 5 │ 2 │ 7 │  in=7                          │
│               └───┴───┴───┘                                │
│               sum = 10 - 3 + 7 = 14                        │
│                                                            │
└────────────────────────────────────────────────────────────┘

Когда использовать: Fixed-size задачи (sum, max, average k элементов)
Мантра: "Один вошёл — один вышел"
```

### Модель 3: "Аккордеон" (Shrinkable Window)

```
Идея: Окно как меха аккордеона — растягивается и сжимается

┌────────────────────────────────────────────────────────────┐
│                                                            │
│  Состояние 1: Растянут (valid window)                      │
│                                                            │
│       [a]─[b]─[c]─[d]─[e]                                  │
│       └═══════════════════┘                                │
│       "Окно валидно, запоминаем размер, пробуем сжать"     │
│                                                            │
│  Состояние 2: Сжат (всё ещё valid)                         │
│                                                            │
│           [b]─[c]─[d]─[e]                                  │
│           └═══════════┘                                    │
│       "Ещё валидно! Запоминаем, сжимаем дальше"            │
│                                                            │
│  Состояние 3: Слишком сжат (invalid)                       │
│                                                            │
│               [c]─[d]─[e]                                  │
│               └═══════┘ ✗                                  │
│       "Невалидно! Прекращаем сжимать, расширяем"           │
│                                                            │
└────────────────────────────────────────────────────────────┘

Когда использовать: Minimize задачи (minimum window substring)
Мантра: "Expand до валидности, shrink до инвалидности"
```

### Модель 4: "Двойной курсор в документе"

```
Идея: Два курсора выделяют текст, оба могут двигаться только вправо

┌────────────────────────────────────────────────────────────┐
│                                                            │
│  Документ: T h e   q u i c k   b r o w n   f o x          │
│            │           │                                   │
│          left       right                                  │
│            └═══════════┘                                   │
│               выделено                                     │
│                                                            │
│  Правила:                                                  │
│  • right может двигаться ТОЛЬКО вправо (expand)            │
│  • left может двигаться ТОЛЬКО вправо (shrink)             │
│  • left НИКОГДА не обгоняет right                          │
│  • Курсоры НИКОГДА не идут назад                           │
│                                                            │
│  Это гарантирует O(n): каждая позиция посещается           │
│  каждым курсором максимум 1 раз                            │
│                                                            │
└────────────────────────────────────────────────────────────┘

Когда использовать: Любые sliding window задачи
Мантра: "Оба курсора только вперёд"
```

### Выбор модели по типу задачи

| Тип задачи | Лучшая модель | Почему |
|------------|---------------|--------|
| Fixed-size sum/max/avg | Конвейерная лента | Чёткий вход-выход |
| Longest substring | Гусеница | Интуитивное растяжение |
| Minimum window | Аккордеон | Фокус на shrink |
| Любая SW задача | Двойной курсор | Понимание O(n) |

### Универсальный шаблон мышления

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  ШАГ 1: ОПРЕДЕЛИТЬ ТИП ОКНА                                 │
│  ─────────────────────────                                  │
│  Вопрос: "Размер окна дан или нужно найти?"                 │
│                                                             │
│  • Дан (k элементов) → FIXED-SIZE                           │
│  • Нужно найти → VARIABLE-SIZE                              │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ШАГ 2: ОПРЕДЕЛИТЬ УСЛОВИЕ ВАЛИДНОСТИ                       │
│  ────────────────────────────────────                       │
│  Вопрос: "Когда окно считается хорошим?"                    │
│                                                             │
│  • sum <= target                                            │
│  • все символы уникальны                                    │
│  • содержит все символы из T                                │
│  • не больше k нулей                                        │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ШАГ 3: ОПРЕДЕЛИТЬ ОПТИМИЗАЦИЮ                              │
│  ─────────────────────────────                              │
│  Вопрос: "Что мы максимизируем/минимизируем?"               │
│                                                             │
│  • MAXIMIZE длину → expand пока valid, shrink когда invalid │
│  • MINIMIZE длину → expand пока invalid, shrink пока valid  │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ШАГ 4: ОПРЕДЕЛИТЬ STATE                                    │
│  ───────────────────────                                    │
│  Вопрос: "Какие данные хранить об окне?"                    │
│                                                             │
│  • Сумма элементов → int sum                                │
│  • Частоты символов → HashMap<Char, Int>                    │
│  • Максимум в окне → Monotonic Deque                        │
│  • Количество уникальных → Set + size                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Зачем это нужно?

**Реальная проблема:**

Анализ временных рядов: найти максимальную среднюю температуру за любую неделю в году (365 дней).

Наивный подход: для каждого дня считаем сумму 7 дней = 365 × 7 = 2555 операций.
Sliding Window: считаем первую неделю, затем для каждого дня: +новый день −старый = 365 операций.

Разница 7x — а для окна в 30 дней уже 30x!

**Где используется:**

| Область | Применение | Пример |
|---------|------------|--------|
| Финансы | Moving Average | SMA, EMA индикаторы |
| Сети | TCP Flow Control | Скользящее окно протокола |
| Streaming | Rate Limiting | Requests per second |
| ML | Time Series | Rolling features |
| Видео | Frame buffering | H.264 sliding window |
| Базы данных | Window functions | OVER (ROWS BETWEEN) |

**Статистика:**
- 15-20% задач на интервью FAANG используют Sliding Window
- LeetCode: 150+ задач с этим паттерном
- Основа для понимания TCP/IP (RFC 793)

---

## Prerequisites (Что нужно знать)

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **Массивы** | Sliding Window работает с contiguous subarrays | [[arrays-strings]] |
| **Hash Tables** | Для frequency counting в variable-size windows | [[hash-tables]] |
| **Two Pointers** | Sliding Window = расширение two pointers pattern | [[two-pointers-pattern]] |
| **Big O нотация** | Понимание amortized O(n) | [[big-o-complexity]] |
| **CS: Deque** | Double-ended queue для monotonic window | Структуры данных |
| **CS: Amortized Analysis** | Почему O(n) несмотря на вложенные циклы | Анализ алгоритмов |

---

## Что это такое?

### Объяснение для 5-летнего

Представь поезд из 3 вагонов, который едет вдоль платформы с 10 людьми.

```
Платформа: [5] [2] [8] [1] [9] [3] [7] [4] [6] [2]

Поезд:     [▓▓▓]
           ────→
```

Поезд останавливается, и ты считаешь людей в 3 вагонах: 5+2+8 = 15.
Поезд сдвигается на 1 позицию. Вместо пересчёта всех трёх:
- Высадился человек слева (5)
- Зашёл человек справа (1)
- Новая сумма: 15 - 5 + 1 = 11

Так поезд "скользит" по платформе, и ты быстро узнаёшь сумму в каждом положении!

### Формальное определение

**Sliding Window** — алгоритмический паттерн, который обрабатывает последовательность данных, поддерживая подмножество (окно) фиксированного или переменного размера и обновляя результат инкрементально при сдвиге окна.

**Ключевые свойства:**
- **Непрерывность**: окно содержит смежные элементы
- **Инкрементальность**: новый результат вычисляется из предыдущего
- **Два указателя**: left/right границы окна
- **Инвариант**: условие, выполняющееся для текущего окна

**Два типа:**

```
Fixed-Size Window (размер k)
┌─────────────────────────────────────┐
│ [1] [2] [3] [4] [5] [6] [7] [8]     │
│      └───k=3───┘                    │
│          └───k=3───┘                │
│              └───k=3───┘            │
└─────────────────────────────────────┘
→ Размер окна постоянный, ищем max/min/sum

Variable-Size Window (условие)
┌─────────────────────────────────────┐
│ [a] [b] [c] [a] [d] [e] [f]         │
│  └──────────┘                       │
│  unique chars, expand →             │
│      └─────────────┘                │
│      found repeat, shrink ←         │
└─────────────────────────────────────┘
→ Размер меняется, ищем оптимальный по условию
```

---

## Терминология

| Термин | Определение | Пример |
|--------|-------------|--------|
| **Window** | Текущий подмассив/подстрока | Элементы [left..right] |
| **Left Pointer** | Левая граница окна | Начало подмассива |
| **Right Pointer** | Правая граница окна | Конец подмассива |
| **Expand** | Расширение окна вправо | right++ |
| **Shrink** | Сужение окна слева | left++ |
| **Window State** | Агрегат окна (сумма, count) | sum, hashmap |
| **Invariant** | Условие валидности окна | sum <= k, unique chars |
| **Monotonic Deque** | Очередь с монотонным порядком | Для max/min за O(1) |

---

## Как это работает?

### Fixed-Size Window

```
Maximum Sum of Subarray of Size K

Array: [2, 1, 5, 1, 3, 2], K = 3

Шаг 0: Инициализация первого окна
       [2, 1, 5] 1, 3, 2
        └──k=3──┘
       sum = 2 + 1 + 5 = 8
       maxSum = 8

Шаг 1: Сдвиг окна
        2 [1, 5, 1] 3, 2
           └──k=3──┘
       sum = 8 - 2 + 1 = 7
       maxSum = max(8, 7) = 8

Шаг 2: Сдвиг окна
        2, 1 [5, 1, 3] 2
              └──k=3──┘
       sum = 7 - 1 + 3 = 9
       maxSum = max(8, 9) = 9 ← новый максимум!

Шаг 3: Сдвиг окна
        2, 1, 5 [1, 3, 2]
                 └──k=3──┘
       sum = 9 - 5 + 2 = 6
       maxSum = max(9, 6) = 9

Результат: maxSum = 9
```

**Инвариант**: окно всегда содержит ровно k элементов.

### Variable-Size Window

```
Longest Substring Without Repeating Characters

String: "abcabcbb"

Шаг 0: Инициализация
       left=0, right=0, seen={}
       [a]bcabcbb
        ↑
       seen={a:0}, length=1, maxLen=1

Шаг 1: Expand (right=1)
       [a,b]cabcbb
        ↑ ↑
       seen={a:0, b:1}, length=2, maxLen=2

Шаг 2: Expand (right=2)
       [a,b,c]abcbb
        ↑   ↑
       seen={a:0, b:1, c:2}, length=3, maxLen=3

Шаг 3: Expand (right=3) → 'a' повторяется!
       [a,b,c,a]bcbb
        ↑     ↑
       seen['a']=0 < left? Нет! Shrink!
       left = seen['a'] + 1 = 1
       a[b,c,a]bcbb
         ↑   ↑
       seen={a:3, b:1, c:2}, length=3, maxLen=3

Шаг 4: Expand (right=4) → 'b' повторяется!
       a[b,c,a,b]cbb
         ↑     ↑
       seen['b']=1 >= left=1 → Shrink!
       left = 2
       a,b[c,a,b]cbb
           ↑   ↑
       seen={a:3, b:4, c:2}, length=3

...продолжаем...

Результат: maxLen = 3 ("abc" или "bca" или "cab")
```

**Инвариант**: в окне [left..right] все символы уникальны.

### Monotonic Deque для Max in Window

```
Sliding Window Maximum, K=3

Array: [1, 3, -1, -3, 5, 3, 6, 7]

Идея: deque хранит ИНДЕКСЫ в порядке убывания значений

Шаг 0: i=0, num=1
       deque = [0]           # indices
       values = [1]          # для понимания
       window не полное

Шаг 1: i=1, num=3
       3 > arr[deque.back()] = 1 → pop back
       deque = [1]
       values = [3]

Шаг 2: i=2, num=-1
       -1 < arr[deque.back()] = 3 → просто добавляем
       deque = [1, 2]
       values = [3, -1]
       window полное! max = arr[deque.front()] = 3

Шаг 3: i=3, num=-3
       Evict: deque.front()=1, но 1 >= i-k+1=1? Нет, 1 >= 1 ✓ остаётся
       -3 < -1 → добавляем
       deque = [1, 2, 3]
       values = [3, -1, -3]
       max = arr[1] = 3

Шаг 4: i=4, num=5
       Evict: deque.front()=1 < i-k+1=2 → pop front!
       deque = [2, 3]
       5 > arr[3]=-3 → pop, 5 > arr[2]=-1 → pop
       deque = [4]
       values = [5]
       max = 5

...и так далее

Результат: [3, 3, 5, 5, 6, 7]
```

**Инварианты**:
1. Индексы в deque всегда в пределах текущего окна
2. Значения по этим индексам строго убывают
3. Front deque = индекс максимума в окне

---

## Сложность операций

| Паттерн | Время | Память | Типичные задачи |
|---------|-------|--------|-----------------|
| Fixed-Size Sum | O(n) | O(1) | Max sum of k elements |
| Fixed-Size Max (naive) | O(n×k) | O(1) | Max in each window |
| Fixed-Size Max (deque) | O(n) | O(k) | Sliding Window Maximum |
| Variable-Size | O(n) | O(k) | Longest/Shortest substring |
| Variable-Size + HashMap | O(n) | O(alphabet) | Char frequency tracking |

**Почему O(n)?**

```
Fixed-Size:
- Один проход по массиву: n итераций
- На каждой итерации: O(1) операций (add/remove one element)
- Итого: O(n)

Variable-Size:
- right проходит от 0 до n-1: n шагов
- left только увеличивается, максимум до n-1
- Каждый элемент добавляется 1 раз, удаляется 1 раз
- Итого: O(n) + O(n) = O(n)

Monotonic Deque:
- Каждый элемент push в deque максимум 1 раз
- Каждый элемент pop из deque максимум 1 раз
- Amortized: O(n)
```

---

## Реализация

### Kotlin

```kotlin
// ═══════════════════════════════════════════════════════════════════════════
// FIXED-SIZE: MAXIMUM SUM OF SUBARRAY OF SIZE K
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Максимальная сумма подмассива размера k
 *
 * ТЕХНИКА: Fixed-size sliding window
 *
 * ПОШАГОВЫЙ ПРИМЕР:
 * ```
 * arr = [1, 4, 2, 10, 2, 3, 1, 0, 20], k = 3
 *
 * 1. Первое окно: [1,4,2] = 7
 * 2. Сдвигаем: [4,2,10] = 7 + 10 - 1 = 16 ← максимум!
 * 3. Сдвигаем: [2,10,2] = 16 + 2 - 4 = 14
 * ...
 * ```
 */
fun maxSumSubarray(arr: IntArray, k: Int): Int {
    if (arr.size < k) return -1

    // Вычисляем сумму первого окна ОДИН РАЗ — это наша база
    var windowSum = arr.take(k).sum()
    var maxSum = windowSum

    /**
     * СДВИГ ОКНА за O(1):
     * Новая сумма = старая сумма + новый элемент - уходящий элемент
     *
     * windowSum += arr[i] - arr[i-k]
     *              ↑ входит   ↑ выходит
     */
    for (i in k until arr.size) {
        windowSum += arr[i] - arr[i - k]
        maxSum = maxOf(maxSum, windowSum)
    }

    return maxSum
}

// ═══════════════════════════════════════════════════════════════════════════
// FIXED-SIZE: SLIDING WINDOW MAXIMUM (MONOTONIC DEQUE)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * LeetCode 239: Sliding Window Maximum
 *
 * ИДЕЯ: Monotonic Deque (убывающая) — front всегда максимум
 *
 * ПОЧЕМУ ИНДЕКСЫ, А НЕ ЗНАЧЕНИЯ:
 * Нужно знать, когда элемент "вышел" из окна (индекс <= i-k)
 *
 * ПОШАГОВЫЙ ПРИМЕР:
 * ```
 * nums = [1,3,-1,-3,5,3,6,7], k = 3
 *
 * i=0: deque = [0]           (индекс 0, значение 1)
 * i=1: deque = [1]           (1 < 3, удалили; добавили 1)
 * i=2: deque = [1,2]         (-1 < 3, не удаляем 1)
 *      result[0] = nums[1] = 3
 * i=3: deque = [1,3]         (-3 < -1, не удаляем 2; но 2 вне окна!)
 *      удаляем 1 (вне окна) → deque = [3]
 *      result[1] = 3... нет, ошибка в примере
 * ```
 */
fun maxSlidingWindow(nums: IntArray, k: Int): IntArray {
    if (nums.isEmpty()) return intArrayOf()

    val result = IntArray(nums.size - k + 1)
    /**
     * Храним ИНДЕКСЫ элементов, не значения!
     * Deque упорядочен по убыванию значений: front = максимум
     */
    val deque = ArrayDeque<Int>()

    for (i in nums.indices) {
        // УДАЛЯЕМ индексы ВНЕ текущего окна (левее чем i-k+1)
        while (deque.isNotEmpty() && deque.first() <= i - k) {
            deque.removeFirst()
        }

        /**
         * ПОДДЕРЖАНИЕ МОНОТОННОСТИ: удаляем все элементы < текущего
         *
         * Почему это безопасно?
         * Если nums[j] < nums[i] и j < i, то nums[j] НИКОГДА не будет
         * максимумом в окне, содержащем nums[i]
         */
        while (deque.isNotEmpty() && nums[deque.last()] < nums[i]) {
            deque.removeLast()
        }

        deque.addLast(i)

        // Записываем результат только когда окно полностью сформировано
        if (i >= k - 1) {
            result[i - k + 1] = nums[deque.first()]  // front = максимум
        }
    }

    return result
}

// ═══════════════════════════════════════════════════════════════════════════
// VARIABLE-SIZE: LONGEST SUBSTRING WITHOUT REPEATING CHARACTERS
// ═══════════════════════════════════════════════════════════════════════════

/**
 * LeetCode 3: Longest Substring Without Repeating Characters
 *
 * ТЕХНИКА: Variable-size window с HashMap для позиций
 *
 * КЛЮЧЕВАЯ ОПТИМИЗАЦИЯ:
 * Вместо Set + сдвига left по одному, храним последнюю позицию каждого символа
 * При повторе "прыгаем" сразу за повторяющийся символ
 */
fun lengthOfLongestSubstring(s: String): Int {
    // lastIndex[char] = последняя позиция где встречался char
    val lastIndex = mutableMapOf<Char, Int>()
    var left = 0
    var maxLen = 0

    for (right in s.indices) {
        val char = s[right]

        /**
         * ПРОВЕРКА: символ уже в текущем окне?
         *
         * Условие lastIndex[char] >= left критично:
         * символ мог быть в строке, но уже "вышел" из окна
         *
         * Пример: s = "abba"
         * right=2 (b): lastIndex[b]=1 >= left=0 → left = 2
         * right=3 (a): lastIndex[a]=0 < left=2 → НЕ сдвигаем (a уже вне окна!)
         */
        if (lastIndex.getOrDefault(char, -1) >= left) {
            // Прыгаем СРАЗУ за повторяющийся символ
            left = lastIndex[char]!! + 1
        }

        lastIndex[char] = right  // Обновляем позицию символа
        maxLen = maxOf(maxLen, right - left + 1)
    }

    return maxLen
}

// ═══════════════════════════════════════════════════════════════════════════
// VARIABLE-SIZE: MINIMUM WINDOW SUBSTRING
// ═══════════════════════════════════════════════════════════════════════════

/**
 * LeetCode 76: Minimum Window Substring
 *
 * Найти минимальное окно в s, содержащее все символы t
 *
 * ТЕХНИКА: Expand-shrink + HashMap для частот
 * - Expand пока не покроем все символы
 * - Shrink пока окно валидно, обновляя минимум
 */
fun minWindow(s: String, t: String): String {
    if (t.isEmpty() || s.length < t.length) return ""

    // Считаем сколько каждого символа НУЖНО
    val need = mutableMapOf<Char, Int>()
    for (c in t) {
        need[c] = need.getOrDefault(c, 0) + 1
    }

    val window = mutableMapOf<Char, Int>()
    /**
     * have = сколько УНИКАЛЬНЫХ символов полностью покрыто
     * required = сколько уникальных символов нужно (= need.size)
     *
     * Когда have == required, окно валидно!
     */
    var have = 0
    val required = need.size

    var left = 0
    var minLen = Int.MAX_VALUE
    var minStart = 0

    for (right in s.indices) {
        val char = s[right]
        window[char] = window.getOrDefault(char, 0) + 1

        // Если этот символ нужен и мы набрали РОВНО столько сколько нужно
        // (не >needed, потому что лишние нам не помогают)
        if (need.containsKey(char) && window[char] == need[char]) {
            have++
        }

        // SHRINK: пока окно валидно, пытаемся сжать слева
        while (have == required) {
            // Обновляем минимум при каждом валидном окне
            if (right - left + 1 < minLen) {
                minLen = right - left + 1
                minStart = left
            }

            // Убираем левый символ из окна
            val leftChar = s[left]
            window[leftChar] = window[leftChar]!! - 1

            // Если убрали нужный символ и теперь его НЕДОСТАТОЧНО
            if (need.containsKey(leftChar) && window[leftChar]!! < need[leftChar]!!) {
                have--  // Окно больше не валидно
            }

            left++
        }
    }

    return if (minLen == Int.MAX_VALUE) "" else s.substring(minStart, minStart + minLen)
}

// ═══════════════════════════════════════════════════════════════════════════
// VARIABLE-SIZE: MINIMUM SIZE SUBARRAY SUM
// ═══════════════════════════════════════════════════════════════════════════

/**
 * LeetCode 209: Minimum Size Subarray Sum
 *
 * Минимальная длина подмассива с суммой >= target
 *
 * ТЕХНИКА: Variable-size shrinkable window
 */
fun minSubArrayLen(target: Int, nums: IntArray): Int {
    var left = 0
    var windowSum = 0
    var minLen = Int.MAX_VALUE

    for (right in nums.indices) {
        windowSum += nums[right]  // EXPAND: добавляем правый элемент

        // SHRINK: пока сумма >= target, сжимаем слева
        while (windowSum >= target) {
            minLen = minOf(minLen, right - left + 1)
            windowSum -= nums[left]  // Убираем левый элемент
            left++
        }
    }

    return if (minLen == Int.MAX_VALUE) 0 else minLen
}

// ═══════════════════════════════════════════════════════════════════════════
// VARIABLE-SIZE: LONGEST REPEATING CHARACTER REPLACEMENT
// ═══════════════════════════════════════════════════════════════════════════

/**
 * LeetCode 424: Longest Repeating Character Replacement
 *
 * Макс. длина подстроки из одного символа после ≤k замен
 *
 * КЛЮЧЕВАЯ ФОРМУЛА:
 * window_size - max_freq = количество символов для замены
 * Если > k, окно невалидно
 */
fun characterReplacement(s: String, k: Int): Int {
    val count = IntArray(26)  // Частоты символов в текущем окне
    var maxFreq = 0           // Максимальная частота одного символа
    var left = 0
    var maxLen = 0

    for (right in s.indices) {
        count[s[right] - 'A']++
        maxFreq = maxOf(maxFreq, count[s[right] - 'A'])

        /**
         * Если нужно заменить > k символов, сжимаем окно
         * (right - left + 1) - maxFreq = кол-во символов для замены
         */
        while (right - left + 1 - maxFreq > k) {
            count[s[left] - 'A']--
            left++
            /**
             * ВАЖНО: НЕ пересчитываем maxFreq!
             *
             * Почему? maxFreq может только РАСТИ для итогового ответа.
             * Если уменьшить maxFreq, придётся пересчитывать O(26).
             * А нам нужен максимум за всё время — он не уменьшается.
             */
        }

        maxLen = maxOf(maxLen, right - left + 1)
    }

    return maxLen
}

// ═══════════════════════════════════════════════════════════════════════════
// VARIABLE-SIZE: SUBARRAY PRODUCT LESS THAN K
// ═══════════════════════════════════════════════════════════════════════════

/**
 * LeetCode 713: Subarray Product Less Than K
 *
 * Количество подмассивов с произведением < k
 */
fun numSubarrayProductLessThanK(nums: IntArray, k: Int): Int {
    // Edge case: все элементы >= 1, произведение >= 1, если k <= 1 — ответ 0
    if (k <= 1) return 0

    var left = 0
    var product = 1
    var count = 0

    for (right in nums.indices) {
        product *= nums[right]

        // Сжимаем окно пока произведение >= k
        while (product >= k) {
            product /= nums[left]
            left++
        }

        /**
         * ПОДСЧЁТ ПОДМАССИВОВ:
         *
         * Все подмассивы, заканчивающиеся на right и начинающиеся в [left, right]:
         * [left..right], [left+1..right], ..., [right..right]
         * Их количество = right - left + 1
         *
         * Пример: left=1, right=4
         * Подмассивы: [1,4], [2,4], [3,4], [4] = 4 штуки
         */
        count += right - left + 1
    }

    return count
}

// ═══════════════════════════════════════════════════════════════════════════
// FIXED-SIZE: FIND ALL ANAGRAMS IN STRING
// ═══════════════════════════════════════════════════════════════════════════

/**
 * LeetCode 438: Find All Anagrams in a String
 *
 * ТЕХНИКА: Fixed-size window + сравнение частот
 * Окно размера p.length, сравниваем массивы частот
 */
fun findAnagrams(s: String, p: String): List<Int> {
    if (s.length < p.length) return emptyList()

    val result = mutableListOf<Int>()
    val pCount = IntArray(26)  // Частоты символов в pattern
    val sCount = IntArray(26)  // Частоты в текущем окне

    // Считаем частоты в pattern
    for (c in p) {
        pCount[c - 'a']++
    }

    for (i in s.indices) {
        sCount[s[i] - 'a']++  // Добавляем правый символ

        // Убираем левый символ если окно стало больше p.length
        if (i >= p.length) {
            sCount[s[i - p.length] - 'a']--
        }

        // Сравниваем массивы частот (O(26) = O(1))
        if (i >= p.length - 1 && pCount.contentEquals(sCount)) {
            result.add(i - p.length + 1)
        }
    }

    return result
}
```

### Java

```java
// ═══════════════════════════════════════════════════════════════════════════
// FIXED-SIZE: SLIDING WINDOW MAXIMUM
// ═══════════════════════════════════════════════════════════════════════════

public int[] maxSlidingWindow(int[] nums, int k) {
    if (nums.length == 0) return new int[0];

    int[] result = new int[nums.length - k + 1];
    // Храним ИНДЕКСЫ для отслеживания выхода за пределы окна
    Deque<Integer> deque = new ArrayDeque<>();

    for (int i = 0; i < nums.length; i++) {
        // Удаляем индексы вне текущего окна
        while (!deque.isEmpty() && deque.peekFirst() <= i - k) {
            deque.pollFirst();
        }

        // Удаляем меньшие элементы — они никогда не будут максимумом
        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
            deque.pollLast();
        }

        deque.offerLast(i);

        if (i >= k - 1) {
            result[i - k + 1] = nums[deque.peekFirst()];
        }
    }

    return result;
}

// ═══════════════════════════════════════════════════════════════════════════
// VARIABLE-SIZE: LONGEST SUBSTRING WITHOUT REPEATING
// ═══════════════════════════════════════════════════════════════════════════

public int lengthOfLongestSubstring(String s) {
    Map<Character, Integer> lastIndex = new HashMap<>();
    int left = 0;
    int maxLen = 0;

    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);

        if (lastIndex.containsKey(c) && lastIndex.get(c) >= left) {
            left = lastIndex.get(c) + 1;
        }

        lastIndex.put(c, right);
        maxLen = Math.max(maxLen, right - left + 1);
    }

    return maxLen;
}

// ═══════════════════════════════════════════════════════════════════════════
// VARIABLE-SIZE: MINIMUM WINDOW SUBSTRING
// ═══════════════════════════════════════════════════════════════════════════

public String minWindow(String s, String t) {
    if (t.isEmpty() || s.length() < t.length()) return "";

    Map<Character, Integer> need = new HashMap<>();
    for (char c : t.toCharArray()) {
        need.put(c, need.getOrDefault(c, 0) + 1);
    }

    Map<Character, Integer> window = new HashMap<>();
    int have = 0;
    int required = need.size();

    int left = 0;
    int minLen = Integer.MAX_VALUE;
    int minStart = 0;

    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);
        window.put(c, window.getOrDefault(c, 0) + 1);

        if (need.containsKey(c) && window.get(c).equals(need.get(c))) {
            have++;
        }

        while (have == required) {
            if (right - left + 1 < minLen) {
                minLen = right - left + 1;
                minStart = left;
            }

            char leftChar = s.charAt(left);
            window.put(leftChar, window.get(leftChar) - 1);

            if (need.containsKey(leftChar) && window.get(leftChar) < need.get(leftChar)) {
                have--;
            }

            left++;
        }
    }

    return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
}
```

### Python

```python
from collections import deque, Counter, defaultdict

# ═══════════════════════════════════════════════════════════════════════════
# FIXED-SIZE: MAXIMUM SUM OF SUBARRAY OF SIZE K
# ═══════════════════════════════════════════════════════════════════════════

def max_sum_subarray(arr: list[int], k: int) -> int:
    if len(arr) < k:
        return -1

    window_sum = sum(arr[:k])
    max_sum = window_sum

    for i in range(k, len(arr)):
        window_sum += arr[i] - arr[i - k]  # WHY: +new -old
        max_sum = max(max_sum, window_sum)

    return max_sum

# ═══════════════════════════════════════════════════════════════════════════
# FIXED-SIZE: SLIDING WINDOW MAXIMUM (MONOTONIC DEQUE)
# ═══════════════════════════════════════════════════════════════════════════

def max_sliding_window(nums: list[int], k: int) -> list[int]:
    if not nums:
        return []

    result = []
    dq = deque()  # WHY: stores indices

    for i, num in enumerate(nums):
        # WHY: remove indices outside window
        while dq and dq[0] <= i - k:
            dq.popleft()

        # WHY: remove smaller elements
        while dq and nums[dq[-1]] < num:
            dq.pop()

        dq.append(i)

        if i >= k - 1:
            result.append(nums[dq[0]])

    return result

# ═══════════════════════════════════════════════════════════════════════════
# VARIABLE-SIZE: LONGEST SUBSTRING WITHOUT REPEATING CHARACTERS
# ═══════════════════════════════════════════════════════════════════════════

def length_of_longest_substring(s: str) -> int:
    last_index = {}
    left = 0
    max_len = 0

    for right, char in enumerate(s):
        if char in last_index and last_index[char] >= left:
            left = last_index[char] + 1

        last_index[char] = right
        max_len = max(max_len, right - left + 1)

    return max_len

# ═══════════════════════════════════════════════════════════════════════════
# VARIABLE-SIZE: MINIMUM WINDOW SUBSTRING
# ═══════════════════════════════════════════════════════════════════════════

def min_window(s: str, t: str) -> str:
    if not t or len(s) < len(t):
        return ""

    need = Counter(t)
    window = defaultdict(int)
    have = 0
    required = len(need)

    left = 0
    min_len = float('inf')
    min_start = 0

    for right, char in enumerate(s):
        window[char] += 1

        if char in need and window[char] == need[char]:
            have += 1

        while have == required:
            if right - left + 1 < min_len:
                min_len = right - left + 1
                min_start = left

            left_char = s[left]
            window[left_char] -= 1

            if left_char in need and window[left_char] < need[left_char]:
                have -= 1

            left += 1

    return "" if min_len == float('inf') else s[min_start:min_start + min_len]

# ═══════════════════════════════════════════════════════════════════════════
# VARIABLE-SIZE: MINIMUM SIZE SUBARRAY SUM
# ═══════════════════════════════════════════════════════════════════════════

def min_sub_array_len(target: int, nums: list[int]) -> int:
    left = 0
    window_sum = 0
    min_len = float('inf')

    for right in range(len(nums)):
        window_sum += nums[right]

        while window_sum >= target:
            min_len = min(min_len, right - left + 1)
            window_sum -= nums[left]
            left += 1

    return 0 if min_len == float('inf') else min_len
```

---

## Распространённые ошибки

### 1. Забыли обновить состояние при сжатии

```kotlin
// ❌ НЕПРАВИЛЬНО: не обновляем have при удалении символа
while (have == required) {
    val leftChar = s[left]
    window[leftChar] = window[leftChar]!! - 1
    left++  // Сдвинули, но have не обновили!
}

// ✅ ПРАВИЛЬНО: проверяем, не испортили ли условие
while (have == required) {
    val leftChar = s[left]
    window[leftChar] = window[leftChar]!! - 1

    /**
     * Проверяем: после уменьшения счётчика символа leftChar
     * стало ли его МЕНЬШЕ, чем требуется?
     *
     * Если да — уменьшаем have, потому что один из
     * "полностью покрытых" символов теперь НЕ покрыт.
     *
     * Пример: need = {A:2}, window = {A:2} → have включает A
     * После window[A]-- получаем {A:1} → A больше не покрыт!
     */
    if (need.containsKey(leftChar) && window[leftChar]!! < need[leftChar]!!) {
        have--
    }
    left++
}
```

### 2. Off-by-one при подсчёте длины

```kotlin
// ❌ НЕПРАВИЛЬНО: забыли +1
val length = right - left  // Если left=2, right=5, это даёт 3, а должно быть 4!

// ✅ ПРАВИЛЬНО: inclusive boundaries
val length = right - left + 1  // [2,3,4,5] = 4 элемента
```

### 3. Monotonic Deque: хранят значения вместо индексов

```kotlin
// ❌ НЕПРАВИЛЬНО: не можем проверить выход из окна
val deque = ArrayDeque<Int>()  // значения
if (deque.first() == arr[i - k]) {  // Как удалить если значения одинаковые?
    deque.removeFirst()
}

// ✅ ПРАВИЛЬНО: храним индексы
val deque = ArrayDeque<Int>()  // индексы
if (deque.first() <= i - k) {  // Проверяем позицию
    deque.removeFirst()
}
```

### 4. Не проверили граничные случаи

```kotlin
// ❌ НЕПРАВИЛЬНО: crash если s.length < k
for (i in k until s.length) {
    // ...
}

// ✅ ПРАВИЛЬНО: проверка в начале
if (s.length < k) return emptyList()
for (i in k until s.length) {
    // ...
}
```

### 5. Неправильный порядок expand/shrink

```kotlin
// ❌ НЕПРАВИЛЬНО: сначала сжимаем, потом расширяем
for (right in indices) {
    while (invalid) {
        left++  // Сжимаем, но right ещё не добавлен!
    }
    add(right)  // Теперь добавляем
}

// ✅ ПРАВИЛЬНО: сначала expand, потом shrink
for (right in indices) {
    add(right)       // Расширяем
    while (invalid) {
        remove(left) // Сжимаем
        left++
    }
}
```

### 6. Сравнение HashMap values в Java через ==

```java
// ❌ НЕПРАВИЛЬНО: Integer boxing, == сравнивает ссылки
if (window.get(c) == need.get(c)) {  // False для Integer > 127!

// ✅ ПРАВИЛЬНО: equals для объектов
if (window.get(c).equals(need.get(c))) {
```

---

## Когда использовать?

### Decision Tree

```
Задача на подмассив/подстроку?
│
├─ Да → Размер окна фиксирован?
│       │
│       ├─ Да → FIXED-SIZE WINDOW
│       │       │
│       │       └─ Нужен max/min в окне? → MONOTONIC DEQUE
│       │
│       └─ Нет → Ищем оптимальный размер по условию?
│               │
│               └─ Да → VARIABLE-SIZE WINDOW
│                       │
│                       ├─ Minimize → Shrink когда valid
│                       └─ Maximize → Expand пока valid
│
└─ Нет → Другой паттерн (Two Pointers, Prefix Sum, etc.)
```

### Сравнение с альтернативами

| Задача | Sliding Window | Альтернатива | Когда что |
|--------|---------------|--------------|-----------|
| Max sum k elements | O(n) | Prefix Sum O(n) | SW проще |
| Max in window | O(n) deque | Heap O(n log k) | Deque быстрее |
| Longest unique | O(n) | Set O(n) | Оба работают |
| Any subarray sum | O(n) | Prefix + HashMap | Prefix для суммы=target |
| K distinct chars | O(n) | — | SW единственный |

### Признаки Sliding Window задачи

1. **"Contiguous subarray/substring"** — ключевое слово
2. **"Maximum/Minimum length"** — variable-size
3. **"Fixed window of size k"** — fixed-size
4. **"All subarrays with..."** — часто SW + counting
5. **"Longest/Shortest with condition"** — variable-size

---

## Практика

### Концептуальные вопросы

1. **Почему variable-size window всё ещё O(n), хотя есть вложенный while?**

   *Ответ:* Каждый элемент добавляется в окно один раз (при right++) и удаляется максимум один раз (при left++). Общее число операций = 2n = O(n).

2. **Когда использовать HashMap vs Array для частот?**

   *Ответ:* Array[26] для lowercase letters — быстрее и O(1) память. HashMap для unicode или когда alphabet неизвестен.

3. **Почему в Longest Repeating Character Replacement не пересчитываем maxFreq при shrink?**

   *Ответ:* Нам нужен глобальный максимум. Если maxFreq был 5, а стал 4 после shrink — длина ответа не изменится. Пересчёт за O(26) каждый раз сделает O(26n).

4. **Чем отличается minimize от maximize для variable window?**

   *Ответ:* Minimize: расширяем пока НЕ валидно, сжимаем пока валидно. Maximize: расширяем пока валидно, сжимаем когда НЕ валидно.

### LeetCode задачи

#### Fixed-Size Window

| # | Название | Сложность | Ключевой момент |
|---|----------|-----------|-----------------|
| 643 | Maximum Average Subarray I | Easy | Базовый fixed-size |
| 1343 | Subarrays of Size K Avg >= Threshold | Medium | Подсчёт окон |
| 239 | Sliding Window Maximum | Hard | Monotonic Deque |
| 480 | Sliding Window Median | Hard | Two Heaps |
| 438 | Find All Anagrams | Medium | Frequency arrays |

#### Variable-Size Window

| # | Название | Сложность | Ключевой момент |
|---|----------|-----------|-----------------|
| 3 | Longest Substring Without Repeating | Medium | HashMap + left jump |
| 209 | Minimum Size Subarray Sum | Medium | Shrink while valid |
| 76 | Minimum Window Substring | Hard | have/required tracking |
| 424 | Longest Repeating Character Replacement | Medium | maxFreq trick |
| 713 | Subarray Product Less Than K | Medium | Counting subarrays |
| 340 | Longest Substring with At Most K Distinct | Medium | HashMap size |
| 904 | Fruit Into Baskets | Medium | Same as 340 |
| 1004 | Max Consecutive Ones III | Medium | Flip at most k zeros |
| 567 | Permutation in String | Medium | Fixed-size anagram |

---

## Мифы и заблуждения

| Миф | Реальность |
|-----|-----------|
| "Sliding Window — это всегда O(n)" | **Почти всегда, но не всегда!** Для fixed-size — да, O(n). Для variable-size с вложенным shrinking — тоже O(n) amortized, но требуется понимание почему. Если внутри окна поиск O(n), общая сложность O(n²) |
| "Можно использовать только для сумм" | **Нет!** Sliding Window работает для любой ассоциативной операции с обратной: сумма (+/-), произведение (×/÷), XOR, frequency count. Для min/max нужен Monotonic Deque |
| "Variable-size window всегда сложнее" | **Не обязательно!** Шаблон одинаковый: expand right, shrink left по условию. Сложность в определении инварианта, а не в коде |
| "Deque для max в окне — overkill" | **Нет, это оптимально!** TreeMap/Heap дают O(n log k). Monotonic Deque — O(n). Разница критична для streaming данных |
| "Sliding Window заменяет Two Pointers" | **Нет!** Sliding Window — подтип Two Pointers для непрерывных подмассивов. Two Pointers шире: opposite direction, fast/slow для списков. Разные инструменты |
| "При shrinking окна нужно пересчитывать всё" | **Нет!** Инкрементальное обновление: при добавлении справа — update, при удалении слева — reverse update. Для суммы: +arr[right], -arr[left]. Для HashMap: freq[char]++, freq[char]-- |
| "Prefix Sum лучше для сумм в диапазоне" | **Зависит!** Prefix Sum: O(1) запрос после O(n) precompute, O(n) памяти. Sliding Window: O(n) один проход, O(1) память. Если много запросов — Prefix Sum, если один проход — Sliding Window |
| "Sliding Window не работает с отрицательными числами" | **Работает для fixed-size!** Для variable-size с условием "сумма ≥ target" — да, проблемы из-за non-monotonicity. Но можно использовать Prefix Sum + Binary Search |

---

## CS-фундамент

| CS-концепция | Применение в Sliding Window |
|--------------|----------------------------|
| **Amortized Analysis** | Хотя внутри while-shrink цикла есть вложенный цикл, каждый элемент добавляется и удаляется из окна РОВНО ОДИН раз. Итого: O(n) + O(n) = O(n), не O(n²) |
| **Incremental Computation** | Вместо пересчёта f(window) с нуля при каждом сдвиге, вычисляем: f(new_window) = f(old_window) - contrib(left) + contrib(right). Требует ассоциативность операции |
| **Invariant Maintenance** | Variable-size window поддерживает инвариант (напр. "все символы уникальны"). При нарушении — shrink. При соблюдении — expand и update answer |
| **Deque Data Structure** | Double-ended queue позволяет O(1) операции с обоих концов. Monotonic deque хранит элементы в порядке возрастания/убывания, отбрасывая "бесполезные" |
| **Monotonic Optimization** | Поддержание max/min в окне: элемент "полезен" только если он может стать max/min. Если новый элемент больше — все предыдущие меньшие никогда не станут max |
| **Space-Time Tradeoff** | Sliding Window: O(1) память, один проход. Prefix Sum: O(n) precompute, O(1) запросы. Выбор зависит от паттерна доступа |
| **Online Algorithm** | Sliding Window — online: обрабатывает поток данных, не требует знания всех данных заранее. Критично для real-time систем (сети, streaming) |

---

## Связанные темы

### Prerequisites (нужно знать до)
- [[arrays-strings]] — базовые операции с массивами
- [[hash-tables]] — для frequency tracking
- [[two-pointers-pattern]] — основа sliding window

### Unlocks (открывает доступ к)
- [Monotonic Stack Pattern](./monotonic-stack-pattern.md) — похожая идея
- [Prefix Sum](./prefix-sum-pattern.md) — альтернатива для сумм
- [DP Patterns](./dp-patterns.md) — для более сложных условий

### Часто комбинируется с
- **HashMaps** — для частот символов
- **Deque** — для max/min в окне
- **Two Heaps** — для медианы в окне
- **Counting** — для подсчёта подмассивов

---

## Источники

| # | Источник | Тип | Вклад |
|---|----------|-----|-------|
| 1 | [LeetCode Sliding Window](https://leetcode.com/problem-list/sliding-window/) | Практика | Задачи |
| 2 | [GeeksforGeeks](https://www.geeksforgeeks.org/window-sliding-technique/) | Туториал | Overview |
| 3 | [Labuladong](https://labuladong.online/algo/en/data-structure/monotonic-queue/) | Туториал | Monotonic Queue |
| 4 | [AlgoMonster](https://algo.monster/problems/sliding_window_maximum) | Туториал | Templates |
| 5 | [Design Gurus](https://www.designgurus.io/course-play/grokking-advanced-coding-patterns-for-interviews/doc/introduction-to-monotonic-queue-pattern) | Гайд | Patterns |
| 6 | [Tech With KP](https://techwithkp.com/variable-size-sliding-window-leetcode-solutions/) | Туториал | Variable-size |

---

## Куда дальше

→ **Предыдущий паттерн:** [[two-pointers-pattern]] — базовый паттерн для освоения
→ **Связанный паттерн:** [[prefix-sum-pattern]] — альтернатива для range queries
→ **Advanced:** [[monotonic-stack-pattern]] — для next greater/smaller
→ **Вернуться к:** [[patterns-overview|Обзор паттернов]]

---

*Проверено: 2026-01-06*
