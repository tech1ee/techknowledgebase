# Two Pointers Pattern

---
title: "Two Pointers Pattern"
created: 2025-12-29
updated: 2026-01-06
type: deep-dive
status: complete
difficulty: intermediate
confidence: high
cs-foundations:
  - pointer-arithmetic
  - sorted-data-property
  - linear-scan-optimization
  - space-time-tradeoff
  - invariant-maintenance
  - cycle-detection-floyd
prerequisites:
  - "[[arrays-strings]]"
  - "[[linked-lists]]"
  - "[[sorting-algorithms]]"
related:
  - "[[sliding-window-pattern]]"
  - "[[binary-search-pattern]]"
tags:
  - pattern
  - two-pointers
  - fast-slow
  - array
  - linked-list
  - interview
---

## TL;DR

Two Pointers использует два индекса для эффективного обхода структур данных. **Снижает O(n²) до O(n)** за счёт устранения вложенных циклов. Три вариации: **Opposite Direction** (сходятся), **Same Direction** (скользящее окно), **Fast/Slow** (Floyd). Оптимально для: отсортированных массивов, поиска пар, связных списков, палиндромов.

---

## Часть 1: Интуиция без кода

> **Цель:** понять ИДЕЮ Two Pointers до любого кода. Если ты понимаешь эти аналогии — ты уже понимаешь паттерн.

### Ты уже используешь Two Pointers

Ты применяешь этот паттерн каждый день, не осознавая:

| Ситуация | Как ты это делаешь | Это и есть... |
|----------|-------------------|---------------|
| **Проверка палиндрома (слово "казак")** | Сравниваешь первую и последнюю буквы, сдвигаешься к центру | Opposite Direction |
| **Разборка двух отсортированных стопок карт** | Берёшь меньшую карту из двух стопок, кладёшь в третью | Same Direction (Merge) |
| **Бег на стадионе с другом (он быстрее)** | Быстрый догонит медленного, если бегут по кругу | Fast/Slow |
| **Поиск двух учеников с нужной суммой баллов** | В отсортированном списке: смотришь на крайних, сужаешь | Opposite Direction |

### Аналогия 1: Встреча посередине

Представь длинный коридор с дверями. Два человека ищут комнату с определённым номером:

```
Глупый способ (O(n²)):
  Персона А проверяет каждую дверь
  Для КАЖДОЙ двери А, персона Б проверяет ВСЕ остальные
  1000 дверей → 1,000,000 проверок!

Умный способ (Two Pointers, O(n)):
  А начинает слева, Б справа
  Они идут навстречу друг другу
  Каждый проверяет только ту дверь, где находится
  1000 дверей → 1000 проверок!
```

**Почему работает:** Каждый шаг хотя бы один человек продвигается. Максимум n шагов суммарно.

### Аналогия 2: Поиск пары с нужной суммой

Ты организатор мероприятия. Есть отсортированный список участников по возрасту:
`[18, 22, 25, 30, 35, 40, 45]`

Нужно найти двух людей с суммой возрастов = 60.

```
Глупый способ:
  Берёшь первого (18), проверяешь со ВСЕМИ остальными:
  18+22=40, 18+25=43, 18+30=48, 18+35=53, 18+40=58, 18+45=63
  Не нашёл... Берёшь второго (22), проверяешь со всеми...
  И так далее. Много работы!

Умный способ (Two Pointers):
  Палец слева: 18, палец справа: 45
  18 + 45 = 63 > 60 → сумма слишком большая → сдвинь правый ←
  18 + 40 = 58 < 60 → сумма слишком маленькая → сдвинь левый →
  22 + 40 = 62 > 60 → сдвинь правый ←
  22 + 35 = 57 < 60 → сдвинь левый →
  25 + 35 = 60 ✓ НАШЛИ!

  Всего 5 проверок вместо 21!
```

### Аналогия 3: Черепаха и заяц

Два друга бегут по круговой дорожке:
- Черепаха делает 1 шаг в секунду
- Заяц делает 2 шага в секунду

**Если дорожка — прямая линия:**
```
Черепаха: →→→→→→→→ (дошла до конца)
Заяц:     →→→→→→→→ →→→→→→→→ (дошёл до конца раньше)

Они НИКОГДА не встретятся после старта.
Заяц дойдёт до конца первым.
```

**Если дорожка — круг:**
```
    ┌──→──┐
    │     │
    ↑     ↓
    │     │
    └──←──┘

Заяц обгонит черепаху и догонит её на круге!
Если они встретились — значит, был круг (цикл).
```

### Аналогия 4: Уборка комнаты (Read/Write)

Тебе нужно разобрать стопку вещей на столе, оставив только уникальные:

```
Стопка: [книга, книга, ручка, ручка, ручка, карандаш]

Read-pointer: просматривает каждую вещь по очереди
Write-pointer: указывает, куда класть уникальные вещи

Шаг 0: R=0, W=0: книга — первая, кладём → [книга]
Шаг 1: R=1, W=0: книга — дубликат, пропускаем
Шаг 2: R=2, W=0: ручка — новая! W++, кладём → [книга, ручка]
Шаг 3-4: R=3,4: ручка — дубликаты, пропускаем
Шаг 5: R=5, W=1: карандаш — новый! W++, кладём → [книга, ручка, карандаш]

Результат: 3 уникальные вещи, без дополнительного места!
```

### Главный инсайт: Почему O(n) вместо O(n²)?

```
┌─────────────────────────────────────────────────────────────────┐
│                    КЛЮЧЕВОЕ НАБЛЮДЕНИЕ                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  НАИВНЫЙ ПОДХОД (вложенные циклы):                              │
│    for each element i:                                          │
│      for each element j:                                        │
│        check pair (i, j)                                        │
│    → n × n = O(n²) проверок                                    │
│                                                                 │
│  TWO POINTERS:                                                  │
│    left starts at 0                                             │
│    right starts at n-1                                          │
│    while (left < right):                                        │
│      check pair (left, right)                                   │
│      move ONE of them closer                                    │
│    → left может только увеличиваться (max n раз)               │
│    → right может только уменьшаться (max n раз)                │
│    → СУММАРНО max 2n движений = O(n)                           │
│                                                                 │
│  Экономия: не проверяем КАЖДУЮ пару!                           │
│  Сортировка позволяет ИСКЛЮЧИТЬ целые группы пар за один шаг.  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Часть 2: Почему Two Pointers бывает сложен?

> **Цель:** понять типичные трудности и как их избежать.

### Три разных паттерна под одним названием

**Главная путаница:** "Two Pointers" — это НЕ один алгоритм, а три РАЗНЫХ техники:

| Паттерн | Как двигаются | Когда использовать | Пример |
|---------|---------------|-------------------|--------|
| **Opposite Direction** | Навстречу друг другу | Отсортированные данные, пары | Two Sum II |
| **Same Direction** | Оба вправо, но с разной скоростью | In-place модификация | Remove Duplicates |
| **Fast/Slow** | Один шаг vs два шага | Циклы в списках | Linked List Cycle |

**Ошибка новичка:** применять один паттерн ко всем задачам.

### Типичные трудности

#### 1. Когда двигать какой указатель?

```
ПРОБЛЕМА: Решаю Two Sum II, сумма больше target.
          Что делать — left++ или right--?

РЕШЕНИЕ: Подумай, что ты ХОЧЕШЬ:
         - Сумма слишком большая → нужно УМЕНЬШИТЬ → right--
         - Сумма слишком маленькая → нужно УВЕЛИЧИТЬ → left++

         Это работает ТОЛЬКО потому что массив ОТСОРТИРОВАН!
         arr[left] — минимум доступного
         arr[right] — максимум доступного
```

#### 2. Границы: < или <=?

```
ПРОБЛЕМА: while (left < right) или while (left <= right)?

ОТВЕТ зависит от задачи:

< для ДВУХ РАЗНЫХ элементов:
  Two Sum — нужны ДВА разных индекса
  Когда left == right — это ОДИН элемент, не пара!

<= когда элемент может быть "ответом сам по себе":
  Binary Search — один элемент может быть target
```

#### 3. Fast/Slow: почему fast.next тоже проверяем?

```
// ОШИБКА:
while (fast != null) {
    fast = fast.next.next;  // CRASH! если fast.next == null
}

// ПРАВИЛЬНО:
while (fast != null && fast.next != null) {
    fast = fast.next.next;  // Безопасно
}

Почему? Заяц делает ДВА прыжка:
fast → fast.next → fast.next.next

Если fast.next == null, второй прыжок невозможен!
```

#### 4. Дубликаты в 3Sum

```
ПРОБЛЕМА: 3Sum возвращает дубликаты триплетов

nums = [-1, -1, 0, 1, 1]
       Триплет [-1, 0, 1] найден ДВАЖДЫ:
       - i=0: nums[0]=-1, нашли (0, 1)
       - i=1: nums[1]=-1, снова нашли (0, 1)

РЕШЕНИЕ: Пропускай дубликаты ПОСЛЕ обработки:
         if (i > 0 && nums[i] == nums[i-1]) continue;

         ВАЖНО: i > 0, иначе nums[i-1] выйдет за границы!
```

### Что отличает новичка от эксперта

| Новичок | Эксперт |
|---------|---------|
| Один шаблон на все задачи | Распознаёт какой из 3 паттернов нужен |
| `left <= right` везде | Знает когда `<` и когда `<=` |
| Забывает про дубликаты | Сразу думает об edge cases |
| Пишет код, потом думает | Сначала рисует пример на бумаге |
| Путает Same Direction с Sliding Window | Понимает разницу (Sliding Window — подтип) |

---

## Часть 3: Ментальные модели для Two Pointers

> **Цель:** дать 3 разных способа ДУМАТЬ о Two Pointers. Выбери тот, который тебе ближе.

### Модель 1: "Сужение пространства поиска"

**Идея:** Начинаем с МАКСИМАЛЬНОГО диапазона и сужаем его, исключая невозможные варианты.

```
┌─────────────────────────────────────────────────────────────────┐
│               СУЖЕНИЕ ПРОСТРАНСТВА ПОИСКА                       │
│                                                                 │
│   Начало: [L ─────────────────────────────────────────────── R] │
│           ↑                                                  ↑  │
│         left=0                                       right=n-1  │
│                                                                 │
│   Шаг 1: sum > target → все пары с right ИСКЛЮЧЕНЫ             │
│          [L ─────────────────────────────────────── R']         │
│                                                                 │
│   Шаг 2: sum < target → все пары с left ИСКЛЮЧЕНЫ              │
│          [L' ─────────────────────────────── R']                │
│                                                                 │
│   ...пока не найдём ответ или L >= R                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Когда использовать:** Opposite Direction, Binary Search.

### Модель 2: "Читатель и писатель"

**Идея:** Read-pointer просматривает данные, Write-pointer записывает результат.

```
┌─────────────────────────────────────────────────────────────────┐
│                    ЧИТАТЕЛЬ И ПИСАТЕЛЬ                          │
│                                                                 │
│   Массив: [1, 1, 2, 2, 3, 3, 3]                                 │
│                                                                 │
│   Read (R) просматривает КАЖДЫЙ элемент                        │
│   Write (W) записывает только НУЖНЫЕ                           │
│                                                                 │
│   [1, 1, 2, 2, 3, 3, 3]                                        │
│    W  R                   → 1 == 1, пропускаем                  │
│    W     R                → 2 != 1, W++, записываем             │
│       W     R             → 2 == 2, пропускаем                  │
│       W        R          → 3 != 2, W++, записываем             │
│          W        R       → 3 == 3, пропускаем                  │
│          W           R    → 3 == 3, пропускаем                  │
│                                                                 │
│   Результат: [1, 2, 3, ?, ?, ?, ?] — первые 3 элемента          │
│                                                                 │
│   Инвариант: W <= R (Write никогда не опережает Read)           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Когда использовать:** Remove Duplicates, Move Zeroes, Merge Arrays.

### Модель 3: "Черепаха и заяц"

**Идея:** Два указателя с РАЗНОЙ СКОРОСТЬЮ. Если есть цикл — догонит.

```
┌─────────────────────────────────────────────────────────────────┐
│                    ЧЕРЕПАХА И ЗАЯЦ                              │
│                                                                 │
│   БЕЗ ЦИКЛА (прямая дорога):                                   │
│                                                                 │
│   🐢 → → → → null                                               │
│   🐇 → → → → → → → → null                                       │
│                                                                 │
│   Заяц дойдёт до конца первым. Встречи не будет.               │
│                                                                 │
│   С ЦИКЛОМ (круговая дорога):                                   │
│                                                                 │
│       ┌──→──┐                                                   │
│       │  🐇 │                                                   │
│       ↑     ↓                                                   │
│       │ 🐢  │                                                   │
│       └──←──┘                                                   │
│                                                                 │
│   Заяц обгонит черепаху и догонит её на круге!                 │
│   Встреча = цикл существует.                                    │
│                                                                 │
│   Математика: разница в позициях уменьшается на 1 за шаг.       │
│   Максимум через cycle_length шагов они встретятся.             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Когда использовать:** Cycle Detection, Find Middle, Happy Number.

### Как выбрать модель?

```
                    Какая задача?
                         │
         ┌───────────────┼───────────────┐
         │               │               │
    Отсортированные   In-place        Связный
    данные, пары?     модификация?    список/цикл?
         │               │               │
         ↓               ↓               ↓
    Модель 1:       Модель 2:       Модель 3:
    "Сужение"       "Read/Write"    "Floyd"

    Opposite        Same            Fast/Slow
    Direction       Direction       Pointers
```

---

## Зачем это нужно?

**Реальная проблема:**

Дан отсортированный массив из 1 миллиона чисел. Нужно найти пару чисел с заданной суммой.

Наивный подход: два вложенных цикла = 10^12 операций ≈ 15+ минут.
Two Pointers: один проход = 10^6 операций ≈ 1 миллисекунда.

**Где используется:**

| Область | Применение | Пример |
|---------|------------|--------|
| Финансы | Поиск арбитражных пар | Торговые алгоритмы |
| Базы данных | Merge Join операции | Слияние отсортированных индексов |
| Строки | Палиндром-проверки | Валидация данных |
| Графика | Collision detection | AABB проверки |
| Сети | Flow control | TCP sliding window |
| ML | Feature pairing | Поиск коррелирующих признаков |

**Статистика:**
- 15-20% задач на интервью используют Two Pointers напрямую
- LeetCode: 200+ задач с тегом Two Pointers
- Паттерн присутствует в 87% интервью FAANG по алгоритмам

---

## Prerequisites (Что нужно знать)

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **Массивы** | Two Pointers работает с индексами массивов | [[arrays-strings]] |
| **Связные списки** | Fast/Slow pointer для циклов | [[linked-lists]] |
| **Big O нотация** | Понимание O(n) vs O(n²) | [[big-o-complexity]] |
| **Сортировка** | Opposite direction требует sorted data | [[sorting-algorithms]] |
| **CS: Указатели** | Концепция pointer arithmetic | Основы программирования |
| **CS: Инварианты** | Условия, сохраняющиеся между итерациями | Теория алгоритмов |

---

## Что это такое?

### Объяснение для 5-летнего

Представь книгу с номерами страниц от 1 до 100. Тебе нужно найти две страницы, номера которых в сумме дают 50.

Можно листать с начала и для каждой страницы проверять все остальные — это долго!

А можно поставить два пальца: один на первую страницу (1), другой на последнюю (100).
- Если сумма слишком большая (1 + 100 = 101 > 50) — двигай правый палец влево
- Если слишком маленькая — двигай левый вправо
- Найдёшь ответ очень быстро!

```
📖 Книга с страницами 1-100, ищем сумму 50

Шаг 1: [1] ... ... ... ... [100]   1+100=101 > 50, двигаем правый
Шаг 2: [1] ... ... ... [49]        1+49=50 ✓ Найдено!
```

### Формальное определение

**Two Pointers** — алгоритмический паттерн, использующий два указателя (индекса) для итерации по структуре данных, где движение указателей зависит от некоторого условия, позволяя решить задачу за один проход.

**Ключевые свойства:**
- **Два указателя**: left/right, slow/fast, read/write
- **Условное движение**: каждый указатель двигается по своему правилу
- **Инвариант**: условие, которое всегда выполняется между указателями
- **Линейная сложность**: O(n) вместо O(n²)

**Три основные вариации:**

```
1. Opposite Direction (сходящиеся)
   [L→ ... ... ... ←R]
   Используют: Two Sum, Container With Most Water

2. Same Direction (однонаправленные)
   [S→ F→ ... ... ...]
   Используют: Remove Duplicates, Sliding Window

3. Fast/Slow (разная скорость)
   [S→ ... F→→ ... ...]
   Используют: Cycle Detection, Find Middle
```

---

## Терминология

| Термин | Определение | Пример |
|--------|-------------|--------|
| **Left Pointer** | Указатель в начале структуры | `left = 0` |
| **Right Pointer** | Указатель в конце структуры | `right = n - 1` |
| **Slow Pointer** | Медленный указатель (шаг = 1) | Движется на 1 элемент |
| **Fast Pointer** | Быстрый указатель (шаг = 2+) | Движется на 2 элемента |
| **Invariant** | Условие между указателями | `left < right` всегда |
| **Shrink** | Сужение диапазона | Сдвиг left вправо или right влево |
| **Expand** | Расширение диапазона | Сдвиг fast вперёд |
| **Collision** | Встреча указателей | `left == right` |

---

## Как это работает?

### Вариация 1: Opposite Direction (Сходящиеся указатели)

```
Two Sum II — Найти пару с заданной суммой в отсортированном массиве

Array: [2, 7, 11, 15], Target: 9

Шаг 0: Инициализация
        L              R
       [2,    7,   11,  15]
        ↑              ↑
       sum = 2 + 15 = 17 > 9 → двигаем R влево

Шаг 1:
        L         R
       [2,    7,   11,  15]
        ↑         ↑
       sum = 2 + 11 = 13 > 9 → двигаем R влево

Шаг 2:
        L    R
       [2,    7,   11,  15]
        ↑    ↑
       sum = 2 + 7 = 9 = 9 ✓ НАЙДЕНО!

Результат: indices (0, 1), values (2, 7)
```

**Почему это работает?**

```
Ключевой инвариант для отсортированного массива:
- Если sum > target: нужно уменьшить сумму → двигаем right влево
- Если sum < target: нужно увеличить сумму → двигаем left вправо
- Каждый шаг сужает пространство поиска минимум на 1

Доказательство корректности:
- Пусть ответ (i, j) где i < j
- Алгоритм рассмотрит все пары (left, right) где left ≤ i и right ≥ j
- Значит пара (i, j) обязательно будет рассмотрена
```

### Вариация 2: Same Direction (Однонаправленные указатели)

```
Remove Duplicates — Удалить дубликаты in-place

Array: [1, 1, 2, 2, 2, 3]

Шаг 0: Инициализация
       W  R
       [1, 1, 2, 2, 2, 3]
        ↑  ↑
       arr[W] = arr[R]? → W не двигается, R двигается

Шаг 1:
       W     R
       [1, 1, 2, 2, 2, 3]
        ↑     ↑
       arr[W] ≠ arr[R]? → W++, записываем arr[R]

       [1, 2, 2, 2, 2, 3]
           W  R

Шаг 2-3: R проходит дубликаты 2
          W        R
       [1, 2, 2, 2, 2, 3]
           ↑        ↑

Шаг 4: arr[W] ≠ arr[R]
          W           R
       [1, 2, 3, 2, 2, 3]
              ↑        ↑

Результат: первые 3 элемента [1, 2, 3]
```

**Read/Write паттерн:**
```
W (Write) — куда записываем уникальные элементы
R (Read)  — откуда читаем следующий элемент

Инвариант: все элементы [0..W] уникальны
```

### Вариация 3: Fast/Slow (Floyd's Tortoise and Hare)

```
Cycle Detection в связном списке

Список с циклом:
    1 → 2 → 3 → 4
            ↑   ↓
            6 ← 5

Шаг 0: slow = 1, fast = 1
Шаг 1: slow = 2, fast = 3
Шаг 2: slow = 3, fast = 5
Шаг 3: slow = 4, fast = 3 (прошёл цикл!)
Шаг 4: slow = 5, fast = 5 → ВСТРЕТИЛИСЬ! Цикл обнаружен.

Без цикла:
    1 → 2 → 3 → null

Шаг 0: slow = 1, fast = 1
Шаг 1: slow = 2, fast = 3
Шаг 2: slow = 3, fast = null → Конец списка, цикла нет.
```

**Математическое обоснование:**

```
Пусть:
- L = длина "хвоста" до входа в цикл
- C = длина цикла

Когда slow входит в цикл (прошёл L шагов):
- fast прошёл 2L шагов
- fast находится на позиции (2L - L) mod C = L mod C внутри цикла

Разница позиций: C - (L mod C)
На каждом шаге разница уменьшается на 1 (fast +2, slow +1, разница +1)
Максимум через C шагов они встретятся.

Общая сложность: O(L + C) = O(n)
```

---

## Сложность операций

| Паттерн | Время | Память | Типичные задачи |
|---------|-------|--------|-----------------|
| Opposite Direction | O(n) | O(1) | Two Sum II, Container Water |
| Same Direction | O(n) | O(1) | Remove Duplicates, Merge Arrays |
| Fast/Slow | O(n) | O(1) | Cycle Detection, Find Middle |
| Three Pointers (3Sum) | O(n²) | O(1) | 3Sum, 3Sum Closest |

**Почему O(n)?**

```
Opposite Direction:
- left начинает с 0, может только увеличиваться
- right начинает с n-1, может только уменьшаться
- Каждую итерацию двигается хотя бы один указатель
- Максимум n итераций

Same Direction:
- Оба указателя начинают с 0 (или близко)
- Каждую итерацию хотя бы один двигается вправо
- Каждый элемент посещается максимум 2 раза
- Суммарно O(n) операций

Fast/Slow:
- Максимум O(n + cycle_length) = O(n)
- После входа в цикл — максимум cycle_length шагов до встречи
```

---

## Реализация

### Kotlin

```kotlin
// ═══════════════════════════════════════════════════════════════════════════
// TWO SUM II — OPPOSITE DIRECTION
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Two Sum II — поиск пары с заданной суммой в ОТСОРТИРОВАННОМ массиве
 *
 * ИДЕЯ: Два указателя с разных концов. Сумма слишком мала? Двигаем левый.
 *       Сумма слишком велика? Двигаем правый.
 *
 * ПОШАГОВЫЙ ПРИМЕР: [2,7,11,15], target=9
 *   left=0 (2), right=3 (15): sum=17 > 9 → right--
 *   left=0 (2), right=2 (11): sum=13 > 9 → right--
 *   left=0 (2), right=1 (7):  sum=9 = target → return [1,2]
 */
fun twoSum(numbers: IntArray, target: Int): IntArray {
    var left = 0
    var right = numbers.lastIndex

    // Указатели двигаются навстречу, но не должны совпасть
    while (left < right) {
        val sum = numbers[left] + numbers[right]

        when {
            sum == target -> return intArrayOf(left + 1, right + 1)  // 1-indexed по условию задачи
            sum < target -> left++   // Сумма мала → нужно больше → сдвигаем левый вправо
            else -> right--          // Сумма велика → нужно меньше → сдвигаем правый влево
        }
    }

    return intArrayOf(-1, -1)  // По условию решение всегда есть
}

// ═══════════════════════════════════════════════════════════════════════════
// 3SUM — OPPOSITE DIRECTION С ВНЕШНИМ ЦИКЛОМ
// ═══════════════════════════════════════════════════════════════════════════

/**
 * 3Sum — найти все уникальные триплеты с суммой 0
 *
 * ИДЕЯ: Фиксируем первый элемент, для оставшихся применяем Two Sum II
 *
 * ПОШАГОВЫЙ ПРИМЕР: [-1,0,1,2,-1,-4]
 *   После сортировки: [-4,-1,-1,0,1,2]
 *   i=0 (-4): ищем пару с суммой 4 в [-1,-1,0,1,2] → нет
 *   i=1 (-1): ищем пару с суммой 1 → [0,1] найден! Триплет: [-1,0,1]
 *   i=2 (-1): пропускаем (дубликат)
 *   ...
 */
fun threeSum(nums: IntArray): List<List<Int>> {
    val result = mutableListOf<List<Int>>()
    // Сортировка: 1) Two Pointers работает 2) Легко пропустить дубликаты
    nums.sort()

    for (i in 0 until nums.size - 2) {
        // Пропускаем дубликаты первого элемента → избегаем повторных триплетов
        if (i > 0 && nums[i] == nums[i - 1]) continue

        // Оптимизация: если nums[i] > 0, то nums[i] + nums[left] + nums[right] > 0
        // (все оставшиеся положительные) → дальше искать бесмысленно
        if (nums[i] > 0) break

        var left = i + 1
        var right = nums.lastIndex
        // Ищем пару с суммой -nums[i], тогда сумма триплета = 0
        val target = -nums[i]

        while (left < right) {
            val sum = nums[left] + nums[right]

            when {
                sum == target -> {
                    result.add(listOf(nums[i], nums[left], nums[right]))
                    left++
                    right--
                    // Пропускаем дубликаты для left и right
                    while (left < right && nums[left] == nums[left - 1]) left++
                    while (left < right && nums[right] == nums[right + 1]) right--
                }
                sum < target -> left++
                else -> right--
            }
        }
    }

    return result
}

// ═══════════════════════════════════════════════════════════════════════════
// CONTAINER WITH MOST WATER — OPPOSITE DIRECTION
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Container With Most Water — максимальная площадь воды между двумя линиями
 *
 * ИДЕЯ: Площадь = ширина × min(высота_левой, высота_правой)
 *       Начинаем с максимальной ширины, сужаем, двигая меньшую линию
 *
 * ПОЧЕМУ ДВИГАЕМ МЕНЬШУЮ?
 *   Площадь ограничена меньшей высотой. Если двигать бóльшую линию:
 *   - ширина уменьшится
 *   - высота не вырастет (ограничена оставшейся меньшей)
 *   → площадь точно не увеличится!
 *
 *   Двигая меньшую, есть шанс найти более высокую → возможный выигрыш
 */
fun maxArea(height: IntArray): Int {
    var left = 0
    var right = height.lastIndex
    var maxWater = 0

    while (left < right) {
        val width = right - left
        // Уровень воды ограничен меньшей из двух стенок
        val h = minOf(height[left], height[right])
        maxWater = maxOf(maxWater, width * h)

        // Двигаем указатель с меньшей высотой
        if (height[left] < height[right]) {
            left++
        } else {
            right--
        }
    }

    return maxWater
}

// ═══════════════════════════════════════════════════════════════════════════
// REMOVE DUPLICATES — SAME DIRECTION
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Remove Duplicates from Sorted Array — удаление дубликатов in-place
 *
 * ИДЕЯ: writePtr — граница "чистой" части, readPtr — сканирование
 *
 * ПОШАГОВЫЙ ПРИМЕР: [1,1,2,2,3]
 *   write=0, read=1: nums[1]=1 = nums[0]=1 → пропуск
 *   write=0, read=2: nums[2]=2 ≠ nums[0]=1 → write++, nums[1]=2 → [1,2,2,2,3]
 *   write=1, read=3: nums[3]=2 = nums[1]=2 → пропуск
 *   write=1, read=4: nums[4]=3 ≠ nums[1]=2 → write++, nums[2]=3 → [1,2,3,2,3]
 *   Результат: первые 3 элемента уникальны
 */
fun removeDuplicates(nums: IntArray): Int {
    if (nums.isEmpty()) return 0

    // writePtr указывает на последний записанный уникальный элемент
    var writePtr = 0

    for (readPtr in 1 until nums.size) {
        // Нашли новый уникальный элемент (отличается от последнего записанного)
        if (nums[readPtr] != nums[writePtr]) {
            writePtr++
            nums[writePtr] = nums[readPtr]
        }
    }

    // Количество уникальных = последний индекс + 1
    return writePtr + 1
}

// ═══════════════════════════════════════════════════════════════════════════
// MOVE ZEROES — SAME DIRECTION
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Move Zeroes — переместить нули в конец, сохранив порядок остальных
 *
 * ПОШАГОВЫЙ ПРИМЕР: [0,1,0,3,12]
 *   Проход 1: writePtr собирает ненулевые → [1,3,12,3,12], writePtr=3
 *   Проход 2: заполняем [3..4] нулями → [1,3,12,0,0]
 */
fun moveZeroes(nums: IntArray) {
    // Позиция для записи следующего ненулевого элемента
    var writePtr = 0

    // Проход 1: переносим все ненулевые в начало
    for (readPtr in nums.indices) {
        if (nums[readPtr] != 0) {
            nums[writePtr] = nums[readPtr]
            writePtr++
        }
    }

    // Проход 2: заполняем остаток нулями
    for (i in writePtr until nums.size) {
        nums[i] = 0
    }
}

/**
 * Move Zeroes за один проход через swap
 *
 * Swap меняет ненулевой с нулём (или с самим собой)
 */
fun moveZeroesOnePass(nums: IntArray) {
    var writePtr = 0

    for (readPtr in nums.indices) {
        if (nums[readPtr] != 0) {
            // Swap: ненулевой идёт на место writePtr, ноль "всплывает" вправо
            nums[writePtr] = nums[readPtr].also { nums[readPtr] = nums[writePtr] }
            writePtr++
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// LINKED LIST CYCLE — FAST/SLOW
// ═══════════════════════════════════════════════════════════════════════════

class ListNode(var `val`: Int) {
    var next: ListNode? = null
}

/**
 * Linked List Cycle — определение наличия цикла (алгоритм Флойда)
 *
 * ИДЕЯ: Быстрый указатель (2 шага) и медленный (1 шаг)
 *       Если есть цикл — они встретятся внутри цикла
 *       Если нет цикла — быстрый дойдёт до null
 *
 * АНАЛОГИЯ: Два бегуна на круговой дорожке — быстрый догонит медленного
 */
fun hasCycle(head: ListNode?): Boolean {
    var slow = head
    var fast = head

    // fast идёт на 2 шага → проверяем и fast, и fast.next
    while (fast?.next != null) {
        slow = slow?.next          // Черепаха: 1 шаг
        fast = fast.next?.next     // Заяц: 2 шага

        // === сравнивает ссылки (один и тот же объект), не значения
        if (slow === fast) {
            return true
        }
    }

    // fast дошёл до конца списка → цикла нет
    return false
}

// ═══════════════════════════════════════════════════════════════════════════
// LINKED LIST CYCLE II — НАЙТИ НАЧАЛО ЦИКЛА
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Linked List Cycle II — найти узел начала цикла
 *
 * МАТЕМАТИЧЕСКОЕ ДОКАЗАТЕЛЬСТВО:
 *   Пусть: a = расстояние от head до входа в цикл
 *          b = расстояние от входа до точки встречи
 *          c = длина цикла
 *
 *   slow прошёл: a + b
 *   fast прошёл: a + b + k*c (обогнал на k кругов)
 *   fast = 2*slow → a + b + k*c = 2*(a + b) → k*c = a + b
 *
 *   От точки встречи до входа: c - b = a (mod c)
 *   → Двигаясь от head и от точки встречи по 1 шагу, встретимся на входе!
 */
fun detectCycle(head: ListNode?): ListNode? {
    var slow = head
    var fast = head

    // Фаза 1: Обнаружение цикла
    while (fast?.next != null) {
        slow = slow?.next
        fast = fast.next?.next

        if (slow === fast) {
            // Фаза 2: Поиск начала цикла
            // Расстояние от head до входа = расстояние от точки встречи до входа
            var ptr = head
            while (ptr !== slow) {
                ptr = ptr?.next
                slow = slow?.next
            }
            return ptr
        }
    }

    return null
}

// ═══════════════════════════════════════════════════════════════════════════
// FIND MIDDLE OF LINKED LIST — FAST/SLOW
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Middle of Linked List — поиск середины за один проход
 *
 * ИДЕЯ: fast проходит 2n шагов → когда fast в конце, slow на n (середина)
 *
 * ПРИМЕР для [1,2,3,4,5]:
 *   fast=1,slow=1 → fast=3,slow=2 → fast=5,slow=3 → fast.next=null → return slow=3
 *
 * Для чётной длины [1,2,3,4]: возвращает второй из двух средних (3)
 */
fun middleNode(head: ListNode?): ListNode? {
    var slow = head
    var fast = head

    // Когда fast дойдёт до конца, slow будет на середине
    while (fast?.next != null) {
        slow = slow?.next
        fast = fast.next?.next
    }

    return slow
}

// ═══════════════════════════════════════════════════════════════════════════
// VALID PALINDROME — OPPOSITE DIRECTION
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Valid Palindrome — проверка палиндрома с игнорированием спецсимволов
 *
 * ПРИМЕР: "A man, a plan, a canal: Panama" → true
 *   Только буквы/цифры: "amanaplanacanalpanama"
 *   Сравниваем с концов → палиндром
 */
fun isPalindrome(s: String): Boolean {
    var left = 0
    var right = s.lastIndex

    while (left < right) {
        // Пропускаем не-буквенно-цифровые символы
        while (left < right && !s[left].isLetterOrDigit()) left++
        while (left < right && !s[right].isLetterOrDigit()) right--

        // Case-insensitive сравнение
        if (s[left].lowercaseChar() != s[right].lowercaseChar()) {
            return false
        }

        left++
        right--
    }

    return true
}

// ═══════════════════════════════════════════════════════════════════════════
// PALINDROME LINKED LIST — FAST/SLOW + REVERSE
// ═══════════════════════════════════════════════════════════════════════════

fun isPalindromeList(head: ListNode?): Boolean {
    if (head?.next == null) return true

    // Шаг 1: Найти середину через fast/slow
    var slow = head
    var fast = head
    while (fast?.next != null) {
        slow = slow?.next
        fast = fast.next?.next
    }

    // Шаг 2: Развернуть вторую половину
    var prev: ListNode? = null
    var curr = slow
    while (curr != null) {
        val next = curr.next
        curr.next = prev
        prev = curr
        curr = next
    }

    // Шаг 3: Сравнить две половины
    var p1 = head
    // prev после разворота указывает на "новую голову" развёрнутой половины
    var p2 = prev
    while (p2 != null) {
        if (p1?.`val` != p2.`val`) return false
        p1 = p1.next
        p2 = p2.next
    }

    return true
}

// ═══════════════════════════════════════════════════════════════════════════
// TRAPPING RAIN WATER — OPPOSITE DIRECTION
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Trapping Rain Water — сколько воды удержится между столбцами
 *
 * ИДЕЯ: Вода в позиции i = min(maxLeft, maxRight) - height[i]
 *       Используем Two Pointers чтобы не вычислять max заранее
 *
 * КЛЮЧЕВОЕ НАБЛЮДЕНИЕ:
 *   Если height[left] < height[right], то уровень воды в left
 *   определяется leftMax (справа точно есть что-то ≥ height[right] > height[left])
 *
 * ВИЗУАЛИЗАЦИЯ: [0,1,0,2,1,0,1,3,2,1,2,1]
 *                   █               █
 *               █   █ █   █ █   █ █ █
 *             █ █ █ █ █ █ █ █ █ █ █ █
 *   Вода заполняет "ямы" между столбцами → answer = 6
 */
fun trap(height: IntArray): Int {
    if (height.isEmpty()) return 0

    var left = 0
    var right = height.lastIndex
    var leftMax = 0
    var rightMax = 0
    var water = 0

    while (left < right) {
        // Обрабатываем сторону с меньшей высотой — она гарантированно определяет уровень
        if (height[left] < height[right]) {
            if (height[left] >= leftMax) {
                leftMax = height[left]  // Новый максимум — вода здесь не задержится
            } else {
                water += leftMax - height[left]  // Вода = разница с максимумом
            }
            left++
        } else {
            if (height[right] >= rightMax) {
                rightMax = height[right]
            } else {
                water += rightMax - height[right]
            }
            right--
        }
    }

    return water
}
```

### Java

```java
// ═══════════════════════════════════════════════════════════════════════════
// TWO SUM II — OPPOSITE DIRECTION
// ═══════════════════════════════════════════════════════════════════════════

public int[] twoSum(int[] numbers, int target) {
    int left = 0;
    int right = numbers.length - 1;

    while (left < right) {
        int sum = numbers[left] + numbers[right];

        if (sum == target) {
            return new int[]{left + 1, right + 1};  // 1-indexed по условию задачи
        } else if (sum < target) {
            left++;
        } else {
            right--;
        }
    }

    return new int[]{-1, -1};
}

// ═══════════════════════════════════════════════════════════════════════════
// 3SUM
// ═══════════════════════════════════════════════════════════════════════════

public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    Arrays.sort(nums);

    for (int i = 0; i < nums.length - 2; i++) {
        if (i > 0 && nums[i] == nums[i - 1]) continue;  // Пропускаем дубликаты
        if (nums[i] > 0) break;  // Оптимизация: если i > 0, все суммы будут > 0

        int left = i + 1;
        int right = nums.length - 1;
        int target = -nums[i];

        while (left < right) {
            int sum = nums[left] + nums[right];

            if (sum == target) {
                result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                left++;
                right--;
                while (left < right && nums[left] == nums[left - 1]) left++;
                while (left < right && nums[right] == nums[right + 1]) right--;
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
    }

    return result;
}

// ═══════════════════════════════════════════════════════════════════════════
// LINKED LIST CYCLE DETECTION
// ═══════════════════════════════════════════════════════════════════════════

public boolean hasCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;

    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;

        if (slow == fast) {
            return true;
        }
    }

    return false;
}
```

### Python

```python
# ═══════════════════════════════════════════════════════════════════════════
# TWO SUM II — OPPOSITE DIRECTION
# ═══════════════════════════════════════════════════════════════════════════

def two_sum(numbers: list[int], target: int) -> list[int]:
    left, right = 0, len(numbers) - 1

    while left < right:
        current_sum = numbers[left] + numbers[right]

        if current_sum == target:
            return [left + 1, right + 1]  # WHY: 1-indexed
        elif current_sum < target:
            left += 1
        else:
            right -= 1

    return [-1, -1]

# ═══════════════════════════════════════════════════════════════════════════
# 3SUM
# ═══════════════════════════════════════════════════════════════════════════

def three_sum(nums: list[int]) -> list[list[int]]:
    nums.sort()
    result = []

    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue  # WHY: skip duplicates

        if nums[i] > 0:
            break  # WHY: optimization

        left, right = i + 1, len(nums) - 1
        target = -nums[i]

        while left < right:
            current_sum = nums[left] + nums[right]

            if current_sum == target:
                result.append([nums[i], nums[left], nums[right]])
                left += 1
                right -= 1
                # WHY: skip duplicates
                while left < right and nums[left] == nums[left - 1]:
                    left += 1
                while left < right and nums[right] == nums[right + 1]:
                    right -= 1
            elif current_sum < target:
                left += 1
            else:
                right -= 1

    return result

# ═══════════════════════════════════════════════════════════════════════════
# CONTAINER WITH MOST WATER
# ═══════════════════════════════════════════════════════════════════════════

def max_area(height: list[int]) -> int:
    left, right = 0, len(height) - 1
    max_water = 0

    while left < right:
        width = right - left
        h = min(height[left], height[right])
        max_water = max(max_water, width * h)

        # WHY: move pointer with smaller height
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1

    return max_water

# ═══════════════════════════════════════════════════════════════════════════
# LINKED LIST CYCLE — FAST/SLOW
# ═══════════════════════════════════════════════════════════════════════════

def has_cycle(head: ListNode) -> bool:
    slow = fast = head

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

        if slow is fast:  # WHY: identity check, not equality
            return True

    return False

# ═══════════════════════════════════════════════════════════════════════════
# TRAPPING RAIN WATER
# ═══════════════════════════════════════════════════════════════════════════

def trap(height: list[int]) -> int:
    if not height:
        return 0

    left, right = 0, len(height) - 1
    left_max = right_max = 0
    water = 0

    while left < right:
        if height[left] < height[right]:
            if height[left] >= left_max:
                left_max = height[left]
            else:
                water += left_max - height[left]
            left += 1
        else:
            if height[right] >= right_max:
                right_max = height[right]
            else:
                water += right_max - height[right]
            right -= 1

    return water
```

---

## Распространённые ошибки

### 1. Неправильное условие цикла

```kotlin
// ❌ НЕПРАВИЛЬНО: left <= right может привести к использованию одного элемента дважды
while (left <= right) {
    if (arr[left] + arr[right] == target) // может вернуть (i, i)
}

// ✅ ПРАВИЛЬНО: строго меньше для двух разных элементов
while (left < right) {
    // ...
}
```

### 2. Забыли двигать указатель после нахождения ответа (3Sum)

```kotlin
// ❌ НЕПРАВИЛЬНО: бесконечный цикл после нахождения триплета
if (sum == target) {
    result.add(listOf(nums[i], nums[left], nums[right]))
    // Забыли left++ и right--
}

// ✅ ПРАВИЛЬНО: двигаем оба указателя
if (sum == target) {
    result.add(listOf(nums[i], nums[left], nums[right]))
    left++
    right--
    // И пропускаем дубликаты!
    while (left < right && nums[left] == nums[left - 1]) left++
    while (left < right && nums[right] == nums[right + 1]) right--
}
```

### 3. Неправильный выбор вариации

```kotlin
// ❌ НЕПРАВИЛЬНО: использовать opposite direction для неотсортированного массива
fun twoSumUnsorted(nums: IntArray, target: Int): IntArray {
    var left = 0
    var right = nums.lastIndex
    // Не работает! Нужен HashMap или сортировка
}

// ✅ ПРАВИЛЬНО: HashMap для неотсортированного
fun twoSumUnsorted(nums: IntArray, target: Int): IntArray {
    val seen = mutableMapOf<Int, Int>()
    for ((i, num) in nums.withIndex()) {
        val complement = target - num
        seen[complement]?.let { return intArrayOf(it, i) }
        seen[num] = i
    }
    return intArrayOf(-1, -1)
}
```

### 4. Fast/Slow: проверка только fast

```kotlin
// ❌ НЕПРАВИЛЬНО: NullPointerException на fast.next
while (fast != null) {
    slow = slow?.next
    fast = fast.next.next  // Crash если fast.next == null!
}

// ✅ ПРАВИЛЬНО: проверяем и fast, и fast.next
while (fast?.next != null) {
    slow = slow?.next
    fast = fast.next?.next
}
```

### 5. Пропуск дубликатов в неправильном месте

```kotlin
// ❌ НЕПРАВИЛЬНО: пропускаем дубликаты ДО добавления первого элемента
for (i in nums.indices) {
    if (nums[i] == nums[i - 1]) continue  // IndexOutOfBounds при i = 0!
}

// ✅ ПРАВИЛЬНО: проверяем i > 0
for (i in nums.indices) {
    if (i > 0 && nums[i] == nums[i - 1]) continue
}
```

### 6. Модификация массива в Same Direction без сохранения оригинала

```kotlin
// ❌ НЕПРАВИЛЬНО: теряем данные при swap
fun removeDuplicatesBad(nums: IntArray): Int {
    for (i in 1 until nums.size) {
        if (nums[i] != nums[i-1]) {
            nums[writePtr++] = nums[i]  // Может затереть ещё не прочитанные
        }
    }
}

// ✅ ПРАВИЛЬНО: read всегда впереди write, данные не теряются
fun removeDuplicatesGood(nums: IntArray): Int {
    var writePtr = 0
    for (readPtr in 1 until nums.size) {  // readPtr всегда >= writePtr
        if (nums[readPtr] != nums[writePtr]) {
            writePtr++
            nums[writePtr] = nums[readPtr]
        }
    }
    return writePtr + 1
}
```

---

## Когда использовать?

### Decision Tree

```
Задача на массив/строку/список?
│
├─ Да → Отсортирован или можно сортировать?
│       │
│       ├─ Да → Ищем пару с условием (сумма, разность)?
│       │       │
│       │       └─ Да → OPPOSITE DIRECTION
│       │
│       └─ Да → Нужно модифицировать in-place?
│               │
│               └─ Да → SAME DIRECTION (Read/Write)
│
├─ Связный список → Цикл? Середина? Палиндром?
│       │
│       └─ Да → FAST/SLOW (Floyd's)
│
└─ Подмассив с условием? → SLIDING WINDOW (см. следующий паттерн)
```

### Сравнение с альтернативами

| Задача | Two Pointers | Альтернатива | Когда что |
|--------|--------------|--------------|-----------|
| Two Sum (sorted) | O(n), O(1) | HashMap O(n), O(n) | TP лучше если отсортировано |
| Two Sum (unsorted) | O(n log n) + O(n) | HashMap O(n), O(n) | HashMap лучше |
| Cycle Detection | O(n), O(1) | HashSet O(n), O(n) | TP экономит память |
| 3Sum | O(n²), O(1) | HashMap O(n²), O(n) | TP проще с дубликатами |
| Remove Duplicates | O(n), O(1) | New Array O(n), O(n) | TP для in-place |

### Признаки Two Pointers задачи

1. **Отсортированный массив** — почти всегда Two Pointers
2. **Пара элементов с условием** — opposite direction
3. **In-place модификация** — same direction
4. **Связный список + цикл/середина** — fast/slow
5. **Слова: "minimum", "maximum", "closest"** — часто Two Pointers

---

## Практика

### Концептуальные вопросы

1. **Почему Two Pointers работает только на отсортированных данных (для opposite direction)?**

   *Ответ:* Потому что сортировка даёт предсказуемость: если сумма слишком большая — двигаем правый указатель (уменьшаем), если маленькая — левый (увеличиваем). На неотсортированных данных нет гарантии, что движение указателя изменит сумму в нужную сторону.

2. **Как fast/slow доказывает наличие цикла?**

   *Ответ:* Если цикл есть, fast "обгонит" slow и в какой-то момент они встретятся внутри цикла (разница в позициях уменьшается на 1 каждую итерацию). Если цикла нет, fast дойдёт до null раньше.

3. **Почему в 3Sum сложность O(n²), а не O(n)?**

   *Ответ:* Внешний цикл O(n) фиксирует первый элемент, внутренний Two Pointers O(n) ищет пару. Итого O(n) × O(n) = O(n²).

4. **Как модифицировать Two Sum для поиска разности вместо суммы?**

   *Ответ:* Для отсортированного массива — так же, но условия другие: если `arr[right] - arr[left] > target`, двигаем right; если меньше — двигаем left.

### LeetCode задачи

#### Easy

| # | Название | Паттерн | Ключевой момент |
|---|----------|---------|-----------------|
| 167 | Two Sum II | Opposite | Базовый opposite direction |
| 125 | Valid Palindrome | Opposite | Пропуск не-alphanumeric |
| 283 | Move Zeroes | Same | Read/Write in-place |
| 344 | Reverse String | Opposite | Swap с двух концов |
| 141 | Linked List Cycle | Fast/Slow | Базовый Floyd |
| 876 | Middle of Linked List | Fast/Slow | Fast дойдёт до конца |

#### Medium

| # | Название | Паттерн | Ключевой момент |
|---|----------|---------|-----------------|
| 11 | Container With Most Water | Opposite | Двигаем меньшую сторону |
| 15 | 3Sum | Opposite + loop | Пропуск дубликатов |
| 16 | 3Sum Closest | Opposite + loop | Отслеживание минимальной разницы |
| 142 | Linked List Cycle II | Fast/Slow | Фаза 2 для поиска входа |
| 881 | Boats to Save People | Opposite | Greedy pairing |
| 80 | Remove Duplicates II | Same | Разрешить до 2 дубликатов |

#### Hard

| # | Название | Паттерн | Ключевой момент |
|---|----------|---------|-----------------|
| 42 | Trapping Rain Water | Opposite | leftMax/rightMax tracking |
| 75 | Sort Colors | Same (3 ptr) | Dutch National Flag |

---

## Мифы и заблуждения

| Миф | Реальность |
|-----|-----------|
| "Two Pointers работает только с отсортированными массивами" | **Нет!** Opposite direction требует сортировку, но Same Direction (remove duplicates) и Fast/Slow (cycle detection) работают с любыми данными. Паттерн определяется не сортировкой, а возможностью принимать решение о движении указателей |
| "Two Pointers — это просто два цикла" | **Нет!** Ключевое отличие: в Two Pointers оба указателя двигаются в ОДНОМ проходе по условию, а не во вложенных циклах. Именно это даёт O(n) вместо O(n²) |
| "Fast/Slow pointer всегда найдёт цикл" | **Только если цикл существует!** Если списка без цикла, fast просто дойдёт до null. Алгоритм гарантирует обнаружение цикла, но не его наличие |
| "Sliding Window — это тот же Two Pointers" | **Частично верно.** Sliding Window — это подтип Same Direction Two Pointers, но с дополнительным ограничением: окно должно быть непрерывным и часто фиксированного или переменного размера. Two Pointers шире |
| "Three Sum нельзя решить за O(n²)" | **Можно!** Фиксируем первый элемент циклом O(n), для оставшихся применяем Two Pointers O(n). Итого O(n²), а не O(n³). Это оптимально для comparison-based подхода |
| "Two Pointers всегда эффективнее HashMap" | **Не всегда!** HashMap даёт O(n) для Two Sum без сортировки. Two Pointers требует O(n log n) на сортировку. Выбор зависит от: нужна ли сортировка, ограничения памяти, повторные запросы |
| "При cycle detection достаточно найти пересечение" | **Нет!** Пересечение fast и slow указателей находит КАКУЮ-ТО точку в цикле, но не начало цикла. Для нахождения начала нужна вторая фаза: сброс одного указателя на head |
| "Two Pointers не работает со связными списками" | **Работает отлично!** Fast/Slow — классика для списков: find middle, detect cycle, find cycle start. Pointer arithmetic заменяется на `.next` переходы |

---

## CS-фундамент

| CS-концепция | Применение в Two Pointers |
|--------------|---------------------------|
| **Pointer Arithmetic** | Указатели `left`, `right` — индексы в массиве. Операции `left++`, `right--` — арифметика указателей. В связных списках: `slow = slow.next`, `fast = fast.next.next` |
| **Invariant Maintenance** | Условие `left < right` или `slow != fast` должно поддерживаться. Инвариант определяет корректность алгоритма. Нарушение инварианта = баг |
| **Linear Scan Optimization** | Two Pointers превращает O(n²) вложенные циклы в O(n) один проход. Каждый элемент посещается константное число раз |
| **Sorted Data Property** | Opposite direction использует монотонность: если `arr[left] + arr[right] > target`, то `arr[left] + arr[right-1]` меньше. Это позволяет отсечь whole branches |
| **Space-Time Tradeoff** | Two Pointers: O(1) память, O(n) время (после сортировки). HashMap: O(n) память, O(n) время без сортировки. Выбор по ограничениям |
| **Cycle Detection (Floyd)** | Математически доказано: если fast догоняет slow, цикл существует. Скорость догоняния = 1 элемент за итерацию. Гарантия обнаружения за O(λ + μ) где λ — длина хвоста, μ — длина цикла |
| **Greedy Choice** | В каждой итерации делаем локально оптимальный выбор: какой указатель двигать. Выбор основан на сравнении с целевым значением |

---

## Связанные темы

### Prerequisites (нужно знать до)
- [Arrays & Strings](../data-structures/arrays-strings.md) — базовые операции
- [Linked Lists](../data-structures/linked-lists.md) — для Fast/Slow
- [Big O Notation](../overview.md) — анализ сложности

### Unlocks (открывает доступ к)
- [Sliding Window Pattern](./sliding-window-pattern.md) — расширение Two Pointers
- [Binary Search Pattern](./binary-search-pattern.md) — похожая логика сужения
- [Merge Intervals](./intervals-pattern.md) — часто комбинируется

### Часто комбинируется с
- **Sorting** — для opposite direction
- **HashMaps** — когда Two Pointers не подходит
- **Greedy** — выбор какой указатель двигать

---

## Источники

| # | Источник | Тип | Вклад |
|---|----------|-----|-------|
| 1 | [LeetCode Two Pointers](https://leetcode.com/tag/two-pointers/) | Практика | Задачи |
| 2 | [GeeksforGeeks](https://www.geeksforgeeks.org/two-pointers-technique/) | Туториал | Примеры |
| 3 | [Hello Interview](https://www.hellointerview.com/learn/code/two-pointers/overview) | Туториал | Two Sum, 3Sum |
| 4 | [AlgoMonster](https://algo.monster/problems/two_pointers_intro) | Туториал | Паттерны |
| 5 | [Design Gurus](https://www.designgurus.io/blog/top-lc-patterns) | Гайд | Интервью |
| 6 | [OpenGenus](https://iq.opengenus.org/fast-and-slow-pointer-technique/) | Туториал | Floyd's |

---

## Куда дальше

→ **Следующий паттерн:** [[sliding-window-pattern]] — расширение Two Pointers для подмассивов
→ **Связанный паттерн:** [[binary-search-pattern]] — похожая логика сужения пространства поиска
→ **Вернуться к:** [[patterns-overview|Обзор паттернов]]

---

*Проверено: 2026-01-06*
