---
title: "Бинарные деревья и деревья поиска (BST)"
created: 2025-12-29
modified: 2026-01-06
type: deep-dive
status: published
difficulty: intermediate
confidence: high
cs-foundations:
  - recursive-data-structure
  - binary-search-principle
  - tree-traversals-dfs-bfs
  - balanced-vs-unbalanced
  - divide-and-conquer
  - space-time-tradeoff
prerequisites:
  - "[[recursion-fundamentals]]"
  - "[[big-o-complexity]]"
  - "[[stacks-queues]]"
teaches:
  - binary-tree-structure
  - tree-traversals
  - bst-operations
  - tree-construction
  - tree-serialization
unlocks:
  - "[[trees-advanced]]"
  - "[[graph-algorithms]]"
  - "[[dfs-bfs-patterns]]"
tags:
  - topic/cs-fundamentals
  - type/deep-dive
  - level/intermediate
  - interview
related:
  - "[[trees-advanced]]"
  - "[[graph-algorithms]]"
  - "[[dfs-bfs-patterns]]"
---

# Binary Trees & Binary Search Trees (BST)

> **TL;DR:** Binary Tree — дерево, где каждый узел имеет максимум 2 ребёнка. BST — binary tree с порядком: левое поддерево < узел < правое поддерево. Это даёт O(log n) поиск вместо O(n). Обходы дерева: Inorder (сортировка), Preorder (копирование), Postorder (удаление), Level-order (BFS). На интервью: 90% задач на деревья — это рекурсия + DFS/BFS.

---

## Часть 1: Интуиция без кода (начни здесь!)

> **Цель:** Понять ИДЕЮ деревьев до любого кода.

### Деревья в реальной жизни

Мы используем "деревья" каждый день, не осознавая этого:

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ДЕРЕВЬЯ ВОКРУГ НАС                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. СЕМЕЙНОЕ ДЕРЕВО                                                 │
│     ─────────────────                                               │
│                    👴 Дедушка                                       │
│                   /         \                                       │
│               👨 Папа      👩 Тётя                                  │
│              /      \                                               │
│           👧 Ты    👦 Брат                                          │
│                                                                     │
│     "Кто твои родители?" = подняться на 1 уровень вверх            │
│     "У тебя есть дети?" = посмотреть на уровень ниже               │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│  2. ФАЙЛОВАЯ СИСТЕМА                                                │
│     ───────────────                                                 │
│                      📁 Documents                                   │
│                     /     |     \                                   │
│               📁 Work  📁 Photos  📁 Music                         │
│              /     \         |                                      │
│        📄 report.docx  📄 notes.txt  📷 vacation.jpg               │
│                                                                     │
│     "/Documents/Work/report.docx" = путь от корня до файла         │
│     Каждая папка — узел, файлы — листья (нет "детей")              │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│  3. ОРГАНИЗАЦИОННАЯ СТРУКТУРА КОМПАНИИ                              │
│     ────────────────────────────────                                │
│                        CEO                                          │
│                      /     \                                        │
│                  CTO        CFO                                     │
│                 /   \         \                                     │
│          Backend  Frontend   Accounting                             │
│            Team     Team      Team                                  │
│                                                                     │
│     "Кому ты подчиняешься?" = parent узел                          │
│     "Кто у тебя в команде?" = children узлы                        │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│  4. ТУРНИРНАЯ СЕТКА                                                 │
│     ──────────────                                                  │
│                      🏆 Финал                                       │
│                     /        \                                      │
│            Полуфинал 1    Полуфинал 2                              │
│            /     \         /     \                                  │
│          1/4     1/4     1/4     1/4                                │
│                                                                     │
│     Победитель = поднимается вверх по дереву                       │
│     Каждый матч — узел с 2 участниками (левый/правый)              │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Почему "дерево" перевёрнуто?

```
РЕАЛЬНОЕ ДЕРЕВО:              ДЕРЕВО В CS:

      🌿🌿🌿                        ⬤ ← Корень (root)
       |||                        / \
       |||                       ⬤   ⬤ ← Ветви
        |                       / \   \
        |                      ⬤  ⬤   ⬤ ← Листья (leaves)
    ════════

В программировании дерево ПЕРЕВЁРНУТО!
Корень — сверху, листья — снизу.

Почему? Потому что мы читаем сверху вниз.
Данные "растут" вниз, как организационная структура.
```

### Binary = "Двоичный"

Почему "binary" tree? Потому что у каждого узла **максимум 2 ребёнка**:

```
BINARY TREE:                 НЕ BINARY TREE:
   [A]                            [A]
  /   \                        /   |   \
[B]   [C]  ← max 2 детей     [B]  [C]  [D]  ← 3 детей!
```

### Главная интуиция: Рекурсивная структура

> **Ключевое понимание:** Каждое поддерево — это тоже дерево!

```
                [5]
               /   \
             [3]   [7]     ← Это ДЕРЕВО
             / \     \
           [2] [4]   [9]

Левое поддерево [3]:       Правое поддерево [7]:
       [3]                        [7]
       / \                          \
     [2] [4]                        [9]

Оба — ПОЛНОЦЕННЫЕ ДЕРЕВЬЯ!

Эта "самоподобность" — ключ к рекурсии:
Задача на дереве = решить для левого + правого + объединить
```

---

## Часть 2: Почему деревья сложные для изучения

> **Источники:** [BTRecurTutor Research (Virginia Tech)](https://people.cs.vt.edu/shaffer/Papers/BTRecurTutor.pdf), [Stanford CS Library](http://cslibrary.stanford.edu/110/BinaryTrees.html), [Interview Cake](https://www.interviewcake.com/concept/java/binary-tree)

### Проблема 1: Путаница Binary Tree vs BST

```
┌─────────────────────────────────────────────────────────────────────┐
│             САМАЯ ЧАСТАЯ ОШИБКА НА ИНТЕРВЬЮ                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Binary Tree:                    BST (Binary Search Tree):          │
│        [5]                              [5]                         │
│       /   \                            /   \                        │
│     [7]   [3]                        [3]   [7]                      │
│     / \                              / \     \                      │
│   [1] [9]                          [1] [4]   [9]                    │
│                                                                     │
│  ❌ НЕТ порядка!                   ✅ Есть порядок:                 │
│     7 > 5, но слева                   левое < корень < правое      │
│     3 < 5, но справа                  ВСЁ левое поддерево < 5      │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ПОСЛЕДСТВИЯ:                                                       │
│  • В Binary Tree нельзя использовать бинарный поиск!               │
│  • Поиск в Binary Tree = O(n), нужно проверить ВСЕ узлы           │
│  • Поиск в BST = O(log n), отбрасываем половину на каждом шаге    │
│                                                                     │
│  ЗАПОМНИ: Если в задаче сказано "Binary Tree" без "Search" —       │
│  ты НЕ можешь предполагать порядок!                                │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Проблема 2: Base Case в рекурсии

**Исследование Virginia Tech:** Самая частая ошибка — неправильный или отсутствующий base case.

```kotlin
// ❌ ЗАБЫЛ BASE CASE — StackOverflowError!
fun height(node: TreeNode): Int {
    return 1 + maxOf(height(node.left), height(node.right))
    // Когда node.left = null, вызовем height(null)
    // А там снова height(null.left) — CRASH!
}

// ❌ НЕПРАВИЛЬНЫЙ BASE CASE
fun height(node: TreeNode?): Int {
    if (node == null) return 0  // Листья получат height = 1
    return 1 + maxOf(height(node.left), height(node.right))
}
// Проблема: высота листа = 1, но по определению height(leaf) = 0!

// ✅ ПРАВИЛЬНО
fun height(node: TreeNode?): Int {
    if (node == null) return -1  // Пустое дерево = -1
    return 1 + maxOf(height(node.left), height(node.right))
    // Теперь: leaf = 1 + max(-1, -1) = 0 ✓
}
```

**Правило:** Всегда спрашивай себя — **"Что происходит когда node = null?"**

### Проблема 3: Проверка null детей

```kotlin
// ❌ ИЗБЫТОЧНАЯ ПРОВЕРКА (но НЕ ошибка)
fun traverse(node: TreeNode?) {
    if (node == null) return

    if (node.left != null) {   // Зачем проверять?
        traverse(node.left)     // traverse(null) всё равно вернётся!
    }
    if (node.right != null) {
        traverse(node.right)
    }
}

// ✅ ИДИОМАТИЧНЫЙ КОД
fun traverse(node: TreeNode?) {
    if (node == null) return   // Base case обрабатывает null

    traverse(node.left)        // Просто вызываем — null обработается
    traverse(node.right)
}
```

### Проблема 4: Путаница с возвратом значений

```kotlin
// ❌ НЕ ВОЗВРАЩАЕТ результат рекурсии
fun find(node: TreeNode?, target: Int): Boolean {
    if (node == null) return false
    if (node.value == target) return true

    find(node.left, target)    // Забыл return!
    find(node.right, target)   // Результат теряется!
    return false               // Всегда false...
}

// ✅ ПРАВИЛЬНО — возвращаем результат
fun find(node: TreeNode?, target: Int): Boolean {
    if (node == null) return false
    if (node.value == target) return true

    // Короткое замыкание: если нашли слева — не ищем справа
    return find(node.left, target) || find(node.right, target)
}
```

### Проблема 5: Space Complexity рекурсии

```
┌─────────────────────────────────────────────────────────────────────┐
│  ЧАСТАЯ ОШИБКА: "Рекурсия не использует дополнительную память"      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  НЕПРАВИЛЬНО: "traverse() — O(1) space, нет новых структур"         │
│                                                                     │
│  ПРАВИЛЬНО: "traverse() — O(h) space, где h = высота дерева"        │
│                                                                     │
│  Почему? Call Stack растёт с каждым рекурсивным вызовом:           │
│                                                                     │
│         [5]                   Call Stack:                           │
│        /   \                  ┌─────────────┐                       │
│      [3]   [7]                │ traverse(5) │ ← 1й кадр             │
│      /                        │ traverse(3) │ ← 2й кадр             │
│    [2]                        │ traverse(2) │ ← 3й кадр             │
│    /                          │ traverse(1) │ ← 4й кадр             │
│  [1]                          │ traverse(null) │                    │
│                               └─────────────┘                       │
│                                                                     │
│  Для balanced дерева: h = log(n) → O(log n) space                  │
│  Для skewed дерева:   h = n     → O(n) space                       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Проблема 6: Неправильная валидация BST

```kotlin
// ❌ ПРОВЕРЯЕТ ТОЛЬКО НЕПОСРЕДСТВЕННЫХ ДЕТЕЙ
fun isValidBST(node: TreeNode?): Boolean {
    if (node == null) return true

    // Это НЕ гарантирует BST property!
    val leftOk = node.left == null || node.left!!.value < node.value
    val rightOk = node.right == null || node.right!!.value > node.value

    return leftOk && rightOk && isValidBST(node.left) && isValidBST(node.right)
}

// Этот код ПРОПУСТИТ невалидный BST:
//        [10]
//       /    \
//     [5]    [15]
//           /
//         [3]  ← 3 < 10, но находится в ПРАВОМ поддереве!
//
// Проверка: 15.left = 3 < 15 ✓ ... но 3 должно быть > 10!

// ✅ ПРАВИЛЬНО — метод диапазонов
fun isValidBST(node: TreeNode?, min: Long = Long.MIN_VALUE, max: Long = Long.MAX_VALUE): Boolean {
    if (node == null) return true
    if (node.value <= min || node.value >= max) return false

    // Левое поддерево: все значения должны быть < node.value
    // Правое поддерево: все значения должны быть > node.value
    return isValidBST(node.left, min, node.value.toLong()) &&
           isValidBST(node.right, node.value.toLong(), max)
}
```

---

## Часть 3: Ментальные модели для работы с деревьями

### Модель 1: "Начальник и подчинённые"

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ИЕРАРХИЯ НАЧАЛЬНИКОВ                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Каждый узел — "начальник" для своих детей:                        │
│                                                                     │
│                        CEO [10]                                     │
│                       /       \                                     │
│         "Левая рука" [5]     [15] "Правая рука"                    │
│                     / \          \                                  │
│                   [3] [7]        [20]                               │
│                                                                     │
│  ВОПРОСЫ через эту модель:                                         │
│                                                                     │
│  Q: "Кто главнее всех?"                                            │
│  A: Корень — CEO                                                    │
│                                                                     │
│  Q: "Кто ближайший общий начальник для [3] и [7]?"                 │
│  A: [5] — их непосредственный родитель                             │
│                                                                     │
│  Q: "Сколько уровней иерархии?"                                    │
│  A: Height дерева                                                   │
│                                                                     │
│  КОГДА ИСПОЛЬЗОВАТЬ:                                               │
│  • LCA (Lowest Common Ancestor)                                    │
│  • Path to root                                                     │
│  • Level-based problems                                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Модель 2: "Разделяй и властвуй"

```
┌─────────────────────────────────────────────────────────────────────┐
│                    DIVIDE AND CONQUER                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Задача на всё дерево = решить для левого + решить для правого +   │
│                       + объединить результаты                       │
│                                                                     │
│  Пример: найти сумму всех узлов                                    │
│                                                                     │
│                         [10]                                        │
│                        /    \                                       │
│                      [5]    [15]                                    │
│                     / \                                             │
│                   [3] [7]                                           │
│                                                                     │
│  sum([10]) = 10 + sum([5]) + sum([15])                             │
│            = 10 + (5 + sum([3]) + sum([7])) + (15 + 0 + 0)         │
│            = 10 + (5 + 3 + 7) + 15                                 │
│            = 40                                                     │
│                                                                     │
│  КОД:                                                               │
│  fun sum(node: TreeNode?): Int {                                   │
│      if (node == null) return 0                                    │
│      return node.value + sum(node.left) + sum(node.right)          │
│  }                                                                  │
│                                                                     │
│  КОГДА ИСПОЛЬЗОВАТЬ:                                               │
│  • Агрегация (sum, count, max, min)                                │
│  • Проверки (isBalanced, isValidBST)                               │
│  • Модификации (invert tree)                                       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Модель 3: "Путешественник" (DFS)

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ПУТЕШЕСТВИЕ ПО ДЕРЕВУ                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Представь, что ты турист, исследующий пещеру с развилками:        │
│                                                                     │
│                         Вход [A]                                    │
│                        /       \                                    │
│             Левый путь [B]    [C] Правый путь                      │
│                       / \                                           │
│                     [D] [E]                                         │
│                                                                     │
│  DFS (Depth-First): "Иди вглубь, пока не упрёшься в тупик"         │
│                                                                     │
│  PREORDER: Записываю ГДЕ Я → потом исследую                        │
│  Путь: A → B → D → E → C                                           │
│  "Фотографирую каждую комнату при ВХОДЕ"                           │
│                                                                     │
│  INORDER: Исследую слева → записываю → исследую справа             │
│  Путь: D → B → E → A → C                                           │
│  "Фотографирую когда возвращаюсь из левого туннеля"               │
│                                                                     │
│  POSTORDER: Исследую всё → потом записываю                         │
│  Путь: D → E → B → C → A                                           │
│  "Фотографирую каждую комнату при ВЫХОДЕ"                          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Модель 4: "Уровни здания" (BFS)

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ЭТАЖИ ЗДАНИЯ                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Дерево — это здание, где каждый этаж = уровень:                   │
│                                                                     │
│  Этаж 0 (root):        [CEO]                                       │
│                        /    \                                       │
│  Этаж 1:          [CTO]    [CFO]                                   │
│                   /   \       \                                     │
│  Этаж 2:     [Dev1] [Dev2] [Accountant]                            │
│                                                                     │
│  BFS: "Обойти весь этаж, потом спуститься ниже"                    │
│                                                                     │
│  Level 0: CEO                                                       │
│  Level 1: CTO, CFO                                                  │
│  Level 2: Dev1, Dev2, Accountant                                   │
│                                                                     │
│  Используем ОЧЕРЕДЬ (Queue), потому что:                           │
│  "Первый встреченный на этаже — первый обработанный"              │
│                                                                     │
│  КОГДА ИСПОЛЬЗОВАТЬ:                                               │
│  • Shortest path (кратчайший путь до узла)                         │
│  • Level-order traversal                                           │
│  • "Ближайший" узел с условием                                     │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Модель 5: "BST как умный справочник"

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ТЕЛЕФОННЫЙ СПРАВОЧНИК                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  BST — это книга, где страницы организованы для быстрого поиска:   │
│                                                                     │
│                     [М - Mike]                                      │
│                    /           \                                    │
│        [Б - Bob]                [Т - Tom]                          │
│        /       \                      \                             │
│  [А - Ann]  [Д - Dan]              [Ш - Sharon]                    │
│                                                                     │
│  Ищем "Dan":                                                        │
│  1. Открываем на M: "Dan" < "Mike" → листаем ВЛЕВО                 │
│  2. Открываем на B: "Dan" > "Bob" → листаем ВПРАВО                 │
│  3. Нашли Dan! ✓                                                    │
│                                                                     │
│  Каждый шаг ОТБРАСЫВАЕТ ПОЛОВИНУ справочника!                      │
│  В справочнике на 1000 страниц → найдём за ~10 шагов              │
│  log₂(1000) ≈ 10                                                   │
│                                                                     │
│  ИНВАРИАНТ BST:                                                    │
│  • Всё слева от узла < узел                                        │
│  • Всё справа от узла > узел                                       │
│  • Это верно для КАЖДОГО узла, не только корня!                   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Выбор модели по типу задачи

| Тип задачи | Лучшая модель | Пример |
|------------|---------------|--------|
| Агрегация (sum, max, count) | Divide & Conquer | Maximum depth |
| Поиск/вставка в BST | Умный справочник | Search, Insert |
| LCA, пути | Начальник/подчинённые | Lowest Common Ancestor |
| Level-based | Этажи здания (BFS) | Level order, Right side view |
| Обход всех узлов | Путешественник (DFS) | Serialize, Compare trees |

---

## 1. Зачем это нужно?

### Проблема: поиск в отсортированных данных

Представь, что у тебя телефонная книга с 1 000 000 контактов:

```
ПОИСК В МАССИВЕ:
┌─────────────────────────────────────────────────────────────┐
│ ["Aaron", "Bob", "Charlie", ... , "Zara"]                   │
│                                                              │
│ Найти "Mike":                                               │
│                                                              │
│ Вариант 1: Линейный поиск                                   │
│   Проверяем каждый элемент: 500,000 сравнений (в среднем)   │
│   Время: O(n) = O(1,000,000) ≈ 1 секунда                    │
│                                                              │
│ Вариант 2: Бинарный поиск                                   │
│   Делим пополам каждый раз: log₂(1,000,000) ≈ 20 сравнений  │
│   Время: O(log n) = O(20) ≈ 0.00002 секунды                 │
│                                                              │
│ Разница: 50,000 раз быстрее!                                 │
└─────────────────────────────────────────────────────────────┘
```

**Но есть проблема:** что если нужно часто добавлять/удалять контакты?

```
ВСТАВКА В ОТСОРТИРОВАННЫЙ МАССИВ:
┌─────────────────────────────────────────────────────────────┐
│ Добавить "Dan" между "Charlie" и "Eve":                     │
│                                                              │
│ До:   [Aaron, Bob, Charlie, Eve, Frank, ...]                │
│                        ↓                                     │
│ Нужно сдвинуть 999,997 элементов вправо!                    │
│                        ↓                                     │
│ После: [Aaron, Bob, Charlie, Dan, Eve, Frank, ...]          │
│                                                              │
│ Время вставки: O(n) = очень медленно                        │
└─────────────────────────────────────────────────────────────┘
```

### Решение: Binary Search Tree

```
BST РЕШАЕТ ОБЕ ПРОБЛЕМЫ:
┌─────────────────────────────────────────────────────────────┐
│                                                              │
│                         [Mike]                              │
│                        /      \                             │
│                   [Dan]        [Tom]                        │
│                  /    \        /    \                       │
│              [Bob]  [Frank] [Sam]  [Zara]                   │
│                                                              │
│ Поиск "Frank":                                              │
│   Mike → меньше → Dan → больше → Frank ✓                   │
│   Всего: 3 сравнения (log n)                                │
│                                                              │
│ Вставка "Eve":                                              │
│   Mike → Dan → Frank → добавить слева                      │
│   Всего: 4 операции (log n), БЕЗ сдвигов!                  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

| Операция | Массив (sorted) | BST (balanced) |
|----------|-----------------|----------------|
| Поиск | O(log n) | O(log n) |
| Вставка | **O(n)** | **O(log n)** |
| Удаление | **O(n)** | **O(log n)** |

**BST даёт O(log n) для ВСЕХ операций!**

---

## 2. Что это такое?

### Объяснение для 5-летнего

```
╔══════════════════════════════════════════════════════════════╗
║                                                               ║
║   Представь семейное дерево:                                  ║
║                                                               ║
║                        👴 Дедушка                             ║
║                       /         \                             ║
║                   👨 Папа     👩 Тётя                          ║
║                   /    \                                      ║
║                👧 Ты  👦 Брат                                  ║
║                                                               ║
║   ПРАВИЛА:                                                    ║
║   • У каждого максимум 2 ребёнка (левый и правый)            ║
║   • Дедушка — это КОРЕНЬ (самый верхний)                     ║
║   • Ты и Брат — это ЛИСТЬЯ (нет детей)                       ║
║                                                               ║
║   Это BINARY TREE (бинарное дерево)!                         ║
║                                                               ║
╚══════════════════════════════════════════════════════════════╝
```

### Binary Search Tree — это binary tree с ПОРЯДКОМ

```
╔══════════════════════════════════════════════════════════════╗
║                                                               ║
║   Представь книжный шкаф:                                     ║
║                                                               ║
║                         [М]                                  ║
║                        /   \                                  ║
║   Буквы А-Л слева →  [Г]   [Ф]  ← Буквы Н-Я справа           ║
║                     /  \   /  \                               ║
║                   [Б] [Е] [П] [Ш]                             ║
║                                                               ║
║   ПРАВИЛО BST:                                               ║
║   • Всё МЕНЬШЕ корня — идёт НАЛЕВО                          ║
║   • Всё БОЛЬШЕ корня — идёт НАПРАВО                         ║
║                                                               ║
║   Найти книгу на "П":                                        ║
║   М → П > М → идём направо → Ф → П < Ф → идём налево → П ✓   ║
║                                                               ║
╚══════════════════════════════════════════════════════════════╝
```

### Уровень 2: Программистское понимание

```kotlin
// Узел бинарного дерева
class TreeNode(
    var value: Int,              // Значение
    var left: TreeNode? = null,  // Левый ребёнок (или null)
    var right: TreeNode? = null  // Правый ребёнок (или null)
)

// BST Property:
// Для КАЖДОГО узла node:
//   • Все значения в node.left  < node.value
//   • Все значения в node.right > node.value
```

### Уровень 3: Формальное определение

**Binary Tree** — это либо:
- Пустое дерево (null)
- Узел с двумя поддеревьями (левым и правым), каждое из которых также binary tree

**Binary Search Tree (BST)** — это binary tree, в котором для каждого узла N:
- Все ключи в левом поддереве N **строго меньше** ключа N
- Все ключи в правом поддереве N **строго больше** ключа N
- Оба поддерева также являются BST

---

## 3. Терминология

| Термин | Определение | Пример |
|--------|-------------|--------|
| **Root** | Корень — самый верхний узел | Узел без родителя |
| **Leaf** | Лист — узел без детей | Узлы внизу дерева |
| **Internal node** | Узел с хотя бы одним ребёнком | Все кроме листьев |
| **Parent** | Родитель — узел выше | A — parent для B |
| **Child** | Ребёнок — узел ниже | B — child для A |
| **Sibling** | Братья — узлы с общим родителем | B и C — siblings |
| **Subtree** | Поддерево — узел и все его потомки | left subtree of A |
| **Height** | Высота — макс. путь до листа | Height(leaf) = 0 |
| **Depth** | Глубина — путь от корня | Depth(root) = 0 |
| **Level** | Уровень = глубина | Level 0, 1, 2... |
| **Degree** | Степень — количество детей | 0, 1, или 2 |

### Типы Binary Trees

```
COMPLETE BINARY TREE:           FULL BINARY TREE:
Все уровни заполнены,           Каждый узел имеет
последний — слева направо       0 или 2 детей

        1                              1
       / \                            / \
      2   3                          2   3
     / \  /                         / \
    4  5 6                         4   5

PERFECT BINARY TREE:            DEGENERATE (SKEWED):
Все узлы имеют 2 детей,         Каждый узел имеет
все листья на одном уровне       только 1 ребёнка

        1                              1
       / \                              \
      2   3                              2
     /\ / \                               \
    4 5 6 7                                3
                                            \
                                             4
```

### Height vs Depth — Визуализация

```
                    Depth=0, Height=3
                           │
                           ▼
                          [8]  ─────── Level 0
                         /   \
          Depth=1 ──►  [3]   [10] ──── Level 1
                      /  \      \
        Depth=2 ──► [1]  [6]    [14] ─ Level 2
                         / \    /
                       [4] [7] [13] ── Level 3
                             ▲
                             │
                    Depth=3, Height=0 (leaf)
```

**Запомни:**
- **Depth** растёт ВНИЗ от корня (root depth = 0)
- **Height** растёт ВВЕРХ от листьев (leaf height = 0)
- Height(tree) = Height(root) = макс. глубина любого листа

---

## 4. Как это работает?

### Обходы дерева (Traversals)

Есть 4 способа "посетить" все узлы дерева:

```
ПРИМЕР ДЕРЕВА:
              [F]
             /   \
           [B]   [G]
           / \      \
         [A] [D]    [I]
             / \    /
           [C] [E] [H]
```

#### Inorder (Left → Root → Right)

```
INORDER TRAVERSAL:

Рекурсивно:
1. Обойти левое поддерево
2. Посетить текущий узел
3. Обойти правое поддерево

Визуализация:
         [F]
        /   \
      [B]   [G]
      / \      \
    [A] [D]    [I]
        / \    /
      [C] [E] [H]

Порядок посещения: A → B → C → D → E → F → G → H → I

ЭТО ОТСОРТИРОВАННЫЙ ПОРЯДОК! (для BST)
```

```kotlin
/**
 * Inorder (симметричный) обход — Left → Root → Right
 *
 * Для BST это даёт ОТСОРТИРОВАННЫЙ вывод!
 * Почему? Потому что сначала обходим всё что меньше (left),
 * потом текущий, потом всё что больше (right).
 */
fun inorder(node: TreeNode?) {
    // База рекурсии: достигли null (пустое поддерево)
    if (node == null) return

    inorder(node.left)        // Шаг 1: обойти ВСЁ левое поддерево (меньшие)
    print("${node.value} ")   // Шаг 2: вывести текущий узел
    inorder(node.right)       // Шаг 3: обойти ВСЁ правое поддерево (большие)
}

// ПРИМЕР для BST:
//         5
//        / \
//       3   7
//      / \
//     2   4
//
// Вызов: inorder(5)
//   → inorder(3)
//       → inorder(2)
//           → inorder(null) → return
//           → print 2
//           → inorder(null) → return
//       → print 3
//       → inorder(4)
//           → inorder(null) → return
//           → print 4
//           → inorder(null) → return
//   → print 5
//   → inorder(7)
//       → ... → print 7
//
// Вывод: 2 3 4 5 7 — отсортировано! ✓
```

#### Preorder (Root → Left → Right)

```
PREORDER TRAVERSAL:

1. Посетить текущий узел
2. Обойти левое поддерево
3. Обойти правое поддерево

Порядок: F → B → A → D → C → E → G → I → H

USE CASE: Копирование дерева, сериализация
```

```kotlin
/**
 * Preorder (прямой) обход — Root → Left → Right
 *
 * Используется для:
 * - КОПИРОВАНИЯ дерева (сначала создаём узел, потом детей)
 * - СЕРИАЛИЗАЦИИ (сохраняем в файл/строку)
 *
 * Почему идеален для копирования? Потому что узел обрабатывается
 * ДО своих детей — мы создаём родителя, затем присоединяем детей.
 */
fun preorder(node: TreeNode?) {
    if (node == null) return

    print("${node.value} ")  // Шаг 1: обработать текущий узел ПЕРВЫМ
    preorder(node.left)       // Шаг 2: рекурсивно обойти левое поддерево
    preorder(node.right)      // Шаг 3: рекурсивно обойти правое поддерево
}

// Порядок для примера: F → B → A → D → C → E → G → I → H
// Это "сверху вниз, слева направо"
```

#### Postorder (Left → Right → Root)

```
POSTORDER TRAVERSAL:

1. Обойти левое поддерево
2. Обойти правое поддерево
3. Посетить текущий узел

Порядок: A → C → E → D → B → H → I → G → F

USE CASE: Удаление дерева (сначала дети, потом родитель)
```

```kotlin
/**
 * POSTORDER TRAVERSAL — обход "после детей"
 *
 * Порядок: Левое → Правое → Корень
 *
 * Почему безопасен для удаления?
 * Потому что узел обрабатывается ПОСЛЕ всех своих потомков.
 * Когда мы доходим до узла, его дети уже "удалены" (обработаны),
 * поэтому мы не потеряем ссылки на детей.
 *
 * ПОШАГОВЫЙ ПРИМЕР (удаление дерева):
 *
 *        A           Порядок удаления:
 *       / \          1. D (лист)
 *      B   C         2. E (лист)
 *     / \            3. B (теперь можно, дети удалены)
 *    D   E           4. C (лист)
 *                    5. A (корень последний)
 */
fun deleteTree(node: TreeNode?): TreeNode? {
    if (node == null) return null

    // Шаг 1: рекурсивно "удалить" левое поддерево
    // Дети должны быть удалены ДО родителя!
    deleteTree(node.left)

    // Шаг 2: рекурсивно "удалить" правое поддерево
    deleteTree(node.right)

    // Шаг 3: теперь безопасно удалить текущий узел
    // Все дети уже обработаны
    return null
}
```

#### Level-order (BFS)

```
LEVEL-ORDER TRAVERSAL:

Обход по уровням слева направо

Level 0: F
Level 1: B → G
Level 2: A → D → I
Level 3: C → E → H

Порядок: F → B → G → A → D → I → C → E → H

USE CASE: Shortest path, найти ближайший узел
```

```kotlin
/**
 * LEVEL-ORDER TRAVERSAL (BFS) — обход по уровням
 *
 * Почему используется Queue (очередь)?
 * BFS работает по принципу "первый пришёл — первый вышел" (FIFO).
 * Мы обрабатываем узлы в порядке их обнаружения, уровень за уровнем.
 *
 * ПОШАГОВЫЙ ПРИМЕР:
 *
 *        F            Очередь (→ = добавление, ← = извлечение):
 *       / \
 *      B   G          Старт: [F]
 *     / \   \         1. ←F, →B, →G       [B, G]        Level 0: [F]
 *    A   D   I        2. ←B, →A, →D       [G, A, D]
 *       / \   \       3. ←G, →I           [A, D, I]     Level 1: [B, G]
 *      C   E   H      4. ←A               [D, I]
 *                     5. ←D, →C, →E       [I, C, E]     Level 2: [A, D, I]
 *                     6. ←I, →H           [C, E, H]
 *                     7-9. ←C, ←E, ←H     []            Level 3: [C, E, H]
 */
fun levelOrder(root: TreeNode?): List<List<Int>> {
    if (root == null) return emptyList()

    val result = mutableListOf<List<Int>>()
    val queue = ArrayDeque<TreeNode>()
    queue.add(root)

    while (queue.isNotEmpty()) {
        // ВАЖНО: фиксируем размер уровня ДО обработки!
        // Почему? Потому что queue будет расти по мере добавления детей.
        // levelSize говорит: "на текущем уровне N узлов"
        val levelSize = queue.size
        val level = mutableListOf<Int>()

        // Обрабатываем ровно levelSize узлов — это текущий уровень
        repeat(levelSize) {
            val node = queue.removeFirst()
            level.add(node.value)

            // Добавляем детей в КОНЕЦ очереди
            // Они будут обработаны на СЛЕДУЮЩЕМ уровне,
            // потому что мы берём только levelSize узлов сейчас
            node.left?.let { queue.add(it) }
            node.right?.let { queue.add(it) }
        }

        result.add(level)
    }

    return result
}
```

### BST Операции

#### Поиск (Search)

```
ПОИСК 6 В BST:
              [8]
             /   \
           [3]   [10]
           / \      \
         [1] [6]    [14]
             / \
           [4] [7]

Шаг 1: 6 < 8 → идём влево
              [8]
             /
           [3]  ← здесь

Шаг 2: 6 > 3 → идём вправо
           [3]
              \
              [6]  ← здесь

Шаг 3: 6 == 6 → НАЙДЕНО! ✓

Всего: 3 сравнения (вместо 8 при линейном поиске)
```

```kotlin
/**
 * ПОИСК В BST — используем свойство упорядоченности
 *
 * Ключевое свойство BST:
 * Для ЛЮБОГО узла: все в левом поддереве < узел < все в правом поддереве
 *
 * Это позволяет на каждом шаге отбрасывать ПОЛОВИНУ оставшихся узлов!
 * Точно как binary search в отсортированном массиве.
 *
 * Time: O(log n) в среднем, O(n) для вырожденного дерева
 * Space: O(log n) — глубина рекурсии
 */
fun search(node: TreeNode?, target: Int): TreeNode? {
    // База рекурсии:
    // 1. node == null → дошли до конца, элемент не найден
    // 2. node.value == target → нашли!
    if (node == null || node.value == target) return node

    // Используем BST property для выбора направления:
    // - target меньше текущего → искомое может быть только СЛЕВА
    // - target больше текущего → искомое может быть только СПРАВА
    return if (target < node.value) {
        search(node.left, target)   // идём влево
    } else {
        search(node.right, target)  // идём вправо
    }
}
```

#### Вставка (Insert)

```
ВСТАВКА 5 В BST:
              [8]
             /   \
           [3]   [10]
           / \
         [1] [6]
             /
           [4]

Шаг 1: 5 < 8 → идём влево к [3]
Шаг 2: 5 > 3 → идём вправо к [6]
Шаг 3: 5 < 6 → идём влево к [4]
Шаг 4: 5 > 4 → вставляем справа от [4]

РЕЗУЛЬТАТ:
              [8]
             /   \
           [3]   [10]
           / \
         [1] [6]
             /
           [4]
              \
              [5]  ← NEW
```

```kotlin
/**
 * ВСТАВКА В BST — всегда происходит в листовой позиции
 *
 * Почему в листовой?
 * Мы спускаемся по дереву, пока не найдём null (пустое место).
 * Это гарантирует, что BST property сохранится:
 * новый узел попадёт туда, где он должен быть по значению.
 *
 * Особенность реализации:
 * Функция возвращает узел, чтобы "привязать" новый узел к родителю.
 * Это паттерн "рекурсивное обновление ссылок".
 *
 * Time: O(log n) в среднем, O(n) для вырожденного дерева
 */
fun insert(node: TreeNode?, value: Int): TreeNode {
    // База: нашли пустое место → создаём новый узел!
    // Этот узел вернётся наверх и станет left или right родителя
    if (node == null) return TreeNode(value)

    // Рекурсивно ищем правильное место:
    // - Значение меньше → должно быть в левом поддереве
    // - Значение больше → должно быть в правом поддереве
    if (value < node.value) {
        node.left = insert(node.left, value)
    } else if (value > node.value) {
        node.right = insert(node.right, value)
    }
    // Если value == node.value → дубликат, игнорируем
    // (стандартный BST не хранит дубликаты)

    return node  // возвращаем узел для "привязки" к родителю
}
```

#### Удаление (Delete)

```
УДАЛЕНИЕ — 3 СЛУЧАЯ:

Случай 1: Узел — ЛИСТ (нет детей)
    [8]                    [8]
   /   \      удалить 4   /   \
  [3]  [10]   ───────►  [3]  [10]
  / \                   / \
[1] [6]               [1] [6]
    /
  [4] ← удаляем просто убираем

Случай 2: Узел имеет ОДНОГО ребёнка
    [8]                    [8]
   /   \      удалить 10  /   \
  [3]  [10]  ───────►   [3]  [14]
         \                   заменяем на ребёнка
        [14]

Случай 3: Узел имеет ДВУХ детей
    [8]                    [8]
   /   \      удалить 3   /   \
  [3]  [10]  ───────►   [4]  [10]
  / \                   / \
[1] [6]               [1] [6]
    /
  [4]                 заменяем на inorder successor (4)
                       или inorder predecessor (1)
```

```kotlin
/**
 * УДАЛЕНИЕ ИЗ BST — самая сложная операция
 *
 * Почему сложная? Нужно сохранить BST property после удаления.
 * Есть 3 случая:
 *
 * 1. ЛИСТ (0 детей): просто убираем узел
 * 2. ОДИН ребёнок: заменяем узел на его ребёнка
 * 3. ДВА ребёнка: находим "заменителя" — inorder successor
 *
 * Что такое inorder successor?
 * Это МИНИМАЛЬНЫЙ элемент в ПРАВОМ поддереве.
 * Он больше всех в левом поддереве (потому что справа)
 * и меньше всех остальных в правом поддереве (потому что минимум).
 * Идеальная замена!
 *
 * Time: O(log n) в среднем, O(n) для вырожденного дерева
 */
fun delete(node: TreeNode?, value: Int): TreeNode? {
    if (node == null) return null

    when {
        // Ищем узел для удаления
        value < node.value -> {
            node.left = delete(node.left, value)
        }
        value > node.value -> {
            node.right = delete(node.right, value)
        }
        else -> {
            // НАШЛИ узел для удаления!

            // Случай 1: ЛИСТ (нет детей) — просто вернём null
            // Случай 2а: нет левого ребёнка — вернём правого
            if (node.left == null) return node.right

            // Случай 2б: нет правого ребёнка — вернём левого
            if (node.right == null) return node.left

            // Случай 3: ЕСТЬ ОБА ребёнка
            // Шаг 1: найти inorder successor (минимум справа)
            val successor = findMin(node.right!!)

            // Шаг 2: скопировать значение successor в текущий узел
            node.value = successor.value

            // Шаг 3: рекурсивно удалить successor из правого поддерева
            // (successor гарантированно имеет 0 или 1 ребёнка — он минимум!)
            node.right = delete(node.right, successor.value)
        }
    }

    return node
}

/**
 * Найти МИНИМАЛЬНЫЙ элемент в поддереве
 *
 * В BST минимум всегда находится в самом левом узле.
 * Почему? Потому что левый ребёнок всегда меньше родителя.
 * Идём влево до упора.
 */
fun findMin(node: TreeNode): TreeNode {
    // Если левого ребёнка нет — это минимум
    // Иначе — продолжаем идти влево
    return if (node.left == null) node else findMin(node.left)
}
```

---

## 5. Сложность операций

### Binary Search Tree

| Операция | Average Case | Worst Case | Best Case |
|----------|--------------|------------|-----------|
| Search | O(log n) | O(n)* | O(1) |
| Insert | O(log n) | O(n)* | O(1) |
| Delete | O(log n) | O(n)* | O(1) |
| Min/Max | O(log n) | O(n)* | O(1) |
| Inorder | O(n) | O(n) | O(n) |

*Worst case O(n) происходит при skewed tree (вырожденном дереве)

### Почему O(n) в худшем случае?

```
BALANCED (O(log n)):           SKEWED (O(n)):

        [4]                        [1]
       /   \                         \
     [2]   [6]                       [2]
     / \   / \                         \
   [1][3][5][7]                        [3]
                                         \
  Height = log n                         [4]
  Каждый шаг отсекает                      \
  половину узлов                           [5]

                                  Height = n
                                  Это просто связный список!
```

### Space Complexity

| Операция | Space |
|----------|-------|
| Recursive traversal | O(h) — глубина стека |
| Level-order | O(w) — ширина уровня |
| Balanced tree | O(log n) |
| Skewed tree | O(n) |

---

## 6. Реализация

### Kotlin

```kotlin
class TreeNode(var value: Int) {
    var left: TreeNode? = null
    var right: TreeNode? = null
}

/**
 * ПОЛНАЯ РЕАЛИЗАЦИЯ BST — Binary Search Tree
 *
 * Класс инкапсулирует корень дерева, предоставляя чистый API.
 * Пользователю не нужно работать с root напрямую.
 */
class BST {
    private var root: TreeNode? = null

    // === PUBLIC API ===
    // Скрываем детали реализации (root) от пользователя.
    // Он просто вызывает insert(5), не думая о рекурсии.

    fun insert(value: Int) {
        root = insertRec(root, value)
    }

    private fun insertRec(node: TreeNode?, value: Int): TreeNode {
        // Дошли до пустого места → создаём новый узел
        if (node == null) return TreeNode(value)

        // Используем BST property: меньше → влево, больше → вправо
        if (value < node.value) {
            node.left = insertRec(node.left, value)
        } else if (value > node.value) {
            node.right = insertRec(node.right, value)
        }
        // Если value == node.value → дубликат, игнорируем

        return node
    }

    fun search(value: Int): Boolean = searchRec(root, value)

    private fun searchRec(node: TreeNode?, value: Int): Boolean {
        // null означает: дошли до конца, элемент не найден
        if (node == null) return false

        return when {
            value == node.value -> true
            value < node.value -> searchRec(node.left, value)
            else -> searchRec(node.right, value)
        }
    }

    /**
     * Inorder traversal даёт ОТСОРТИРОВАННЫЙ список!
     *
     * Почему? Inorder обходит: левое → корень → правое.
     * В BST: левое < корень < правое.
     * Поэтому элементы выводятся по возрастанию.
     */
    fun inorderList(): List<Int> {
        val result = mutableListOf<Int>()
        inorderRec(root, result)
        return result
    }

    private fun inorderRec(node: TreeNode?, result: MutableList<Int>) {
        if (node == null) return
        inorderRec(node.left, result)
        result.add(node.value)
        inorderRec(node.right, result)
    }

    /**
     * ПРОВЕРКА ВАЛИДНОСТИ BST — метод диапазонов
     *
     * Идея: каждый узел должен находиться в допустимом диапазоне (min, max).
     * При спуске влево: max обновляется до текущего значения.
     * При спуске вправо: min обновляется до текущего значения.
     *
     * ПРИМЕР:
     *        8              Диапазон для 8: (-∞, +∞)
     *       / \             Диапазон для 3: (-∞, 8)
     *      3   10           Диапазон для 10: (8, +∞)
     *     / \               Диапазон для 1: (-∞, 3)
     *    1   6              Диапазон для 6: (3, 8)
     *
     * Почему Long? Чтобы min/max могли быть за пределами Int.
     */
    fun isValidBST(): Boolean = isValidRec(root, Long.MIN_VALUE, Long.MAX_VALUE)

    private fun isValidRec(node: TreeNode?, min: Long, max: Long): Boolean {
        if (node == null) return true

        // Узел должен быть СТРОГО в диапазоне (min, max)
        if (node.value <= min || node.value >= max) return false

        // Левые дети: сужаем верхнюю границу до node.value
        // Правые дети: сужаем нижнюю границу до node.value
        return isValidRec(node.left, min, node.value.toLong()) &&
               isValidRec(node.right, node.value.toLong(), max)
    }
}
```

### Java

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int val) {
        this.val = val;
    }
}

/**
 * Java реализация BST
 *
 * Демонстрирует как рекурсивные, так и итеративные подходы.
 */
public class BST {
    private TreeNode root;

    // === ВСТАВКА (рекурсивная) ===
    // Паттерн "обновление через возврат":
    // Рекурсия возвращает узел, родитель присваивает его left/right.
    // Это позволяет "привязать" новый узел к дереву.
    public void insert(int value) {
        root = insertRec(root, value);
    }

    private TreeNode insertRec(TreeNode node, int value) {
        if (node == null) {
            return new TreeNode(value);
        }

        if (value < node.val) {
            node.left = insertRec(node.left, value);
        } else if (value > node.val) {
            node.right = insertRec(node.right, value);
        }

        return node;
    }

    // === ПОИСК (итеративный) ===
    // Итеративный подход экономит память стека!
    // Рекурсия использует O(h) памяти (h = высота).
    // Итерация использует O(1) памяти.
    // Для глубоких деревьев это важно.
    public boolean searchIterative(int value) {
        TreeNode current = root;

        while (current != null) {
            if (value == current.val) {
                return true;
            } else if (value < current.val) {
                current = current.left;
            } else {
                current = current.right;
            }
        }

        return false;
    }

    /**
     * ИТЕРАТИВНЫЙ INORDER — через явный стек
     *
     * Идея: стек симулирует стек вызовов рекурсии.
     * Мы вручную делаем то, что делает рекурсия автоматически.
     *
     * ПОШАГОВЫЙ АЛГОРИТМ:
     * 1. Идём влево до упора, кладя узлы в стек
     * 2. Когда дошли до null — достаём узел, обрабатываем
     * 3. Переходим в правое поддерево и повторяем
     *
     * ПРИМЕР для дерева:
     *        4
     *       / \
     *      2   6
     *     / \
     *    1   3
     *
     * Стек: [] → [4] → [4,2] → [4,2,1]
     * Pop 1, вывод: [1]
     * Pop 2, вывод: [1,2], идём вправо к 3
     * Стек: [4,3]
     * Pop 3, вывод: [1,2,3]
     * Pop 4, вывод: [1,2,3,4], идём вправо к 6
     * Стек: [6]
     * Pop 6, вывод: [1,2,3,4,6]
     */
    public List<Integer> inorderIterative() {
        List<Integer> result = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode current = root;

        while (current != null || !stack.isEmpty()) {
            // Фаза 1: идём влево до упора, сохраняя путь
            while (current != null) {
                stack.push(current);
                current = current.left;
            }

            // Фаза 2: достигли левого края — обрабатываем
            current = stack.pop();
            result.add(current.val);

            // Фаза 3: переходим в правое поддерево
            current = current.right;
        }

        return result;
    }
}
```

### Python

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BST:
    """
    Python реализация BST

    Python позволяет очень элегантную рекурсию благодаря:
    - Динамической типизации (не нужны explicit null checks)
    - Простому синтаксису (if not node вместо if node == null)
    - Вложенным функциям (closure для traverse)
    """

    def __init__(self):
        self.root = None

    def insert(self, val: int) -> None:
        """Вставка через рекурсивное обновление ссылок"""
        self.root = self._insert_rec(self.root, val)

    def _insert_rec(self, node: TreeNode, val: int) -> TreeNode:
        if not node:
            return TreeNode(val)

        if val < node.val:
            node.left = self._insert_rec(node.left, val)
        elif val > node.val:
            node.right = self._insert_rec(node.right, val)

        return node

    def search(self, val: int) -> bool:
        """
        Итеративный поиск — простой и эффективный

        Итеративный подход в Python часто предпочтительнее:
        - Нет ограничения глубины рекурсии (default 1000)
        - Проще читается для простых операций
        """
        current = self.root

        while current:
            if val == current.val:
                return True
            elif val < current.val:
                current = current.left
            else:
                current = current.right

        return False

    def inorder(self) -> list[int]:
        """
        Inorder обход через вложенную функцию

        Вложенная функция traverse имеет доступ к result
        через closure (замыкание). Это Pythonic способ
        собирать результаты рекурсии без передачи списка.
        """
        result = []

        def traverse(node):
            if not node:
                return
            traverse(node.left)
            result.append(node.val)
            traverse(node.right)

        traverse(self.root)
        return result

    def height(self) -> int:
        """
        Вычисление высоты дерева

        Формула: height = 1 + max(left_height, right_height)

        Почему -1 для пустого дерева?
        - Лист (узел без детей) имеет высоту 0
        - Пустое поддерево (None) должно давать -1
        - Тогда: 1 + max(-1, -1) = 0 для листа ✓
        """
        def get_height(node) -> int:
            if not node:
                return -1  # Пустое дерево = -1

            left_h = get_height(node.left)
            right_h = get_height(node.right)

            return 1 + max(left_h, right_h)

        return get_height(self.root)
```

---

## 7. Распространённые ошибки

### Ошибка 1: Забыть проверку на null

```kotlin
// ❌ WRONG — NullPointerException
fun getHeight(node: TreeNode): Int {
    return 1 + maxOf(getHeight(node.left), getHeight(node.right))
}

// ✅ CORRECT
fun getHeight(node: TreeNode?): Int {
    if (node == null) return 0
    return 1 + maxOf(getHeight(node.left), getHeight(node.right))
}
```

### Ошибка 2: Неправильная валидация BST

```kotlin
// ❌ WRONG — проверяет только immediate children
fun isValidBST(node: TreeNode?): Boolean {
    if (node == null) return true

    if (node.left != null && node.left!!.value >= node.value) return false
    if (node.right != null && node.right!!.value <= node.value) return false

    return isValidBST(node.left) && isValidBST(node.right)
}

// Этот код ПРОПУСТИТ невалидный BST:
//       [5]
//      /   \
//    [1]   [6]
//         /
//       [3]  ← 3 < 5, но находится справа от 5!

// ✅ CORRECT — используем диапазон
fun isValidBST(node: TreeNode?, min: Long = Long.MIN_VALUE, max: Long = Long.MAX_VALUE): Boolean {
    if (node == null) return true
    if (node.value <= min || node.value >= max) return false

    return isValidBST(node.left, min, node.value.toLong()) &&
           isValidBST(node.right, node.value.toLong(), max)
}
```

### Ошибка 3: Путаница Binary Tree vs BST

```kotlin
// Если задача говорит "Binary Tree" — нельзя использовать BST property!

// ❌ WRONG для Binary Tree
fun find(node: TreeNode?, target: Int): TreeNode? {
    if (node == null || node.value == target) return node

    // Это работает только для BST!
    return if (target < node.value) find(node.left, target)
           else find(node.right, target)
}

// ✅ CORRECT для Binary Tree
fun find(node: TreeNode?, target: Int): TreeNode? {
    if (node == null) return null
    if (node.value == target) return node

    // Ищем в обоих поддеревьях
    return find(node.left, target) ?: find(node.right, target)
}
```

### Ошибка 4: Забыть вернуть значение из рекурсии

```kotlin
// ❌ WRONG — не возвращает результат
fun insert(node: TreeNode?, value: Int) {
    if (node == null) {
        TreeNode(value)  // Создали, но не вернули!
        return
    }

    if (value < node.value) {
        insert(node.left, value)  // Не обновляем node.left!
    } else {
        insert(node.right, value)
    }
}

// ✅ CORRECT
fun insert(node: TreeNode?, value: Int): TreeNode {
    if (node == null) return TreeNode(value)

    if (value < node.value) {
        node.left = insert(node.left, value)  // Обновляем ссылку!
    } else if (value > node.value) {
        node.right = insert(node.right, value)
    }

    return node
}
```

### Ошибка 5: Integer Overflow при валидации

```kotlin
// ❌ WRONG — если node.value = Int.MAX_VALUE, min + 1 переполнится
fun isValid(node: TreeNode?, min: Int, max: Int): Boolean {
    // ...
}

// ✅ CORRECT — используем Long
fun isValid(node: TreeNode?, min: Long, max: Long): Boolean {
    // ...
}

// Или используем null для unbounded
fun isValid(node: TreeNode?, min: Int?, max: Int?): Boolean {
    if (node == null) return true
    if (min != null && node.value <= min) return false
    if (max != null && node.value >= max) return false
    // ...
}
```

---

## 8. Когда использовать

### Выбор структуры данных

| Сценарий | Лучший выбор | Почему |
|----------|--------------|--------|
| Частый поиск, редкие изменения | Sorted Array + Binary Search | O(log n) поиск, проще |
| Частые вставки/удаления | BST или HashMap | O(log n) все операции |
| Нужен порядок + быстрый поиск | BST | Inorder = sorted |
| Только поиск по ключу | HashMap | O(1) в среднем |
| Гарантия O(log n) | AVL или Red-Black Tree | Self-balancing |
| Диапазонные запросы | BST | floor, ceiling, range |

### BST vs Array

| Операция | Sorted Array | BST (balanced) |
|----------|--------------|----------------|
| Search | O(log n) | O(log n) |
| Insert | **O(n)** | O(log n) |
| Delete | **O(n)** | O(log n) |
| Min/Max | O(1) | O(log n) |
| Range query | O(log n + k) | O(log n + k) |

### BST vs HashMap

| Операция | HashMap | BST |
|----------|---------|-----|
| Search | O(1)* | O(log n) |
| Insert | O(1)* | O(log n) |
| Delete | O(1)* | O(log n) |
| Ordered iteration | O(n log n) | O(n) |
| Find min/max | O(n) | O(log n) |
| Range query | O(n) | O(log n + k) |

*HashMap O(1) — в среднем, O(n) в худшем случае

### Реальные применения

| Применение | Структура | Почему |
|------------|-----------|--------|
| Database indexing | B-Tree (balanced) | Оптимально для disk I/O |
| In-memory ordered map | Red-Black Tree | Java TreeMap, C++ std::map |
| Priority scheduling | Heap | Не BST, но дерево |
| File systems | B-Tree | Быстрый поиск файлов |
| Game engines | BST | Spatial partitioning |

---

## 9. Практика

### Концептуальные вопросы (без кода)

1. **Чем BST отличается от Binary Tree?**
   <details>
   <summary>Ответ</summary>
   BST имеет упорядоченность: левое поддерево < корень < правое поддерево. Обычное binary tree — просто каждый узел имеет max 2 детей, без порядка.
   </details>

2. **Какой обход даст отсортированный вывод для BST?**
   <details>
   <summary>Ответ</summary>
   Inorder (Left → Root → Right). Сначала все меньшие, потом текущий, потом все большие.
   </details>

3. **Почему worst case для BST — O(n)?**
   <details>
   <summary>Ответ</summary>
   Если вставлять элементы в отсортированном порядке (1, 2, 3, 4, 5), дерево становится "вырожденным" — фактически связным списком. Высота = n.
   </details>

4. **Как проверить, является ли binary tree валидным BST?**
   <details>
   <summary>Ответ</summary>
   Два способа: (1) Inorder traversal должен давать строго возрастающую последовательность. (2) Рекурсивно проверять, что каждый узел в допустимом диапазоне (min, max).
   </details>

5. **В чём разница между height и depth?**
   <details>
   <summary>Ответ</summary>
   Depth — расстояние от корня до узла (корень depth=0). Height — расстояние от узла до самого дальнего листа (лист height=0). Height(tree) = Height(root).
   </details>

### LeetCode задачи (по сложности)

#### Easy (начни с этих)

| # | Задача | Паттерн | Цель обучения |
|---|--------|---------|---------------|
| 104 | Maximum Depth of Binary Tree | DFS | Базовая рекурсия |
| 226 | Invert Binary Tree | DFS | Модификация дерева |
| 100 | Same Tree | Comparison | Сравнение двух деревьев |
| 572 | Subtree of Another Tree | Comparison | Same Tree + поиск |
| 700 | Search in BST | BST property | Использование BST |
| 701 | Insert into BST | BST property | Вставка в BST |

#### Medium (основной набор)

| # | Задача | Паттерн | Цель обучения |
|---|--------|---------|---------------|
| 98 | Validate BST | Range check | Валидация с диапазоном |
| 102 | Binary Tree Level Order | BFS | Level-order traversal |
| 105 | Construct from Preorder/Inorder | Construction | Построение дерева |
| 235 | LCA of BST | BST property | Использование BST для LCA |
| 236 | LCA of Binary Tree | DFS | Общий случай LCA |
| 230 | Kth Smallest in BST | Inorder | Inorder = sorted |
| 199 | Binary Tree Right Side View | BFS/DFS | Level-order с twist |

#### Hard (для advanced)

| # | Задача | Паттерн | Цель обучения |
|---|--------|---------|---------------|
| 297 | Serialize/Deserialize Binary Tree | Preorder | Сериализация |
| 124 | Binary Tree Maximum Path Sum | DFS + global | Сложная рекурсия |
| 99 | Recover BST | Inorder | Найти 2 swapped nodes |

---

## 10. Связанные темы

### Prerequisites (изучить до)

- [[recursion-fundamentals]] — рекурсия нужна для всех tree алгоритмов
- [[big-o-complexity]] — понимание O(log n) vs O(n)
- [[stacks-queues]] — для итеративных обходов

### Unlocks (открывает доступ к)

- [[trees-advanced]] — AVL, Red-Black, B-Tree
- [[graph-algorithms]] — деревья — частный случай графов
- [[dfs-bfs-patterns]] — паттерны на основе обходов
- [[dp-patterns]] — tree DP

### Related Patterns

- [[binary-search-pattern]] — BST использует binary search идею
- [[two-pointers-pattern]] — иногда применимо к деревьям

---

## Мифы и заблуждения

| Миф | Реальность |
|-----|-----------|
| "BST всегда O(log n)" | **Degenerates to O(n)** на отсортированных данных. Нужны self-balancing (AVL, Red-Black) |
| "Inorder = sorted" | Только для BST! Для обычного binary tree **inorder не даёт sorted** |
| "Рекурсия медленная для деревьев" | Стек рекурсии ~O(h). Для balanced tree h = log n. **Редко проблема** |
| "BFS лучше DFS" | Зависит от задачи. BFS для shortest path, DFS для **space efficiency** и backtracking |
| "Нужно знать все traversals" | **Preorder** (копирование), **Inorder** (BST sorted), **Postorder** (deletion). Этого достаточно |

---

## CS-фундамент

| CS-концепция | Применение в Binary Trees |
|--------------|--------------------------|
| **Recursion** | Структура дерева naturally recursive. Left subtree, right subtree — подзадачи |
| **BST Property** | left < root < right. Позволяет binary search на структуре данных |
| **Tree Traversals** | DFS (pre/in/post-order), BFS (level-order). Основа для большинства операций |
| **Balanced Trees** | AVL, Red-Black гарантируют h = O(log n). Критично для performance |
| **Tree DP** | Решение на поддереве зависит от решений на детях. Рекурсивная структура |

---

## 11. Источники

| # | Источник | Тип | Что взято |
|---|----------|-----|-----------|
| 1 | [GeeksforGeeks - BST](https://www.geeksforgeeks.org/dsa/binary-search-tree-data-structure/) | Reference | Операции, complexity |
| 2 | [Interview Cake - Binary Tree](https://www.interviewcake.com/concept/java/binary-tree) | Guide | Терминология, типы |
| 3 | [Tech Interview Handbook](https://www.techinterviewhandbook.org/algorithms/tree/) | Guide | Interview tips |
| 4 | [Wikipedia - Tree Traversal](https://en.wikipedia.org/wiki/Tree_traversal) | Reference | Traversal definitions |
| 5 | [NeetCode Blind 75](https://neetcode.io/practice?tab=blind75) | Problems | Задачи |
| 6 | [LeetCode - Trees](https://leetcode.com/problem-list/binary-tree/) | Problems | Practice |
| 7 | Research: [[2025-12-29-binary-trees-bst]] | Research | Deep research |

---

*Обновлено: 2026-01-06 — добавлены педагогические секции (интуиция деревьев, типичные ошибки рекурсии, 5 ментальных моделей)*

---

[[stacks-queues|← Stacks & Queues]] | [[cs-fundamentals-overview|CS Fundamentals MOC]] | [[graphs|Graphs →]]
