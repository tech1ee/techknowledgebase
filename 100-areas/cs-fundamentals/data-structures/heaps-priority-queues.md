---
title: "Heaps & Priority Queues"
created: 2025-12-29
updated: 2026-01-06
type: deep-dive
status: complete
difficulty: intermediate
confidence: high
cs-foundations:
  - complete-binary-tree
  - heap-property
  - array-representation-of-trees
  - amortized-analysis
  - abstract-data-type
  - comparison-based-ordering
prerequisites:
  - "[[arrays-strings]]"
  - "[[trees-binary]]"
  - "[[big-o-complexity]]"
teaches:
  - min-heap-max-heap
  - sift-up-sift-down
  - build-heap-linear-time
  - top-k-pattern
  - two-heaps-median
unlocks:
  - "[[sorting-algorithms]]"
  - "[[graph-algorithms]]"
  - "[[greedy-algorithms]]"
tags:
  - cs-fundamentals
  - data-structures
  - heap
  - priority-queue
  - interview
---

# Кучи и очереди с приоритетом (Heaps & Priority Queues)

---

## TL;DR

Куча (heap) — полное бинарное дерево, где каждый родитель ≤ (min-heap) или ≥ (max-heap) своих детей. Хранится как массив. **Insert/Delete: O(log n), Peek: O(1), Build: O(n)**. Используй для задач "найти K наибольших/наименьших" (паттерн Top K), Dijkstra, медианы в потоке. В Java/Kotlin `PriorityQueue` — min-heap по умолчанию.

---

## Часть 1: Интуиция без кода (начни здесь!)

> **Цель:** Понять ИДЕЮ кучи и приоритетной очереди до любого кода.

### Приоритетные очереди в жизни

Мы сталкиваемся с "приоритетными очередями" каждый день:

```
┌─────────────────────────────────────────────────────────────────────┐
│                 ПРИОРИТЕТНЫЕ ОЧЕРЕДИ В ЖИЗНИ                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. СКОРАЯ ПОМОЩЬ (Triage)                                         │
│     ──────────────────────                                          │
│     Пациенты обслуживаются НЕ по порядку прихода,                  │
│     а по срочности состояния:                                       │
│                                                                     │
│     🔴 Инфаркт (10)  ──────────────────→  Первый!                   │
│     🟡 Перелом руки (5)  ──────────────→  Второй                    │
│     🟢 Насморк (1)  ───────────────────→  Последний                 │
│                                                                     │
│     "Кто самый срочный?" = peek()                                  │
│     "Лечим самого срочного" = poll()                               │
│     "Приходит новый пациент" = offer()                             │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│  2. ОЧЕРЕДЬ НА ПОСАДКУ В САМОЛЁТ                                   │
│     ────────────────────────────                                    │
│     Порядок посадки по "приоритету":                               │
│                                                                     │
│     👑 Бизнес-класс (приоритет 1)                                  │
│     ⭐ Эконом-комфорт (приоритет 2)                                 │
│     👤 Обычный эконом (приоритет 3)                                │
│                                                                     │
│     Внутри каждого класса — обычная очередь (FIFO)                 │
│     Но бизнес ВСЕГДА раньше эконома                                │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│  3. ПЛАНИРОВЩИК ЗАДАЧ В ТЕЛЕФОНЕ                                   │
│     ─────────────────────────────                                   │
│     Какое приложение получит CPU?                                  │
│                                                                     │
│     📞 Входящий звонок (приоритет 10) — НЕМЕДЛЕННО!                │
│     🎵 Музыка в фоне (приоритет 3)                                 │
│     📊 Обновление погоды (приоритет 1)                             │
│                                                                     │
│     OS использует приоритетную очередь процессов                   │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│  4. GPS НАВИГАЦИЯ (Dijkstra)                                       │
│     ───────────────────────                                         │
│     "Какой следующий узел ближе всего?"                            │
│                                                                     │
│           🏠 Дом                                                    │
│          /   \                                                      │
│      5км/     \3км                                                  │
│        /       \                                                    │
│     🏪 Магазин  🏥 Больница                                         │
│                                                                     │
│     Min-heap хранит: [(Больница, 3), (Магазин, 5)]                 │
│     poll() → Больница (ближайшая)                                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Почему нужна специальная структура?

```
┌─────────────────────────────────────────────────────────────────────┐
│                 ПРОБЛЕМА: Как хранить приоритеты?                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ВАРИАНТ 1: Простой список                                         │
│  ──────────────────────────                                         │
│  [5, 2, 8, 1, 9]                                                    │
│                                                                     │
│  Добавить: O(1) — просто в конец                                   │
│  Найти минимум: O(n) — просмотреть ВСЁ! 😱                         │
│                                                                     │
│  При 1 000 000 элементов: 1 000 000 сравнений каждый раз          │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│  ВАРИАНТ 2: Отсортированный список                                 │
│  ─────────────────────────────────                                  │
│  [1, 2, 5, 8, 9]                                                    │
│                                                                     │
│  Найти минимум: O(1) — просто первый                               │
│  Добавить: O(n) — найти место + сдвинуть 😱                        │
│                                                                     │
│  При 1 000 000 элементов: сдвигать 500 000 в среднем              │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│  ВАРИАНТ 3: КУЧА (Heap) 🏆                                         │
│  ────────────────────────                                           │
│  [1, 2, 5, 8, 9] — но как ДЕРЕВО!                                  │
│                                                                     │
│  Найти минимум: O(1) — всегда корень!                              │
│  Добавить: O(log n) — только путь до корня                         │
│                                                                     │
│  При 1 000 000 элементов: ~20 сравнений! log₂(1M) ≈ 20             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Главная интуиция: "Пирамида с правилом"

```
КУЧА = Пирамида, где родитель ВСЕГДА меньше (или больше) детей

          MIN-HEAP (корень = минимум):

                    [1]          ← Наименьший ВСЕГДА наверху!
                   /   \
                 [3]   [2]       ← Оба больше родителя (1)
                 / \   /
               [7] [4][5]        ← Все больше своих родителей

          Правило: parent ≤ children

          ВАЖНО: Нет порядка между братьями!
          [3] и [2] — оба дети [1], но [3] > [2]
          Это нормально! Heap требует порядок только parent → child
```

### Почему массив?

```
┌─────────────────────────────────────────────────────────────────────┐
│          МАГИЯ: Дерево хранится как массив!                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ДЕРЕВО:                          МАССИВ:                           │
│                                                                     │
│          [1]                      index: 0   1   2   3   4   5      │
│         /   \                     value:[1] [3] [2] [7] [4] [5]     │
│       [3]   [2]                                                     │
│       / \   /                                                       │
│     [7][4][5]                                                       │
│                                                                     │
│  ФОРМУЛЫ для index i (0-based):                                    │
│  ─────────────────────────────                                      │
│  • Родитель:     (i - 1) / 2                                       │
│  • Левый ребёнок:  2 * i + 1                                       │
│  • Правый ребёнок: 2 * i + 2                                       │
│                                                                     │
│  ПРИМЕР для index = 1 (value = 3):                                 │
│  • Parent(1) = (1-1)/2 = 0  → value[0] = 1  ✓                      │
│  • Left(1)  = 2*1+1 = 3     → value[3] = 7  ✓                      │
│  • Right(1) = 2*1+2 = 4     → value[4] = 4  ✓                      │
│                                                                     │
│  ПОЧЕМУ массив лучше указателей:                                   │
│  • Нет overhead на хранение left/right указателей                  │
│  • Cache-friendly (данные рядом в памяти)                          │
│  • Простая математика вместо разыменования                         │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Часть 2: Почему кучи сложные для изучения

> **Источники:** [Oregon State CS261](https://web.engr.oregonstate.edu/~sinisa/courses/OSU/CS261/CS261_Textbook/Chapter11.pdf), [OpenDSA Virginia Tech](https://opendsa-server.cs.vt.edu/ODSA/Books/CS3/html/Heaps.html), [Princeton Algorithms](https://algs4.cs.princeton.edu/24pq/)

### Проблема 1: Путаница Heap vs BST

```
┌─────────────────────────────────────────────────────────────────────┐
│                    HEAP ≠ BST!                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  BST (Binary Search Tree):         HEAP (Min-Heap):                │
│        [5]                               [1]                        │
│       /   \                             /   \                       │
│     [3]   [7]                         [3]   [2]                     │
│     / \                               / \                           │
│   [2] [4]                           [7] [4]                         │
│                                                                     │
│  ПРАВИЛО BST:                       ПРАВИЛО HEAP:                   │
│  left < parent < right              parent ≤ children               │
│                                                                     │
│  СЛЕДСТВИЯ:                                                         │
│  • BST: inorder = sorted            • Heap: нет полной сортировки  │
│  • BST: поиск любого O(log n)       • Heap: поиск любого O(n)!     │
│  • BST: min в самом левом           • Heap: min в корне            │
│                                                                     │
│  ОШИБКА НОВИЧКА:                                                   │
│  "Heap отсортирован" — НЕТ!                                        │
│  В heap только parent < children, братья НЕ упорядочены!          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Проблема 2: Вставка "сверху" вместо "снизу"

```kotlin
// ❌ НЕПРАВИЛЬНАЯ интуиция: "вставлю как в BST"
// Пытаемся найти место сверху вниз
fun wrongInsert(heap: MutableList<Int>, value: Int) {
    var i = 0
    while (i < heap.size) {
        if (value < heap[i]) {
            // Куда идти? Влево? Вправо? Непонятно!
            // В BST: меньше → влево. В Heap это НЕ работает!
        }
    }
}

// ✅ ПРАВИЛЬНО: вставляем в КОНЕЦ, потом "всплываем"
fun correctInsert(heap: MutableList<Int>, value: Int) {
    heap.add(value)  // Добавляем в конец (сохраняем complete tree)
    siftUp(heap.lastIndex)  // "Всплываем" пока не найдём место
}

// Почему снизу вверх?
// 1. Complete tree требует заполнения слева направо
// 2. Добавление в конец — единственный способ сохранить форму
// 3. Sift-up восстанавливает heap property
```

### Проблема 3: Путаница с терминами "Heap" vs "Heap Memory"

```
┌─────────────────────────────────────────────────────────────────────┐
│                 ДВА РАЗНЫХ "HEAP"!                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  HEAP (структура данных):           HEAP MEMORY:                   │
│  • Полное бинарное дерево           • Область памяти для malloc    │
│  • Для приоритетных очередей        • Для динамических объектов    │
│  • O(log n) операции                • "new Object()" в Java        │
│                                                                     │
│  НИКАКОЙ связи между ними!                                         │
│  Просто одинаковое название.                                       │
│                                                                     │
│  Когда говорят "heap allocation" — это про память.                 │
│  Когда говорят "min-heap" — это про структуру данных.              │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Проблема 4: Min-Heap vs Max-Heap для Top K

```
┌─────────────────────────────────────────────────────────────────────┐
│          ПАРАДОКС TOP K: Для наибольших нужен MIN-heap!            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ЗАДАЧА: Найти 3 наибольших из [5, 2, 9, 1, 7, 8, 3]               │
│                                                                     │
│  ❌ НЕПРАВИЛЬНАЯ интуиция:                                         │
│  "Для наибольших нужен MAX-heap!"                                  │
│                                                                     │
│  Если использовать MAX-heap:                                       │
│  • Добавляем все 7 элементов                                       │
│  • Heap растёт до размера n                                        │
│  • poll() 3 раза → O(n + 3 log n) = O(n log n)                    │
│                                                                     │
│  ✅ ПРАВИЛЬНО: MIN-heap размера K=3                                │
│                                                                     │
│  Алгоритм:                                                         │
│  1. Добавляем 5: [5]                                               │
│  2. Добавляем 2: [2, 5]                                            │
│  3. Добавляем 9: [2, 5, 9]      (размер = K)                       │
│  4. Приходит 1: 1 < 2 (корень) → ПРОПУСКАЕМ                        │
│  5. Приходит 7: 7 > 2 → удаляем 2, добавляем 7: [5, 7, 9]          │
│  6. Приходит 8: 8 > 5 → удаляем 5, добавляем 8: [7, 8, 9]          │
│  7. Приходит 3: 3 < 7 → ПРОПУСКАЕМ                                 │
│                                                                     │
│  Результат: [7, 8, 9] — три наибольших! ✓                          │
│  Сложность: O(n log K) — ЛУЧШЕ чем O(n log n)!                     │
│                                                                     │
│  ПОЧЕМУ MIN-heap работает:                                         │
│  • Корень = минимальный из K наибольших                            │
│  • Если новый элемент > корня → он "заслуживает" быть в Top K     │
│  • Если новый элемент < корня → он точно НЕ в Top K               │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Проблема 5: Итерация по PriorityQueue

```kotlin
// ❌ ЧАСТАЯ ОШИБКА: думать что forEach даст отсортированный порядок
val pq = PriorityQueue<Int>()
pq.addAll(listOf(5, 1, 3, 2, 4))

// НЕПРАВИЛЬНО: итерация НЕ гарантирует порядок!
pq.forEach { println(it) }  // Может вывести: 1 2 3 5 4 (НЕ 1 2 3 4 5!)

// ПОЧЕМУ?
// PriorityQueue — это массив-heap, НЕ отсортированный массив!
// Heap гарантирует только: корень = минимум
// Остальные элементы НЕ отсортированы!

// ✅ ПРАВИЛЬНО: для отсортированного вывода используй poll()
while (pq.isNotEmpty()) {
    println(pq.poll())  // Гарантированно: 1 2 3 4 5
}
```

### Проблема 6: Build Heap O(n) vs O(n log n)

```
┌─────────────────────────────────────────────────────────────────────┐
│          Build Heap за O(n), а НЕ O(n log n)!                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ❌ НЕПРАВИЛЬНАЯ интуиция:                                         │
│  "n вставок по O(log n) = O(n log n)"                              │
│                                                                     │
│  ✅ ПРАВИЛЬНО: Floyd's метод за O(n)!                              │
│                                                                     │
│  ПОЧЕМУ O(n)?                                                       │
│                                                                     │
│  Уровень:  Узлов:   Макс. sift-down:                               │
│     0        1         h шагов      (только корень)                │
│     1        2         h-1 шагов                                    │
│     2        4         h-2 шагов                                    │
│    ...      ...        ...                                          │
│     h       n/2        0 шагов      (ЛИСТЬЯ — половина!)           │
│                                                                     │
│  Интуиция: Большинство узлов — листья (n/2).                       │
│  Листья НЕ требуют sift-down (нет детей).                          │
│  Только корень требует O(log n) работы, но он ОДИН.                │
│                                                                     │
│  Математика: 1*h + 2*(h-1) + 4*(h-2) + ... + n/2*0 = O(n)         │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Часть 3: Ментальные модели для работы с кучами

### Модель 1: "Пирамида с правилом наверх"

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ПИРАМИДА ВЛАСТИ                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Min-Heap = Пирамида, где "самый важный" наверху                   │
│                                                                     │
│                      👑 [1]        ← "Главный" (минимум)            │
│                     /     \                                         │
│                  [3]       [2]     ← "Заместители"                  │
│                 /   \     /                                         │
│               [7]  [4]  [5]        ← "Рядовые"                      │
│                                                                     │
│  ПРАВИЛО: Начальник ВСЕГДА "важнее" подчинённых.                   │
│  (В min-heap: родитель ≤ детей)                                    │
│                                                                     │
│  INSERT (новый сотрудник):                                         │
│  1. Приходит новый → ставим в конец (рядовой)                      │
│  2. Если "важнее" начальника → ПОВЫШАЕМ (swap)                     │
│  3. Повторяем пока не дойдём до места                              │
│                                                                     │
│  EXTRACT (главный уходит):                                         │
│  1. Главный уходит → ставим рядового на его место                  │
│  2. Он слабее подчинённых → ПОНИЖАЕМ (swap с лучшим)               │
│  3. Повторяем пока не устаканится                                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Модель 2: "Пузырьки в воде"

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ПУЗЫРЬКИ (Bubble Up/Down)                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Min-Heap = Стакан воды с пузырьками (числа = размер)              │
│                                                                     │
│  МАЛЕНЬКИЕ пузырьки ВСПЛЫВАЮТ!                                     │
│  БОЛЬШИЕ пузырьки ТОНУТ!                                           │
│                                                                     │
│  Вода (до вставки):        После вставки 0:                        │
│         ~~~                       ~~~                               │
│        [1]                       [0]  ← 0 всплыл на поверхность!   │
│       /   \                     /   \                               │
│     [3]   [2]                 [1]   [2]                             │
│     / \                       / \   /                               │
│   [7] [4]                   [7] [3][4]                              │
│                                   ↑                                 │
│                               1 опустился, 3 опустился             │
│                                                                     │
│  SIFT-UP = "всплытие" маленького пузырька вверх                    │
│  SIFT-DOWN = "погружение" большого пузырька вниз                   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Модель 3: "Турнир наоборот"

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ТУРНИР (для Max-Heap)                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Max-Heap = Турнирная сетка, где победитель наверху               │
│                                                                     │
│                      🏆 [9]        ← Чемпион (максимум)             │
│                     /      \                                        │
│  Полуфинал:      [7]       [8]     ← Проиграли финал               │
│                 /   \     /                                         │
│  Четверть:    [5]  [3]  [2]        ← Проиграли раньше              │
│                                                                     │
│  ПРАВИЛО: Победитель матча ВСЕГДА "сильнее" проигравшего.          │
│  (В max-heap: родитель ≥ детей)                                    │
│                                                                     │
│  Чемпион уходит? Проводим "переигровку":                           │
│  1. Ставим кого-то на место чемпиона                               │
│  2. Играет матчи вниз, пока не найдёт своё место                   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Модель 4: "Конвейер с сортировкой"

```
┌─────────────────────────────────────────────────────────────────────┐
│                 TOP K: Конвейер с фильтром                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Задача: Найти 3 самых тяжёлых из потока посылок                   │
│                                                                     │
│  Min-Heap размера K=3 = "Корзина для лидеров"                      │
│                                                                     │
│     Поток посылок:    5 → 2 → 9 → 1 → 7 → 8 → 3                    │
│                       ↓                                             │
│                 ┌───────────┐                                       │
│                 │ ФИЛЬТР    │   "Тяжелее минимума в корзине?"       │
│                 └─────┬─────┘                                       │
│                       │                                             │
│      ┌────────────────┼────────────────┐                            │
│      │          КОРЗИНА (K=3)          │                            │
│      │     Min-heap: лёгкий наверху    │                            │
│      │                                 │                            │
│      │          [7]  ← Порог входа     │                            │
│      │         /   \                   │                            │
│      │       [8]   [9]                 │                            │
│      │                                 │                            │
│      │   "Новая посылка тяжелее 7?    │                            │
│      │    → Выкинь 7, возьми новую"   │                            │
│      │                                 │                            │
│      └─────────────────────────────────┘                            │
│                                                                     │
│  ГЕНИАЛЬНОСТЬ:                                                     │
│  • Корзина хранит только K элементов → O(K) памяти                │
│  • Проверка "достоин ли?" = O(1) сравнение с корнем               │
│  • Общая сложность: O(n log K), а не O(n log n)!                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Выбор модели по ситуации

| Ситуация | Лучшая модель | Почему |
|----------|---------------|--------|
| Insert/Extract | Пузырьки | Наглядно показывает движение |
| Top K | Конвейер с фильтром | Объясняет min-heap для наибольших |
| Max-heap | Турнир | Интуитивно для "кто сильнее" |
| Иерархия | Пирамида власти | Понятно про parent-child |
| Build heap | Строительство | Снизу вверх, уровень за уровнем |

---

## Зачем это нужно?

### Мотивирующая проблема

**Задача: Система экстренной помощи 112**

В call-центр 112 поступают вызовы разной срочности:
- Пожар с пострадавшими (приоритет 10)
- ДТП без жертв (приоритет 7)
- Кража (приоритет 3)
- Потерянная кошка (приоритет 1)

**Требования:**
- Обрабатывать самый срочный вызов первым
- Новые вызовы поступают постоянно
- Нужно быстро находить самый приоритетный

**Как решить?**

```
Вариант 1: Простой список
- Добавление: O(1)
- Найти максимум: O(n) — нужно просмотреть все
→ При 10000 вызовов = медленно

Вариант 2: Отсортированный список
- Найти максимум: O(1)
- Добавление: O(n) — нужно найти место и сдвинуть
→ Постоянные вставки = медленно

Вариант 3: Куча (Heap)
- Добавление: O(log n)
- Найти/извлечь максимум: O(1) / O(log n)
→ При 10000 вызовов: ~13 операций vs 10000
```

### Где используются кучи?

| Область | Применение | Пример |
|---------|------------|--------|
| Алгоритмы | Dijkstra, Prim | GPS навигация |
| Планирование | Очередь задач OS | Процессы в Linux |
| Сжатие | Huffman coding | JPEG, MP3, ZIP |
| Базы данных | Top-K запросы | "Топ 10 продаж" |
| Игры | A* pathfinding | NPC навигация |
| Финансы | Order matching | Биржевые торги |
| Медицина | Triage система | Приоритет пациентов |

**Факт:** Алгоритм Dijkstra с кучей работает за O((V+E) log V). Без кучи — O(V²). Для графа Google Maps (миллиарды вершин) это разница между секундами и часами.

---

## Что это такое?

### Объяснение для 5-летнего

Представь пирамиду из кубиков с числами:
- На **вершине** всегда самый маленький (или самый большой) кубик
- Каждый кубик **держит** два кубика под собой
- Кубики под ним всегда больше (или меньше) чем он

```
Min-Heap (самый маленький наверху):

          [2]           ← Корень: минимальный элемент
         /   \
       [5]   [3]
       / \   /
     [8][9][6]

Правило: Родитель ≤ Детей
2 ≤ 5, 2 ≤ 3, 5 ≤ 8, 5 ≤ 9, 3 ≤ 6 ✓
```

Когда добавляешь новый кубик — он "всплывает" вверх, пока не найдёт своё место.
Когда забираешь верхний — последний кубик ставится наверх и "тонет" вниз.

### Формальное определение

**Куча (Heap)** — это полное бинарное дерево, удовлетворяющее свойству кучи:

**Min-Heap**: ∀ узла i: `value(parent(i)) ≤ value(i)`
**Max-Heap**: ∀ узла i: `value(parent(i)) ≥ value(i)`

**Полное бинарное дерево**: все уровни заполнены, кроме последнего, который заполняется слева направо.

```
ПОЛНОЕ (heap-valid):          НЕ ПОЛНОЕ (heap-invalid):

        [1]                         [1]
       /   \                       /   \
     [2]   [3]                   [2]   [3]
     / \                               /
   [4] [5]                           [4]

Последний уровень              Дырка слева
заполняется слева
```

### Представление в виде массива

Куча хранится как массив — это эффективнее, чем указатели:

```
Дерево:                    Массив (0-based):
        [2]                index:  0   1   2   3   4   5
       /   \               value: [2] [5] [3] [8] [9] [6]
     [5]   [3]
     / \   /
   [8][9][6]

Формулы (0-based indexing):
- Parent(i) = (i - 1) / 2
- Left(i)   = 2 * i + 1
- Right(i)  = 2 * i + 2

Пример для index=1 (value=5):
- Parent(1) = (1-1)/2 = 0 → value=2 ✓
- Left(1)   = 2*1+1 = 3 → value=8 ✓
- Right(1)  = 2*1+2 = 4 → value=9 ✓
```

---

## Терминология

| Термин | Английский | Определение | Пример |
|--------|------------|-------------|--------|
| Куча | Heap | Полное бинарное дерево со свойством кучи | Min-heap, Max-heap |
| Min-Heap | Min-Heap | Минимум в корне, родитель ≤ детей | [1, 3, 2, 7, 4] |
| Max-Heap | Max-Heap | Максимум в корне, родитель ≥ детей | [7, 4, 3, 1, 2] |
| Очередь с приоритетом | Priority Queue | ADT, элементы извлекаются по приоритету | PriorityQueue в Java |
| Sift-Up | Bubble-Up, Heapify-Up | Перемещение элемента вверх | После insert |
| Sift-Down | Bubble-Down, Heapify-Down | Перемещение элемента вниз | После extract |
| Heapify | Heapify | Построение кучи из массива | O(n) Floyd's method |
| Extract | Extract-Min/Max | Извлечение корня | poll() в Java |
| Peek | Get-Min/Max | Просмотр корня без удаления | peek() в Java |
| Полное дерево | Complete Binary Tree | Все уровни заполнены, кроме последнего | Требование heap |

---

## Как это работает?

### Операция: Insert (Sift-Up)

```
Добавляем 1 в min-heap [2, 5, 3, 8, 9, 6]:

Шаг 1: Добавляем в конец
        [2]
       /   \
     [5]   [3]
     / \   / \
   [8][9][6][1]  ← Добавили 1 в позицию 6

Шаг 2: Sift-Up — сравниваем с родителем
1 < 3? Да → меняем местами
        [2]
       /   \
     [5]   [1]  ← 1 поднялся
     / \   / \
   [8][9][6][3]

Шаг 3: Продолжаем sift-up
1 < 2? Да → меняем местами
        [1]  ← 1 теперь корень
       /   \
     [5]   [2]
     / \   / \
   [8][9][6][3]

Шаг 4: Родителя нет → СТОП
Результат: [1, 5, 2, 8, 9, 6, 3]
```

### Операция: Extract-Min (Sift-Down)

```
Извлекаем минимум из [1, 5, 2, 8, 9, 6, 3]:

Шаг 1: Сохраняем корень, заменяем последним элементом
        [3]  ← Последний элемент (3) на место корня
       /   \
     [5]   [2]
     / \   /
   [8][9][6]

Шаг 2: Sift-Down — сравниваем с меньшим ребёнком
Дети 3: [5, 2], min = 2
3 > 2? Да → меняем местами
        [2]
       /   \
     [5]   [3]  ← 3 опустился
     / \   /
   [8][9][6]

Шаг 3: Продолжаем sift-down
Дети 3: [6], 3 < 6 → СТОП

Результат: [2, 5, 3, 8, 9, 6]
Извлечённый элемент: 1
```

### Операция: Build Heap (Floyd's Method)

```
Построить min-heap из [4, 10, 3, 5, 1]:

Начальное дерево (не куча):
        [4]
       /   \
    [10]   [3]
     / \
   [5] [1]

Шаг 1: Начинаем с последнего не-листа (index = n/2 - 1 = 1)
Heapify(index=1): [10] с детьми [5, 1]
min(10, 5, 1) = 1 → меняем 10 и 1
        [4]
       /   \
     [1]   [3]
     / \
   [5][10]

Шаг 2: Heapify(index=0): [4] с детьми [1, 3]
min(4, 1, 3) = 1 → меняем 4 и 1
        [1]
       /   \
     [4]   [3]  ← 4 может нарушить свойство
     / \
   [5][10]

Шаг 3: Рекурсивно heapify позицию, куда переместился 4
[4] с детьми [5, 10]: 4 < 5 и 4 < 10 → OK

Результат: [1, 4, 3, 5, 10] — валидная min-heap
```

**Почему Build Heap за O(n)?**

```
Уровень (сверху)  Узлов   Макс. sift-down шагов
      0             1            h
      1             2            h-1
      2             4            h-2
      ...          ...           ...
      h           n/2            0     ← Листья — 0 шагов!

Сумма работы = 1*h + 2*(h-1) + 4*(h-2) + ... + n/2*0
             = O(n)  (геометрическая прогрессия)

Интуиция: большинство узлов — листья (n/2), и они не требуют работы.
Только корень требует O(log n) работы, но он один.
```

---

## Сложность операций

### Основные операции

| Операция | Время | Объяснение |
|----------|-------|------------|
| peek() / findMin | O(1) | Корень всегда минимум/максимум |
| insert() / offer | O(log n) | Sift-up от листа до корня |
| extract() / poll | O(log n) | Sift-down от корня до листа |
| build heap | O(n) | Floyd's method |
| heapify (один узел) | O(log n) | Один проход вниз |
| size() | O(1) | Хранится как поле |
| isEmpty() | O(1) | Проверка size == 0 |

### Сравнение с альтернативами

| Операция | Heap | Sorted Array | BST (balanced) |
|----------|------|--------------|----------------|
| Find min/max | O(1) | O(1) | O(log n) |
| Insert | O(log n) | O(n) | O(log n) |
| Delete min/max | O(log n) | O(1) / O(n) | O(log n) |
| Build from array | O(n) | O(n log n) | O(n log n) |
| Space | O(n) | O(n) | O(n) |

**Когда heap лучше BST?**
- Нужен только min/max (не произвольный поиск)
- Важна cache locality (массив vs указатели)
- Build heap за O(n) vs O(n log n)

---

## Реализация

### Kotlin — Min-Heap с нуля

```kotlin
/**
 * Min-Heap реализация на массиве
 *
 * WHY array: O(1) доступ по индексу, cache-friendly,
 * не нужны указатели на детей/родителя
 */
class MinHeap {
    // WHY ArrayList: динамический размер, не нужно знать размер заранее
    private val heap = ArrayList<Int>()

    val size: Int get() = heap.size
    fun isEmpty(): Boolean = heap.isEmpty()

    /**
     * Возвращает минимум без удаления
     * WHY O(1): минимум всегда в корне (index 0)
     */
    fun peek(): Int {
        if (isEmpty()) throw NoSuchElementException("Heap is empty")
        return heap[0]
    }

    /**
     * Добавляет элемент в кучу
     *
     * WHY add to end: сохраняем свойство полного дерева
     * WHY sift-up: восстанавливаем свойство кучи
     */
    fun insert(value: Int) {
        heap.add(value)        // O(1) amortized
        siftUp(heap.lastIndex) // O(log n)
    }

    /**
     * Извлекает и удаляет минимум
     *
     * WHY swap with last: удаление из конца массива O(1),
     * удаление из начала было бы O(n) из-за сдвига
     */
    fun extractMin(): Int {
        if (isEmpty()) throw NoSuchElementException("Heap is empty")

        val min = heap[0]
        val last = heap.removeAt(heap.lastIndex)

        if (heap.isNotEmpty()) {
            heap[0] = last     // Ставим последний на место корня
            siftDown(0)        // Восстанавливаем свойство кучи
        }

        return min
    }

    /**
     * Sift-Up: перемещаем элемент вверх пока heap property не восстановлено
     *
     * WHY while loop: может потребоваться несколько обменов
     * WHY parent check: останавливаемся когда родитель меньше или достигли корня
     */
    private fun siftUp(index: Int) {
        var i = index

        while (i > 0) {
            val parentIdx = (i - 1) / 2

            // WHY this condition: min-heap требует parent ≤ child
            if (heap[parentIdx] <= heap[i]) break

            // Меняем с родителем
            swap(i, parentIdx)
            i = parentIdx
        }
    }

    /**
     * Sift-Down: перемещаем элемент вниз пока heap property не восстановлено
     *
     * WHY compare with smaller child: в min-heap меньший ребёнок
     * должен стать родителем если текущий узел больше обоих детей
     */
    private fun siftDown(index: Int) {
        var i = index

        while (true) {
            val leftIdx = 2 * i + 1
            val rightIdx = 2 * i + 2
            var smallest = i

            // WHY check bounds: ребёнок может не существовать
            if (leftIdx < heap.size && heap[leftIdx] < heap[smallest]) {
                smallest = leftIdx
            }
            if (rightIdx < heap.size && heap[rightIdx] < heap[smallest]) {
                smallest = rightIdx
            }

            // WHY break condition: элемент на своём месте
            if (smallest == i) break

            swap(i, smallest)
            i = smallest
        }
    }

    private fun swap(i: Int, j: Int) {
        val temp = heap[i]
        heap[i] = heap[j]
        heap[j] = temp
    }

    /**
     * Построение кучи из массива за O(n)
     *
     * WHY start from n/2-1: листья (индексы ≥ n/2) уже удовлетворяют
     * свойству кучи — у них нет детей
     *
     * WHY downTo: обрабатываем снизу вверх, чтобы siftDown
     * работал на уже исправленных поддеревьях
     */
    fun buildHeap(arr: IntArray) {
        heap.clear()
        heap.addAll(arr.toList())

        // WHY n/2 - 1: индекс последнего не-листа
        for (i in heap.size / 2 - 1 downTo 0) {
            siftDown(i)
        }
    }
}
```

### Kotlin — Использование PriorityQueue

```kotlin
import java.util.PriorityQueue

/**
 * PriorityQueue в Kotlin — это java.util.PriorityQueue
 *
 * WHY use standard: проверено, оптимизировано, потокобезопасные альтернативы есть
 */
fun priorityQueueExamples() {
    // Min-Heap (по умолчанию)
    val minHeap = PriorityQueue<Int>()
    minHeap.offer(5)
    minHeap.offer(2)
    minHeap.offer(8)
    println(minHeap.poll())  // 2 — минимум

    // Max-Heap — используем reverseOrder или compareByDescending
    val maxHeap = PriorityQueue<Int>(compareByDescending { it })
    // Или: PriorityQueue<Int>(Collections.reverseOrder())
    // Или: PriorityQueue<Int> { a, b -> b - a }
    maxHeap.offer(5)
    maxHeap.offer(2)
    maxHeap.offer(8)
    println(maxHeap.poll())  // 8 — максимум

    // Кастомный компаратор — сортировка по второму элементу пары
    val customHeap = PriorityQueue<Pair<String, Int>>(compareBy { it.second })
    customHeap.offer("task1" to 3)
    customHeap.offer("task2" to 1)
    customHeap.offer("task3" to 2)
    println(customHeap.poll())  // (task2, 1) — минимальный приоритет

    // Для объектов — по полю
    data class Task(val name: String, val priority: Int)
    val taskHeap = PriorityQueue<Task>(compareBy { it.priority })
}

/**
 * ВАЖНО: PriorityQueue НЕ гарантирует порядок при итерации!
 *
 * Только poll() гарантированно возвращает min/max.
 * Итерация через forEach может быть в любом порядке.
 */
fun iterationPitfall() {
    val pq = PriorityQueue<Int>()
    pq.addAll(listOf(5, 1, 3, 2, 4))

    // НЕПРАВИЛЬНО: порядок не гарантирован!
    pq.forEach { print("$it ") }  // Может быть: 1 2 3 5 4

    // ПРАВИЛЬНО: извлекаем по одному
    while (pq.isNotEmpty()) {
        print("${pq.poll()} ")  // Гарантированно: 1 2 3 4 5
    }
}
```

### Java — Min-Heap и Max-Heap

```java
import java.util.*;

public class HeapExamples {

    /**
     * Min-Heap (по умолчанию в Java)
     */
    public static void minHeapExample() {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        minHeap.offer(5);
        minHeap.offer(2);
        minHeap.offer(8);

        System.out.println(minHeap.poll());  // 2
    }

    /**
     * Max-Heap — нужен Comparator
     */
    public static void maxHeapExample() {
        // Способ 1: Collections.reverseOrder()
        PriorityQueue<Integer> maxHeap1 = new PriorityQueue<>(Collections.reverseOrder());

        // Способ 2: Lambda comparator
        PriorityQueue<Integer> maxHeap2 = new PriorityQueue<>((a, b) -> b - a);

        // Способ 3: Comparator.reverseOrder()
        PriorityQueue<Integer> maxHeap3 = new PriorityQueue<>(Comparator.reverseOrder());

        maxHeap1.offer(5);
        maxHeap1.offer(2);
        maxHeap1.offer(8);

        System.out.println(maxHeap1.poll());  // 8
    }

    /**
     * Custom object with comparator
     */
    public static void customComparatorExample() {
        // По расстоянию (для задачи K Closest Points)
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
            int distA = a[0] * a[0] + a[1] * a[1];
            int distB = b[0] * b[0] + b[1] * b[1];
            return distA - distB;  // Min-heap по расстоянию
        });

        pq.offer(new int[]{3, 3});  // dist = 18
        pq.offer(new int[]{1, 1});  // dist = 2
        pq.offer(new int[]{2, 2});  // dist = 8

        int[] closest = pq.poll();  // [1, 1]
    }
}
```

### Python — heapq

```python
import heapq
from typing import List

def heap_examples():
    """
    Python heapq — это MIN-HEAP
    Для max-heap нужно негатировать значения
    """
    # Min-heap
    min_heap = []
    heapq.heappush(min_heap, 5)
    heapq.heappush(min_heap, 2)
    heapq.heappush(min_heap, 8)
    print(heapq.heappop(min_heap))  # 2

    # Max-heap — негатируем значения
    max_heap = []
    heapq.heappush(max_heap, -5)
    heapq.heappush(max_heap, -2)
    heapq.heappush(max_heap, -8)
    print(-heapq.heappop(max_heap))  # 8

    # Heapify — построить heap из списка за O(n)
    arr = [5, 2, 8, 1, 9]
    heapq.heapify(arr)  # In-place! arr теперь [1, 2, 8, 5, 9]

    # nlargest / nsmallest — топ K элементов
    data = [5, 2, 8, 1, 9, 3]
    print(heapq.nlargest(3, data))   # [9, 8, 5]
    print(heapq.nsmallest(3, data))  # [1, 2, 3]


def custom_comparator_python():
    """
    Для кастомной сортировки используем кортежи
    """
    # Сортировка по приоритету (первый элемент кортежа)
    tasks = []
    heapq.heappush(tasks, (3, "low priority"))
    heapq.heappush(tasks, (1, "high priority"))
    heapq.heappush(tasks, (2, "medium priority"))

    while tasks:
        priority, task = heapq.heappop(tasks)
        print(f"{priority}: {task}")
    # Output:
    # 1: high priority
    # 2: medium priority
    # 3: low priority
```

---

## Паттерны решения задач

### Паттерн 1: Top K Elements

```kotlin
/**
 * Найти K наибольших элементов
 *
 * WHY min-heap размера K:
 * - Храним K наибольших
 * - Корень = минимальный из K наибольших
 * - Если новый элемент > корня → он входит в Top K
 *
 * Time: O(n log k) — лучше чем сортировка O(n log n)
 * Space: O(k)
 */
fun topKLargest(nums: IntArray, k: Int): List<Int> {
    // Min-heap размера K
    val minHeap = PriorityQueue<Int>()

    for (num in nums) {
        minHeap.offer(num)

        // WHY remove when size > k: держим только K наибольших
        if (minHeap.size > k) {
            minHeap.poll()  // Удаляем минимальный
        }
    }

    return minHeap.toList()  // K наибольших
}

/**
 * Найти K-й наибольший элемент (LeetCode 215)
 */
fun kthLargest(nums: IntArray, k: Int): Int {
    val minHeap = PriorityQueue<Int>()

    for (num in nums) {
        minHeap.offer(num)
        if (minHeap.size > k) {
            minHeap.poll()
        }
    }

    // WHY peek: корень = K-й наибольший (минимальный из K наибольших)
    return minHeap.peek()
}
```

### Паттерн 2: Merge K Sorted Lists

```kotlin
/**
 * Слить K отсортированных списков (LeetCode 23)
 *
 * WHY heap: в любой момент нужен минимальный из K текущих элементов
 * Time: O(N log K) где N = общее количество элементов
 */
fun mergeKLists(lists: Array<ListNode?>): ListNode? {
    // Min-heap по значению узла
    val minHeap = PriorityQueue<ListNode>(compareBy { it.value })

    // Добавляем головы всех списков
    for (list in lists) {
        list?.let { minHeap.offer(it) }
    }

    val dummy = ListNode(0)
    var current = dummy

    while (minHeap.isNotEmpty()) {
        val smallest = minHeap.poll()
        current.next = smallest
        current = smallest

        // WHY add next: продолжаем из того же списка
        smallest.next?.let { minHeap.offer(it) }
    }

    return dummy.next
}
```

### Паттерн 3: Two Heaps (Медиана в потоке)

```kotlin
/**
 * Медиана в потоке данных (LeetCode 295)
 *
 * WHY two heaps:
 * - maxHeap хранит меньшую половину (максимум = медиана кандидат)
 * - minHeap хранит большую половину (минимум = медиана кандидат)
 *
 * Invariant: размеры отличаются максимум на 1
 */
class MedianFinder {
    // Меньшая половина — max-heap (чтобы быстро получить максимум)
    private val maxHeap = PriorityQueue<Int>(compareByDescending { it })
    // Большая половина — min-heap (чтобы быстро получить минимум)
    private val minHeap = PriorityQueue<Int>()

    fun addNum(num: Int) {
        // Шаг 1: Добавляем в maxHeap (меньшую половину)
        maxHeap.offer(num)

        // Шаг 2: Балансируем — перекидываем максимум меньшей половины в большую
        minHeap.offer(maxHeap.poll())

        // Шаг 3: Балансируем размеры — maxHeap может быть больше на 1
        if (minHeap.size > maxHeap.size) {
            maxHeap.offer(minHeap.poll())
        }
    }

    fun findMedian(): Double {
        return if (maxHeap.size > minHeap.size) {
            maxHeap.peek().toDouble()  // Нечётное количество
        } else {
            (maxHeap.peek() + minHeap.peek()) / 2.0  // Чётное
        }
    }
}
```

### Паттерн 4: Scheduling / Task Processing

```kotlin
/**
 * Задача: минимизировать максимальное время ожидания
 * Используем heap для выбора следующей задачи
 */
fun scheduleTasks(tasks: IntArray): Int {
    // Min-heap по длительности (короткие задачи первыми = SJF)
    val minHeap = PriorityQueue<Int>()
    tasks.forEach { minHeap.offer(it) }

    var totalWaitTime = 0
    var currentTime = 0

    while (minHeap.isNotEmpty()) {
        val task = minHeap.poll()
        totalWaitTime += currentTime  // Время ожидания этой задачи
        currentTime += task           // Задача выполняется
    }

    return totalWaitTime
}
```

---

## Распространённые ошибки

### 1. Итерация вместо poll()

```kotlin
// НЕПРАВИЛЬНО: итерация не гарантирует порядок!
val pq = PriorityQueue<Int>()
pq.addAll(listOf(5, 1, 3))

pq.forEach { println(it) }  // Может вывести: 1 5 3 (не 1 3 5!)

// ПРАВИЛЬНО: используйте poll() для упорядоченного извлечения
while (pq.isNotEmpty()) {
    println(pq.poll())  // Гарантированно: 1, 3, 5
}
```

### 2. Min-Heap вместо Max-Heap

```kotlin
// НЕПРАВИЛЬНО: для Top K наибольших нужен min-heap, не max-heap!
fun topKWrong(nums: IntArray, k: Int): List<Int> {
    val maxHeap = PriorityQueue<Int>(compareByDescending { it })
    nums.forEach { maxHeap.offer(it) }

    // BUG: heap растёт до n элементов, нет смысла
    return (1..k).map { maxHeap.poll() }  // O(n log n), не O(n log k)
}

// ПРАВИЛЬНО: min-heap размера K
fun topKCorrect(nums: IntArray, k: Int): List<Int> {
    val minHeap = PriorityQueue<Int>()

    for (num in nums) {
        minHeap.offer(num)
        if (minHeap.size > k) {
            minHeap.poll()  // Убираем минимальный
        }
    }

    return minHeap.toList()
}
```

### 3. Неправильный компаратор

```kotlin
// НЕПРАВИЛЬНО: a - b может overflow при больших числах!
val badHeap = PriorityQueue<Int> { a, b -> a - b }

// ПРАВИЛЬНО: используйте compare или compareTo
val goodHeap1 = PriorityQueue<Int>(compareBy { it })
val goodHeap2 = PriorityQueue<Int> { a, b -> a.compareTo(b) }

// Для max-heap
val maxHeap = PriorityQueue<Int>(compareByDescending { it })
```

### 4. Забыли о динамическом приоритете

```kotlin
// ПРОБЛЕМА: изменение объекта в heap не обновляет его позицию!
data class Task(var priority: Int, val name: String)

val heap = PriorityQueue<Task>(compareBy { it.priority })
val task = Task(5, "Task A")
heap.offer(task)

task.priority = 1  // BUG: heap не знает об изменении!
println(heap.peek())  // Всё ещё может быть другой элемент

// РЕШЕНИЕ: remove + add (или использовать IndexedPriorityQueue)
heap.remove(task)
task.priority = 1
heap.offer(task)
```

### 5. Build Heap vs последовательный Insert

```kotlin
// НЕЭФФЕКТИВНО: O(n log n)
val heap = PriorityQueue<Int>()
for (num in largeArray) {
    heap.offer(num)  // Каждый offer = O(log n)
}

// ЭФФЕКТИВНО в Java/Kotlin: O(n) — используйте конструктор с коллекцией
val efficientHeap = PriorityQueue(largeArray.toList())

// В Python — heapify:
// heapq.heapify(arr)  # O(n), in-place
```

---

## Когда использовать?

### Heap vs другие структуры

```
            ВЫБОР СТРУКТУРЫ ДАННЫХ
                    │
    ┌───────────────┼───────────────┐
    │               │               │
Нужен только    Нужен поиск      Нужен и min/max
 min/max?      произвольного     и произвольный
    │           элемента?          поиск?
    │               │               │
    ▼               ▼               ▼
  HEAP            BST            BALANCED BST
  O(1) peek      O(log n)         (TreeMap)
  O(log n) ops   все ops       O(log n) все ops
```

### Когда использовать Heap

| Сценарий | Почему Heap |
|----------|-------------|
| Top K elements | O(n log k) < O(n log n) сортировки |
| Медиана в потоке | Two heaps: O(1) median, O(log n) insert |
| Dijkstra/Prim | Быстрое извлечение минимума |
| Task scheduling | Приоритетная обработка |
| Merge K sorted | O(N log K) вместо O(N log N) |
| Event simulation | Следующее событие по времени |

### Когда НЕ использовать Heap

| Сценарий | Лучшая альтернатива |
|----------|---------------------|
| Поиск произвольного элемента | BST, HashSet |
| Частые обновления приоритета | Indexed Heap, Fibonacci Heap |
| Нужен отсортированный порядок | TreeSet, сортировка |
| Маленькие данные (< 100) | Простой список + max() |

---

## Практика

### Концептуальные вопросы

1. **Q:** Почему Build Heap за O(n), а не O(n log n)?

   **A:** Большинство узлов — листья (n/2), которые не требуют sift-down. Узлы на уровне выше требуют максимум 1 шаг, ещё выше — 2 шага, и только корень требует log n шагов. Сумма этой геометрической прогрессии = O(n).

2. **Q:** Почему для Top K наибольших используем min-heap, а не max-heap?

   **A:** Min-heap размера K хранит K наибольших элементов, где корень — минимальный из них. Когда приходит новый элемент > корня, мы знаем, что он входит в Top K. Удаляем корень (минимальный), добавляем новый. С max-heap пришлось бы хранить все n элементов.

3. **Q:** Можно ли найти медиану за O(1) с одним heap?

   **A:** Нет. Heap гарантирует только O(1) доступ к min ИЛИ max, но не к медиане. Для O(1) медианы нужны два heap (max-heap для меньшей половины, min-heap для большей) или order statistics tree.

4. **Q:** Почему PriorityQueue в Java не гарантирует порядок при итерации?

   **A:** Внутренне PriorityQueue — это массив-heap. Heap property гарантирует только что корень — минимум. Остальные элементы не отсортированы относительно друг друга. Для отсортированной итерации нужно использовать poll().

5. **Q:** Когда Fibonacci Heap лучше Binary Heap?

   **A:** Fibonacci Heap имеет O(1) amortized insert и decrease-key (vs O(log n) в binary heap). Это улучшает Dijkstra до O(E + V log V). Но на практике константы больше, и binary heap быстрее для большинства реальных графов.

### LeetCode задачи

#### Easy

| # | Задача | Паттерн |
|---|--------|---------|
| 703 | [Kth Largest Element in a Stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/) | Min-heap размера K |
| 1046 | [Last Stone Weight](https://leetcode.com/problems/last-stone-weight/) | Max-heap simulation |
| 506 | [Relative Ranks](https://leetcode.com/problems/relative-ranks/) | Max-heap + mapping |

#### Medium

| # | Задача | Паттерн |
|---|--------|---------|
| 215 | [Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/) | Top K |
| 347 | [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/) | Top K + HashMap |
| 973 | [K Closest Points to Origin](https://leetcode.com/problems/k-closest-points-to-origin/) | Top K с custom distance |
| 692 | [Top K Frequent Words](https://leetcode.com/problems/top-k-frequent-words/) | Top K + custom comparator |
| 767 | [Reorganize String](https://leetcode.com/problems/reorganize-string/) | Max-heap greedy |
| 621 | [Task Scheduler](https://leetcode.com/problems/task-scheduler/) | Max-heap + cooldown |
| 378 | [Kth Smallest Element in Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/) | Min-heap + BFS |
| 373 | [Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/) | Min-heap pairs |
| 1642 | [Furthest Building You Can Reach](https://leetcode.com/problems/furthest-building-you-can-reach/) | Min-heap greedy |

#### Hard

| # | Задача | Паттерн |
|---|--------|---------|
| 23 | [Merge K Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/) | K-way merge |
| 295 | [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/) | Two heaps |
| 480 | [Sliding Window Median](https://leetcode.com/problems/sliding-window-median/) | Two heaps + lazy removal |
| 502 | [IPO](https://leetcode.com/problems/ipo/) | Two heaps greedy |
| 632 | [Smallest Range Covering Elements](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/) | Min-heap sliding window |

---

## Мифы и заблуждения

| Миф | Реальность |
|-----|-----------|
| "Heap всегда даёт отсортированный порядок при итерации" | **Нет!** Heap гарантирует только что корень = min/max. Остальные элементы НЕ отсортированы. `forEach` по PriorityQueue в Java даст произвольный порядок. |
| "Max-Heap и Min-Heap — разные структуры" | **Одна структура.** Разница только в компараторе. Min-heap: parent ≤ children. Max-heap: parent ≥ children. Реализация идентична. |
| "Build Heap за O(n log n)" | **O(n)!** Floyd's метод: большинство узлов — листья (не требуют работы). Только корень требует O(log n). Сумма = O(n). |
| "Для Top K всегда нужен Max-Heap" | **Наоборот!** Для Top K наибольших используй Min-Heap размера K. Корень = минимальный из K наибольших. Легко проверить, входит ли новый элемент в Top K. |
| "Heap = Priority Queue" | **Heap — реализация, PQ — абстракция.** Priority Queue можно реализовать через heap, sorted array, unsorted array, BST. Heap — самая эффективная реализация для большинства случаев. |
| "PriorityQueue в Java/Kotlin — Max-Heap" | **По умолчанию — Min-Heap!** Для Max-Heap нужен reverseOrder: `PriorityQueue(compareByDescending { it })` или `Collections.reverseOrder()`. |
| "Изменение элемента в heap автоматически обновляет его позицию" | **Нет!** Heap не отслеживает изменения объектов. Нужно `remove()` + `add()`, или использовать IndexedPriorityQueue с decrease-key. |
| "Heap Sort всегда лучше Quick Sort" | **Нет.** Heap Sort O(n log n) worst-case, но хуже cache locality. Quick Sort O(n log n) average, лучше на практике. Heap Sort полезен для in-place + guaranteed O(n log n). |

---

## CS-фундамент

| CS-концепция | Как применяется в Heap |
|--------------|------------------------|
| **Complete Binary Tree** | Heap — полное бинарное дерево: все уровни заполнены, последний — слева направо. Это позволяет хранить дерево в массиве без указателей. |
| **Heap Property** | Инвариант: parent ≤ children (min) или parent ≥ children (max). Гарантирует O(1) доступ к min/max в корне. Не гарантирует полную сортировку. |
| **Array Representation** | Parent(i) = (i-1)/2, Left(i) = 2i+1, Right(i) = 2i+2. Cache-friendly (последовательная память), нет overhead указателей. |
| **Amortized Analysis** | Build Heap за O(n) — не O(n log n). Большинство узлов на нижних уровнях требуют мало работы. Сумма геометрической прогрессии = O(n). |
| **Abstract Data Type** | Priority Queue — ADT с операциями insert, extractMin/Max, peek. Heap — конкретная реализация ADT. Можно реализовать через BST, sorted array, но heap оптимален. |
| **Comparison-based** | Heap работает с любыми comparable объектами. Требует только операцию сравнения. Позволяет custom comparator для разных критериев приоритета. |

---

## Связанные темы

### Prerequisites (нужно знать перед кучами)

- [[arrays]] — heap хранится как массив
- [[trees-binary]] — heap — это полное бинарное дерево
- [[complexity-analysis]] — понимание O(log n) операций

### Что изучать после куч

- [[sorting-algorithms]] — Heap Sort
- [[graphs]] — Dijkstra, Prim используют heap
- [[greedy-algorithms]] — heap часто используется в greedy
- [[dp-patterns]] — некоторые задачи комбинируют heap + DP

### Продвинутые темы

- **Indexed Heap** — поддержка decrease-key за O(log n)
- **Fibonacci Heap** — O(1) amortized decrease-key
- **Binomial Heap** — эффективное слияние
- **Pairing Heap** — простая реализация с хорошей практической производительностью

---

## Источники

1. [GeeksforGeeks — Binary Heap](https://www.geeksforgeeks.org/dsa/binary-heap/)
2. [Tech Interview Handbook — Heap](https://www.techinterviewhandbook.org/algorithms/heap/)
3. [Interview Cake — Heap](https://www.interviewcake.com/concept/java/heap)
4. [Wikipedia — Binary Heap](https://en.wikipedia.org/wiki/Binary_heap)
5. [BezKoder — Kotlin Priority Queue](https://www.bezkoder.com/kotlin-priority-queue/)
6. [Kodeco — Priority Queues in Kotlin](https://www.kodeco.com/books/data-structures-algorithms-in-kotlin/v1.0/chapters/13-priority-queues)
7. [LeetCode — Top K Discussion](https://leetcode.com/discuss/general-discussion/1088565/top-k-problems-sort-heap-and-quickselect)
8. Research: [2025-12-29-heaps-priority-queues.md](../../docs/research/2025-12-29-heaps-priority-queues.md)

---

*Обновлено: 2026-01-06 — добавлены педагогические секции (интуиция приоритетных очередей, типичные ошибки, 4 ментальные модели)*

---

[[graphs|← Graphs]] | [[cs-fundamentals-overview|CS Fundamentals MOC]] | [[tries|Tries →]]
