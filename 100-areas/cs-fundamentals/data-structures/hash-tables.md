---
title: "Хеш-таблицы (Hash Tables)"
created: 2025-12-29
modified: 2026-01-06
type: deep-dive
status: published
difficulty: intermediate
cs-foundations:
  - hashing-algorithms
  - collision-resolution
  - space-time-tradeoff
  - amortized-complexity
  - modular-arithmetic
prerequisites:
  - "[[arrays-strings]]"
  - "[[big-o-complexity]]"
teaches:
  - hash-function
  - collision-resolution
  - O(1)-lookup
  - key-value-storage
unlocks:
  - "[[lru-cache]]"
  - "[[two-pointers-pattern]]"
  - "[[frequency-counting]]"
tags:
  - topic/cs-fundamentals
  - type/deep-dive
  - level/intermediate
  - interview
related:
  - "[[lru-cache]]"
  - "[[two-pointers-pattern]]"
  - "[[frequency-counting]]"
---

# Hash Tables

> **TL;DR:** Hash Table превращает O(n) поиск в O(1) с помощью "волшебной формулы" (hash function), которая мгновенно говорит, где искать данные. Это как каталог в библиотеке: вместо перебора миллиона книг — сразу знаешь номер полки.

---

## Часть 1: Интуиция без кода (начни здесь!)

> **Цель:** Понять ИДЕЮ хеш-таблиц до любого кода.

### Хеширование в реальной жизни

```
┌─────────────────────────────────────────────────────────────────────┐
│                 ХЕШИРОВАНИЕ ВОКРУГ НАС                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. ГАРДЕРОБ В ТЕАТРЕ                                              │
│     ─────────────────                                               │
│     • Отдаёшь пальто → получаешь НОМЕРОК                           │
│     • Показываешь номерок → мгновенно получаешь пальто             │
│     • Не нужно искать среди 500 пальто!                            │
│                                                                     │
│     Номерок = HASH                                                  │
│     Вешалка с номером = BUCKET                                     │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│  2. ПОЧТОВЫЕ ИНДЕКСЫ                                               │
│     ────────────────                                                │
│     119021 → Москва, ЦАО, определённый район                       │
│                                                                     │
│     Индекс = "хеш" адреса                                          │
│     Вместо "Москва, Остоженка, д.5" — просто 119021                │
│     Сортировочный центр сразу знает куда отправить                 │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│  3. КАРТОТЕКА В БИБЛИОТЕКЕ                                         │
│     ──────────────────────                                          │
│     "Толстой" → Ящик "Т" → Карточка с номером полки               │
│                                                                     │
│     Первая буква автора = простейшая хеш-функция                   │
│     Но "Тургенев" тоже в ящике "Т" → КОЛЛИЗИЯ!                     │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│  4. ПАРКОВКА С РАЗМЕТКОЙ                                           │
│     ───────────────────                                             │
│     Номер машины → Формула → Номер места                           │
│                                                                     │
│     "А123БВ" → 123 % 50 = место 23                                 │
│                                                                     │
│     Load Factor = сколько мест занято                              │
│     Если 90% занято — долго искать свободное место!                │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Главная интуиция: "Волшебная формула"

```
┌─────────────────────────────────────────────────────────────────────┐
│              КАК РАБОТАЕТ "ВОЛШЕБНАЯ ФОРМУЛА"                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ЗАДАЧА: Быстро найти телефон Маши среди 1 000 000 контактов       │
│                                                                     │
│  БЕЗ ХЕШИРОВАНИЯ:                                                  │
│  ┌─────────────────────────────┐                                   │
│  │ for each contact:           │                                   │
│  │   if name == "Маша":        │   ← Проверяем КАЖДЫЙ контакт      │
│  │     return phone            │   ← 500 000 проверок в среднем!   │
│  └─────────────────────────────┘                                   │
│                                                                     │
│  С ХЕШИРОВАНИЕМ:                                                   │
│  ┌─────────────────────────────┐                                   │
│  │ index = hash("Маша") % size │   ← 1 вычисление                  │
│  │ return bucket[index]        │   ← 1 обращение к памяти          │
│  └─────────────────────────────┘                                   │
│                                                                     │
│  Hash("Маша") = 77 + 97 + 109 + 97 = 380                          │
│  index = 380 % 100 = 80                                            │
│  Маша в ячейке 80! Сразу знаем где искать.                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Почему это работает?

```
МАССИВ (линейный поиск):
┌───┬───┬───┬───┬───┬─────────┬───┐
│Ann│Bob│Cat│...│...│ 999999  │Маша│
└───┴───┴───┴───┴───┴─────────┴───┘
  ↑                              ↑
  Начинаем здесь     Находим здесь (после 1М проверок)

HASH TABLE (прямой доступ):
index = hash("Маша") % 100 = 80
       ↓
┌───┬───┬───┬─────────┬───┬───┬───┐
│   │   │...│  ...    │Маша│...│   │
└───┴───┴───┴─────────┴───┴───┴───┘
  0   1              80

СРАЗУ идём к ячейке 80, без перебора!
```

---

## Часть 2: Почему хеш-таблицы сложные для изучения

> **Источники:** [freeCodeCamp - Codeless Guide](https://www.freecodecamp.org/news/the-codeless-guide-to-hash/), [YouCademy - Best Practices](https://youcademy.org/hash-table-best-practices/), [CMU CS Course](https://www.cs.cmu.edu/~15122/handouts/lectures/12-hashing.pdf)

### Проблема 1: "O(1) всегда" — НЕПРАВИЛЬНО!

```
┌─────────────────────────────────────────────────────────────────────┐
│                    O(1) — ТОЛЬКО В СРЕДНЕМ!                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  WORST CASE: Все ключи попали в один bucket!                       │
│                                                                     │
│  Плохая hash function: hash(key) = 0  (всегда возвращает 0)        │
│                                                                     │
│  [0] → Ann → Bob → Cat → Dan → Eve → ... → 1 000 000 элементов     │
│  [1] → null                                                         │
│  [2] → null                                                         │
│  ...                                                                │
│                                                                     │
│  Поиск "Zoe" = пройти весь список в bucket[0] = O(n)!              │
│                                                                     │
│  ЗАЩИТА в Java 8+:                                                 │
│  Если bucket > 8 элементов → превращается в Red-Black Tree        │
│  Тогда поиск = O(log n) вместо O(n)                                │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Проблема 2: Коллизии неизбежны (Birthday Paradox)

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ПАРАДОКС ДНЕЙ РОЖДЕНИЯ                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  В комнате 23 человека.                                            │
│  Вероятность, что у двоих совпадёт день рождения: 50%!             │
│  При 70 людях: 99.9%!                                              │
│                                                                     │
│  Почему?                                                            │
│  365 возможных дней (как 365 buckets)                              │
│  23 человека (как 23 ключа)                                        │
│  Вероятность столкновения растёт БЫСТРЕЕ чем кажется!              │
│                                                                     │
│  ДЛЯ HASH TABLE:                                                   │
│  Даже с идеальной hash function коллизии НЕИЗБЕЖНЫ                 │
│  при большом количестве ключей!                                    │
│                                                                     │
│  ВЫВОД: Нужно хорошо обрабатывать коллизии (chaining или probing)  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Проблема 3: Мутабельные ключи — "потерянные" элементы

```kotlin
// ❌ ОПАСНО: мутабельный ключ
data class User(var name: String, val id: Int)

val map = mutableMapOf<User, String>()
val user = User("Alice", 1)

map[user] = "data"        // hash("Alice", 1) → bucket 42
println(map[user])        // "data" ✓

user.name = "Bob"         // ИЗМЕНИЛИ КЛЮЧ!
println(map[user])        // null! 😱

// ПОЧЕМУ?
// hash("Bob", 1) → bucket 17 (другой bucket!)
// Элемент в bucket 42, но мы ищем в bucket 17
// Элемент "потерялся" в таблице!

// ✅ ПРАВИЛЬНО: использовать только immutable как ключи
// или не менять объекты после добавления в map
```

### Проблема 4: Load Factor — "переполненная парковка"

```
┌─────────────────────────────────────────────────────────────────────┐
│                    АНАЛОГИЯ С ПАРКОВКОЙ                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Load Factor = n / capacity (сколько мест занято)                  │
│                                                                     │
│  α = 0.3 (30% занято):     α = 0.9 (90% занято):                   │
│  ┌───┬───┬───┬───┬───┐     ┌───┬───┬───┬───┬───┐                   │
│  │ 🚗│   │ 🚗│   │   │     │ 🚗│ 🚗│ 🚗│ 🚗│   │                   │
│  └───┴───┴───┴───┴───┘     └───┴───┴───┴───┴───┘                   │
│  Легко найти место!        Долго искать место!                     │
│  Мало коллизий              Много коллизий                          │
│                                                                     │
│  ЭМПИРИЧЕСКОЕ ПРАВИЛО:                                             │
│  • α = 0.75 — баланс память/скорость (Java HashMap default)        │
│  • α > 0.75 → rehashing (увеличить таблицу в 2 раза)               │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Проблема 5: Chaining vs Open Addressing — что выбрать?

```
┌─────────────────────────────────────────────────────────────────────┐
│                 ДВА СПОСОБА ОБРАБОТКИ КОЛЛИЗИЙ                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  CHAINING (списки):                OPEN ADDRESSING (probing):       │
│  ┌───┐                             ┌───┬───┬───┬───┬───┐            │
│  │[0]│→ A → C → null               │ A │ B │ C │   │ D │            │
│  │[1]│→ B → null                   └───┴───┴───┴───┴───┘            │
│  │[2]│→ null                         ↑       ↑                      │
│  │[3]│→ D → null                   C хотел в [0], но занято        │
│  └───┘                             → пробуем [1] занято             │
│                                    → пробуем [2] свободно!          │
│                                                                     │
│  КОГДА ЧТО:                                                         │
│  • Chaining: проще, работает при α > 1, но хуже cache locality     │
│  • Open Addressing: быстрее при α < 0.7, но clustering проблема    │
│                                                                     │
│  Java HashMap: Chaining (с treeification)                          │
│  Python dict: Open Addressing                                       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Часть 3: Ментальные модели для работы с хеш-таблицами

### Модель 1: "Гардероб в театре"

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ТЕАТРАЛЬНЫЙ ГАРДЕРОБ                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  put(coat, person):                                                 │
│  1. Получаем номерок (hash)                                        │
│  2. Вешаем пальто на вешалку с этим номером                        │
│                                                                     │
│  get(ticket):                                                       │
│  1. Смотрим номер на билете                                        │
│  2. Идём к вешалке с этим номером                                  │
│  3. Забираем пальто                                                 │
│                                                                     │
│  КОЛЛИЗИЯ: Два пальто на одной вешалке?                            │
│  → Вешаем оба, но помечаем чьё какое (chaining)                    │
│  → Или ищем соседнюю свободную вешалку (open addressing)           │
│                                                                     │
│  ПРИМЕНЕНИЕ: Когда объясняешь API (put/get/remove)                 │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Модель 2: "Телефонная книга"

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ТЕЛЕФОННЫЙ СПРАВОЧНИК                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Ключ = Фамилия                                                    │
│  Hash = Первая буква фамилии                                       │
│  Bucket = Страница с этой буквой                                   │
│                                                                     │
│  "Иванов" → hash("И") → Страница "И"                               │
│                                                                     │
│  Страница "И" (bucket):                                            │
│  ┌────────────────────────┐                                         │
│  │ Иванов    → 123-45-67  │                                         │
│  │ Игнатьев  → 234-56-78  │  ← Все на букву "И" в одном месте      │
│  │ Ильин     → 345-67-89  │                                         │
│  └────────────────────────┘                                         │
│                                                                     │
│  Поиск: Открываем страницу "И" → Ищем в списке                     │
│  Это Chaining!                                                      │
│                                                                     │
│  ПРИМЕНЕНИЕ: Когда объясняешь коллизии и chaining                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Модель 3: "Шахматная доска" (для Open Addressing)

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ШАХМАТНАЯ ДОСКА (Linear Probing)                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Каждая клетка может хранить одну фигуру.                          │
│  Если клетка занята — ставим на соседнюю.                          │
│                                                                     │
│  hash(A) = 0, hash(B) = 0, hash(C) = 0                             │
│                                                                     │
│  Вставка A: [A] [ ] [ ] [ ] [ ]                                    │
│              ↑ место 0 свободно                                     │
│                                                                     │
│  Вставка B: [A] [B] [ ] [ ] [ ]                                    │
│              ↑ занято, пробуем 1 → свободно                        │
│                                                                     │
│  Вставка C: [A] [B] [C] [ ] [ ]                                    │
│              ↑ занято, ↑ занято, ↑ свободно                        │
│                                                                     │
│  ПРОБЛЕМА КЛАСТЕРИЗАЦИИ:                                           │
│  [A] [B] [C] [D] [E] [ ] [ ] [ ]                                   │
│   ↑───────────────↑                                                 │
│   Большой кластер = медленный поиск!                               │
│                                                                     │
│  ПРИМЕНЕНИЕ: Когда объясняешь open addressing и clustering         │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Модель 4: "Почтовая сортировка" (для понимания hash function)

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ПОЧТОВАЯ СОРТИРОВКА                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Письма приходят → сортируем по индексу → раскладываем по полкам  │
│                                                                     │
│  Письмо с индексом 119021:                                         │
│  • 119 = регион Москвы → Полка "Москва"                            │
│  • 021 = район → Ящик в полке                                      │
│                                                                     │
│  Hash function = "правило сортировки"                              │
│  • Детерминированная: один индекс → одна полка (всегда!)          │
│  • Равномерная: письма распределяются по всем полкам              │
│                                                                     │
│  ПЛОХАЯ hash function:                                             │
│  "Все письма на полку 0" → O(n) поиск нужного                      │
│                                                                     │
│  ХОРОШАЯ hash function:                                            │
│  Равномерное распределение → O(1) поиск                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Выбор модели по ситуации

| Концепция | Лучшая модель | Почему |
|-----------|---------------|--------|
| put/get/remove API | Гардероб | Номерок = интуитивно |
| Коллизии + Chaining | Телефонная книга | Несколько записей на букву |
| Open Addressing | Шахматная доска | Видно probing и clustering |
| Hash function | Почтовая сортировка | Понятно детерминированность |
| Load Factor | Парковка | Интуиция "переполнения" |

---

## 1. Зачем это нужно?

### Представьте ситуацию

Вы работаете библиотекарем в огромной библиотеке с **миллионом книг**.

Посетитель подходит и спрашивает:
> "У вас есть 'Война и мир' Толстого?"

**Без системы каталогов:**
Вы начинаете обходить полки одну за другой, проверяя каждую книгу...
- 1,000,000 книг
- 1 секунда на проверку каждой
- **Итого: 11 дней непрерывной работы!**

**С каталогом (Hash Table):**
Смотрите в каталог: "Толстой → Полка 47, Ряд 3"
- **Итого: 5 секунд**

### Проблема в числах

```
Допустим, у нас список из 1,000,000 пользователей.
Нужно проверить: есть ли "john_doe"?

СПОСОБ 1: Обычный массив (перебор)
┌─────────────────────────────────────────────────┐
│ for each user in list:                          │
│     if user == "john_doe": return true          │
│ return false                                    │
└─────────────────────────────────────────────────┘
Сложность: O(n) = 1,000,000 операций
Время: ~1 секунда

СПОСОБ 2: Hash Table
┌─────────────────────────────────────────────────┐
│ return users_hash_table["john_doe"]             │
└─────────────────────────────────────────────────┘
Сложность: O(1) = 1 операция
Время: ~0.000001 секунды

РАЗНИЦА: в МИЛЛИОН раз быстрее!
```

### Где это используется в реальности

| Применение | Почему Hash Table |
|------------|-------------------|
| **База данных** | Индексы для быстрого поиска записей |
| **Кэширование** | Redis, Memcached хранят ключ→значение |
| **Компилятор** | Таблица символов (имя переменной → адрес) |
| **DNS** | Доменное имя → IP адрес |
| **Браузер** | Кэш посещённых страниц |
| **Blockchain** | Верификация транзакций |

---

## 2. Что это такое?

### Объяснение для 5-летнего

Представь, что у тебя есть **10 пронумерованных коробок**:

```
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
```

И много игрушек, которые нужно разложить так, чтобы **потом быстро найти**.

**Волшебное правило** (hash function):
> "Посчитай буквы в названии игрушки и возьми остаток от деления на 10"

Раскладываем:
- **"Cat"** = 3 буквы → 3 % 10 = **коробка 3**
- **"Dog"** = 3 буквы → 3 % 10 = **коробка 3** (ой, там уже Cat!)
- **"Elephant"** = 8 букв → 8 % 10 = **коробка 8**

Когда нужно найти "Elephant":
- Считаем: 8 букв → коробка 8
- Смотрим в коробку 8 → вот он!

**Не надо перебирать все коробки!**

А когда две игрушки попадают в одну коробку — это называется **collision** (столкновение).

### Постепенное усложнение

**Уровень 1: Интуиция**

Hash Table — это как **гардероб в театре**:
- Отдаёшь пальто → получаешь номерок (hash)
- Показываешь номерок → сразу получаешь своё пальто
- Не нужно искать среди сотен пальто!

**Уровень 2: Абстракция**

Hash Table состоит из двух частей:
1. **Массив** (array) — наши "коробки" или "ячейки"
2. **Hash Function** — правило, которое превращает ключ в номер ячейки

```
     key            hash function         index        value
   ┌──────┐        ┌────────────┐        ┌─────┐      ┌──────┐
   │"name"│  ────▶ │ f(key) = i │  ────▶ │  5  │ ───▶ │"John"│
   └──────┘        └────────────┘        └─────┘      └──────┘
```

**Уровень 3: Формальное определение**

> **Hash Table** — структура данных, реализующая ассоциативный массив (key → value), где позиция элемента вычисляется hash-функцией за O(1) в среднем случае.

---

## 3. Терминология

| Термин | Простыми словами | Формальное определение |
|--------|-----------------|------------------------|
| **Hash Function** | "Волшебная формула" — название → номер полки | Функция h(key) → index, преобразующая ключ произвольной длины в индекс массива фиксированного размера |
| **Bucket** | "Коробка" или "ячейка" | Слот в массиве, где хранятся элементы |
| **Collision** | Два ключа попали в одну ячейку | Ситуация, когда h(key1) = h(key2) для key1 ≠ key2 |
| **Load Factor** | Насколько "заполнена парковка" | α = n/m, где n — количество элементов, m — размер массива |
| **Rehashing** | "Переезд в бОльший дом" | Увеличение размера массива и пересчёт всех хешей |
| **Chaining** | "Списки в ячейках" | Collision resolution: каждая ячейка — linked list |
| **Open Addressing** | "Ищем свободное место рядом" | Collision resolution: при коллизии ищем следующую свободную ячейку |

---

## 4. Как работает Hash Function?

### Простой пример

Допустим, у нас массив размером 10 и мы хотим сохранить строки.

**Шаг 1: Превращаем строку в число**
Каждая буква имеет ASCII-код:
- 'a' = 97, 'b' = 98, 'c' = 99, ...
- 'A' = 65, 'B' = 66, 'C' = 67, ...

**Шаг 2: Комбинируем коды в одно число**
```
"cat" = 99 + 97 + 116 = 312
```

**Шаг 3: Получаем индекс (modulo)**
```
index = 312 % 10 = 2
```

Значит, "cat" попадёт в ячейку 2.

### Визуализация

```
ВХОД:  "cat"

Шаг 1: Буквы → ASCII коды
       c → 99
       a → 97
       t → 116

Шаг 2: Сумма = 99 + 97 + 116 = 312

Шаг 3: Index = 312 % 10 = 2

Hash Table:
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│     │     │ cat │     │     │     │     │     │     │     │
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
   0     1     2     3     4     5     6     7     8     9
                ↑
           hash("cat") = 2
```

### Свойства хорошей hash function

| Свойство | Что значит | Почему важно |
|----------|-----------|--------------|
| **Детерминированность** | Одинаковый вход → одинаковый выход | Иначе не найдём элемент! |
| **Равномерность** | Элементы распределены равномерно | Меньше коллизий |
| **Быстрота** | Вычисляется за O(длина ключа) | Не теряем преимущество O(1) |
| **Avalanche Effect** | Маленькое изменение → большая разница | "cat" и "bat" должны быть далеко |

---

## 5. Коллизии: неизбежное зло

### Почему коллизии неизбежны?

**Парадокс дней рождения:**
- В комнате 23 человека
- Вероятность, что у двоих совпадёт день рождения: **50%!**
- При 70 людях: **99.9%**

То же самое с hash table:
- Если ключей много, а ячеек мало — столкновения гарантированы
- Даже с идеальной hash function!

### Визуализация коллизии

```
hash("apple") = 530 % 10 = 0
hash("grape") = 520 % 10 = 0   ← Коллизия!

Оба хотят в ячейку 0:

┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│ ??? │     │     │     │     │     │     │     │     │     │
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
   0
   ↑
 apple хочет сюда
 grape тоже хочет сюда!
```

Как быть? Есть два основных решения.

---

## 6. Collision Resolution: Chaining

### Идея

Каждая ячейка — не одно значение, а **список** (linked list).
Если два элемента попали в одну ячейку — оба хранятся в списке.

### Пошаговый пример

**Начальное состояние:** пустая таблица

```
Buckets:
[0] → null
[1] → null
[2] → null
[3] → null
[4] → null
```

**Шаг 1:** Вставляем "apple" → 42
```
hash("apple") = 0

[0] → [apple:42] → null
[1] → null
[2] → null
[3] → null
[4] → null
```

**Шаг 2:** Вставляем "banana" → 17
```
hash("banana") = 3

[0] → [apple:42] → null
[1] → null
[2] → null
[3] → [banana:17] → null
[4] → null
```

**Шаг 3:** Вставляем "grape" → 99 (КОЛЛИЗИЯ! hash = 0)
```
hash("grape") = 0  ← Коллизия с apple!

[0] → [grape:99] → [apple:42] → null   ← Оба в списке!
[1] → null
[2] → null
[3] → [banana:17] → null
[4] → null
```

**Поиск "apple":**
1. hash("apple") = 0
2. Идём по списку в bucket[0]
3. Проверяем: "grape"? Нет. "apple"? Да!
4. Возвращаем 42

### Плюсы и минусы Chaining

| Плюсы | Минусы |
|-------|--------|
| Простая реализация | Дополнительная память на указатели |
| Таблица никогда не переполнится | Плохая cache locality |
| Удаление — просто | При многих коллизиях — O(n) |

---

## 7. Collision Resolution: Open Addressing

### Идея

Все элементы хранятся **в самом массиве** (не в списках).
Если ячейка занята — ищем следующую свободную по правилу.

### Типы probing

**Linear Probing:** шаг +1
```
Если занято h(key), пробуем:
h(key) + 1
h(key) + 2
h(key) + 3
...
```

**Quadratic Probing:** шаг = i²
```
Если занято h(key), пробуем:
h(key) + 1²
h(key) + 2²
h(key) + 3²
...
```

**Double Hashing:** второй хеш
```
Если занято h1(key), пробуем:
h1(key) + 1 * h2(key)
h1(key) + 2 * h2(key)
...
```

### Пошаговый пример (Linear Probing)

**Начальное состояние:**
```
[0] [1] [2] [3] [4]
     empty
```

**Шаг 1:** insert("A", 10), hash("A") = 0
```
[A:10] [   ] [   ] [   ] [   ]
  0      1     2     3     4
```

**Шаг 2:** insert("B", 20), hash("B") = 2
```
[A:10] [   ] [B:20] [   ] [   ]
  0      1     2      3     4
```

**Шаг 3:** insert("C", 30), hash("C") = 0 ← КОЛЛИЗИЯ!
```
0 занят, пробуем 1 → свободен!

[A:10] [C:30] [B:20] [   ] [   ]
  0      1      2      3     4
         ↑
    C переехал сюда
```

**Шаг 4:** insert("D", 40), hash("D") = 1 ← КОЛЛИЗИЯ!
```
1 занят, пробуем 2 → занят, пробуем 3 → свободен!

[A:10] [C:30] [B:20] [D:40] [   ]
  0      1      2      3      4
                       ↑
                  D переехал сюда
```

### Проблема: Clustering

При linear probing образуются "кластеры" — цепочки занятых ячеек:

```
Плохо:
[X] [X] [X] [X] [X] [ ] [ ] [ ] [ ] [ ]
 ↑───────────────↑
     кластер

Новый элемент попадёт в начало кластера →
придётся пройти весь кластер → O(n)!
```

### Плюсы и минусы Open Addressing

| Плюсы | Минусы |
|-------|--------|
| Лучше cache locality | Clustering (особенно linear) |
| Меньше памяти | Сложное удаление |
| Быстрее при низком load factor | Load factor > 0.7 → плохо |

---

## 8. Load Factor и Rehashing

### Что такое Load Factor?

**Load Factor (α)** — насколько "заполнена" таблица:

```
α = n / m

где:
n = количество элементов
m = размер массива
```

**Аналогия — парковка:**
- 100 мест, 50 машин → α = 0.5 (50% занято)
- 100 мест, 90 машин → α = 0.9 (90% занято — сложно найти место!)

### Почему Load Factor важен?

| α | Chaining | Open Addressing |
|---|----------|-----------------|
| 0.5 | Хорошо | Отлично |
| 0.75 | Хорошо | Хорошо |
| 0.9 | Приемлемо | Плохо (много коллизий) |
| > 1.0 | Работает | Невозможно! |

**Эмпирическое правило:**
- α = 0.75 — хороший баланс (Java HashMap default)
- Когда α > 0.75 → делаем rehashing

### Rehashing — "переезд в бОльший дом"

**Алгоритм:**
1. Создаём новый массив в 2 раза больше
2. Пересчитываем хеш КАЖДОГО элемента
3. Вставляем все элементы в новый массив

```
ДО (capacity = 4, elements = 3, α = 0.75):
[A] [B] [ ] [C]
 0   1   2   3

ПОСЛЕ (capacity = 8):
[ ] [A] [B] [ ] [ ] [ ] [ ] [C]
 0   1   2   3   4   5   6   7

Все хеши пересчитаны!
hash("A") % 4 = 0  →  hash("A") % 8 = 1
```

### Почему O(1) amortized?

Rehashing стоит O(n), но происходит редко:
- После n вставок — 1 rehash на n элементов
- После n/2 вставок — 1 rehash на n/2 элементов
- ...

Суммарно: n + n/2 + n/4 + ... = 2n операций на n вставок = O(1) на вставку!

---

## 9. Сложность операций

| Операция | Average | Worst | Когда worst? |
|----------|---------|-------|--------------|
| **Search** | O(1) | O(n) | Все ключи в одном bucket |
| **Insert** | O(1)* | O(n) | Rehashing или много коллизий |
| **Delete** | O(1) | O(n) | Много коллизий |
| **Space** | O(n) | O(n) | — |

*amortized (с учётом редких rehashing)

### Почему O(1) в среднем?

**Математически:**

Если hash function распределяет равномерно:
- n элементов в m buckets
- В каждом bucket в среднем α = n/m элементов
- При α = 0.75 → в среднем 0.75 элемента на bucket
- Поиск в списке из 0.75 элементов ≈ O(1)

**Простыми словами:**

1. Hash function мгновенно говорит номер ячейки → O(1)
2. В ячейке мало элементов (при хорошем α) → O(1)
3. Итого: O(1) + O(1) = O(1)

---

## 10. Java HashMap: как устроен внутри

### Ключевые параметры

| Параметр | Default | Что значит |
|----------|---------|-----------|
| **Initial Capacity** | 16 | Начальный размер массива (степень 2!) |
| **Load Factor** | 0.75 | Порог для rehashing |
| **Threshold** | capacity × loadFactor | Когда делать rehash (16 × 0.75 = 12) |
| **Treeify Threshold** | 8 | Когда bucket → Red-Black Tree |
| **Untreeify Threshold** | 6 | Когда tree → обратно в список |

### Почему capacity — степень двойки?

**Оптимизация modulo:**
```java
// Обычно:
index = hash % capacity      // Деление — медленно!

// HashMap:
index = hash & (capacity - 1) // Битовая операция — быстро!

// Работает только если capacity = 2^n:
capacity = 16 = 10000 (binary)
capacity - 1 = 15 = 01111 (binary)

hash = 12345 = 11000000111001
hash & 15 = 11000000111001 & 01111 = 01001 = 9
```

### Java 8+: Treeification

**Проблема:** если много коллизий, linked list → O(n)

**Решение:** при 8+ элементах в bucket → Red-Black Tree

```
ДО Java 8:
bucket[5] → A → B → C → D → E → F → G → H → ...
Поиск: O(n)

ПОСЛЕ Java 8 (если ≥8 элементов):
bucket[5] → Red-Black Tree
                 D
               /   \
              B     F
             / \   / \
            A  C  E  G
                       \
                        H
Поиск: O(log n)
```

---

## 11. Реализация

### Базовая Hash Table с Chaining

```kotlin
/**
 * Простая Hash Table с Separate Chaining.
 *
 * Почему MutableList: реализует chaining (список в каждом bucket)
 * Почему capacity: размер массива buckets
 */
class HashTable<K, V>(private val capacity: Int = 16) {

    // Entry хранит пару ключ-значение
    private data class Entry<K, V>(val key: K, var value: V)

    // Массив buckets, каждый bucket — список для chaining
    private val buckets: Array<MutableList<Entry<K, V>>> =
        Array(capacity) { mutableListOf() }

    private var size: Int = 0

    /**
     * Hash function: преобразует ключ в индекс bucket.
     *
     * Почему and Int.MAX_VALUE:
     *   hashCode() может быть отрицательным,
     *   and с MAX_VALUE убирает знаковый бит → всегда >= 0
     *
     * Почему % capacity:
     *   результат должен быть в диапазоне [0, capacity)
     */
    private fun hash(key: K): Int =
        (key.hashCode() and Int.MAX_VALUE) % capacity

    /**
     * Вставка или обновление элемента.
     *
     * 1. Вычисляем hash → находим bucket
     * 2. Ищем в bucket элемент с таким же ключом
     * 3. Если нашли — обновляем value
     * 4. Если не нашли — добавляем новый Entry
     */
    fun put(key: K, value: V) {
        val bucket = buckets[hash(key)]
        val entry = bucket.find { it.key == key }

        if (entry != null) {
            // Ключ уже есть — обновляем значение
            entry.value = value
        } else {
            // Новый ключ — добавляем в список
            bucket.add(Entry(key, value))
            size++
        }
    }

    /**
     * Поиск по ключу.
     *
     * 1. Вычисляем hash → находим bucket
     * 2. Ищем в bucket элемент с нужным ключом
     * 3. Возвращаем value или null
     */
    fun get(key: K): V? {
        val bucket = buckets[hash(key)]
        return bucket.find { it.key == key }?.value
    }

    /**
     * Удаление по ключу.
     *
     * 1. Находим bucket
     * 2. Находим и удаляем Entry
     * 3. Возвращаем удалённое значение
     */
    fun remove(key: K): V? {
        val bucket = buckets[hash(key)]
        val entry = bucket.find { it.key == key }

        return if (entry != null) {
            bucket.remove(entry)
            size--
            entry.value
        } else null
    }

    fun containsKey(key: K): Boolean = get(key) != null

    fun size(): Int = size
}
```

```java
import java.util.*;

/**
 * Простая Hash Table с Separate Chaining.
 */
class HashTable<K, V> {

    private static class Entry<K, V> {
        K key;
        V value;

        Entry(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }

    private final int capacity;
    private final List<List<Entry<K, V>>> buckets;
    private int size = 0;

    public HashTable(int capacity) {
        this.capacity = capacity;
        // Инициализируем массив пустыми списками
        this.buckets = new ArrayList<>(capacity);
        for (int i = 0; i < capacity; i++) {
            buckets.add(new ArrayList<>());
        }
    }

    /**
     * Hash function с защитой от отрицательных значений.
     */
    private int hash(K key) {
        return (key.hashCode() & Integer.MAX_VALUE) % capacity;
    }

    public void put(K key, V value) {
        List<Entry<K, V>> bucket = buckets.get(hash(key));

        // Ищем существующий ключ
        for (Entry<K, V> entry : bucket) {
            if (entry.key.equals(key)) {
                entry.value = value;  // Обновляем
                return;
            }
        }

        // Не нашли — добавляем новый
        bucket.add(new Entry<>(key, value));
        size++;
    }

    public V get(K key) {
        List<Entry<K, V>> bucket = buckets.get(hash(key));

        for (Entry<K, V> entry : bucket) {
            if (entry.key.equals(key)) {
                return entry.value;
            }
        }
        return null;
    }

    public V remove(K key) {
        List<Entry<K, V>> bucket = buckets.get(hash(key));

        for (int i = 0; i < bucket.size(); i++) {
            if (bucket.get(i).key.equals(key)) {
                V value = bucket.get(i).value;
                bucket.remove(i);
                size--;
                return value;
            }
        }
        return null;
    }

    public int size() {
        return size;
    }
}
```

```python
class HashTable:
    """
    Простая Hash Table с Separate Chaining.
    """

    def __init__(self, capacity: int = 16):
        self.capacity = capacity
        # Каждый bucket — список пар (key, value)
        self.buckets = [[] for _ in range(capacity)]
        self._size = 0

    def _hash(self, key) -> int:
        """
        Используем встроенную hash() функцию Python.
        Modulo capacity даёт индекс bucket.
        """
        return hash(key) % self.capacity

    def put(self, key, value) -> None:
        """Вставка или обновление."""
        bucket = self.buckets[self._hash(key)]

        # Ищем существующий ключ
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)  # Обновляем
                return

        # Не нашли — добавляем
        bucket.append((key, value))
        self._size += 1

    def get(self, key):
        """Поиск по ключу."""
        bucket = self.buckets[self._hash(key)]

        for k, v in bucket:
            if k == key:
                return v
        return None

    def remove(self, key):
        """Удаление по ключу."""
        bucket = self.buckets[self._hash(key)]

        for i, (k, v) in enumerate(bucket):
            if k == key:
                del bucket[i]
                self._size -= 1
                return v
        return None

    def __contains__(self, key) -> bool:
        """Поддержка оператора 'in'."""
        return self.get(key) is not None

    def __len__(self) -> int:
        return self._size
```

---

## 12. Использование стандартных библиотек

### Kotlin

```kotlin
// Создание
val map = HashMap<String, Int>()
val map2 = mutableMapOf<String, Int>()

// Основные операции
map["key"] = 1                     // put
val value = map["key"]             // get (nullable)
map.remove("key")                  // remove
val exists = "key" in map          // containsKey

// Полезные методы
map.getOrDefault("key", 0)         // default если нет ключа
map.getOrPut("key") { 0 }          // создаёт если нет
map.computeIfAbsent("key") { k -> calculate(k) }

// Итерация
for ((k, v) in map) {
    println("$k -> $v")
}
```

### Java

```java
// Создание
Map<String, Integer> map = new HashMap<>();

// Основные операции
map.put("key", 1);                 // put
Integer value = map.get("key");    // get (null если нет)
map.remove("key");                 // remove
boolean exists = map.containsKey("key");

// Полезные методы
map.getOrDefault("key", 0);        // default если нет
map.computeIfAbsent("key", k -> calculate(k));
map.merge("key", 1, Integer::sum); // increment counter

// Итерация
for (Map.Entry<String, Integer> e : map.entrySet()) {
    System.out.println(e.getKey() + " -> " + e.getValue());
}
```

### Python

```python
from collections import defaultdict, Counter

# Создание
d = {}
d = dict()

# Основные операции
d["key"] = 1                       # put
value = d["key"]                   # get (KeyError если нет!)
value = d.get("key")               # get (None если нет)
value = d.get("key", 0)            # get с default
del d["key"]                       # remove
exists = "key" in d                # containsKey

# defaultdict — auto-создаёт значение для нового ключа
counts = defaultdict(int)
counts["a"] += 1                   # Работает! (default = 0)

groups = defaultdict(list)
groups["team1"].append("Alice")    # Работает! (default = [])

# Counter — подсчёт частот
counts = Counter([1, 2, 2, 3, 3, 3])
# Counter({3: 3, 2: 2, 1: 1})

counts.most_common(2)              # [(3, 3), (2, 2)]
```

---

## 13. Распространённые ошибки

### Ошибка 1: Мутабельные ключи

**Неправильно:**
```python
key = [1, 2, 3]  # Список — мутабельный!
d = {}
d[key] = "value"
# TypeError: unhashable type: 'list'
```

**Почему это неправильно:**
Если ключ изменится после вставки, hash изменится, и элемент "потеряется" — мы не сможем его найти!

**Правильно:**
```python
key = (1, 2, 3)  # Кортеж — иммутабельный
d = {}
d[key] = "value"  # Работает!
```

### Ошибка 2: Забыли проверить null

**Неправильно (Java):**
```java
Map<String, Integer> map = new HashMap<>();
int value = map.get("missing");  // NullPointerException!
```

**Правильно:**
```java
// Вариант 1: проверка
Integer value = map.get("missing");
if (value != null) {
    // использовать value
}

// Вариант 2: getOrDefault
int value = map.getOrDefault("missing", 0);
```

### Ошибка 3: Плохой equals/hashCode

**Неправильно:**
```kotlin
data class User(val id: Int, var name: String)

val map = mutableMapOf<User, String>()
val user = User(1, "Alice")
map[user] = "data"

user.name = "Bob"  // Изменили!
println(map[user]) // null! Потеряли элемент
```

**Почему:** hashCode изменился, элемент в "старом" bucket.

**Правильно:** Использовать только immutable поля в hashCode или не менять объекты-ключи.

### Ошибка 4: Игнорирование Load Factor

**Неправильно:**
```java
// Будет 1000 элементов, но начальный capacity = 16
Map<Integer, String> map = new HashMap<>();
for (int i = 0; i < 1000; i++) {
    map.put(i, "value");  // Много rehashing!
}
```

**Правильно:**
```java
// Указываем начальный размер
Map<Integer, String> map = new HashMap<>(1024);
// или с load factor
Map<Integer, String> map = new HashMap<>(1024, 0.75f);
```

---

## 14. Когда использовать Hash Table

### Используй Hash Table, когда:

| Ситуация | Пример |
|----------|--------|
| Нужен быстрый lookup по ключу | Проверка "есть ли пользователь в БД" |
| Нужен подсчёт частот | "Сколько раз встречается каждое слово" |
| Нужна группировка | "Сгруппировать анаграммы" |
| Нужен кэш | "Запомнить вычисленные значения" |
| Нужно O(1) insert/delete | "Добавить/удалить из множества" |

### НЕ используй Hash Table, когда:

| Ситуация | Лучше использовать |
|----------|-------------------|
| Нужен упорядоченный обход | [[TreeMap]] (Java), sorted dict |
| Нужен range query (от A до B) | [[segment-tree]], balanced BST |
| Мало памяти | Array с binary search |
| Ключи нельзя хешировать | Balanced BST |
| Нужен min/max за O(1) | [[heaps-priority-queues]] |

### HashMap vs TreeMap vs LinkedHashMap

| Критерий | HashMap | TreeMap | LinkedHashMap |
|----------|---------|---------|---------------|
| Порядок | Нет | Sorted by key | Insertion order |
| Get/Put | O(1) | O(log n) | O(1) |
| Итерация | Случайный | По возрастанию | Порядок вставки |
| Null keys | Да (1) | Нет | Да (1) |

---

## 15. Interview Patterns

### Pattern 1: Two Sum

**Идея:** Храним виденные значения, проверяем complement.

```kotlin
fun twoSum(nums: IntArray, target: Int): IntArray {
    // value → index, где мы видели это значение
    val seen = mutableMapOf<Int, Int>()

    for ((i, num) in nums.withIndex()) {
        val complement = target - num
        // Если complement уже видели — нашли пару!
        if (complement in seen) {
            return intArrayOf(seen[complement]!!, i)
        }
        seen[num] = i
    }
    return intArrayOf()
}
```

**Сложность:** O(n) time, O(n) space

### Pattern 2: Frequency Counter

**Идея:** Считаем частоту каждого элемента.

```python
from collections import Counter

def top_k_frequent(nums: list[int], k: int) -> list[int]:
    # Counter считает частоту каждого элемента
    counts = Counter(nums)
    # most_common(k) возвращает k самых частых
    return [num for num, _ in counts.most_common(k)]
```

**Сложность:** O(n log k) с heap или O(n) с bucket sort

### Pattern 3: Group by Key

**Идея:** Группируем элементы по какому-то признаку.

```python
from collections import defaultdict

def group_anagrams(strs: list[str]) -> list[list[str]]:
    # sorted строка — ключ, все анаграммы — в одну группу
    groups = defaultdict(list)

    for s in strs:
        key = "".join(sorted(s))
        groups[key].append(s)

    return list(groups.values())
```

**Сложность:** O(n × k log k), где k — длина строки

### Pattern 4: Prefix Sum + Hash

**Идея:** Сохраняем prefix sums для поиска subarrays.

```kotlin
fun subarraySum(nums: IntArray, k: Int): Int {
    // prefix_sum → сколько раз встречался
    val prefixCounts = mutableMapOf(0 to 1)
    var sum = 0
    var count = 0

    for (num in nums) {
        sum += num
        // Если (sum - k) встречался — есть subarray с суммой k
        count += prefixCounts.getOrDefault(sum - k, 0)
        prefixCounts[sum] = prefixCounts.getOrDefault(sum, 0) + 1
    }

    return count
}
```

**Сложность:** O(n) time, O(n) space

---

## 16. Практика

### Вопросы на понимание (без кода)

1. **Почему hash table быстрее массива для поиска?**
   <details><summary>Ответ</summary>
   Потому что hash function вычисляет позицию напрямую за O(1), вместо перебора всех элементов O(n).
   </details>

2. **Что произойдёт, если все ключи попадут в один bucket?**
   <details><summary>Ответ</summary>
   Поиск станет O(n) вместо O(1), потому что придётся перебирать весь список в этом bucket.
   </details>

3. **Почему load factor 0.75, а не 0.9 или 0.5?**
   <details><summary>Ответ</summary>
   0.75 — баланс между памятью (меньше пустых ячеек) и скоростью (меньше коллизий). При 0.9 много коллизий, при 0.5 тратим память.
   </details>

4. **Можно ли использовать mutable объект как ключ? Почему?**
   <details><summary>Ответ</summary>
   Технически можно, но опасно: если объект изменится, его hash изменится, и элемент "потеряется" в таблице.
   </details>

### Задачи для закрепления

| # | Задача | Сложность | Цель обучения |
|---|--------|-----------|---------------|
| 1 | [Two Sum](https://leetcode.com/problems/two-sum/) | Easy | Основы hash lookup |
| 2 | [Valid Anagram](https://leetcode.com/problems/valid-anagram/) | Easy | Frequency counting |
| 3 | [Ransom Note](https://leetcode.com/problems/ransom-note/) | Easy | Frequency comparison |
| 4 | [Group Anagrams](https://leetcode.com/problems/group-anagrams/) | Medium | Grouping pattern |
| 5 | [Top K Frequent](https://leetcode.com/problems/top-k-frequent-elements/) | Medium | Frequency + sorting |
| 6 | [Subarray Sum = K](https://leetcode.com/problems/subarray-sum-equals-k/) | Medium | Prefix sum + hash |
| 7 | [LRU Cache](https://leetcode.com/problems/lru-cache/) | Medium | Hash + LinkedList |
| 8 | [Longest Consecutive](https://leetcode.com/problems/longest-consecutive-sequence/) | Medium | HashSet magic |

### Порядок решения

1. **Сначала:** Two Sum, Valid Anagram — закрепляем базовый lookup
2. **Затем:** Group Anagrams, Top K — усложняем до grouping
3. **Продвинутый:** LRU Cache — комбинируем с [[linked-lists]]

---

## 17. Мифы и заблуждения

| Миф | Реальность |
|-----|-----------|
| "HashMap всегда O(1)" | **Только в среднем.** При плохой hash-функции или атаке коллизиями — O(n). Java 8+ использует Red-Black Tree для buckets > 8 элементов, что даёт O(log n) worst case. |
| "HashSet быстрее HashMap" | **Одинаково.** HashSet внутри использует HashMap (значения = dummy object). Та же производительность, просто другое API. |
| "Можно использовать любой объект как ключ" | **Нужен корректный hashCode() и equals().** Если объект mutable — hash может измениться, и элемент "потеряется" в таблице. |
| "Load factor 0.75 — всегда лучший" | **Зависит от use case.** Для read-heavy: можно 0.5 (меньше коллизий). Для memory-constrained: можно 0.9 (но медленнее). |
| "Chaining всегда лучше Open Addressing" | **Зависит от load factor.** При низком load factor (< 0.5) open addressing быстрее из-за лучшей cache locality. |
| "Rehashing — это плохо" | **Это необходимое зло.** Без rehashing при высоком load factor производительность деградирует. Java HashMap делает rehash автоматически. |
| "dict в Python = HashMap в Java" | **Похоже, но не идентично.** Python dict сохраняет insertion order (с 3.7), Java HashMap — нет (используй LinkedHashMap). |
| "Сложность O(1) означает мгновенно" | **O(1) = константное время, не мгновенное.** Hash вычисление для длинной строки всё равно O(длина строки). O(1) относительно размера таблицы. |

---

## 18. CS-фундамент

| CS-концепция | Как применяется в Hash Tables |
|--------------|------------------------------|
| **Hashing** | Преобразование данных произвольной длины в фиксированный индекс. Основа криптографии, checksums, и hash tables. |
| **Modular Arithmetic** | hash % capacity даёт индекс в массиве. Свойства: (a + b) % m = ((a % m) + (b % m)) % m — используется в rolling hash. |
| **Space-Time Trade-off** | Hash table жертвует O(n) памятью ради O(1) поиска. Классический пример trade-off: время vs память. |
| **Amortized Analysis** | Отдельная вставка может быть O(n) при rehashing, но в среднем по серии операций — O(1). |
| **Birthday Paradox** | Объясняет неизбежность коллизий: при 23 людях вероятность совпадения дней рождения > 50%. То же с hash values. |
| **Collision Resolution** | Две стратегии: Chaining (linked lists в buckets) и Open Addressing (probing для поиска свободного слота). |
| **Determinism** | Hash функция должна быть детерминированной: одинаковый input → одинаковый output. Иначе поиск невозможен. |

---

## 19. Связанные темы

### Prerequisites (изучить ДО этого материала)
- [[arrays-strings]] — понимание массивов и индексов
- [[big-o-complexity]] — понимание O(1) vs O(n)

### Эта тема открывает (изучить ПОСЛЕ)
- [[lru-cache]] — классическая задача Hash + LinkedList
- [[two-pointers-pattern]] — часто комбинируется с hash lookup
- [[sliding-window-pattern]] — hash для tracking элементов в окне

### Связанные паттерны
- [[frequency-counting]] — подсчёт частот через HashMap
- [[prefix-sum]] — комбинируется с hash для subarray задач

---

## 20. Источники

| # | Источник | Тип | Что взято |
|---|----------|-----|-----------|
| 1 | [Tech Interview Handbook](https://www.techinterviewhandbook.org/algorithms/hash-table/) | Guide | Interview patterns |
| 2 | [VisuAlgo](https://visualgo.net/en/hashtable) | Interactive | Visualizations |
| 3 | [YourBasic - Hash Tables](https://yourbasic.org/algorithms/hash-tables-explained/) | Tutorial | Step-by-step approach |
| 4 | [freeCodeCamp - Codeless Guide](https://www.freecodecamp.org/news/the-codeless-guide-to-hash/) | Tutorial | Language-agnostic concepts |
| 5 | [Baeldung - Java HashMap](https://www.baeldung.com/java-hashmap) | Deep dive | Java internals |
| 6 | [GeeksforGeeks - Hash Table](https://www.geeksforgeeks.org/dsa/hash-table-data-structure/) | Reference | Collision resolution |
| 7 | [Medium - Magic of O(1)](https://medium.com/nerd-for-tech/the-magic-of-hash-tables-a-quick-deep-dive-into-o-1-1295199fcd05) | Explanation | O(1) proof |

*Исследование проведено: 2025-12-29*
*Обновлено: 2026-01-06 — добавлены педагогические секции (интуиция хеширования, типичные ошибки, 4 ментальные модели)*
*Отчёт: [[docs/research/2025-12-29-hash-tables-teaching.md]]*

---

[[cs-fundamentals-overview|← CS Fundamentals]] | [[linked-lists|Linked Lists →]]
