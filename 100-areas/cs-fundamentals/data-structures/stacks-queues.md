---
title: "Стеки и очереди: LIFO и FIFO от нуля"
created: 2025-12-29
modified: 2026-01-06
type: deep-dive
status: published
confidence: high
cs-foundations:
  - lifo-data-structure
  - fifo-data-structure
  - abstract-data-type
  - monotonic-invariant
  - circular-buffer
  - amortized-analysis
tags:
  - topic/cs-fundamentals
  - type/deep-dive
  - level/beginner
  - interview
prerequisites:
  - "[[arrays-strings]]"
teaches:
  - stack-lifo
  - queue-fifo
  - deque
  - monotonic-stack
  - circular-queue
unlocks:
  - "[[graph-algorithms]]"
  - "[[dfs-bfs-patterns]]"
  - "[[monotonic-stack-pattern]]"
related:
  - "[[linked-lists]]"
  - "[[trees-binary]]"
---

# Stacks & Queues: структуры с ограниченным доступом

> **TL;DR:** Stack = стопка тарелок (LIFO — последний положил, первый взял). Queue = очередь в кассу (FIFO — первый пришёл, первый обслужен). Все операции O(1). Stack нужен для Undo, function calls, DFS. Queue — для BFS, scheduling, буферов. Monotonic Stack — мощный паттерн для "Next Greater Element" за O(n).

---

## Часть 1: Интуиция без кода — Stack и Queue в жизни

### Stack: Вещи, которые накапливаются

```
┌──────────────────────────────────────────────────────────────────┐
│              STACK В РЕАЛЬНОЙ ЖИЗНИ                              │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    СТОПКА ТАРЕЛОК в посудомойке:                                 │
│                                                                  │
│       ┌─────────┐                                                │
│       │ Тарелка │ ← последняя (её возьмём первой)                │
│       ├─────────┤                                                │
│       │ Тарелка │                                                │
│       ├─────────┤                                                │
│       │ Тарелка │ ← первая (она внизу, до неё не добраться)      │
│       └─────────┘                                                │
│                                                                  │
│    CTRL+Z (отмена действий):                                     │
│                                                                  │
│    Действия: напечатал "Hello" → удалил "o" → добавил "!"        │
│                                                                  │
│    Stack действий:                                               │
│    ┌─────────────────┐                                           │
│    │ добавил "!"     │ ← последнее (отменится первым)            │
│    ├─────────────────┤                                           │
│    │ удалил "o"      │                                           │
│    ├─────────────────┤                                           │
│    │ напечатал "Hello"│ ← первое (отменится последним)           │
│    └─────────────────┘                                           │
│                                                                  │
│    Нажал Ctrl+Z → отменится "добавил !" (последнее!)            │
│                                                                  │
│    ДРУГИЕ ПРИМЕРЫ STACK:                                         │
│    • Стопка книг на столе                                        │
│    • Фишки казино (снимаем сверху)                               │
│    • Конфеты PEZ (первой выпадает последняя загруженная)         │
│    • История браузера (назад = последняя страница)               │
│    • Call Stack в программировании                               │
└──────────────────────────────────────────────────────────────────┘
```

### Queue: Вещи, которые обрабатываются по очереди

```
┌──────────────────────────────────────────────────────────────────┐
│              QUEUE В РЕАЛЬНОЙ ЖИЗНИ                              │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    ОЧЕРЕДЬ В КАССУ:                                              │
│                                                                  │
│    КАССА ←── Аня ←── Боря ←── Вася ←── ВХОД                     │
│      ↓                                                           │
│    Обслуживают АНЬКУ (она пришла первой!)                        │
│                                                                  │
│    ПРИНТЕР:                                                      │
│                                                                  │
│    Документы в очереди на печать:                                │
│    1. Резюме (отправлено 10:00) ← печатается СЕЙЧАС              │
│    2. Курсовая (отправлено 10:05)                                │
│    3. Мем (отправлено 10:10)                                     │
│                                                                  │
│    Нельзя напечатать мем раньше резюме!                          │
│    Первый отправленный = первый напечатанный.                    │
│                                                                  │
│    ДРУГИЕ ПРИМЕРЫ QUEUE:                                         │
│    • Эскалатор (первый встал = первый сошёл)                     │
│    • Автомойка (машины проезжают по порядку)                     │
│    • Конвейер на заводе                                          │
│    • Буфер видео (кадры воспроизводятся по порядку)              │
│    • Message Queue (Kafka, RabbitMQ)                             │
└──────────────────────────────────────────────────────────────────┘
```

### Ключевое различие: LIFO vs FIFO

```
┌──────────────────────────────────────────────────────────────────┐
│                    LIFO vs FIFO                                  │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    STACK (LIFO):                                                 │
│    Last In → First Out                                           │
│    "Последний пришёл — первый ушёл"                              │
│                                                                  │
│    Добавили: A → B → C                                           │
│    Уберём:   C (последний добавленный!)                          │
│                                                                  │
│         ┌───┐                                                    │
│         │ C │ ← входит и выходит ЗДЕСЬ                           │
│         ├───┤                                                    │
│         │ B │                                                    │
│         ├───┤                                                    │
│         │ A │                                                    │
│         └───┘                                                    │
│                                                                  │
│    ────────────────────────────────────────────────────────────  │
│                                                                  │
│    QUEUE (FIFO):                                                 │
│    First In → First Out                                          │
│    "Первый пришёл — первый ушёл"                                 │
│                                                                  │
│    Добавили: A → B → C                                           │
│    Уберём:   A (первый добавленный!)                             │
│                                                                  │
│    ┌───┬───┬───┐                                                │
│    │ A │ B │ C │                                                │
│    └───┴───┴───┘                                                │
│      ↑           ↑                                               │
│    выход       вход                                              │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

---

## Часть 2: Почему Stack и Queue бывают сложными?

### Проблема 1: Путаница между Push/Pop и Enqueue/Dequeue

```
┌──────────────────────────────────────────────────────────────────┐
│              ТЕРМИНОЛОГИЯ — ИСТОЧНИК ПУТАНИЦЫ                    │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    ❌ ТИПИЧНАЯ ОШИБКА:                                           │
│    "push и enqueue — это одно и то же"                           │
│    "pop и dequeue — это одно и то же"                            │
│                                                                  │
│    ✅ ПРАВИЛЬНО:                                                 │
│                                                                  │
│    STACK:                    QUEUE:                              │
│    • push = положить сверху  • enqueue = встать в конец          │
│    • pop = снять сверху      • dequeue = выйти из начала         │
│    • peek = посмотреть верх  • peek = посмотреть начало          │
│                                                                  │
│    ГЛАВНОЕ РАЗЛИЧИЕ:                                             │
│    Stack: добавление И удаление с ОДНОГО конца (вершина)         │
│    Queue: добавление с ОДНОГО конца, удаление с ДРУГОГО          │
│                                                                  │
│    МНЕМОНИКА:                                                    │
│    Stack = "СТопка" — работаем только с верхом                   │
│    Queue = "Очередь" — входим сзади, выходим спереди             │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

### Проблема 2: O(n) в неправильных реализациях

```
┌──────────────────────────────────────────────────────────────────┐
│              СКРЫТАЯ ОШИБКА ПРОИЗВОДИТЕЛЬНОСТИ                   │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    ❌ НЕПРАВИЛЬНО (Python):                                      │
│                                                                  │
│    queue = []                                                    │
│    queue.append(1)    # O(1) ✓                                   │
│    queue.pop(0)       # O(n) ✗ — все элементы сдвигаются!        │
│                                                                  │
│    Что происходит при pop(0)?                                    │
│    [1, 2, 3, 4, 5]                                               │
│     ↑                                                            │
│    Удаляем 1, все остальные сдвигаются:                          │
│    [2, 3, 4, 5]     ← 4 операции сдвига!                         │
│                                                                  │
│    Для 1,000,000 элементов: 999,999 сдвигов = O(n)!              │
│                                                                  │
│    ✅ ПРАВИЛЬНО (Python):                                        │
│                                                                  │
│    from collections import deque                                 │
│    queue = deque()                                               │
│    queue.append(1)    # O(1) ✓                                   │
│    queue.popleft()    # O(1) ✓ — никаких сдвигов!                │
│                                                                  │
│    ТА ЖЕ ПРОБЛЕМА В JAVASCRIPT:                                  │
│    arr.shift() — O(n), не O(1)!                                  │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

### Проблема 3: Когда Stack, когда Queue?

```
┌──────────────────────────────────────────────────────────────────┐
│              ВЫБОР СТРУКТУРЫ — ТИПИЧНАЯ ПУТАНИЦА                 │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    КЛЮЧЕВОЙ ВОПРОС: Что важнее?                                  │
│                                                                  │
│    Последний элемент важнее (LIFO) → STACK                       │
│    Первый элемент важнее (FIFO) → QUEUE                          │
│                                                                  │
│    ПРИМЕРЫ:                                                      │
│                                                                  │
│    • Undo (Ctrl+Z):                                              │
│      Отменяем ПОСЛЕДНЕЕ действие → STACK                         │
│                                                                  │
│    • Печать документов:                                          │
│      Печатаем ПЕРВЫЙ отправленный → QUEUE                        │
│                                                                  │
│    • DFS (обход в глубину):                                      │
│      Сначала идём ГЛУБЖЕ → STACK                                 │
│      (последний найденный узел исследуем первым)                 │
│                                                                  │
│    • BFS (обход в ширину):                                       │
│      Сначала исследуем СОСЕДЕЙ → QUEUE                           │
│      (первый найденный узел исследуем первым)                    │
│                                                                  │
│    • Проверка скобок:                                            │
│      Последняя открытая должна закрыться первой → STACK          │
│                                                                  │
│    • Задачи в очереди:                                           │
│      Первая задача выполняется первой → QUEUE                    │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

### Проблема 4: Monotonic Stack — "что это вообще?"

```
┌──────────────────────────────────────────────────────────────────┐
│              MONOTONIC STACK — СЛОЖНАЯ КОНЦЕПЦИЯ                 │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    Обычный Stack: кладём что угодно                              │
│    [5, 3, 8, 1, 9] — никакого порядка                           │
│                                                                  │
│    Monotonic Stack: поддерживаем порядок                         │
│    [9, 5, 3, 1] — убывающий (каждый следующий меньше)            │
│    [1, 3, 5, 9] — возрастающий (каждый следующий больше)         │
│                                                                  │
│    КАК ПОДДЕРЖИВАТЬ ПОРЯДОК?                                     │
│    Когда новый элемент "нарушает" порядок — удаляем старые       │
│                                                                  │
│    Пример (Decreasing Stack):                                    │
│    Добавляем 5: [5]                                              │
│    Добавляем 3: [5, 3]     ← 3 < 5, порядок сохраняется          │
│    Добавляем 8: [8]        ← 8 > 3 и > 5, удалили их!           │
│    Добавляем 1: [8, 1]     ← 1 < 8, порядок сохраняется          │
│                                                                  │
│    ЗАЧЕМ ЭТО НУЖНО?                                              │
│    Для задач типа "найди первый больший/меньший элемент"         │
│    за O(n) вместо O(n²)!                                         │
│                                                                  │
│    Когда приходит новый элемент и "выбивает" старые —            │
│    он и есть "первый больший" для выбитых!                       │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

---

## Часть 3: Ментальные модели для Stack и Queue

### Модель 1: "Стопка тарелок" (Stack)

```
┌──────────────────────────────────────────────────────────────────┐
│              МОДЕЛЬ: СТОПКА ТАРЕЛОК                              │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    Представь стопку тарелок в посудомойке:                       │
│                                                                  │
│       ┌─────────┐                                                │
│       │ Тарелка │ ← TOP (вершина)                                │
│       ├─────────┤                                                │
│       │ Тарелка │                                                │
│       ├─────────┤                                                │
│       │ Тарелка │ ← BOTTOM (дно)                                 │
│       └─────────┘                                                │
│                                                                  │
│    ОПЕРАЦИИ:                                                     │
│    • push = положить тарелку СВЕРХУ                              │
│    • pop = взять тарелку СВЕРХУ                                  │
│    • peek = посмотреть на верхнюю (не трогая)                    │
│                                                                  │
│    ОГРАНИЧЕНИЕ:                                                  │
│    Нельзя взять тарелку из середины — сначала сними все сверху!  │
│                                                                  │
│    КОГДА ИСПОЛЬЗОВАТЬ:                                           │
│    Когда нужно работать только с "последним добавленным"         │
└──────────────────────────────────────────────────────────────────┘
```

### Модель 2: "Очередь в кассу" (Queue)

```
┌──────────────────────────────────────────────────────────────────┐
│              МОДЕЛЬ: ОЧЕРЕДЬ В КАССУ                             │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    Представь очередь в супермаркете:                             │
│                                                                  │
│    КАССА ←── [ Аня ] ←── [ Боря ] ←── [ Вася ] ←── ВХОД         │
│               FRONT                       REAR                   │
│             (выход)                     (вход)                   │
│                                                                  │
│    ОПЕРАЦИИ:                                                     │
│    • enqueue = Галя встаёт в конец (за Васей)                    │
│    • dequeue = Аню обслужили, она уходит                         │
│    • peek = посмотреть кто следующий (Аня)                       │
│                                                                  │
│    ОГРАНИЧЕНИЕ:                                                  │
│    Нельзя обслужить Васю раньше Ани — это нечестно!              │
│    (ну, если Вася не VIP с Priority Queue)                       │
│                                                                  │
│    КОГДА ИСПОЛЬЗОВАТЬ:                                           │
│    Когда нужно обрабатывать в порядке поступления                │
└──────────────────────────────────────────────────────────────────┘
```

### Модель 3: "Дверь-турникет" (для понимания одного vs двух концов)

```
┌──────────────────────────────────────────────────────────────────┐
│              МОДЕЛЬ: ДВЕРЬ vs ТУРНИКЕТ                           │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    STACK = ОДНА ДВЕРЬ (вход и выход — одно место):               │
│                                                                  │
│           ┌─────────────────┐                                    │
│    ВХОД → │                 │ → ВЫХОД                            │
│     ←─────│     КОМНАТА     │─────→                              │
│     (одна │                 │ (одна                              │
│     дверь)│                 │ дверь)                             │
│           └─────────────────┘                                    │
│                                                                  │
│    Последний вошёл — стоит у двери — первый выйдет!              │
│                                                                  │
│    ────────────────────────────────────────────────────────────  │
│                                                                  │
│    QUEUE = ТУРНИКЕТ (вход и выход — разные места):               │
│                                                                  │
│           ┌─────────────────┐                                    │
│    ВХОД → │                 │                                    │
│     ─────→│     КОРИДОР     │─────→ ВЫХОД                        │
│    (сзади)│                 │ (спереди)                          │
│           └─────────────────┘                                    │
│                                                                  │
│    Первый вошёл — ближе к выходу — первый выйдет!                │
│                                                                  │
│    КОГДА ИСПОЛЬЗОВАТЬ:                                           │
│    Когда выбираешь структуру — представь дверь или турникет      │
└──────────────────────────────────────────────────────────────────┘
```

### Модель 4: "Call Stack как стопка документов"

```
┌──────────────────────────────────────────────────────────────────┐
│              МОДЕЛЬ: CALL STACK = СТОПКА ДОКУМЕНТОВ              │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    Рекурсия factorial(4):                                        │
│                                                                  │
│    factorial(4) вызывает factorial(3)                            │
│    factorial(3) вызывает factorial(2)                            │
│    factorial(2) вызывает factorial(1)                            │
│    factorial(1) возвращает 1                                     │
│                                                                  │
│    Call Stack:                                                   │
│    ┌─────────────────┐                                           │
│    │ factorial(1)    │ ← текущий (на вершине)                    │
│    ├─────────────────┤                                           │
│    │ factorial(2)    │                                           │
│    ├─────────────────┤                                           │
│    │ factorial(3)    │                                           │
│    ├─────────────────┤                                           │
│    │ factorial(4)    │ ← первый вызов (внизу)                    │
│    └─────────────────┘                                           │
│                                                                  │
│    Возвращаемся в ОБРАТНОМ порядке:                              │
│    factorial(1) → factorial(2) → factorial(3) → factorial(4)     │
│                                                                  │
│    STACK OVERFLOW = стопка переполнилась!                        │
│    (слишком глубокая рекурсия)                                   │
│                                                                  │
│    КОГДА ИСПОЛЬЗОВАТЬ:                                           │
│    Для понимания рекурсии и почему бывает Stack Overflow         │
└──────────────────────────────────────────────────────────────────┘
```

### Сравнение моделей: когда какую использовать

| Модель | Когда использовать | Помогает понять |
|--------|-------------------|-----------------|
| **Стопка тарелок** | Базовое понимание Stack | push/pop с одного конца |
| **Очередь в кассу** | Базовое понимание Queue | FIFO, fairness |
| **Дверь vs турникет** | Выбор структуры | Один vs два конца |
| **Call Stack** | Рекурсия, отладка | Stack Overflow, возврат из функций |

---

## 1. Зачем это нужно?

### Представьте ситуацию

Вы работаете в текстовом редакторе и случайно удалили целый абзац. Нажимаете **Ctrl+Z** — и текст возвращается! Как это работает?

```
Действия пользователя:
1. Напечатал "Hello"           → сохранили
2. Напечатал " World"          → сохранили
3. Удалил "World"              → сохранили
4. Нажал Ctrl+Z                → ???

Что должно произойти?
Отменить ПОСЛЕДНЕЕ действие (удаление "World")
А не первое!
```

**Это LIFO — Last In, First Out.**
Последнее действие должно быть отменено первым.

---

### Другая ситуация

Вы в очереди в банке. Пришли 10 человек. Кого обслужат первым?

```
9:00 — Пришёл Иван (1-й в очереди)
9:05 — Пришла Мария (2-я)
9:10 — Пришёл Сергей (3-й)

Кого обслужат первым?
Ивана! Он пришёл первым.
```

**Это FIFO — First In, First Out.**
Первый пришёл — первый обслужен.

---

### Проблема, которую решают Stack и Queue

```
УНИВЕРСАЛЬНЫЕ ПРОБЛЕМЫ:

Stack (LIFO):
├── Отмена действий (Undo/Redo)
├── Вызов функций (Call Stack)
├── Обход в глубину (DFS)
├── Проверка скобок (Parentheses)
└── Вычисление выражений (Calculator)

Queue (FIFO):
├── Обработка заявок по порядку
├── Обход в ширину (BFS)
├── Планирование задач (Task Scheduling)
├── Буферизация данных (Streaming)
└── Message Queues (Kafka, RabbitMQ)

Обе структуры: O(1) для добавления и удаления!
```

---

## 2. Объяснение для 5-летнего

### Stack: Стопка блинов

```
Мама печёт блины и кладёт их стопкой:

       ┌─────────┐
       │ Блин 5  │ ← Последний (горячий!)
       ├─────────┤
       │ Блин 4  │
       ├─────────┤
       │ Блин 3  │
       ├─────────┤
       │ Блин 2  │
       ├─────────┤
       │ Блин 1  │ ← Первый (уже остыл)
       └─────────┘
         СТОПКА

Какой блин ты возьмёшь?
Верхний! (Блин 5)

Можешь взять нижний?
Нет! Сначала нужно убрать все верхние.

Это и есть Stack — LIFO:
Last In (Блин 5) → First Out (его берём первым)
```

**Другие аналогии Stack:**
- **PEZ-конфеты** — сначала выпадает последняя загруженная
- **Стопка книг** — берёшь верхнюю
- **Покерные фишки** — снимаешь сверху
- **Ctrl+Z** — отменяешь последнее действие

---

### Queue: Очередь в кассу

```
Супермаркет. Люди встают в очередь:

КАССА                              ВХОД
  ↓                                  ↓
┌─────┐   ┌─────┐   ┌─────┐   ┌─────┐
│ Аня │ → │ Боря│ → │ Вася│ → │ Галя│
└─────┘   └─────┘   └─────┘   └─────┘
  FRONT                         REAR
(первый)                    (последний)

Кого обслужат первым?
Аню! Она пришла раньше всех.

Может Галя пройти первой?
Нет! (Если не хочет скандала)

Это и есть Queue — FIFO:
First In (Аня пришла первой) → First Out (её обслужат первой)
```

**Другие аналогии Queue:**
- **Эскалатор** — первый встал, первый сошёл
- **Автомойка** — машины проезжают по порядку
- **Принтер** — документы печатаются в порядке отправки
- **Конвейер** — бутылки двигаются по очереди

---

## 3. Терминология

| Термин | Stack | Queue |
|--------|-------|-------|
| **Принцип** | LIFO (Last In, First Out) | FIFO (First In, First Out) |
| **Добавить** | Push (положить сверху) | Enqueue (встать в конец) |
| **Удалить** | Pop (снять сверху) | Dequeue (выйти из начала) |
| **Посмотреть** | Peek/Top (верхний элемент) | Peek/Front (первый в очереди) |
| **Указатели** | 1 (top — вершина) | 2 (front и rear) |

| Дополнительные термины | Определение |
|------------------------|-------------|
| **Deque** | Double-Ended Queue — можно добавлять/удалять с обоих концов |
| **Circular Queue** | Очередь, где конец соединён с началом (экономит память) |
| **Priority Queue** | Очередь с приоритетами — не FIFO, а по важности |
| **Monotonic Stack** | Stack с элементами в монотонном порядке (только возрастают или убывают) |

---

## 4. Как это работает

### Stack: Пошаговая визуализация

```
Операции: push(A), push(B), push(C), pop(), peek(), pop()

НАЧАЛО          push(A)         push(B)         push(C)
┌───┐           ┌───┐           ┌───┐           ┌───┐
│   │           │   │           │   │           │ C │ ← top
├───┤           ├───┤           ├───┤           ├───┤
│   │           │   │           │ B │ ← top     │ B │
├───┤           ├───┤           ├───┤           ├───┤
│   │           │ A │ ← top     │ A │           │ A │
└───┘           └───┘           └───┘           └───┘
size=0          size=1          size=2          size=3


pop() → C       peek() → B      pop() → B
┌───┐           ┌───┐           ┌───┐
│   │           │   │           │   │
├───┤           ├───┤           ├───┤
│ B │ ← top     │ B │ ← top     │   │
├───┤           ├───┤           ├───┤
│ A │           │ A │           │ A │ ← top
└───┘           └───┘           └───┘
return C        return B        return B
size=2          size=2          size=1
                (не удаляет!)
```

**Ключевое правило Stack:**
> Работаем ТОЛЬКО с вершиной (top). Нельзя достать элемент из середины — нужно сначала снять все верхние.

---

### Queue: Пошаговая визуализация

```
Операции: enqueue(A), enqueue(B), enqueue(C), dequeue(), peek()

НАЧАЛО:
FRONT→ [   ] ←REAR (пустая очередь)

enqueue(A):
FRONT→ [ A ] ←REAR

enqueue(B):
FRONT→ [ A | B ] ←REAR

enqueue(C):
FRONT→ [ A | B | C ] ←REAR

dequeue() → A:
FRONT→ [ B | C ] ←REAR  (A ушёл, он был первым)

peek() → B:
FRONT→ [ B | C ] ←REAR  (смотрим на B, но не убираем)
```

**Ключевое правило Queue:**
> Добавляем в конец (rear), удаляем из начала (front). Два разных конца!

---

### Circular Queue: Почему лучше?

**Проблема Linear Queue:**

```
После нескольких dequeue:

Linear Queue:
┌───┬───┬───┬───┬───┬───┬───┬───┐
│   │   │   │ D │ E │ F │   │   │
└───┴───┴───┴───┴───┴───┴───┴───┘
              ↑           ↑
            FRONT        REAR

Проблема: 3 пустые ячейки слева НЕ ИСПОЛЬЗУЮТСЯ!
Когда REAR дойдёт до конца — "очередь полна",
хотя есть свободное место.
```

**Решение Circular Queue:**

```
Circular Queue (кольцевой буфер):

        ┌───┐
     ┌──┤ E │──┐
   ┌─┤  └───┘  │─┐
 ┌─┤ │    ↑    │ │─┐
 │ D │   REAR  │ A │
 └───┘         └───┘
   ↑             ↓
 ┌───┐         ┌───┐
 │ C │←────────│ B │
 └───┘  FRONT  └───┘

Когда REAR доходит до конца — он "оборачивается" к началу!
rear = (rear + 1) % capacity

Память используется на 100%!
```

---

### Deque: Двусторонняя очередь

```
Deque = Double-Ended Queue

Можно работать с ОБОИХ концов:

     addFirst()                    addLast()
         ↓                             ↓
     ┌───────────────────────────────────┐
     │  [A] [B] [C] [D] [E]              │
     └───────────────────────────────────┘
         ↑                             ↑
    removeFirst()                 removeLast()


Deque может работать как:
- Stack (используем только один конец)
- Queue (добавляем с одного конца, удаляем с другого)
- Sliding Window (удаляем "старые" элементы с обоих концов)
```

**Важно для Java:**
> Java Stack class считается legacy. Официальная рекомендация: используйте `Deque<E>` (ArrayDeque) вместо Stack!

---

## 5. Stack vs Queue: Когда что использовать?

| Критерий | Stack (LIFO) | Queue (FIFO) |
|----------|--------------|--------------|
| **Порядок важности** | Последний важнее | Первый важнее |
| **Пример** | Undo (отменить последнее) | Заявки (обработать первую) |
| **Обход графа** | DFS (в глубину) | BFS (в ширину) |
| **Рекурсия** | Call Stack | Не применимо |
| **Буферизация** | Редко | Часто (потоки данных) |

### Мнемоника для запоминания

```
Stack = "СТОПКА" — кладёшь сверху, берёшь сверху
        Как стопка книг или тарелок.

Queue = "ОЧЕРЕДЬ" — встаёшь в конец, выходишь из начала
        Как очередь в магазине.
```

---

## 6. Complexity Analysis

| Операция | Stack | Queue | Deque |
|----------|-------|-------|-------|
| Push/Enqueue | O(1) | O(1) | O(1) |
| Pop/Dequeue | O(1) | O(1) | O(1) |
| Peek (Top/Front) | O(1) | O(1) | O(1) |
| isEmpty | O(1) | O(1) | O(1) |
| Search | O(n) | O(n) | O(n) |
| Space | O(n) | O(n) | O(n) |

**Важно о Queue в разных языках:**

```
ОСТОРОЖНО С JAVASCRIPT!

// НЕПРАВИЛЬНО — O(n) dequeue!
const queue = [1, 2, 3, 4, 5];
queue.push(6);      // O(1) ✓
queue.shift();      // O(n) ✗ — все элементы сдвигаются!

// ПРАВИЛЬНО — используй два стека или custom Deque

ОСТОРОЖНО С PYTHON!

# НЕПРАВИЛЬНО — O(n) dequeue!
queue = []
queue.append(1)     # O(1) ✓
queue.pop(0)        # O(n) ✗ — все элементы сдвигаются!

# ПРАВИЛЬНО
from collections import deque
queue = deque()
queue.append(1)     # O(1) ✓
queue.popleft()     # O(1) ✓
```

---

## 7. Реализация

### Stack

```kotlin
// ПОЧЕМУ: Kotlin ArrayDeque — современный и эффективный
// КАК: addLast = push, removeLast = pop
val stack = ArrayDeque<Int>()

// Push: добавить на вершину
stack.addLast(1)   // stack = [1]
stack.addLast(2)   // stack = [1, 2]
stack.addLast(3)   // stack = [1, 2, 3]

// Pop: снять с вершины
val top = stack.removeLast()  // top = 3, stack = [1, 2]

// Peek: посмотреть вершину (не удаляя)
val peek = stack.lastOrNull() // peek = 2, stack = [1, 2]

// isEmpty: проверить пустоту
val empty = stack.isEmpty()   // false
```

```java
// ПОЧЕМУ: Java Stack класс — legacy, используем Deque
// КАК: push/pop/peek работают с "головой" (началом) Deque
import java.util.ArrayDeque;
import java.util.Deque;

Deque<Integer> stack = new ArrayDeque<>();

// Push: добавить на вершину
stack.push(1);   // stack = [1]
stack.push(2);   // stack = [2, 1] — голова слева!
stack.push(3);   // stack = [3, 2, 1]

// Pop: снять с вершины
int top = stack.pop();   // top = 3, stack = [2, 1]

// Peek: посмотреть вершину
int peek = stack.peek(); // peek = 2

// isEmpty
boolean empty = stack.isEmpty(); // false
```

```python
# ПОЧЕМУ: list работает как stack "из коробки"
# КАК: append = push, pop = pop, [-1] = peek
stack = []

# Push
stack.append(1)  # stack = [1]
stack.append(2)  # stack = [1, 2]
stack.append(3)  # stack = [1, 2, 3]

# Pop
top = stack.pop()  # top = 3, stack = [1, 2]

# Peek
peek = stack[-1]   # peek = 2

# isEmpty
empty = len(stack) == 0  # False
```

---

### Queue

```kotlin
// ПОЧЕМУ: ArrayDeque эффективен для обоих концов
// КАК: addLast = enqueue, removeFirst = dequeue
val queue = ArrayDeque<Int>()

// Enqueue: добавить в конец
queue.addLast(1)   // queue = [1]
queue.addLast(2)   // queue = [1, 2]
queue.addLast(3)   // queue = [1, 2, 3]

// Dequeue: удалить из начала
val front = queue.removeFirst() // front = 1, queue = [2, 3]

// Peek: посмотреть первый элемент
val peek = queue.firstOrNull()  // peek = 2
```

```java
// ПОЧЕМУ: Queue интерфейс + LinkedList или ArrayDeque
// КАК: offer = enqueue, poll = dequeue, peek = peek
import java.util.LinkedList;
import java.util.Queue;

Queue<Integer> queue = new LinkedList<>();

// Enqueue
queue.offer(1);  // queue = [1]
queue.offer(2);  // queue = [1, 2]
queue.offer(3);  // queue = [1, 2, 3]

// Dequeue
int front = queue.poll();  // front = 1, queue = [2, 3]

// Peek
int peek = queue.peek();   // peek = 2
```

```python
# ПОЧЕМУ: collections.deque оптимизирован для обоих концов
# КАК: append = enqueue, popleft = dequeue
from collections import deque

queue = deque()

# Enqueue
queue.append(1)  # queue = deque([1])
queue.append(2)  # queue = deque([1, 2])
queue.append(3)  # queue = deque([1, 2, 3])

# Dequeue
front = queue.popleft()  # front = 1, queue = deque([2, 3])

# Peek
peek = queue[0]          # peek = 2
```

---

## 8. Interview Patterns

### Pattern 1: Valid Parentheses (Проверка скобок)

**Задача:** Строка содержит `()`, `{}`, `[]`. Проверить, что все скобки закрыты правильно.

```
"()"      → true   (открыли и закрыли)
"()[]{}"  → true   (несколько пар)
"(]"      → false  (открыли (, закрыли ])
"([)]"    → false  (неправильный порядок)
"{[]}"    → true   (вложенные скобки)
```

**Почему Stack?**
> Последняя открытая скобка должна быть закрыта первой — это LIFO!

```
Строка: "{[]}"

Шаг 1: '{' — открывающая → push → stack = ['{']
Шаг 2: '[' — открывающая → push → stack = ['{', '[']
Шаг 3: ']' — закрывающая → pop '[', проверяем: '[' ↔ ']' ✓
Шаг 4: '}' — закрывающая → pop '{', проверяем: '{' ↔ '}' ✓
Шаг 5: stack пуст → TRUE
```

```kotlin
fun isValid(s: String): Boolean {
    val stack = ArrayDeque<Char>()
    // ПОЧЕМУ: map закрывающих к открывающим для быстрой проверки
    val pairs = mapOf(')' to '(', '}' to '{', ']' to '[')

    for (char in s) {
        when {
            // Открывающая скобка — положить в stack
            char in pairs.values -> stack.addLast(char)
            // Закрывающая скобка — проверить и снять
            char in pairs.keys -> {
                // ВАЖНО: проверяем isEmpty перед pop!
                if (stack.isEmpty() || stack.removeLast() != pairs[char]) {
                    return false
                }
            }
        }
    }
    // Stack должен быть пуст (все скобки закрыты)
    return stack.isEmpty()
}
```

```java
public boolean isValid(String s) {
    Deque<Character> stack = new ArrayDeque<>();
    Map<Character, Character> pairs = Map.of(')', '(', '}', '{', ']', '[');

    for (char c : s.toCharArray()) {
        if (pairs.containsValue(c)) {
            stack.push(c);
        } else if (pairs.containsKey(c)) {
            if (stack.isEmpty() || stack.pop() != pairs.get(c)) {
                return false;
            }
        }
    }
    return stack.isEmpty();
}
```

```python
def is_valid(s: str) -> bool:
    stack = []
    pairs = {')': '(', '}': '{', ']': '['}

    for char in s:
        if char in pairs.values():
            stack.append(char)
        elif char in pairs:
            if not stack or stack.pop() != pairs[char]:
                return False

    return len(stack) == 0
```

---

### Pattern 2: Min Stack (Stack с O(1) минимумом)

**Задача:** Реализовать stack, который поддерживает `getMin()` за O(1).

**Идея:** Вести два стека — основной и "стек минимумов".

```
push(5): stack=[5], minStack=[5]
push(3): stack=[5,3], minStack=[5,3]     // 3 < 5, добавляем
push(7): stack=[5,3,7], minStack=[5,3]   // 7 > 3, НЕ добавляем
push(2): stack=[5,3,7,2], minStack=[5,3,2] // 2 < 3, добавляем

getMin() → 2 (вершина minStack)

pop(): stack=[5,3,7], minStack=[5,3]     // 2 == minStack.top, удаляем из обоих
getMin() → 3
```

```kotlin
class MinStack {
    private val stack = ArrayDeque<Int>()
    private val minStack = ArrayDeque<Int>()

    fun push(x: Int) {
        stack.addLast(x)
        // ПОЧЕМУ <=: если несколько одинаковых минимумов
        if (minStack.isEmpty() || x <= minStack.last()) {
            minStack.addLast(x)
        }
    }

    fun pop() {
        val popped = stack.removeLast()
        // Если удалили минимум — удаляем и из minStack
        if (popped == minStack.last()) {
            minStack.removeLast()
        }
    }

    fun top(): Int = stack.last()

    fun getMin(): Int = minStack.last()  // O(1)!
}
```

```java
class MinStack {
    private Deque<Integer> stack = new ArrayDeque<>();
    private Deque<Integer> minStack = new ArrayDeque<>();

    public void push(int x) {
        stack.push(x);
        if (minStack.isEmpty() || x <= minStack.peek()) {
            minStack.push(x);
        }
    }

    public void pop() {
        int popped = stack.pop();
        if (popped == minStack.peek()) {
            minStack.pop();
        }
    }

    public int top() { return stack.peek(); }

    public int getMin() { return minStack.peek(); }
}
```

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, x: int) -> None:
        self.stack.append(x)
        if not self.min_stack or x <= self.min_stack[-1]:
            self.min_stack.append(x)

    def pop(self) -> None:
        popped = self.stack.pop()
        if popped == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def get_min(self) -> int:
        return self.min_stack[-1]
```

---

### Pattern 3: Queue из двух Stacks

**Задача:** Реализовать Queue, используя только Stack операции.

**Идея:** Два стека — `pushStack` для добавления, `popStack` для удаления.

```
Почему это работает?

Добавляем 1, 2, 3 в pushStack:
pushStack = [1, 2, 3]  (3 на вершине)
popStack = []

Когда нужен dequeue — "переливаем":
pushStack = []
popStack = [3, 2, 1]   (1 на вершине!)

Теперь pop() даёт 1 — как раз FIFO!
```

```kotlin
class MyQueue {
    private val pushStack = ArrayDeque<Int>()
    private val popStack = ArrayDeque<Int>()

    fun push(x: Int) {
        pushStack.addLast(x)
    }

    fun pop(): Int {
        moveIfNeeded()
        return popStack.removeLast()
    }

    fun peek(): Int {
        moveIfNeeded()
        return popStack.last()
    }

    fun empty(): Boolean = pushStack.isEmpty() && popStack.isEmpty()

    // ПОЧЕМУ: переливаем только когда popStack пуст
    // Amortized O(1) — каждый элемент перемещается максимум 1 раз
    private fun moveIfNeeded() {
        if (popStack.isEmpty()) {
            while (pushStack.isNotEmpty()) {
                popStack.addLast(pushStack.removeLast())
            }
        }
    }
}
```

```java
class MyQueue {
    private Deque<Integer> pushStack = new ArrayDeque<>();
    private Deque<Integer> popStack = new ArrayDeque<>();

    public void push(int x) {
        pushStack.push(x);
    }

    public int pop() {
        moveIfNeeded();
        return popStack.pop();
    }

    public int peek() {
        moveIfNeeded();
        return popStack.peek();
    }

    public boolean empty() {
        return pushStack.isEmpty() && popStack.isEmpty();
    }

    private void moveIfNeeded() {
        if (popStack.isEmpty()) {
            while (!pushStack.isEmpty()) {
                popStack.push(pushStack.pop());
            }
        }
    }
}
```

```python
class MyQueue:
    def __init__(self):
        self.push_stack = []
        self.pop_stack = []

    def push(self, x: int) -> None:
        self.push_stack.append(x)

    def pop(self) -> int:
        self._move_if_needed()
        return self.pop_stack.pop()

    def peek(self) -> int:
        self._move_if_needed()
        return self.pop_stack[-1]

    def empty(self) -> bool:
        return not self.push_stack and not self.pop_stack

    def _move_if_needed(self):
        if not self.pop_stack:
            while self.push_stack:
                self.pop_stack.append(self.push_stack.pop())
```

---

## 9. Monotonic Stack

### Что это?

**Monotonic Stack** — stack, где элементы всегда упорядочены (только возрастают ИЛИ только убывают).

```
Monotonic Decreasing: [8, 6, 4, 2]  — каждый следующий меньше
Monotonic Increasing: [2, 4, 6, 8]  — каждый следующий больше

При добавлении нового элемента:
Если он "нарушает порядок" — удаляем элементы, пока порядок не восстановится.
```

### Когда использовать?

| Задача | Тип Stack | Что получаем |
|--------|-----------|--------------|
| Next Greater Element | Decreasing | Для каждого элемента — первый больший справа |
| Next Smaller Element | Increasing | Для каждого элемента — первый меньший справа |
| Previous Greater | Decreasing | Первый больший слева |
| Previous Smaller | Increasing | Первый меньший слева |
| Largest Rectangle | Increasing | Площадь максимального прямоугольника |

---

### Пример: Next Greater Element

**Задача:** Для каждого элемента найти первый элемент справа, который больше него.

```
Array: [4, 5, 2, 10, 8]

Для 4:  первый больший справа = 5
Для 5:  первый больший справа = 10
Для 2:  первый больший справа = 10
Для 10: нет большего справа = -1
Для 8:  нет большего справа = -1

Answer: [5, 10, 10, -1, -1]
```

**Почему Monotonic Stack?**

```
Brute Force: для каждого элемента ищем справа → O(n²)

Monotonic Stack: каждый элемент push/pop максимум 1 раз → O(n)!

Идея:
- Храним элементы, для которых ещё не нашли "больший"
- Когда приходит новый — он и есть "больший" для всех меньших в стеке
```

**Визуализация:**

```
Array: [4, 5, 2, 10, 8]
Stack: [] (храним ИНДЕКСЫ, monotonic decreasing по значениям)

i=0, num=4:
  stack пуст → push 0
  stack = [0]  (values: [4])

i=1, num=5:
  5 > nums[0]=4 → pop 0, result[0]=5
  stack пуст → push 1
  stack = [1]  (values: [5])
  result = [5, ?, ?, ?, ?]

i=2, num=2:
  2 < nums[1]=5 → НЕ pop (порядок сохраняется)
  push 2
  stack = [1, 2]  (values: [5, 2])

i=3, num=10:
  10 > nums[2]=2 → pop 2, result[2]=10
  10 > nums[1]=5 → pop 1, result[1]=10
  stack пуст → push 3
  stack = [3]  (values: [10])
  result = [5, 10, 10, ?, ?]

i=4, num=8:
  8 < nums[3]=10 → НЕ pop
  push 4
  stack = [3, 4]  (values: [10, 8])

Конец: оставшиеся в стеке не имеют greater → result[3]=-1, result[4]=-1

FINAL: [5, 10, 10, -1, -1]
```

```kotlin
fun nextGreaterElements(nums: IntArray): IntArray {
    val n = nums.size
    val result = IntArray(n) { -1 }  // default: нет большего
    val stack = ArrayDeque<Int>()    // храним ИНДЕКСЫ

    for (i in 0 until n) {
        // ПОЧЕМУ while: текущий может быть больше нескольких элементов
        while (stack.isNotEmpty() && nums[stack.last()] < nums[i]) {
            // Нашли "next greater" для элемента на вершине
            result[stack.removeLast()] = nums[i]
        }
        stack.addLast(i)
    }
    return result
}
```

```java
public int[] nextGreaterElements(int[] nums) {
    int n = nums.length;
    int[] result = new int[n];
    Arrays.fill(result, -1);
    Deque<Integer> stack = new ArrayDeque<>();

    for (int i = 0; i < n; i++) {
        while (!stack.isEmpty() && nums[stack.peek()] < nums[i]) {
            result[stack.pop()] = nums[i];
        }
        stack.push(i);
    }
    return result;
}
```

```python
def next_greater_elements(nums: list[int]) -> list[int]:
    n = len(nums)
    result = [-1] * n
    stack = []  # stores indices

    for i in range(n):
        while stack and nums[stack[-1]] < nums[i]:
            result[stack.pop()] = nums[i]
        stack.append(i)

    return result
```

---

### Daily Temperatures

**Задача:** Для каждого дня найти, через сколько дней будет теплее.

```
temps = [73, 74, 75, 71, 69, 72, 76, 73]

День 0 (73°): через 1 день будет 74° → answer[0] = 1
День 1 (74°): через 1 день будет 75° → answer[1] = 1
День 2 (75°): через 4 дня будет 76°  → answer[2] = 4
День 3 (71°): через 2 дня будет 72°  → answer[3] = 2
...

Answer: [1, 1, 4, 2, 1, 1, 0, 0]
```

```kotlin
fun dailyTemperatures(temperatures: IntArray): IntArray {
    val n = temperatures.size
    val result = IntArray(n)  // default 0 = никогда не будет теплее
    val stack = ArrayDeque<Int>()

    for (i in 0 until n) {
        while (stack.isNotEmpty() && temperatures[stack.last()] < temperatures[i]) {
            val prevDay = stack.removeLast()
            // ПОЧЕМУ i - prevDay: расстояние в днях
            result[prevDay] = i - prevDay
        }
        stack.addLast(i)
    }
    return result
}
```

```java
public int[] dailyTemperatures(int[] temperatures) {
    int n = temperatures.length;
    int[] result = new int[n];
    Deque<Integer> stack = new ArrayDeque<>();

    for (int i = 0; i < n; i++) {
        while (!stack.isEmpty() && temperatures[stack.peek()] < temperatures[i]) {
            int prevDay = stack.pop();
            result[prevDay] = i - prevDay;
        }
        stack.push(i);
    }
    return result;
}
```

```python
def daily_temperatures(temperatures: list[int]) -> list[int]:
    n = len(temperatures)
    result = [0] * n
    stack = []

    for i in range(n):
        while stack and temperatures[stack[-1]] < temperatures[i]:
            prev_day = stack.pop()
            result[prev_day] = i - prev_day
        stack.append(i)

    return result
```

---

## 10. Типичные ошибки

### Ошибка 1: Pop из пустого Stack

```kotlin
// НЕПРАВИЛЬНО — Stack Underflow!
val stack = ArrayDeque<Int>()
val top = stack.removeLast()  // Exception!

// ПРАВИЛЬНО — проверяем isEmpty()
val stack = ArrayDeque<Int>()
if (stack.isNotEmpty()) {
    val top = stack.removeLast()
}
// Или используем nullable
val top = stack.removeLastOrNull()  // null если пуст
```

### Ошибка 2: O(n) Dequeue в Python/JavaScript

```python
# НЕПРАВИЛЬНО — O(n) из-за сдвига элементов!
queue = [1, 2, 3, 4, 5]
front = queue.pop(0)  # O(n)!

# ПРАВИЛЬНО — O(1)
from collections import deque
queue = deque([1, 2, 3, 4, 5])
front = queue.popleft()  # O(1)!
```

```javascript
// НЕПРАВИЛЬНО — O(n)!
const queue = [1, 2, 3, 4, 5];
const front = queue.shift();  // O(n) — все элементы сдвигаются!

// ПРАВИЛЬНО — используй two-stack queue или custom Deque
```

### Ошибка 3: Путаница Index vs Value в Monotonic Stack

```kotlin
// НЕПРАВИЛЬНО — храним значения, не можем найти позицию
val stack = ArrayDeque<Int>()
for (num in nums) {
    while (stack.isNotEmpty() && stack.last() < num) {
        stack.removeLast()
        // Куда записать результат? Мы не знаем индекс!
    }
    stack.addLast(num)
}

// ПРАВИЛЬНО — храним ИНДЕКСЫ
val stack = ArrayDeque<Int>()  // indices!
for (i in nums.indices) {
    while (stack.isNotEmpty() && nums[stack.last()] < nums[i]) {
        val idx = stack.removeLast()
        result[idx] = nums[i]  // Знаем куда записать!
    }
    stack.addLast(i)
}
```

### Ошибка 4: Забыли Sentinel в Histogram

```kotlin
// НЕПРАВИЛЬНО — не все элементы обработаны
fun largestRectangle(heights: IntArray): Int {
    val stack = ArrayDeque<Int>()
    var maxArea = 0

    for (i in heights.indices) {
        while (stack.isNotEmpty() && heights[stack.last()] > heights[i]) {
            // ...
        }
        stack.addLast(i)
    }
    // Проблема: stack не пуст! Элементы не обработаны!
    return maxArea
}

// ПРАВИЛЬНО — добавляем sentinel (0) в конец
fun largestRectangle(heights: IntArray): Int {
    val stack = ArrayDeque<Int>()
    var maxArea = 0

    for (i in 0..heights.size) {
        val h = if (i == heights.size) 0 else heights[i]  // sentinel!
        while (stack.isNotEmpty() && heights[stack.last()] > h) {
            val height = heights[stack.removeLast()]
            val width = if (stack.isEmpty()) i else i - stack.last() - 1
            maxArea = maxOf(maxArea, height * width)
        }
        stack.addLast(i)
    }
    return maxArea
}
```

---

## 11. Вопросы на понимание (без кода)

### Базовые

1. **Стопка книг:** Вы положили книги A, B, C (в таком порядке). Какую книгу возьмёте первой?

2. **Очередь в банке:** Пришли Аня, Боря, Вася (в таком порядке). Кого обслужат первым?

3. **LIFO vs FIFO:** Вы пользуетесь Undo (Ctrl+Z). Это LIFO или FIFO? Почему?

4. **Deque:** Чем Deque отличается от обычной Queue?

### Средние

5. **Скобки:** Строка `"([)]"`. Правильная ли она? Объясните почему.

6. **Two Stacks Queue:** Почему Queue из двух стеков имеет amortized O(1)?

7. **Circular Queue:** Зачем нужна circular queue? Какую проблему решает?

8. **Min Stack:** Почему нельзя просто хранить минимум в переменной?

### Продвинутые

9. **Monotonic Stack:** Для задачи "Next Greater Element" — почему используем Decreasing Stack, а не Increasing?

10. **Sentinel:** Зачем в задаче Largest Rectangle добавлять 0 в конец массива?

<details>
<summary>Ответы</summary>

1. **C** — последняя положенная, первая взятая (LIFO)

2. **Аня** — первая пришла, первая обслужена (FIFO)

3. **LIFO** — отменяется последнее действие первым

4. **Deque** позволяет добавлять/удалять с ОБОИХ концов, Queue — только добавлять в конец, удалять из начала

5. **Неправильная** — `(` ожидает `)`, но встречает `]`. Скобки должны закрываться в обратном порядке открытия.

6. Каждый элемент перемещается между стеками **максимум 1 раз**. N элементов = N перемещений, распределённых на N операций = O(1) amortized.

7. В linear queue после dequeue освобождённые места **не переиспользуются**. Circular queue "оборачивает" rear к началу, используя память на 100%.

8. При pop минимального элемента — нужно знать **новый минимум**. С переменной — потребуется O(n) поиск. С min stack — O(1).

9. **Decreasing Stack**: когда приходит больший элемент, он "выбивает" все меньшие — для них он и есть Next Greater. Если бы Increasing — большие оставались бы в стеке вечно.

10. **Sentinel 0** гарантирует, что все оставшиеся в стеке элементы будут "вытолкнуты" (у них нет меньшего элемента справа, но мы должны посчитать их площадь).

</details>

---

## 12. Практика (LeetCode)

| # | Задача | Сложность | Pattern |
|---|--------|-----------|---------|
| 20 | Valid Parentheses | Easy | Stack matching |
| 155 | Min Stack | Medium | Auxiliary stack |
| 232 | Implement Queue using Stacks | Easy | Two stacks |
| 225 | Implement Stack using Queues | Easy | Queue rotation |
| 622 | Design Circular Queue | Medium | Circular array |
| 496 | Next Greater Element I | Easy | Monotonic stack |
| 739 | Daily Temperatures | Medium | Monotonic stack |
| 503 | Next Greater Element II | Medium | Circular + monotonic |
| 84 | Largest Rectangle in Histogram | Hard | Monotonic + sentinel |
| 42 | Trapping Rain Water | Hard | Monotonic / Two pointers |
| 239 | Sliding Window Maximum | Hard | Monotonic deque |
| 150 | Evaluate Reverse Polish Notation | Medium | Stack evaluation |

---

## 13. Связи с другими темами

```
prerequisites (изучить до):
├── [[arrays-strings]] — базовые операции с данными
└── [[linked-lists]] — понимание указателей

stacks-queues
│
unlocks (открывает):
├── [[graph-algorithms]] — BFS использует Queue, DFS использует Stack
├── [[dfs-bfs-patterns]] — паттерны обхода
├── [[monotonic-stack-pattern]] — глубже про monotonic
└── [[trees-binary]] — обход деревьев
```

---

## Мифы и заблуждения

| Миф | Реальность |
|-----|-----------|
| "Stack.push в Java современен" | `java.util.Stack` **deprecated**. Используй `ArrayDeque` как stack |
| "Queue и Deque — одно и то же" | Queue — **FIFO only**. Deque — **double-ended**, можно с обоих концов |
| "Monotonic stack = обычный stack" | Monotonic stack поддерживает **инвариант** (возрастающий/убывающий). Другая логика push |
| "Рекурсия = стек" | Рекурсия использует **call stack**. Глубокая рекурсия = stack overflow. Итеративно с explicit stack безопаснее |
| "Circular queue сложен" | Circular queue — **два указателя** head/tail с модулем. Простая реализация |

---

## CS-фундамент

| CS-концепция | Применение в Stacks & Queues |
|--------------|------------------------------|
| **LIFO (Last In First Out)** | Stack: последний добавленный элемент удаляется первым. Undo, expression parsing |
| **FIFO (First In First Out)** | Queue: первый добавленный элемент удаляется первым. BFS, task scheduling |
| **Monotonic Stack** | Stack с инвариантом монотонности. Next Greater Element за O(n) |
| **Deque (Double-ended Queue)** | Операции с обоих концов за O(1). Sliding window maximum |
| **Priority Queue** | Элементы извлекаются по приоритету. Обычно реализуется через Heap |

---

## 14. Источники

- [Tech Interview Handbook - Stack](https://www.techinterviewhandbook.org/algorithms/stack/) — проверено 2025-12-29
- [Tech Interview Handbook - Queue](https://www.techinterviewhandbook.org/algorithms/queue/) — проверено 2025-12-29
- [DEV.to - Monotonic Stack Pattern](https://dev.to/alex_hunter_44f4c9ed6671e/monotonic-stacks-the-pattern-that-makes-next-greater-problems-easy-jd6) — проверено 2025-12-29
- [GeeksforGeeks - Circular Queue](https://www.geeksforgeeks.org/dsa/advantages-of-circular-queue-over-linear-queue/) — проверено 2025-12-29
- [Baeldung - Java Deque vs Stack](https://www.baeldung.com/java-deque-vs-stack) — проверено 2025-12-29

---

*Обновлено: 2026-01-06 — добавлены педагогические секции (интуиция LIFO/FIFO, типичные ошибки, ментальные модели)*

---

[[linked-lists|← Linked Lists]] | [[cs-fundamentals-overview|CS Fundamentals MOC]] | [[trees-binary|Trees →]]
