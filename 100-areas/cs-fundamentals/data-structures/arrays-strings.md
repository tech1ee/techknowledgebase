---
title: "Массивы и строки: фундамент всех алгоритмов"
created: 2025-12-29
modified: 2026-01-06
type: deep-dive
status: published
confidence: high
cs-foundations:
  - contiguous-memory
  - cache-locality
  - pointer-arithmetic
  - random-access
  - immutability
tags:
  - topic/cs-fundamentals
  - type/deep-dive
  - level/beginner
  - interview
related:
  - "[[big-o-complexity]]"
  - "[[problem-solving-framework]]"
  - "[[two-pointers-pattern]]"
  - "[[sliding-window-pattern]]"
---

# Arrays & Strings: фундамент всех алгоритмов

90% задач на coding интервью так или иначе связаны с массивами и строками. Это не просто структуры данных — это язык, на котором формулируются алгоритмические задачи. Mastery of arrays is essential for interviews.

---

## Часть 1: Интуиция без кода — Массивы в реальной жизни

### Аналогия 1: Почтовые ящики в подъезде

Представь подъезд многоквартирного дома. На первом этаже — стена почтовых ящиков:

```
┌──────────────────────────────────────────────────────────────────┐
│                    ПОЧТОВЫЕ ЯЩИКИ ПОДЪЕЗДА                       │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐     │
│    │ кв.1│ │ кв.2│ │ кв.3│ │ кв.4│ │ кв.5│ │ кв.6│ │ кв.7│     │
│    │     │ │     │ │     │ │     │ │     │ │     │ │     │     │
│    │ 📧  │ │     │ │ 📧  │ │ 📧📧│ │     │ │ 📧  │ │     │     │
│    └─────┘ └─────┘ └─────┘ └─────┘ └─────┘ └─────┘ └─────┘     │
│                                                                  │
│    Хочешь положить письмо в кв.4?                                │
│    → Идёшь СРАЗУ к ящику 4                                       │
│    → Не нужно открывать 1, 2, 3                                  │
│    → Время НЕ зависит от количества ящиков                       │
│                                                                  │
│    Это и есть O(1) — ПРЯМОЙ ДОСТУП                               │
└──────────────────────────────────────────────────────────────────┘
```

**Почему это работает так быстро?**

Представь: каждый ящик имеет ширину 20 см. Ящик 1 начинается с позиции 0.
- Ящик 1 → позиция 0 см
- Ящик 2 → позиция 20 см
- Ящик 3 → позиция 40 см
- Ящик 4 → позиция 60 см (0 + 3 × 20)

**Формула:** `позиция_ящика_N = начало + (N-1) × ширина_ящика`

Не нужно идти и считать ящики — можно ВЫЧИСЛИТЬ позицию математически!

### Аналогия 2: Лоток для яиц (2D массивы)

```
┌──────────────────────────────────────────────────────────────────┐
│                       ЛОТОК ДЛЯ ЯИЦ                              │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│         столбец 0   1   2   3   4   5                            │
│              ┌───┬───┬───┬───┬───┬───┐                          │
│    строка 0  │ 🥚│ 🥚│   │ 🥚│ 🥚│ 🥚│                          │
│              ├───┼───┼───┼───┼───┼───┤                          │
│    строка 1  │ 🥚│ 🥚│ 🥚│   │ 🥚│ 🥚│                          │
│              └───┴───┴───┴───┴───┴───┘                          │
│                                                                  │
│    Где яйцо [1][3]?                                              │
│    → строка 1, столбец 3                                         │
│    → там ПУСТО!                                                  │
│                                                                  │
│    Эта аналогия показывает, почему 2D массивы                    │
│    записываются как array[row][col]                              │
│    (сначала КАКАЯ строка, потом КАКОЙ столбец)                   │
└──────────────────────────────────────────────────────────────────┘
```

### Аналогия 3: Строка как бусы на нитке

```
┌──────────────────────────────────────────────────────────────────┐
│                    СТРОКА = БУСЫ НА НИТКЕ                        │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    Слово "KOTLIN":                                               │
│                                                                  │
│        ╭───╮   ╭───╮   ╭───╮   ╭───╮   ╭───╮   ╭───╮            │
│    ━━━━│ K │━━━│ O │━━━│ T │━━━│ L │━━━│ I │━━━│ N │━━━━        │
│        ╰───╯   ╰───╯   ╰───╯   ╰───╯   ╰───╯   ╰───╯            │
│          0       1       2       3       4       5               │
│                                                                  │
│    ОСОБЕННОСТЬ: бусы НЕЛЬЗЯ переделать!                          │
│                                                                  │
│    Хочешь "KOTLIN" → "PYTHON"?                                   │
│    ❌ Нельзя просто поменять буквы на существующих бусах        │
│    ✅ Нужно собрать НОВЫЕ бусы с новыми буквами                 │
│                                                                  │
│    Старые бусы остаются, пока их не выбросят (garbage collector)│
│                                                                  │
│    ЭТО НАЗЫВАЕТСЯ: IMMUTABILITY (неизменяемость)                 │
└──────────────────────────────────────────────────────────────────┘
```

### Аналогия 4: Инвентарь в видеоигре

```
┌──────────────────────────────────────────────────────────────────┐
│                    ИНВЕНТАРЬ В ИГРЕ                              │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    ┌──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┐    │
│    │ ⚔️  │ 🛡️  │ 🧪  │ 🧪  │ 🍎  │ 🗝️  │      │      │    │
│    │меч  │щит   │зелье │зелье │яблоко│ключ  │пусто │пусто │    │
│    └──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┘    │
│    слот: 0      1      2      3      4      5      6      7     │
│                                                                  │
│    Нажал горячую клавишу "3"?                                    │
│    → Игра СРАЗУ берёт предмет из слота 3                         │
│    → Не перебирает все слоты                                     │
│    → Мгновенный доступ!                                          │
│                                                                  │
│    Но если хочешь НАЙТИ ключ (не зная слота)?                    │
│    → Нужно проверить слот 0... нет                               │
│    → Проверить слот 1... нет                                     │
│    → ...                                                         │
│    → Проверить слот 5... НАШЁЛ!                                  │
│    → Это уже O(n) — линейный поиск                               │
└──────────────────────────────────────────────────────────────────┘
```

---

## Часть 2: Почему массивы и строки бывают сложными?

### Исследования: Типичные ошибки студентов

Согласно [исследованию CS1 misconceptions](https://www.researchgate.net/publication/377195037_Incoming_CS1_Students'_Misconceptions_on_Arrays):

> "Students exhibit various misconceptions in syntactic knowledge, conceptual knowledge, and strategic knowledge related to arrays. These difficulties are related to unfamiliarity of syntax, natural language interference, math knowledge, and inaccurate mental models."

**Статистика по исследованиям (2024):**
- 33% студентов проваливают курсы программирования в среднем по миру ([Bennedsen & Caspersen](https://therenegadecoder.com/teach/how-to-teach-arrays-in-computer-science/))
- ~650,000 студентов проваливают курсы программирования ежегодно
- Массивы — одна из САМЫХ проблемных тем для новичков

### Ошибка 1: Путаница между ИНДЕКСОМ и ЗНАЧЕНИЕМ

```
┌──────────────────────────────────────────────────────────────────┐
│            ИНДЕКС vs ЗНАЧЕНИЕ — ГЛАВНАЯ ПУТАНИЦА                 │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    arr = [10, 20, 30, 40, 50]                                    │
│                                                                  │
│    Индекс:    0    1    2    3    4    ← ПОЗИЦИЯ (где лежит)    │
│               │    │    │    │    │                              │
│    Значение: 10   20   30   40   50    ← СОДЕРЖИМОЕ (что лежит)  │
│                                                                  │
│    ❌ ТИПИЧНАЯ ОШИБКА студента:                                  │
│    "Найди элемент 30" → студент пишет arr[30]                    │
│    Но arr[30] — это элемент по ИНДЕКСУ 30, которого нет!         │
│                                                                  │
│    ✅ ПРАВИЛЬНО:                                                 │
│    arr[2] = 30  ← элемент со значением 30 лежит по индексу 2     │
│                                                                  │
│    АНАЛОГИЯ: Квартира №3 и 3 человека в квартире — РАЗНЫЕ вещи!  │
│    - Номер квартиры = ИНДЕКС                                     │
│    - Сколько людей живёт = ЗНАЧЕНИЕ                              │
└──────────────────────────────────────────────────────────────────┘
```

### Ошибка 2: Off-by-One (Ошибка на единицу)

Согласно [исследованию "A Miss is as Good as a Mile"](https://www.researchgate.net/publication/338785924_A_Miss_is_as_Good_as_a_Mile_Off-By-One_Errors_and_Arrays_in_an_Introductory_Programming_Course):

> "Off-by-one errors -- logic errors where loops perform one too few or one too many iterations -- are both common and persist across multiple types of exercises."

```
┌──────────────────────────────────────────────────────────────────┐
│                   OFF-BY-ONE: ПОЧЕМУ ПРОИСХОДИТ?                 │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    В ЖИЗНИ мы считаем с 1:                                       │
│    "Первый элемент, второй элемент, третий..."                   │
│                                                                  │
│    В ПРОГРАММИРОВАНИИ — с 0:                                     │
│    arr[0], arr[1], arr[2]...                                     │
│                                                                  │
│    Массив из 5 элементов:                                        │
│    arr = [A, B, C, D, E]                                         │
│           0  1  2  3  4   ← последний индекс = 4, НЕ 5!          │
│                                                                  │
│    ❌ ТИПИЧНЫЕ ОШИБКИ:                                           │
│                                                                  │
│    1. Выход за границы:                                          │
│       for i in range(5):     # i = 0,1,2,3,4 ← правильно        │
│       for i in range(1, 6):  # i = 1,2,3,4,5 ← arr[5] не сущ!   │
│                                                                  │
│    2. Пропуск первого элемента:                                  │
│       for i in range(1, 5):  # i = 1,2,3,4 ← пропустили arr[0]! │
│                                                                  │
│    3. Неправильные границы:                                      │
│       while i <= len(arr):   # при i=5 → arr[5] ошибка!         │
│       while i < len(arr):    # при i=4 → arr[4] ← правильно     │
│                                                                  │
│    ПРАВИЛО: < len(arr), НЕ <= len(arr)                           │
└──────────────────────────────────────────────────────────────────┘
```

**Почему индексация с нуля?**

```
┌──────────────────────────────────────────────────────────────────┐
│              ПОЧЕМУ ПРОГРАММИСТЫ СЧИТАЮТ С НУЛЯ?                 │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    Это связано с тем, КАК компьютер хранит массив в памяти:      │
│                                                                  │
│    base_address = 0x1000  (начальный адрес массива)              │
│                                                                  │
│    element[i] = base_address + i × element_size                  │
│                                                                  │
│    element[0] = 0x1000 + 0 × 4 = 0x1000  ← первый элемент        │
│    element[1] = 0x1000 + 1 × 4 = 0x1004                          │
│    element[2] = 0x1000 + 2 × 4 = 0x1008                          │
│                                                                  │
│    Если бы индексация была с 1:                                  │
│    element[i] = base_address + (i - 1) × element_size            │
│                               ^^^^^^^^                           │
│                               лишняя операция!                   │
│                                                                  │
│    Индексация с 0 = меньше вычислений = быстрее                  │
│    (это решение Дейкстры, 1982 год)                              │
└──────────────────────────────────────────────────────────────────┘
```

### Ошибка 3: Непонимание неизменяемости строк

Согласно [MIT Reading on Immutability](https://web.mit.edu/6.005/www/fa16/classes/09-immutability/):

> "Make sure you understand the difference between an immutable object (like a String) and an immutable reference (like a final variable)."

```
┌──────────────────────────────────────────────────────────────────┐
│            СТРОКИ НЕИЗМЕНЯЕМЫ — ЧТО ЭТО ЗНАЧИТ?                  │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    ❌ ТИПИЧНОЕ ЗАБЛУЖДЕНИЕ:                                      │
│    "Я же могу написать s = s + 'x', значит строка изменяется!"   │
│                                                                  │
│    ✅ РЕАЛЬНОСТЬ:                                                │
│    Ты НЕ изменяешь строку — ты создаёшь НОВУЮ строку             │
│    и присваиваешь её той же переменной.                          │
│                                                                  │
│    ВИЗУАЛИЗАЦИЯ:                                                 │
│                                                                  │
│    s = "hello"                                                   │
│         ┌─────────┐                                              │
│    s ──►│ "hello" │  ← объект строки в памяти                    │
│         └─────────┘                                              │
│                                                                  │
│    s = s + " world"                                              │
│         ┌─────────┐                                              │
│         │ "hello" │  ← старый объект (будет удалён GC)           │
│         └─────────┘                                              │
│         ┌───────────────┐                                        │
│    s ──►│ "hello world" │  ← НОВЫЙ объект!                       │
│         └───────────────┘                                        │
│                                                                  │
│    Переменная s — это СТРЕЛКА (ссылка).                          │
│    Стрелку можно перенаправить.                                  │
│    Но сам объект "hello" изменить НЕЛЬЗЯ.                        │
└──────────────────────────────────────────────────────────────────┘
```

### Ошибка 4: Конкатенация в цикле = O(n²)

```
┌──────────────────────────────────────────────────────────────────┐
│              СКРЫТАЯ ПРОБЛЕМА ПРОИЗВОДИТЕЛЬНОСТИ                 │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    ❌ ПЛОХО (но выглядит нормально):                             │
│                                                                  │
│    result = ""                                                   │
│    for char in "abcde":                                          │
│        result = result + char                                    │
│                                                                  │
│    Что РЕАЛЬНО происходит:                                       │
│                                                                  │
│    Итерация 1: "" + "a" → создать "a" (копировать 1 символ)      │
│    Итерация 2: "a" + "b" → создать "ab" (копировать 2 символа)   │
│    Итерация 3: "ab" + "c" → создать "abc" (копировать 3 символа) │
│    Итерация 4: "abc" + "d" → создать "abcd" (4 символа)          │
│    Итерация 5: "abcd" + "e" → создать "abcde" (5 символов)       │
│                                                                  │
│    Всего копирований: 1 + 2 + 3 + 4 + 5 = 15                     │
│    Для n символов: 1 + 2 + ... + n = n(n+1)/2 = O(n²)            │
│                                                                  │
│    ✅ РЕШЕНИЕ: StringBuilder / join                              │
│                                                                  │
│    StringBuilder хранит массив символов,                         │
│    который растёт по мере необходимости.                         │
│    Добавление — O(1) амортизированно.                            │
│    Итого: O(n) вместо O(n²)!                                     │
└──────────────────────────────────────────────────────────────────┘
```

### Ошибка 5: Непонимание разницы между Array и List

```
┌──────────────────────────────────────────────────────────────────┐
│                  ARRAY vs LIST — В ЧЁМ РАЗНИЦА?                  │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    ARRAY (массив):                                               │
│    ┌───┬───┬───┬───┬───┐                                        │
│    │ 1 │ 2 │ 3 │ 4 │ 5 │  ← непрерывная память                  │
│    └───┴───┴───┴───┴───┘                                        │
│    • Фиксированный размер (или resize)                           │
│    • Элементы подряд в памяти                                    │
│    • O(1) доступ по индексу                                      │
│    • O(n) вставка в середину                                     │
│                                                                  │
│    LINKED LIST (связный список):                                 │
│    ┌───┐    ┌───┐    ┌───┐    ┌───┐    ┌───┐                   │
│    │ 1 │───►│ 2 │───►│ 3 │───►│ 4 │───►│ 5 │                   │
│    └───┘    └───┘    └───┘    └───┘    └───┘                   │
│      ↑                                                           │
│    head     элементы разбросаны по памяти                        │
│    • Динамический размер                                         │
│    • Элементы где угодно в памяти                                │
│    • O(n) доступ по индексу (нужно пройти цепочку)               │
│    • O(1) вставка (если есть ссылка на узел)                     │
│                                                                  │
│    ❌ ТИПИЧНАЯ ПУТАНИЦА:                                         │
│    Python list — это НЕ linked list!                             │
│    Python list = dynamic array (как ArrayList в Java)            │
└──────────────────────────────────────────────────────────────────┘
```

---

## Часть 3: Ментальные модели для массивов и строк

### Модель 1: "Шкаф с пронумерованными полками"

```
┌──────────────────────────────────────────────────────────────────┐
│              МОДЕЛЬ: ШКАФ С ПОЛКАМИ                              │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    Массив = шкаф, где:                                           │
│    • Каждая полка имеет НОМЕР (индекс)                           │
│    • На каждой полке лежит ОДНА вещь (значение)                  │
│    • Все полки ОДИНАКОВОГО размера (один тип данных)             │
│    • Полки идут ПОДРЯД (непрерывная память)                      │
│                                                                  │
│         ┌─────────────────────────────────────────┐              │
│    [0]  │  📚 книга "Война и мир"                 │              │
│         ├─────────────────────────────────────────┤              │
│    [1]  │  📚 книга "1984"                        │              │
│         ├─────────────────────────────────────────┤              │
│    [2]  │  📚 книга "Мастер и Маргарита"          │              │
│         ├─────────────────────────────────────────┤              │
│    [3]  │  📚 (пусто — зарезервировано)           │              │
│         └─────────────────────────────────────────┘              │
│                                                                  │
│    ОПЕРАЦИИ:                                                     │
│    • Взять книгу с полки 2 → O(1), сразу идём к полке            │
│    • Найти "1984" не зная полки → O(n), смотрим все полки        │
│    • Вставить книгу между 0 и 1 → O(n), сдвигаем все вниз        │
│                                                                  │
│    КОГДА ИСПОЛЬЗОВАТЬ ЭТУ МОДЕЛЬ:                                │
│    Когда думаешь о доступе по индексу и понимании сложности      │
└──────────────────────────────────────────────────────────────────┘
```

### Модель 2: "Адреса в памяти" (для понимания O(1))

```
┌──────────────────────────────────────────────────────────────────┐
│              МОДЕЛЬ: ПАМЯТЬ КАК УЛИЦА С ДОМАМИ                   │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    Представь улицу, где дома идут подряд с равными интервалами:  │
│                                                                  │
│    Адрес 100   104   108   112   116   120                       │
│         ┌───┐ ┌───┐ ┌───┐ ┌───┐ ┌───┐ ┌───┐                     │
│         │ A │ │ B │ │ C │ │ D │ │ E │ │ F │                     │
│         └───┘ └───┘ └───┘ └───┘ └───┘ └───┘                     │
│          [0]   [1]   [2]   [3]   [4]   [5]                       │
│                                                                  │
│    Каждый дом занимает 4 метра (4 байта для int).                │
│    Первый дом на адресе 100 (base address).                      │
│                                                                  │
│    Где дом [3]?                                                  │
│    адрес = 100 + 3 × 4 = 112                                     │
│                                                                  │
│    ВАЖНО: Не нужно идти мимо домов 0, 1, 2!                      │
│    Можно ВЫЧИСЛИТЬ адрес и телепортироваться туда.               │
│    Это математическая операция — мгновенно!                      │
│                                                                  │
│    КОГДА ИСПОЛЬЗОВАТЬ ЭТУ МОДЕЛЬ:                                │
│    Когда нужно понять ПОЧЕМУ доступ O(1)                         │
│    и почему элементы должны быть одного размера                  │
└──────────────────────────────────────────────────────────────────┘
```

### Модель 3: "Поезд с вагонами" (для понимания операций)

```
┌──────────────────────────────────────────────────────────────────┐
│              МОДЕЛЬ: ПОЕЗД С ВАГОНАМИ                            │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    Массив = поезд, где вагоны сцеплены:                          │
│                                                                  │
│    ┌─────┬─────┬─────┬─────┬─────┐                              │
│    │ 🚃 ─┼─ 🚃 ─┼─ 🚃 ─┼─ 🚃 ─┼─ 🚃 │                            │
│    │  A  │  B  │  C  │  D  │  E  │                              │
│    └─────┴─────┴─────┴─────┴─────┘                              │
│                                                                  │
│    ДОСТУП: Можно залезть в любой вагон по номеру                │
│            (вертолётом сверху) — O(1)                            │
│                                                                  │
│    ВСТАВКА В СЕРЕДИНУ:                                           │
│    Хочешь добавить вагон между B и C?                            │
│                                                                  │
│    1. Расцепить C, D, E                                          │
│    2. Оттянуть их назад                                          │
│    3. Вставить новый вагон                                       │
│    4. Сцепить обратно                                            │
│                                                                  │
│    ┌─────┬─────┬─────┬─────┬─────┬─────┐                        │
│    │ 🚃 ─┼─ 🚃 ─┼─ 🚃 ─┼─ 🚃 ─┼─ 🚃 ─┼─ 🚃 │                      │
│    │  A  │  B  │ NEW │  C  │  D  │  E  │                        │
│    └─────┴─────┴─────┴─────┴─────┴─────┘                        │
│                                                                  │
│    Сдвинули 3 вагона — это O(n)!                                 │
│                                                                  │
│    КОГДА ИСПОЛЬЗОВАТЬ ЭТУ МОДЕЛЬ:                                │
│    Когда думаешь о вставке/удалении и почему это дорого          │
└──────────────────────────────────────────────────────────────────┘
```

### Модель 4: "Два указателя как два пальца"

```
┌──────────────────────────────────────────────────────────────────┐
│          МОДЕЛЬ: ДВА ПАЛЬЦА НА ЛИНЕЙКЕ                           │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    Представь: ты держишь линейку двумя пальцами                  │
│                                                                  │
│         L                               R                        │
│         ↓                               ↓                        │
│    ┌────┬────┬────┬────┬────┬────┬────┬────┐                    │
│    │ 1  │ 2  │ 3  │ 4  │ 5  │ 6  │ 7  │ 8  │                    │
│    └────┴────┴────┴────┴────┴────┴────┴────┘                    │
│    👆                                    👆                       │
│    левый палец                   правый палец                    │
│                                                                  │
│    ВАРИАНТЫ ДВИЖЕНИЯ:                                            │
│                                                                  │
│    1. СЖИМАЮЩИЕСЯ (opposite direction):                          │
│       Пальцы идут навстречу друг другу                           │
│       Пример: проверка палиндрома, two sum в sorted array        │
│                                                                  │
│    2. ПАРАЛЛЕЛЬНЫЕ (same direction):                             │
│       Оба пальца идут в одну сторону                             │
│       Один быстрый, один медленный                               │
│       Пример: удаление дубликатов, sliding window                │
│                                                                  │
│    КОГДА ИСПОЛЬЗОВАТЬ ЭТУ МОДЕЛЬ:                                │
│    При решении задач с two pointers                              │
│    Физически представь руки на массиве!                          │
└──────────────────────────────────────────────────────────────────┘
```

### Модель 5: "Окно в поезде" (Sliding Window)

```
┌──────────────────────────────────────────────────────────────────┐
│              МОДЕЛЬ: ОКНО В ПОЕЗДЕ                               │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    Представь: ты едешь в поезде и смотришь в окно                │
│    Окно показывает только часть пейзажа                          │
│                                                                  │
│    Пейзаж (массив): 🏠 🌲 🏢 🌲 🏠 🌲 🌲 🏢 🏠                      │
│                                                                  │
│    Окно (ширина 3):                                              │
│         ┌─────────────┐                                          │
│    🏠 🌲 │ 🏢 🌲 🏠 │ 🌲 🌲 🏢 🏠                                  │
│         └─────────────┘                                          │
│         видишь: 🏢 🌲 🏠                                          │
│                                                                  │
│    Поезд едет (окно сдвигается):                                 │
│              ┌─────────────┐                                     │
│    🏠 🌲 🏢 │ 🌲 🏠 🌲 │ 🌲 🏢 🏠                                  │
│              └─────────────┘                                     │
│              видишь: 🌲 🏠 🌲                                     │
│                                                                  │
│    ЧТО ПРОИСХОДИТ ПРИ СДВИГЕ:                                    │
│    - ВЫХОДИТ из окна: 🏢 (левый край)                            │
│    - ВХОДИТ в окно: 🌲 (правый край)                             │
│    - Не нужно пересматривать всё окно!                           │
│                                                                  │
│    Это O(1) на каждый сдвиг, O(n) на весь массив                 │
│                                                                  │
│    КОГДА ИСПОЛЬЗОВАТЬ ЭТУ МОДЕЛЬ:                                │
│    Задачи типа "найди максимум/сумму подмассива размера k"       │
└──────────────────────────────────────────────────────────────────┘
```

### Сравнение моделей: когда какую использовать

| Модель | Когда использовать | Что объясняет |
|--------|-------------------|---------------|
| **Шкаф с полками** | Базовое понимание | Индекс vs значение, хранение |
| **Адреса в памяти** | Глубокое понимание O(1) | Почему доступ мгновенный |
| **Поезд с вагонами** | Анализ операций | Почему вставка O(n) |
| **Два пальца** | Two pointers задачи | Визуализация указателей |
| **Окно в поезде** | Sliding window задачи | Инкрементальные вычисления |

---

## Prerequisites (Что нужно знать перед изучением)

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| Big O notation | Понять сложность операций | [[big-o-complexity]] |
| Базовый синтаксис (циклы, условия) | Читать примеры кода | Любой курс по языку |
| **CS: Адресация памяти** | Понять почему доступ O(1) | Основы компьютерной архитектуры |

---

## УРОВЕНЬ 1: Объяснение для бабушки (без кода)

### Что такое массив простыми словами

**Массив — это шкаф с пронумерованными ящиками.**

```
Представь шкаф с 10 одинаковыми ящиками:

┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│  0  │  1  │  2  │  3  │  4  │  5  │  6  │  7  │  8  │  9  │  ← номера ящиков
├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
│носки│майки│джинс│шарф │ ... │     │     │     │     │     │  ← содержимое
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘

Хочешь достать шарф?
→ Знаешь, что шарф в ящике #3
→ Идёшь сразу к ящику #3
→ Достаёшь шарф

Время НЕ зависит от количества ящиков.
100 ящиков или 1000 — ты идёшь сразу к нужному.
Это O(1) — константное время!
```

### Почему поиск O(n)?

```
А теперь представь: ты ЗАБЫЛ, в каком ящике шарф.

┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│носки│майки│джинс│  ?  │  ?  │  ?  │  ?  │  ?  │  ?  │  ?  │
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
  ↑
  Открываешь ящик 0... не шарф
       ↑
       Открываешь ящик 1... не шарф
            ↑
            Открываешь ящик 2... не шарф
                 ↑
                 Открываешь ящик 3... НАШЁЛ!

В худшем случае: шарф в последнем ящике
→ Откроешь ВСЕ ящики
→ n ящиков = n проверок
→ Это O(n) — линейное время!
```

### Почему вставка медленная?

```
Хочешь добавить новый ящик посередине?
Все ящики справа нужно СДВИНУТЬ!

ДО:
┌─────┬─────┬─────┬─────┬─────┐
│  A  │  B  │  C  │  D  │  E  │
└─────┴─────┴─────┴─────┴─────┘
            ↑
      хочу вставить X сюда

ПРОЦЕСС:
1. Сдвинуть E → (новая позиция)
2. Сдвинуть D → (место E)
3. Сдвинуть C → (место D)
4. Теперь есть место для X!

ПОСЛЕ:
┌─────┬─────┬─────┬─────┬─────┬─────┐
│  A  │  B  │  X  │  C  │  D  │  E  │
└─────┴─────┴─────┴─────┴─────┴─────┘

Сдвинули 3 элемента.
В худшем случае (вставка в начало): n сдвигов.
Это O(n)!
```

### Что такое строка простыми словами

**Строка — это бусы из букв.**

```
Слово "ПРИВЕТ" — это бусы с 6 бусинами:

  ┌───┬───┬───┬───┬───┬───┐
  │ П │ Р │ И │ В │ Е │ Т │
  └───┴───┴───┴───┴───┴───┘
    0   1   2   3   4   5

Каждая буква — отдельная бусина.
Бусины нанизаны по порядку.

ОСОБЕННОСТЬ: бусы нельзя переделать!
Хочешь изменить букву? Нужно делать НОВЫЕ бусы.

Это называется "immutability" — неизменяемость.
```

### Почему строки неизменяемы?

```
Представь: строка "КОТ"
Хочешь изменить на "КИТ"?

❌ НЕ МОЖЕШЬ просто поменять букву:
  "КОТ" — эти бусы уже готовы, склеены

✅ МОЖЕШЬ создать новые бусы:
  "КОТ" → создать "КИТ" (новые бусы)

Старые "КОТ" остаются в памяти,
пока сборщик мусора их не уберёт.

ПРОБЛЕМА: если делаешь много изменений,
создаёшь много "мусорных" бус!
```

### Аналогия: Поезд vs Вагоны

```
МАССИВ = ПОЕЗД
┌───┬───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │ 5 │  ← вагоны идут подряд
└───┴───┴───┴───┴───┘

✓ Быстро найти вагон по номеру (O(1))
✗ Сложно вставить вагон посередине (O(n))
✗ Размер фиксирован


ДИНАМИЧЕСКИЙ МАССИВ = ПОЕЗД С ЗАПАСНЫМИ ВАГОНАМИ
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │ 5 │   │   │   │  ← есть пустые места
└───┴───┴───┴───┴───┴───┴───┴───┘

✓ Можно добавлять в конец быстро (O(1))
✓ Когда места нет — удваиваем состав
✗ Иногда нужно "пересаживать" всех (resize)
```

---

## Терминология

| Термин | Определение |
|--------|-------------|
| **Array** | Коллекция элементов одного типа в contiguous memory |
| **String** | Последовательность символов (обычно immutable) |
| **Index** | Позиция элемента в массиве (начиная с 0) |
| **Contiguous** | Элементы расположены подряд в памяти |
| **Dynamic Array** | Массив с автоматическим увеличением размера |
| **Subarray** | Непрерывная часть массива |
| **Substring** | Непрерывная часть строки |
| **In-place** | Модификация без дополнительной памяти O(1) |
| **Immutable** | Объект нельзя изменить после создания |

---

## Array: как работает под капотом

### Memory Layout

```
ARRAY В ПАМЯТИ:

arr = [10, 20, 30, 40, 50]

Address:    0x1000  0x1004  0x1008  0x100C  0x1010
            ┌───────┬───────┬───────┬───────┬───────┐
Value:      │  10   │  20   │  30   │  40   │  50   │
            └───────┴───────┴───────┴───────┴───────┘
Index:         0       1       2       3       4

Доступ к arr[3]:
  address = base_address + index × element_size
  address = 0x1000 + 3 × 4 = 0x100C
  → O(1) доступ!
```

### Static vs Dynamic Arrays

```
STATIC ARRAY (fixed size):
┌───┬───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │ 5 │  size = 5, нельзя добавить
└───┴───┴───┴───┴───┘

DYNAMIC ARRAY (grows automatically):

Шаг 1: size=4, capacity=4
┌───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │
└───┴───┴───┴───┘

Шаг 2: add(5) → capacity exceeded → DOUBLE capacity
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │ 5 │   │   │   │  capacity = 8
└───┴───┴───┴───┴───┴───┴───┴───┘

Amortized O(1) для добавления!
```

### Time Complexity

| Operation | Static | Dynamic | Notes |
|-----------|--------|---------|-------|
| Access `arr[i]` | O(1) | O(1) | Direct memory access |
| Search | O(n) | O(n) | Linear scan |
| Search (sorted) | O(log n) | O(log n) | Binary search |
| Insert at end | N/A | O(1)* | Amortized |
| Insert at middle | O(n) | O(n) | Shift elements |
| Delete at end | N/A | O(1) | No shift |
| Delete at middle | O(n) | O(n) | Shift elements |

---

## String: особенности работы

### Immutability

```
IMMUTABLE STRING:

s = "hello"
s = s + " world"  // Создаётся НОВАЯ строка!

Memory:
  "hello"        → остаётся в памяти (garbage collected)
  "hello world"  → новый объект

ПРОБЛЕМА: Конкатенация в цикле = O(n²)

for i in range(n):
    s = s + char  # Каждая итерация создаёт новую строку!

Итого: 1 + 2 + 3 + ... + n = O(n²)
```

### StringBuilder решение

**Kotlin:**

```kotlin
// ПЛОХО: O(n²)
var result = ""
for (char in chars) {
    result += char
}

// ХОРОШО: O(n)
val sb = StringBuilder()
for (char in chars) {
    sb.append(char)
}
val result = sb.toString()

// ЛУЧШЕ: Kotlin idiom
val result = chars.joinToString("")
```

**Java:**

```java
// ПЛОХО: O(n²)
String result = "";
for (char c : chars) {
    result += c;
}

// ХОРОШО: O(n)
StringBuilder sb = new StringBuilder();
for (char c : chars) {
    sb.append(c);
}
String result = sb.toString();
```

**Python:**

```python
# ПЛОХО: O(n²)
result = ""
for char in chars:
    result += char

# ХОРОШО: O(n)
result = "".join(chars)

# ИЛИ: list accumulator
parts = []
for char in chars:
    parts.append(char)
result = "".join(parts)
```

### String Pool (Java/Kotlin)

```
STRING POOL:

String s1 = "hello";  // создаётся в pool
String s2 = "hello";  // берётся из pool

s1 == s2  // true (same object)

String s3 = new String("hello");  // новый объект в heap
s1 == s3  // false (different objects)
s1.equals(s3)  // true (same content)
```

---

## Two Pointers Technique

### Pattern 1: Opposite Direction

```
СХОДЯЩИЕСЯ УКАЗАТЕЛИ:

Задача: Проверить palindrome

  l                   r
  ↓                   ↓
  r   a   c   e   c   a   r
  ↓                   ↓
  ✓ match             ✓

      l           r
      ↓           ↓
  r   a   c   e   c   a   r
      ↓           ↓
      ✓ match     ✓

          l   r
          ↓   ↓
  r   a   c   e   c   a   r
          ↓   ↓
          ✓ match

              l
              r
          → PALINDROME!
```

**Kotlin:**

```kotlin
fun isPalindrome(s: String): Boolean {
    var left = 0
    var right = s.length - 1

    while (left < right) {
        if (s[left] != s[right]) return false
        left++
        right--
    }
    return true
}
```

**Java:**

```java
public boolean isPalindrome(String s) {
    int left = 0;
    int right = s.length() - 1;

    while (left < right) {
        if (s.charAt(left) != s.charAt(right)) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}
```

**Python:**

```python
def is_palindrome(s: str) -> bool:
    left, right = 0, len(s) - 1

    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1

    return True
```

### Pattern 2: Same Direction (Slow/Fast)

```
МЕДЛЕННЫЙ И БЫСТРЫЙ УКАЗАТЕЛИ:

Задача: Remove duplicates from sorted array

slow
fast
 ↓
[1, 1, 2, 2, 3, 4, 4]

slow    fast
 ↓       ↓
[1, 1, 2, 2, 3, 4, 4]
 ↑
 arr[fast] != arr[slow], swap

   slow    fast
    ↓       ↓
[1, 2, 2, 2, 3, 4, 4]
         ↑
    arr[fast] = 2 = arr[slow], skip

   slow       fast
    ↓          ↓
[1, 2, 2, 2, 3, 4, 4]
            ↑
    arr[fast] = 3 != arr[slow], swap

      slow       fast
       ↓          ↓
[1, 2, 3, 2, 3, 4, 4]
               ...

Результат: [1, 2, 3, 4, _, _, _]
           ↑──────────↑
           unique elements
```

**Kotlin:**

```kotlin
fun removeDuplicates(nums: IntArray): Int {
    if (nums.isEmpty()) return 0

    var slow = 0

    for (fast in 1 until nums.size) {
        if (nums[fast] != nums[slow]) {
            slow++
            nums[slow] = nums[fast]
        }
    }

    return slow + 1
}
```

**Java:**

```java
public int removeDuplicates(int[] nums) {
    if (nums.length == 0) return 0;

    int slow = 0;

    for (int fast = 1; fast < nums.length; fast++) {
        if (nums[fast] != nums[slow]) {
            slow++;
            nums[slow] = nums[fast];
        }
    }

    return slow + 1;
}
```

**Python:**

```python
def remove_duplicates(nums: list[int]) -> int:
    if not nums:
        return 0

    slow = 0

    for fast in range(1, len(nums)):
        if nums[fast] != nums[slow]:
            slow += 1
            nums[slow] = nums[fast]

    return slow + 1
```

### Pattern 3: Two Arrays

```
СЛИЯНИЕ SORTED ARRAYS:

arr1 = [1, 3, 5]
         ↑ i

arr2 = [2, 4, 6]
         ↑ j

Compare arr1[i] vs arr2[j]:
  1 < 2 → add 1, i++

arr1 = [1, 3, 5]
            ↑ i

arr2 = [2, 4, 6]
         ↑ j

Compare: 3 > 2 → add 2, j++

...

Result: [1, 2, 3, 4, 5, 6]
```

**Kotlin:**

```kotlin
fun merge(nums1: IntArray, m: Int, nums2: IntArray, n: Int) {
    var i = m - 1
    var j = n - 1
    var k = m + n - 1

    while (j >= 0) {
        if (i >= 0 && nums1[i] > nums2[j]) {
            nums1[k--] = nums1[i--]
        } else {
            nums1[k--] = nums2[j--]
        }
    }
}
```

---

## Sliding Window Technique

### Fixed Size Window

```
FIXED WINDOW: Max sum of k elements

arr = [1, 4, 2, 10, 2, 3, 1, 0, 20]
k = 4

Step 1: Calculate initial window sum
[1, 4, 2, 10] = 17
 └────────┘

Step 2: Slide window
   [4, 2, 10, 2] = 18  (remove 1, add 2)
    └────────┘

Step 3: Continue sliding
      [2, 10, 2, 3] = 17
       └────────┘

...

Max sum = 24 (window [10, 2, 3, 1, 0, 20] — wait, k=4!)
Actually: [3, 1, 0, 20] = 24
```

**Kotlin:**

```kotlin
fun maxSumSubarray(arr: IntArray, k: Int): Int {
    if (arr.size < k) return -1

    // Initial window sum
    var windowSum = arr.take(k).sum()
    var maxSum = windowSum

    // Slide the window
    for (i in k until arr.size) {
        windowSum += arr[i] - arr[i - k]
        maxSum = maxOf(maxSum, windowSum)
    }

    return maxSum
}
```

### Variable Size Window

```
VARIABLE WINDOW: Minimum subarray with sum >= target

arr = [2, 3, 1, 2, 4, 3]
target = 7

[2] = 2 < 7 → expand
[2, 3] = 5 < 7 → expand
[2, 3, 1] = 6 < 7 → expand
[2, 3, 1, 2] = 8 >= 7 → found! length=4, try to shrink
   [3, 1, 2] = 6 < 7 → need to expand
   [3, 1, 2, 4] = 10 >= 7 → found! length=4, shrink
      [1, 2, 4] = 7 >= 7 → found! length=3, shrink
         [2, 4] = 6 < 7 → expand
         [2, 4, 3] = 9 >= 7 → found! length=3, shrink
            [4, 3] = 7 >= 7 → found! length=2 ← ANSWER!
```

**Kotlin:**

```kotlin
fun minSubArrayLen(target: Int, nums: IntArray): Int {
    var left = 0
    var sum = 0
    var minLength = Int.MAX_VALUE

    for (right in nums.indices) {
        sum += nums[right]

        while (sum >= target) {
            minLength = minOf(minLength, right - left + 1)
            sum -= nums[left]
            left++
        }
    }

    return if (minLength == Int.MAX_VALUE) 0 else minLength
}
```

**Java:**

```java
public int minSubArrayLen(int target, int[] nums) {
    int left = 0;
    int sum = 0;
    int minLength = Integer.MAX_VALUE;

    for (int right = 0; right < nums.length; right++) {
        sum += nums[right];

        while (sum >= target) {
            minLength = Math.min(minLength, right - left + 1);
            sum -= nums[left];
            left++;
        }
    }

    return minLength == Integer.MAX_VALUE ? 0 : minLength;
}
```

**Python:**

```python
def min_sub_array_len(target: int, nums: list[int]) -> int:
    left = 0
    total = 0
    min_length = float('inf')

    for right in range(len(nums)):
        total += nums[right]

        while total >= target:
            min_length = min(min_length, right - left + 1)
            total -= nums[left]
            left += 1

    return 0 if min_length == float('inf') else min_length
```

### Sliding Window Template

```
УНИВЕРСАЛЬНЫЙ ШАБЛОН:

def sliding_window(s):
    window = {}  # или set, counter
    left = 0
    result = 0

    for right in range(len(s)):
        # 1. Expand: add s[right] to window
        window[s[right]] = window.get(s[right], 0) + 1

        # 2. Contract: while window is invalid
        while window_is_invalid():
            window[s[left]] -= 1
            if window[s[left]] == 0:
                del window[s[left]]
            left += 1

        # 3. Update result
        result = max(result, right - left + 1)

    return result
```

---

## In-Place Algorithms

### Swap Elements

```kotlin
// XOR swap (classic, but use temp for clarity)
fun swap(arr: IntArray, i: Int, j: Int) {
    val temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

// Kotlin also syntax
arr[i] = arr[j].also { arr[j] = arr[i] }
```

### Reverse Array

**Kotlin:**

```kotlin
fun reverse(arr: IntArray) {
    var left = 0
    var right = arr.size - 1

    while (left < right) {
        val temp = arr[left]
        arr[left] = arr[right]
        arr[right] = temp
        left++
        right--
    }
}
```

### Rotate Array

```
ROTATE RIGHT by k:

[1, 2, 3, 4, 5, 6, 7], k = 3

Step 1: Reverse all
[7, 6, 5, 4, 3, 2, 1]

Step 2: Reverse first k
[5, 6, 7, 4, 3, 2, 1]

Step 3: Reverse rest
[5, 6, 7, 1, 2, 3, 4] ← RESULT
```

**Kotlin:**

```kotlin
fun rotate(nums: IntArray, k: Int) {
    val n = nums.size
    val shift = k % n

    fun reverse(start: Int, end: Int) {
        var l = start
        var r = end
        while (l < r) {
            val temp = nums[l]
            nums[l] = nums[r]
            nums[r] = temp
            l++
            r--
        }
    }

    reverse(0, n - 1)
    reverse(0, shift - 1)
    reverse(shift, n - 1)
}
```

### Dutch National Flag (3-way partition)

```
DUTCH NATIONAL FLAG: Sort 0s, 1s, 2s

[2, 0, 2, 1, 1, 0]

low = 0, mid = 0, high = 5

mid=0: arr[0]=2 → swap with high, high--
[0, 0, 2, 1, 1, 2], low=0, mid=0, high=4

mid=0: arr[0]=0 → low++, mid++
[0, 0, 2, 1, 1, 2], low=1, mid=1, high=4

mid=1: arr[1]=0 → low++, mid++
[0, 0, 2, 1, 1, 2], low=2, mid=2, high=4

mid=2: arr[2]=2 → swap with high, high--
[0, 0, 1, 1, 2, 2], low=2, mid=2, high=3

mid=2: arr[2]=1 → mid++
[0, 0, 1, 1, 2, 2], low=2, mid=3, high=3

mid=3: arr[3]=1 → mid++
[0, 0, 1, 1, 2, 2] ← SORTED!
```

**Kotlin:**

```kotlin
fun sortColors(nums: IntArray) {
    var low = 0
    var mid = 0
    var high = nums.size - 1

    while (mid <= high) {
        when (nums[mid]) {
            0 -> {
                swap(nums, low, mid)
                low++
                mid++
            }
            1 -> {
                mid++
            }
            2 -> {
                swap(nums, mid, high)
                high--
            }
        }
    }
}

fun swap(arr: IntArray, i: Int, j: Int) {
    val temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}
```

---

## Prefix Sum Technique

### Concept

```
ARRAY:      [1, 2, 3, 4, 5]
PREFIX SUM: [1, 3, 6, 10, 15]
             ↑  ↑  ↑   ↑   ↑
             1  1+2 1+2+3 ...

Sum of subarray [i, j] = prefix[j] - prefix[i-1]

Example: sum of [1, 3] (indices)
         = prefix[3] - prefix[0]
         = 10 - 1 = 9
         = 2 + 3 + 4 = 9 ✓
```

**Kotlin:**

```kotlin
fun buildPrefixSum(nums: IntArray): IntArray {
    val prefix = IntArray(nums.size)
    prefix[0] = nums[0]

    for (i in 1 until nums.size) {
        prefix[i] = prefix[i - 1] + nums[i]
    }

    return prefix
}

fun rangeSum(prefix: IntArray, i: Int, j: Int): Int {
    return if (i == 0) prefix[j] else prefix[j] - prefix[i - 1]
}
```

### Application: Subarray Sum Equals K

**Kotlin:**

```kotlin
fun subarraySum(nums: IntArray, k: Int): Int {
    val prefixCount = mutableMapOf(0 to 1)
    var sum = 0
    var count = 0

    for (num in nums) {
        sum += num
        count += prefixCount.getOrDefault(sum - k, 0)
        prefixCount[sum] = prefixCount.getOrDefault(sum, 0) + 1
    }

    return count
}
```

---

## String Pattern Matching

### Naive Algorithm

```kotlin
// O(n × m) time
fun naiveSearch(text: String, pattern: String): Int {
    val n = text.length
    val m = pattern.length

    for (i in 0..n - m) {
        var j = 0
        while (j < m && text[i + j] == pattern[j]) {
            j++
        }
        if (j == m) return i
    }

    return -1
}
```

### KMP Algorithm (O(n + m))

```kotlin
fun kmpSearch(text: String, pattern: String): Int {
    val lps = buildLPS(pattern)
    var i = 0  // text index
    var j = 0  // pattern index

    while (i < text.length) {
        if (text[i] == pattern[j]) {
            i++
            j++
            if (j == pattern.length) {
                return i - j  // Found
            }
        } else if (j > 0) {
            j = lps[j - 1]
        } else {
            i++
        }
    }

    return -1
}

fun buildLPS(pattern: String): IntArray {
    val lps = IntArray(pattern.length)
    var length = 0
    var i = 1

    while (i < pattern.length) {
        if (pattern[i] == pattern[length]) {
            length++
            lps[i] = length
            i++
        } else if (length > 0) {
            length = lps[length - 1]
        } else {
            lps[i] = 0
            i++
        }
    }

    return lps
}
```

---

## Anagram Detection

### Using Sorting

```kotlin
// O(n log n)
fun isAnagram(s: String, t: String): Boolean {
    return s.toCharArray().sorted() == t.toCharArray().sorted()
}
```

### Using Frequency Count

```kotlin
// O(n)
fun isAnagram(s: String, t: String): Boolean {
    if (s.length != t.length) return false

    val count = IntArray(26)

    for (i in s.indices) {
        count[s[i] - 'a']++
        count[t[i] - 'a']--
    }

    return count.all { it == 0 }
}
```

---

## Common Interview Problems

### By Pattern

| Pattern | Problems |
|---------|----------|
| Two Pointers | Two Sum II, 3Sum, Container With Most Water |
| Sliding Window | Longest Substring Without Repeating, Min Window Substring |
| Prefix Sum | Subarray Sum Equals K, Range Sum Query |
| In-place | Rotate Array, Move Zeroes, Remove Duplicates |
| Binary Search | Search in Rotated Array, Find Peak Element |

### Must-Know Problems

| # | Problem | Pattern | Difficulty |
|---|---------|---------|------------|
| 1 | Two Sum | HashMap | Easy |
| 2 | Best Time to Buy and Sell Stock | Single Pass | Easy |
| 3 | Contains Duplicate | HashSet | Easy |
| 4 | Product of Array Except Self | Prefix/Suffix | Medium |
| 5 | Maximum Subarray | Kadane's Algorithm | Medium |
| 6 | Merge Intervals | Sort + Scan | Medium |
| 7 | 3Sum | Two Pointers | Medium |
| 8 | Container With Most Water | Two Pointers | Medium |
| 9 | Longest Substring Without Repeating | Sliding Window | Medium |
| 10 | Minimum Window Substring | Sliding Window | Hard |

---

## Corner Cases Checklist

### Array Corner Cases

```
□ Empty array []
□ Single element [1]
□ Two elements [1, 2]
□ All same elements [1, 1, 1, 1]
□ Negative numbers [-1, -2, 3]
□ Integer overflow (sum of large numbers)
□ Sorted vs unsorted
□ Even vs odd length
```

### String Corner Cases

```
□ Empty string ""
□ Single character "a"
□ All same characters "aaaa"
□ Palindrome "aba"
□ Case sensitivity "Aa" vs "aa"
□ Spaces and special characters "a b c"
□ Unicode characters
□ Very long strings (memory)
```

---

## Interview Tips

### Before Coding

1. **Clarify duplicates** — есть ли дубликаты и как их обрабатывать?
2. **Clarify sorting** — отсортирован ли массив?
3. **Clarify in-place** — нужно ли модифицировать in-place?
4. **Edge cases** — пустой массив, один элемент?

### During Coding

1. **Index bounds** — проверяй `i < arr.length`
2. **Off-by-one** — `<` vs `<=`
3. **Integer overflow** — используй `long` для сумм
4. **String immutability** — используй StringBuilder

### Complexity Analysis

```
ARRAY OPERATIONS CHEAT SHEET:

Access:        O(1)
Search:        O(n) unsorted, O(log n) sorted
Insert/Delete: O(n) middle, O(1) end
Sort:          O(n log n)
Two Pointers:  O(n)
Sliding Window: O(n)
Prefix Sum:    O(n) build, O(1) query
```

---

## Мифы и заблуждения

| Миф | Реальность |
|-----|-----------|
| "Массив и список — одно и то же" | **Нет.** Массив = contiguous memory, O(1) доступ. Список = узлы со ссылками, O(n) доступ. ArrayList внутри использует массив. |
| "ArrayList медленный из-за resize" | **Редко.** Resize происходит редко (удвоение capacity). Амортизированная сложность add() = O(1). На практике ArrayList быстрее LinkedList почти всегда. |
| "LinkedList лучше для вставок" | **Только если есть ссылка на узел.** Без ссылки сначала O(n) поиск, потом O(1) вставка. ArrayList с его cache locality часто быстрее. |
| "Строки можно изменять" | **В большинстве языков — нет.** Java, Kotlin, Python — strings immutable. Изменение создаёт новый объект. Используй StringBuilder. |
| "str += char в цикле — это O(n)" | **Это O(n²)!** Каждая конкатенация создаёт новую строку. 1+2+3+...+n = O(n²). Используй StringBuilder или join(). |
| "Все операции с массивом O(1)" | **Только доступ по индексу.** Поиск = O(n), вставка/удаление = O(n). Не путай доступ и поиск! |
| "Индексы начинаются с 1" | **Почти везде с 0.** C, Java, Python, Kotlin, JavaScript — с 0. Lua, MATLAB — с 1 (редкость). |
| "Two Pointers работает только с sorted arrays" | **Нет.** Работает и с unsorted: palindrome check, partition, Dutch flag. Sorted нужен для specific задач типа Two Sum II. |

---

## CS-фундамент

| CS-концепция | Как применяется в массивах/строках |
|--------------|-----------------------------------|
| **Contiguous Memory** | Элементы массива хранятся подряд в памяти. Адрес элемента = base + index × size. Это даёт O(1) доступ. |
| **Cache Locality** | Последовательные элементы попадают в одну cache line. Iteration по массиву очень быстра — данные уже в кэше CPU. |
| **Pointer Arithmetic** | arr[i] = *(arr + i). Компилятор преобразует индекс в сдвиг указателя. Работает за O(1). |
| **Random Access** | Доступ к любому элементу за одинаковое время. Противоположность sequential access (как в LinkedList). |
| **Amortized Analysis** | ArrayList.add() обычно O(1), иногда O(n) при resize. В среднем по серии операций — O(1). |
| **Immutability** | Строки неизменяемы для thread safety и оптимизаций (string interning, hash caching). Trade-off: безопасность vs производительность при модификациях. |
| **Space-Time Trade-off** | Prefix sum: O(n) предобработка + O(1) запросы vs O(1) память + O(n) на каждый запрос. |

---

## Связи

- [[big-o-complexity]] — анализ сложности операций
- [[problem-solving-framework]] — как подходить к задачам
- [[patterns/two-pointers-pattern]] — детальный разбор two pointers
- [[patterns/sliding-window-pattern]] — детальный разбор sliding window
- [[data-structures/hash-tables]] — для O(1) lookup

---

## Источники

- [Tech Interview Handbook - Array](https://www.techinterviewhandbook.org/algorithms/array/) — cheatsheet
- [Tech Interview Handbook - String](https://www.techinterviewhandbook.org/algorithms/string/) — cheatsheet
- [GeeksforGeeks - Two Pointers](https://www.geeksforgeeks.org/dsa/two-pointers-technique/) — tutorial
- [GeeksforGeeks - Sliding Window](https://www.geeksforgeeks.org/dsa/window-sliding-technique/) — tutorial
- [Labuladong - Sliding Window](https://labuladong.online/algo/en/essential-technique/sliding-window-framework/) — template
- [Research: Arrays & Strings](../docs/research/2025-12-29-arrays-strings.md) — полное исследование

---

*Обновлено: 2026-01-06 — добавлены педагогические секции (интуиция, типичные ошибки, ментальные модели)*

---

[[algorithms/recursion-fundamentals|← Recursion]] | [[data-structures/linked-lists|Linked Lists →]]
