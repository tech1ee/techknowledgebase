---
title: "Комбинаторика для соревновательного программирования"
created: 2026-02-09
modified: 2026-02-09
type: deep-dive
status: published
tags:
  - topic/cs-fundamentals
  - type/deep-dive
  - level/advanced
related:
  - "[[number-theory]]"
  - "[[dynamic-programming]]"
  - "[[backtracking]]"
prerequisites:
  - "[[recursion-fundamentals]]"
  - "[[dynamic-programming]]"
  - "[[number-theory]]"
---

# Combinatorics for Competitive Programming

## TL;DR

**nCr mod p**: предвычисление факториалов + Fermat inverse за O(n) prep, O(1) query. **Lucas theorem**: C(n,k) mod p для больших n через разложение по base p. **Catalan**: C(n) = C(2n,n)/(n+1), применения — скобки, BST, пути. **Inclusion-Exclusion**: |A∪B∪C| = |A|+|B|+|C|-|A∩B|-... Derangements: D(n) = (n-1)(D(n-1)+D(n-2)).

---

## Часть 1: Интуиция без кода

### Аналогия 1: Биномиальные коэффициенты — "команда из класса"

Представь класс из 30 учеников. Нужно выбрать команду из 5 человек.

```
Вопрос: Сколькими способами можно выбрать команду?

Ответ: C(30, 5) — "30 выбрать 5"

Формула: C(n, k) = n! / (k! × (n-k)!)

Почему? Разбиваем на шаги:
1. Выбираем 1-го члена: 30 вариантов
2. Выбираем 2-го: 29 вариантов
3. ... 5-го: 26 вариантов

Итого: 30 × 29 × 28 × 27 × 26 = 17,100,720

НО! Мы посчитали одну команду 5! раз
(например, {Аня, Боря, Вася} и {Вася, Аня, Боря} — это ОДНА команда)

Делим: 17,100,720 / 120 = 142,506 команд
```

---

### Аналогия 2: Числа Каталана — "правильные скобки"

Сколькими способами расставить 3 пары скобок так, чтобы они были "правильными"?

```
n = 3 (три пары скобок)

Правильные:    Неправильные:
((()))         )(((()))
(()())         (()))((
(())()         ))((
()(())         )()())
()()()         ...

Ответ: C₃ = 5 способов

Почему это работает?

Представь путь на сетке от (0,0) до (n,n):
- '(' = шаг вправо
- ')' = шаг вверх

Правильная последовательность = путь НЕ ВЫШЕ диагонали
(никогда не закрываем больше скобок, чем открыли)

      ┌─────────────→
      │      /
      │    /    ← граница (диагональ)
      │  /
      │/
      └──────────────
```

---

### Аналогия 3: Включение-исключение — "диаграммы Венна"

Сколько учеников изучают хотя бы один язык из трёх?

```
                     Англ (A)
                    ┌──────┐
              ┌─────┼──┐   │
              │     │  │   │
        Нем (B)     │  │   │
              │  ┌──┼──┼───┼──┐
              │  │  │  │   │  │
              │  │  │  │   │  │  Фр (C)
              └──┼──┼──┘   │  │
                 │  │      │  │
                 │  └──────┼──┘
                 └─────────┘

Наивно: |A| + |B| + |C| = посчитаем некоторых дважды или трижды!

Правильно (Inclusion-Exclusion):
|A ∪ B ∪ C| = |A| + |B| + |C|
            - |A ∩ B| - |A ∩ C| - |B ∩ C|  (убираем дважды посчитанных)
            + |A ∩ B ∩ C|                   (добавляем трижды вычтенных)

Пример:
A = 20, B = 15, C = 18
A∩B = 5, A∩C = 7, B∩C = 6
A∩B∩C = 3

|A∪B∪C| = 20 + 15 + 18 - 5 - 7 - 6 + 3 = 38 учеников
```

---

### Аналогия 4: Деранжменты — "секретный Санта"

На корпоративе каждый кладёт подарок в общую кучу. Нужно раздать так, чтобы НИКТО не получил свой подарок.

```
3 человека: Аня (A), Боря (B), Вася (C)
Подарки: a (от Ани), b (от Бори), c (от Васи)

Все перестановки: 6
ABC → Ааc Bbc Cca — НЕТ (все свои)
ABc → ... (Аня своё)
AcB → ... (Аня своё)
BAC → ... (Боря своё, Вася своё)
BCA → Аb Bc Сa — ДА! (никто своё)
CAB → Ac Ba Cb — ДА! (никто своё)

Ответ: D(3) = 2 деранжмента

Формула: D(n) = (n-1) × (D(n-1) + D(n-2))

Интуиция: подарок Ани идёт кому-то из n-1 человек.
- Если Боря получает подарок Ани, и Аня получает подарок Бори:
  Остальные n-2 человека — это деранжмент D(n-2)
- Если Боря НЕ получает подарок Ани взамен:
  Задача сводится к n-1 людям — это D(n-1)
```

---

### Аналогия 5: Треугольник Паскаля — "путь сверху"

```
                1                 C(0,0)
              1   1               C(1,0)  C(1,1)
            1   2   1             C(2,0)  C(2,1)  C(2,2)
          1   3   3   1           C(3,0)  C(3,1)  C(3,2)  C(3,3)
        1   4   6   4   1         ...
      1   5  10  10   5   1
    1   6  15  20  15   6   1

Правило: каждое число = сумма двух чисел над ним
C(n, k) = C(n-1, k-1) + C(n-1, k)

Почему? Для n-го элемента:
- Либо берём его → нужно выбрать ещё k-1 из n-1 → C(n-1, k-1)
- Либо НЕ берём → нужно выбрать k из n-1 → C(n-1, k)
```

---

### Числовой пример: Пути на сетке

```
Сколько путей из A в B, если можно идти только вправо (→) и вверх (↑)?

     B ────────────────┐
     │                 │
     │  ↑              │
     │  └→→↑           │
     │     └→→         │
     │        ↑        │
     │        └→→→     │
     │            ↑    │
     A ───────────┘    │
        m = 4 шагов вправо
        n = 3 шага вверх

Всего нужно: m + n = 7 шагов
Из них выбираем m = 4 "вправо" (остальные — "вверх")

Ответ: C(7, 4) = C(7, 3) = 35 путей

Формула для сетки m×n: C(m+n, m) = C(m+n, n)
```

---

## Часть 2: Почему комбинаторика сложная

### Типичные ошибки студентов

#### Ошибка 1: Путаница между перестановками и сочетаниями

**Симптом:** Неправильный ответ на задачи "выбрать"

```
// ❌ ОШИБКА: использовать P вместо C
// "Сколько способов выбрать 3 книги из 10?"
val wrong = P(10, 3)  // 720 — это с учётом ПОРЯДКА!

// Но "выбрать" без порядка, порядок не важен!

// ✅ ПРАВИЛЬНО:
val correct = C(10, 3)  // 120

// Когда P? Когда порядок важен:
// "Сколько способов расставить 3 книги из 10 на полку?"
// Ответ: P(10, 3) = 720 (порядок на полке важен!)
```

---

#### Ошибка 2: Переполнение факториала

**Симптом:** Неправильные или отрицательные числа

```
// ❌ ОШИБКА: факториалы растут очень быстро!
val fact20 = (1..20).fold(1L) { acc, i -> acc * i }  // 2,432,902,008,176,640,000
val fact21 = (1..21).fold(1L) { acc, i -> acc * i }  // OVERFLOW!

// 21! = 51,090,942,171,709,440,000 > Long.MAX_VALUE

// ✅ ПРАВИЛЬНО: всегда берём mod
val MOD = 1_000_000_007L
val fact = LongArray(maxN + 1)
fact[0] = 1
for (i in 1..maxN) {
    fact[i] = fact[i - 1] * i % MOD
}
```

---

#### Ошибка 3: C(n, k) когда k > n

**Симптом:** ArrayIndexOutOfBoundsException или неправильный результат

```
// ❌ ОШИБКА: забыли проверить границы
fun C(n: Int, k: Int) = fact[n] * invFact[k] % mod * invFact[n - k] % mod
// При k > n: invFact[отрицательное] → CRASH!

// ✅ ПРАВИЛЬНО: проверяем границы
fun C(n: Int, k: Int): Long {
    if (k < 0 || k > n) return 0  // Нельзя выбрать больше, чем есть
    return fact[n] * invFact[k] % mod * invFact[n - k] % mod
}
```

---

#### Ошибка 4: Fermat для непростого mod

**Симптом:** Неправильный обратный элемент

```
// ❌ ОШИБКА: теорема Ферма НЕ работает для составного mod!
val mod = 1000L  // НЕ простое (1000 = 8 × 125)
val inv5 = modPow(5, mod - 2, mod)  // 5^998 mod 1000 = ???

// Проверка: 5 × inv5 mod 1000 ≠ 1 скорее всего!

// ✅ ПРАВИЛЬНО:
// 1. Использовать ПРОСТОЕ mod (10^9 + 7, 998244353)
// 2. Или использовать Extended Euclidean Algorithm
```

---

#### Ошибка 5: Путаница с Catalan применениями

**Симптом:** Неправильное число Каталана для задачи

```
// ❌ ОШИБКА: забыли про +1 или -1
// "Сколько BST с n узлами?" → Cₙ
// "Сколько путей в сетке n×n?" → Cₙ
// "Сколько триангуляций n-угольника?" → C_{n-2} (НЕ Cₙ!)

// ✅ ПРАВИЛЬНО: запомнить смещение для каждой задачи
// BST с n узлами = Cₙ
// Скобки длины 2n = Cₙ
// Full binary tree с n+1 листьями = Cₙ
// Триангуляция (n+2)-угольника = Cₙ
```

---

#### Ошибка 6: Знак в inclusion-exclusion

**Симптом:** Неправильный результат PIE

```
// ❌ ОШИБКА: перепутать знаки
// |A ∪ B| = |A| + |B| + |A ∩ B|  // НЕПРАВИЛЬНО!

// ✅ ПРАВИЛЬНО:
// |A ∪ B| = |A| + |B| - |A ∩ B|  // Вычитаем пересечение!

// Общее правило: (-1)^(k+1) для пересечения k множеств
// 1 множество: +
// 2 множества: -
// 3 множества: +
// ...
```

---

## Часть 3: Ментальные модели

### Модель 1: Таблица выбора формулы

```
┌────────────────────────────────────────────────────────────┐
│                  КАКУЮ ФОРМУЛУ ИСПОЛЬЗОВАТЬ?               │
├────────────────────────────────────────────────────────────┤
│                                                            │
│ ВЫБРАТЬ k из n БЕЗ ПОРЯДКА, БЕЗ ПОВТОРЕНИЙ?               │
│   → C(n, k) = n! / (k! × (n-k)!)                          │
│   Пример: команда из класса                               │
│                                                            │
│ ВЫБРАТЬ k из n С ПОРЯДКОМ, БЕЗ ПОВТОРЕНИЙ?                │
│   → P(n, k) = n! / (n-k)!                                 │
│   Пример: призовые места                                  │
│                                                            │
│ ВЫБРАТЬ k из n БЕЗ ПОРЯДКА, С ПОВТОРЕНИЯМИ?               │
│   → H(n, k) = C(n+k-1, k)                                 │
│   Пример: конфеты из видов                                │
│                                                            │
│ РАССТАВИТЬ n объектов, ВСЕ РАЗНЫЕ?                        │
│   → n!                                                    │
│   Пример: очередь                                         │
│                                                            │
│ РАССТАВИТЬ n объектов, ЕСТЬ ОДИНАКОВЫЕ?                   │
│   → n! / (n₁! × n₂! × ...)                               │
│   Пример: слово MISSISSIPPI                               │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

---

### Модель 2: Когда использовать какую технику

```
                  Комбинаторная задача
                          │
         ┌────────────────┼────────────────┐
         │                │                │
    ПОДСЧЁТ           ПОДСЧЁТ С         СПЕЦИАЛЬНЫЕ
    НАПРЯМУЮ          ИСКЛЮЧЕНИЕМ        ЧИСЛА
         │                │                │
    ┌────┴────┐      Inclusion-      ┌────┴────┐
    │         │      Exclusion       │         │
   C(n,k)   P(n,k)        │        Catalan  Stirling
   H(n,k)   n!            │         Bell   Деранжменты
                          │
              "Хотя бы один" или
              "Ровно k свойств"
```

---

### Модель 3: Числа Каталана — универсальные применения

```
Cₙ отвечает на ВСЕ эти вопросы:

┌────────────────────────────────────────────────────────────┐
│                  ЧИСЛА КАТАЛАНА Cₙ                         │
├────────────────────────────────────────────────────────────┤
│                                                            │
│ • Правильные скобочные последовательности длины 2n        │
│                                                            │
│ • BST с n узлами                                          │
│                                                            │
│ • Full binary trees с n+1 листом                          │
│                                                            │
│ • Пути в сетке n×n НЕ ВЫШЕ диагонали                      │
│                                                            │
│ • Триангуляции выпуклого (n+2)-угольника                  │
│                                                            │
│ • Способы умножения n+1 матриц (порядок скобок)           │
│                                                            │
│ • Не-пересекающиеся хорды между 2n точками на окружности  │
│                                                            │
│ Формула: Cₙ = C(2n,n)/(n+1) = C(2n,n) - C(2n,n+1)         │
│                                                            │
│ Первые: 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862...       │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

---

### Модель 4: Предвычисление vs Формула

```
┌────────────────────────────────────────────────────────────┐
│        КОГДА ПРЕДВЫЧИСЛЯТЬ, КОГДА ФОРМУЛА?                 │
├────────────────────────────────────────────────────────────┤
│                                                            │
│ ПРЕДВЫЧИСЛЕНИЕ (O(maxN) memory + O(maxN) time):           │
│   • Много запросов C(n,k) для n ≤ maxN                    │
│   • maxN ≤ 10^6 (помещается в память)                     │
│   • Нужен O(1) на запрос                                  │
│                                                            │
│ ТЕОРЕМА ЛУКАСА (O(p) memory + O(log n) per query):        │
│   • n очень большой (до 10^18)                            │
│   • p маленький простой (< 10^6)                          │
│   • Мало запросов                                         │
│                                                            │
│ ТРЕУГОЛЬНИК ПАСКАЛЯ (O(n²) memory + O(n²) time):          │
│   • n небольшой (< 5000)                                  │
│   • Не нужен mod или mod не простой                       │
│   • Нужны все C(i,j) для i,j ≤ n                          │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

---

### Модель 5: Шаблоны для типовых задач

```kotlin
// ПУТЬ НА СЕТКЕ m×n (вправо + вверх)
fun gridPaths(m: Int, n: Int, comb: Combinatorics): Long {
    return comb.C(m + n, m)
}

// СКОБКИ длины 2n
fun validBrackets(n: Int, comb: Combinatorics): Long {
    return comb.C(2 * n, n) - comb.C(2 * n, n + 1)  // Catalan
}

// ДЕЛИТСЯ НА ХОТЯ БЫ ОДНО из primes
fun divisibleByAtLeastOne(n: Long, primes: List<Long>): Long {
    var result = 0L
    for (mask in 1 until (1 shl primes.size)) {
        val product = primes.filterIndexed { i, _ -> (mask and (1 shl i)) != 0 }
            .fold(1L) { acc, p -> acc * p }
        val sign = if (Integer.bitCount(mask) % 2 == 1) 1 else -1
        result += sign * (n / product)
    }
    return result
}

// СЛОВО С ПОВТОРЯЮЩИМИСЯ БУКВАМИ
// "MISSISSIPPI" → 11! / (4! × 4! × 2! × 1!)
fun permutationsWithRepetition(counts: List<Int>, comb: Combinatorics): Long {
    val n = counts.sum()
    var result = comb.factorial(n)
    for (c in counts) {
        result = result * comb.invFactorial(c) % MOD
    }
    return result
}
```

---

## Зачем это нужно?

**Проблема:**

```
Посчитать C(10^9, 10^6) mod (10^9+7)

Наивно: вычислить 10^9! — невозможно
С Lucas: O(log n) операций
С предвычислением: O(1) если n ≤ 10^6
```

**Типичные задачи:**

| Тип | Формула |
|-----|---------|
| Выбор k из n | C(n, k) |
| Расстановка k из n | P(n, k) = n!/(n-k)! |
| С повторениями | C(n+k-1, k) |
| Разбиения | Числа Стирлинга |
| Скобки, пути, деревья | Числа Каталана |

---

## Биномиальные коэффициенты

### Базовые свойства

```
C(n, k) = n! / (k! × (n-k)!)
C(n, k) = C(n, n-k)
C(n, k) = C(n-1, k-1) + C(n-1, k)  (Pascal)
Σ C(n, k) = 2^n
```

### Реализация с предвычислением

```kotlin
/**
 * КОМБИНАТОРИКА С ПРЕДВЫЧИСЛЕНИЕМ
 *
 * Идея: предвычисляем факториалы и их обратные элементы за O(n),
 * затем любой C(n,k) или P(n,k) — за O(1).
 *
 * Ключевая формула: C(n,k) = n! / (k! × (n-k)!)
 * В модульной арифметике деление = умножение на обратный элемент:
 * C(n,k) = n! × (k!)^(-1) × ((n-k)!)^(-1) mod p
 */
class Combinatorics(maxN: Int, private val mod: Long = 1_000_000_007) {
    private val fact = LongArray(maxN + 1)
    private val invFact = LongArray(maxN + 1)

    init {
        // Предвычисляем ВСЕ факториалы от 0! до maxN!
        // fact[i] = i! mod p
        fact[0] = 1
        for (i in 1..maxN) {
            fact[i] = fact[i - 1] * i % mod
        }

        // ОБРАТНЫЕ ФАКТОРИАЛЫ через малую теорему Ферма:
        // Если p простое, то a^(-1) ≡ a^(p-2) (mod p)
        // Вычисляем только invFact[maxN], остальные — через рекуррентность
        invFact[maxN] = modPow(fact[maxN], mod - 2)

        // Рекуррентность: (n-1)!^(-1) = n!^(-1) × n
        // Потому что: (n-1)! = n! / n → (n-1)!^(-1) = n × n!^(-1)
        for (i in maxN - 1 downTo 0) {
            invFact[i] = invFact[i + 1] * (i + 1) % mod
        }
    }

    private fun modPow(base: Long, exp: Long): Long {
        var result = 1L
        var b = base % mod
        var e = exp
        while (e > 0) {
            if (e and 1L == 1L) result = result * b % mod
            b = b * b % mod
            e = e shr 1
        }
        return result
    }

    /**
     * БИНОМИАЛЬНЫЙ КОЭФФИЦИЕНТ C(n, k) = n! / (k! × (n-k)!)
     * "Сколькими способами выбрать k элементов из n?"
     */
    fun C(n: Int, k: Int): Long {
        if (k < 0 || k > n) return 0
        return fact[n] * invFact[k] % mod * invFact[n - k] % mod
    }

    /**
     * ПЕРЕСТАНОВКИ P(n, k) = n! / (n-k)!
     * "Сколькими способами расставить k элементов из n по порядку?"
     */
    fun P(n: Int, k: Int): Long {
        if (k < 0 || k > n) return 0
        return fact[n] * invFact[n - k] % mod
    }

    /**
     * СОЧЕТАНИЯ С ПОВТОРЕНИЯМИ H(n, k) = C(n+k-1, k)
     * "Сколькими способами выбрать k предметов из n типов, можно повторять?"
     * Пример: 5 конфет из 3 видов = C(7, 5) = 21
     */
    fun multiset(n: Int, k: Int): Long = C(n + k - 1, k)

    fun factorial(n: Int): Long = fact[n]
    fun invFactorial(n: Int): Long = invFact[n]
}
```

**Сложность:**
- Preprocessing: O(n)
- Query: O(1)

---

## Lucas' Theorem

### Когда использовать

```
C(n, k) mod p где n очень большой (10^18), но p маленький (< 10^6).

Идея: разложить n и k по base p, перемножить малые C.
```

### Формула

```
C(n, k) ≡ ∏ C(nᵢ, kᵢ) (mod p)

где n = Σ nᵢ × pⁱ, k = Σ kᵢ × pⁱ (base p representation)

Важно: если kᵢ > nᵢ для какого-то i, то C(n,k) ≡ 0 (mod p)
```

### Реализация

```kotlin
/**
 * ТЕОРЕМА ЛУКАСА — C(n, k) mod p для ОГРОМНЫХ n (до 10^18)
 *
 * Условие: p — простое и МАЛЕНЬКОЕ (< 10^6)
 *
 * Идея: представляем n и k в системе счисления по основанию p,
 * затем перемножаем малые биномиальные коэффициенты.
 *
 * Формула: C(n, k) ≡ ∏ C(nᵢ, kᵢ) (mod p)
 * где n = Σnᵢ×pⁱ, k = Σkᵢ×pⁱ
 *
 * Пример: C(10, 3) mod 5
 * 10 = 2×5 + 0 → (2, 0) в base 5
 * 3 = 0×5 + 3 → (0, 3) в base 5
 * C(10,3) ≡ C(2,0) × C(0,3) = 1 × 0 = 0 (mod 5)
 * (потому что C(0,3) = 0, нельзя выбрать 3 из 0)
 */
class LucasTheorem(private val p: Long) {
    // Предвычисляем C(0..p-1, 0..p-1) — все малые коэффициенты
    private val comb = Combinatorics(p.toInt(), p)

    /**
     * Вычисляет C(n, k) mod p для n до 10^18
     * Сложность: O(p + log_p(n))
     */
    fun C(n: Long, k: Long): Long {
        if (k > n) return 0
        if (k == 0L || k == n) return 1

        var result = 1L
        var nn = n
        var kk = k

        // Разлагаем n и k по base p (как в десятичной системе разлагаем по base 10)
        while (nn > 0 || kk > 0) {
            val ni = (nn % p).toInt()  // Последняя "цифра" n в base p
            val ki = (kk % p).toInt()  // Последняя "цифра" k в base p

            // ВАЖНО: если ki > ni для какого-то разряда, то C(n,k) ≡ 0 (mod p)
            // Интуитивно: нельзя выбрать больше элементов, чем есть
            if (ki > ni) return 0

            result = result * comb.C(ni, ki) % p

            nn /= p  // Переходим к следующему разряду
            kk /= p
        }

        return result
    }
}

// Использование
val lucas = LucasTheorem(1000003)  // малое простое p
println(lucas.C(1_000_000_000_000L, 500_000_000_000L))
```

**Сложность:** O(p + log_p(n))

---

## Числа Каталана

### Определение

```
C₀ = 1
Cₙ = Σ(i=0 to n-1) Cᵢ × Cₙ₋₁₋ᵢ

Явная формула:
Cₙ = C(2n, n) / (n + 1) = C(2n, n) - C(2n, n+1)
```

### Первые значения

```
C₀ = 1
C₁ = 1
C₂ = 2
C₃ = 5
C₄ = 14
C₅ = 42
C₆ = 132
```

### Применения

| Задача | Формула |
|--------|---------|
| Правильные скобочные последовательности длины 2n | Cₙ |
| Количество BST с n узлами | Cₙ |
| Количество full binary trees с n+1 листьями | Cₙ |
| Монотонные пути n×n не выше диагонали | Cₙ |
| Триангуляции выпуклого (n+2)-угольника | Cₙ |
| Способы разбить многоугольник на треугольники | Cₙ |

### Реализация

```kotlin
fun catalanDP(n: Int, mod: Long = 1_000_000_007): LongArray {
    val c = LongArray(n + 1)
    c[0] = 1

    for (i in 1..n) {
        for (j in 0 until i) {
            c[i] = (c[i] + c[j] * c[i - 1 - j]) % mod
        }
    }

    return c
}

/**
 * ЧИСЛА КАТАЛАНА через формулу — O(1) вместо O(n²)
 *
 * Cₙ = C(2n, n) / (n+1) = C(2n, n) - C(2n, n+1)
 *
 * Вторая формула удобнее в модульной арифметике —
 * не нужно делить, только вычитать.
 */
fun catalanFormula(n: Int, comb: Combinatorics): Long {
    val mod = 1_000_000_007L
    // Cₙ = C(2n, n) - C(2n, n+1)
    return (comb.C(2 * n, n) - comb.C(2 * n, n + 1) + mod) % mod
}
```

### Пример: количество BST

```kotlin
/**
 * Количество различных BST с n узлами = n-е число Каталана
 *
 * Почему? Для корня k (от 1 до n):
 * - Левое поддерево содержит k-1 узлов (1..k-1)
 * - Правое поддерево содержит n-k узлов (k+1..n)
 * - Общее число = Σ(k=1..n) C(k-1) × C(n-k) = C(n)
 *
 * Это в точности рекуррентность чисел Каталана!
 */
fun countBST(n: Int): Long {
    val catalan = catalanDP(n)
    return catalan[n]
}
```

---

## Принцип включения-исключения

### Формула

```
|A₁ ∪ A₂ ∪ ... ∪ Aₙ| = Σ|Aᵢ| - Σ|Aᵢ ∩ Aⱼ| + Σ|Aᵢ ∩ Aⱼ ∩ Aₖ| - ...

Общая формула:
Σ (-1)^(|S|+1) × |∩ᵢ∈S Aᵢ|
для всех непустых S ⊆ {1, 2, ..., n}
```

### Реализация

```kotlin
/**
 * ПРИНЦИП ВКЛЮЧЕНИЯ-ИСКЛЮЧЕНИЯ (Inclusion-Exclusion)
 *
 * Формула: |A₁ ∪ A₂ ∪ ... ∪ Aₙ| =
 *   + Σ|Aᵢ|           (добавляем все)
 *   - Σ|Aᵢ ∩ Aⱼ|      (вычитаем пересечения пар)
 *   + Σ|Aᵢ ∩ Aⱼ ∩ Aₖ| (добавляем пересечения троек)
 *   - ...
 *
 * Знак: (-1)^(|S|+1) для подмножества S
 * Нечётное число элементов → +, чётное → -
 *
 * Реализация через bitmask: перебираем все 2^n - 1 непустых подмножеств
 */
fun inclusionExclusion(n: Int, intersectionSize: (Int) -> Long): Long {
    var result = 0L

    // Перебираем все непустые подмножества {1, 2, ..., n}
    // mask = 1 до 2^n - 1 кодирует подмножество битами
    for (mask in 1 until (1 shl n)) {
        val bits = Integer.bitCount(mask)  // Количество элементов в подмножестве
        val size = intersectionSize(mask)  // Размер пересечения выбранных множеств

        // Знак зависит от чётности: нечётное число → +, чётное → -
        if (bits % 2 == 1) {
            result += size
        } else {
            result -= size
        }
    }

    return result
}
```

### Пример: сколько чисел до n делятся на хотя бы одно из p₁, p₂, ...

```kotlin
fun countDivisible(n: Long, primes: List<Long>): Long {
    val k = primes.size
    var count = 0L

    for (mask in 1 until (1 shl k)) {
        var product = 1L
        var bits = 0

        for (i in 0 until k) {
            if ((mask and (1 shl i)) != 0) {
                product *= primes[i]
                bits++
            }
        }

        val contribution = n / product

        if (bits % 2 == 1) {
            count += contribution
        } else {
            count -= contribution
        }
    }

    return count
}

// Сколько чисел от 1 до 100 делятся на 2 или 3 или 5?
println(countDivisible(100, listOf(2, 3, 5)))  // 74
```

---

## Деранжменты (Subfactorial)

### Определение

```
D(n) = количество перестановок без неподвижных точек
     = количество способов положить n писем в n конвертов
       так, чтобы ни одно не попало в свой конверт
```

### Формулы

```
Рекуррентность:
D(0) = 1
D(1) = 0
D(n) = (n-1) × (D(n-1) + D(n-2))

Явная формула (через inclusion-exclusion):
D(n) = n! × Σ(k=0 to n) (-1)^k / k!

Приближение:
D(n) ≈ n! / e ≈ [n! / e]  (ближайшее целое)
```

### Реализация

```kotlin
/**
 * ДЕРАНЖМЕНТЫ (Subfactorial) — перестановки без неподвижных точек
 *
 * D(n) = количество способов разложить n писем по n конвертам
 *        так, чтобы НИ ОДНО письмо не попало в свой конверт
 *
 * Рекуррентность: D(n) = (n-1) × (D(n-1) + D(n-2))
 *
 * Интуиция: рассмотрим письмо 1. Оно идёт в какой-то конверт k (n-1 вариант).
 * - Если письмо k идёт в конверт 1: осталось разложить n-2 писем → D(n-2)
 * - Если письмо k НЕ идёт в конверт 1: можно считать, что конверт 1 "принадлежит" k,
 *   и задача сводится к n-1 письмам → D(n-1)
 *
 * Приближение: D(n) ≈ n! / e (округлённое)
 */
fun derangements(n: Int, mod: Long = 1_000_000_007): LongArray {
    val d = LongArray(n + 1)
    d[0] = 1  // Пустая перестановка — тривиальный деранжмент
    if (n >= 1) d[1] = 0  // Одно письмо может пойти только в свой конверт

    for (i in 2..n) {
        // D(n) = (n-1) × (D(n-1) + D(n-2))
        d[i] = (i - 1) * (d[i - 1] + d[i - 2]) % mod
    }

    return d
}

// Первые значения: 1, 0, 1, 2, 9, 44, 265, ...
```

### Пример: частичные деранжменты

```kotlin
/**
 * Количество перестановок n элементов с РОВНО k неподвижными точками
 *
 * Идея: выбираем k позиций, которые останутся на месте (C(n,k) способов),
 * остальные n-k элементов переставляем без неподвижных точек (D(n-k))
 *
 * Пример: перестановки [1,2,3,4] с ровно 1 неподвижной точкой
 * C(4,1) × D(3) = 4 × 2 = 8 перестановок
 */
fun permutationsWithKFixed(n: Int, k: Int, comb: Combinatorics): Long {
    val mod = 1_000_000_007L
    val d = derangements(n - k, mod)

    // Выбираем k позиций для неподвижных точек × деранжмент остальных
    return comb.C(n, k) * d[n - k] % mod
}
```

---

## Числа Стирлинга

### Стирлинг второго рода S(n, k)

```
S(n, k) = количество способов разбить n элементов на k непустых подмножеств

Рекуррентность:
S(n, k) = k × S(n-1, k) + S(n-1, k-1)

База: S(0, 0) = 1, S(n, 0) = S(0, k) = 0 для n,k > 0
```

```kotlin
/**
 * ЧИСЛА СТИРЛИНГА ВТОРОГО РОДА S(n, k)
 *
 * S(n, k) = количество способов разбить n различных элементов
 *           на k НЕПУСТЫХ неупорядоченных подмножеств
 *
 * Рекуррентность: S(n, k) = k × S(n-1, k) + S(n-1, k-1)
 *
 * Интуиция для нового элемента:
 * 1) Добавить в одно из k существующих подмножеств → k × S(n-1, k)
 * 2) Создать новое подмножество из этого элемента → S(n-1, k-1)
 *
 * Пример: S(4, 2) = 7
 * Разбиения {1,2,3,4} на 2 группы:
 * {{1},{2,3,4}}, {{2},{1,3,4}}, {{3},{1,2,4}}, {{4},{1,2,3}},
 * {{1,2},{3,4}}, {{1,3},{2,4}}, {{1,4},{2,3}}
 */
fun stirling2(n: Int, k: Int, mod: Long = 1_000_000_007): Array<LongArray> {
    val s = Array(n + 1) { LongArray(k + 1) }
    s[0][0] = 1

    for (i in 1..n) {
        for (j in 1..minOf(i, k)) {
            // k способов добавить в существующее + 1 способ создать новое
            s[i][j] = (j * s[i - 1][j] + s[i - 1][j - 1]) % mod
        }
    }

    return s
}
```

### Стирлинг первого рода (беззнаковый) c(n, k)

```
c(n, k) = количество перестановок n элементов с ровно k циклами

Рекуррентность:
c(n, k) = (n-1) × c(n-1, k) + c(n-1, k-1)
```

---

## Полезные формулы

### Сочетания с повторениями

```
Количество способов выбрать k предметов из n типов (с повторениями):
H(n, k) = C(n + k - 1, k)

Пример: сколько способов выбрать 5 конфет из 3 видов?
H(3, 5) = C(7, 5) = 21
```

### Мультиномиальные коэффициенты

```
Количество перестановок с повторениями:
n! / (n₁! × n₂! × ... × nₖ!)

где n = n₁ + n₂ + ... + nₖ
```

### Принцип Дирихле (Pigeonhole)

```
Если n+1 объектов положить в n ящиков,
хотя бы в одном ящике будет ≥ 2 объекта.

Обобщение: если kn+1 объектов в n ящиков,
хотя бы в одном будет ≥ k+1.
```

---

## Распространённые ошибки

### 1. Overflow при вычислении факториала

```kotlin
// ❌ НЕПРАВИЛЬНО: 21! > Long.MAX_VALUE
val fact = (1..n).fold(1L) { acc, i -> acc * i }

// ✅ ПРАВИЛЬНО: берём mod на каждом шаге
val fact = (1..n).fold(1L) { acc, i -> acc * i % mod }
```

### 2. Забыть проверку k > n в C(n, k)

```kotlin
// ❌ НЕПРАВИЛЬНО: ArrayIndexOutOfBounds
fun C(n: Int, k: Int) = fact[n] * invFact[k] % mod * invFact[n - k] % mod

// ✅ ПРАВИЛЬНО:
fun C(n: Int, k: Int): Long {
    if (k < 0 || k > n) return 0
    return fact[n] * invFact[k] % mod * invFact[n - k] % mod
}
```

### 3. Неправильный mod для invFact

```kotlin
// ❌ НЕПРАВИЛЬНО: Fermat работает только для простого mod
val invFact = modPow(fact[n], mod - 2)  // mod должен быть простым!

// ✅ ПРАВИЛЬНО: проверять или использовать extended GCD
```

---

## Практика

### LeetCode задачи

| # | Название | Сложность | Тема |
|---|----------|-----------|------|
| 62 | Unique Paths | Medium | C(n+m-2, n-1) |
| 96 | Unique Binary Search Trees | Medium | Catalan |
| 634 | Find the Derangement | Medium | Деранжменты |
| 1569 | Number of Ways to Reorder Array | Hard | Биномиалы + DP |
| 1643 | Kth Smallest Instructions | Hard | Комбинаторика |

---

## Связанные темы

### Prerequisites
- [Number Theory](./number-theory.md) — modular arithmetic
- Basic probability

### Unlocks
- Generating functions
- Probability algorithms
- Advanced counting

---

## Источники

| # | Источник | Тип | Вклад |
|---|----------|-----|-------|
| 1 | [CP-Algorithms: Binomial](https://cp-algorithms.com/combinatorics/binomial-coefficients.html) | Reference | nCr mod p |
| 2 | [CP-Algorithms: Catalan](https://cp-algorithms.com/combinatorics/catalan-numbers.html) | Reference | Catalan |
| 3 | [CP-Algorithms: Inclusion-Exclusion](https://cp-algorithms.com/combinatorics/inclusion-exclusion.html) | Reference | PIE |
| 4 | [Brilliant: Lucas](https://brilliant.org/wiki/lucas-theorem/) | Wiki | Lucas theorem |
| 5 | [Wikipedia: Derangement](https://en.wikipedia.org/wiki/Derangement) | Reference | Subfactorial |

---

*Обновлено: 2026-01-09 — добавлены педагогические секции (интуиция биномиальных коэффициентов/Catalan/PIE/деранжментов, 6 типичных ошибок, 5 ментальных моделей)*
