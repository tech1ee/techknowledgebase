---
title: "Алгоритмы поиска"
created: 2025-12-30
modified: 2026-01-06
type: deep-dive
status: published
difficulty: intermediate
confidence: high
cs-foundations:
  - logarithmic-complexity
  - sorted-data-invariant
  - binary-search-on-answer
  - lower-upper-bound
  - divide-and-conquer
  - monotonic-predicate
prerequisites:
  - "[[arrays-strings]]"
  - "[[sorting-algorithms]]"
  - "[[big-o-complexity]]"
tags:
  - topic/cs-fundamentals
  - type/deep-dive
  - level/intermediate
  - interview
related:
  - "[[binary-search-pattern]]"
  - "[[two-pointers-pattern]]"
  - "[[trees-binary]]"
---

# Searching Algorithms

## TL;DR

Searching algorithms locate elements in data structures. **Linear search** O(n) works on any data; **Binary search** O(log n) requires sorted data but is much faster. Key variations: lower/upper bound for boundaries, binary search on answer for optimization problems. Most interview problems use modified binary search on sorted/rotated arrays or search spaces.

---

## Часть 1: Интуиция без кода

> **Цель:** понять ИДЕЮ поиска до любого кода. Если ты понимаешь эти аналогии — ты уже понимаешь алгоритмы поиска.

### Ты уже умеешь искать

Ты выполняешь поиск каждый день, даже не задумываясь:

| Ситуация | Как ты ищешь | Это и есть... |
|----------|--------------|---------------|
| **Ищешь ключи на столе** | Смотришь всё подряд | Linear Search |
| **Ищешь слово в словаре** | Открываешь примерно на нужной букве, корректируешь | Binary Search |
| **Ищешь страницу в книге по номеру** | Открываешь посередине, переходишь влево/вправо | Binary Search |
| **Ищешь товар в алфавитном каталоге** | Сразу к нужной букве, потом уточняешь | Binary Search |

### Аналогия 1: Игра "Угадай число"

Представь игру: я загадал число от 1 до 100, ты угадываешь.

**Глупый способ (Linear Search):**
```
Ты: "Это 1?"    Я: "Нет, больше"
Ты: "Это 2?"    Я: "Нет, больше"
Ты: "Это 3?"    Я: "Нет, больше"
... (может занять до 100 попыток!)
```

**Умный способ (Binary Search):**
```
Ты: "Больше 50?"   Я: "Да"    → диапазон [51-100]
Ты: "Больше 75?"   Я: "Нет"   → диапазон [51-75]
Ты: "Больше 63?"   Я: "Да"    → диапазон [64-75]
Ты: "Больше 69?"   Я: "Нет"   → диапазон [64-69]
Ты: "Больше 66?"   Я: "Да"    → диапазон [67-69]
Ты: "Больше 68?"   Я: "Нет"   → диапазон [67-68]
Ты: "Это 67?"      Я: "Да!"

7 вопросов вместо потенциальных 100!
```

**Почему это работает:** каждый вопрос УПОЛОВИНИВАЕТ диапазон поиска.
- 100 → 50 → 25 → 12 → 6 → 3 → 1
- Это 7 шагов, что равно log₂(100) ≈ 7

### Аналогия 2: Словарь

Как ты ищешь слово "programming" в бумажном словаре?

**Глупый способ (никто так не делает):**
```
Открываешь страницу 1: "aardvark" — не то
Открываешь страницу 2: "abandon" — не то
...
Открываешь страницу 12345: "programming" — нашёл!
```

**Умный способ (все так делают):**
```
1. Открываешь примерно посередине: "mountain"
   "programming" > "mountain" → ищем во второй половине

2. Открываешь примерно 3/4 книги: "something"
   "programming" < "something" → ищем левее

3. Открываешь между "mountain" и "something": "picture"
   "programming" > "picture" → ищем правее

4. И так далее...
```

### Аналогия 3: Поиск квартиры по номеру

Ты в подъезде 20-этажного дома, ищешь квартиру 147.

**Вариант А: Идёшь пешком (Linear)**
Первый этаж — квартиры 1-8, не то. Второй этаж — 9-16, не то...

**Вариант Б: Используешь лифт (Binary)**
1. Едешь на 10-й этаж: квартиры 73-80. 147 > 80 → нужно выше
2. Едешь на 15-й этаж: квартиры 113-120. 147 > 120 → нужно выше
3. Едешь на 18-й этаж: квартиры 137-144. 147 > 144 → нужно выше
4. Едешь на 19-й этаж: квартиры 145-152. 147 в диапазоне! Нашёл!

### Главный инсайт: Условие для Binary Search

Binary Search работает **ТОЛЬКО** когда:
- Данные ОТСОРТИРОВАНЫ (или имеют монотонное свойство)
- Каждый шаг ГАРАНТИРОВАННО исключает половину

| Ситуация | Можно Binary Search? | Почему |
|----------|---------------------|--------|
| Отсортированный массив | ✅ Да | Меньше/больше mid — однозначно левее/правее |
| Неотсортированный массив | ❌ Нет | Не знаем, где искать |
| Словарь по алфавиту | ✅ Да | Слова упорядочены |
| Колода карт вразнобой | ❌ Нет | Порядок случайный |
| Телефонная книга | ✅ Да | Имена по алфавиту |

---

## Часть 2: Почему Binary Search сложен?

> **Цель:** понять, что Binary Search — это НЕ простая тема, несмотря на простую идею.

### История: 16 лет до правильной реализации

Джон Бентли в книге "Programming Pearls" описывает шокирующий факт:

> **Бинарный поиск был впервые описан в 1946 году.**
> **Первая КОРРЕКТНАЯ реализация появилась только в 1962 году.**
> **16 лет программисты писали багованный код!**

Более того, Бентли давал задачу написать binary search на своих курсах:
- **90% профессиональных программистов** написали код с багами
- Самая частая ошибка: off-by-one (ошибка на единицу)

### Почему так сложно?

```
┌────────────────────────────────────────────────────────────────┐
│           ПРОСТАЯ ИДЕЯ, СЛОЖНАЯ РЕАЛИЗАЦИЯ                    │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│   ИДЕЯ: "делим пополам пока не найдём"                        │
│                                                                │
│   ПРОБЛЕМЫ:                                                    │
│   • Как именно "делить"? (lo+hi)/2 или lo+(hi-lo)/2?          │
│   • Когда останавливаться? lo < hi или lo <= hi?              │
│   • Как обновлять границы? mid+1 или mid?                     │
│   • Inclusive или exclusive границы?                          │
│   • Что если элемента нет?                                     │
│   • Что если есть дубликаты?                                  │
│                                                                │
│   КАЖДОЕ решение влияет на корректность!                      │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### 5 типичных ошибок (с объяснением ПОЧЕМУ)

#### Ошибка 1: Переполнение при вычислении mid

```
// НЕПРАВИЛЬНО:
mid = (low + high) / 2

// При low = 2,000,000,000 и high = 2,000,000,000:
// low + high = 4,000,000,000 > INT_MAX (2,147,483,647)
// Результат: ПЕРЕПОЛНЕНИЕ → отрицательное число → crash!

// ПРАВИЛЬНО:
mid = low + (high - low) / 2

// Почему работает: сначала вычисляем разницу (она точно помещается),
// потом делим и прибавляем к low
```

#### Ошибка 2: Бесконечный цикл

```
// ПРОБЛЕМА: застреваем когда low + 1 == high

Пример: low=5, high=6, ищем максимум
mid = 5 + (6-5)/2 = 5 (округление вниз!)
Если условие: low = mid
То low остаётся 5, high остаётся 6 → БЕСКОНЕЧНЫЙ ЦИКЛ

// РЕШЕНИЕ для максимизации: округляем ВВЕРХ
mid = low + (high - low + 1) / 2
```

#### Ошибка 3: Неправильное условие цикла

```
// lo < hi vs lo <= hi — это РАЗНЫЕ алгоритмы!

lo <= hi: для поиска КОНКРЕТНОГО элемента
- Цикл продолжается пока есть хотя бы 1 элемент
- После цикла: элемент не найден

lo < hi: для поиска ГРАНИЦЫ (lower/upper bound)
- Цикл продолжается пока диапазон > 1 элемента
- После цикла: lo == hi == найденная граница
```

#### Ошибка 4: Неправильное обновление границ

```
// После сравнения: куда двигать границы?

Если arr[mid] < target:
  low = mid + 1  ← mid точно не ответ, исключаем его

Если arr[mid] > target:
  high = mid - 1  ← mid точно не ответ, исключаем его

// ДЛЯ LOWER BOUND другая логика:
Если arr[mid] < target:
  low = mid + 1  ← mid НЕ ответ
Если arr[mid] >= target:
  high = mid     ← mid МОЖЕТ быть ответом, не исключаем!
```

#### Ошибка 5: Забыли проверить результат

```
// lower_bound может вернуть:
// - Индекс элемента (если нашли)
// - Индекс ЗА массивом (если все элементы < target)
// - Индекс большего элемента (если target нет)

// НЕПРАВИЛЬНО:
int idx = lowerBound(arr, target);
return arr[idx];  // Может быть IndexOutOfBounds!

// ПРАВИЛЬНО:
int idx = lowerBound(arr, target);
if (idx < arr.length && arr[idx] == target) {
    return idx;  // Нашли
}
return -1;  // Не нашли
```

### Что отличает новичка от эксперта

| Новичок | Эксперт |
|---------|---------|
| Пишет "по памяти" | Понимает ИНВАРИАНТ цикла |
| Путает lo < hi и lo <= hi | Знает когда какой использовать |
| Один паттерн на все задачи | Разные паттерны: exact, lower, upper, on answer |
| Не тестирует edge cases | Всегда проверяет: пустой массив, 1 элемент, all same |
| Отлаживает долго | Доказывает корректность ДО написания |

---

## Часть 3: Ментальные модели для Binary Search

> **Цель:** дать 3 разных способа ДУМАТЬ о binary search. Выбери тот, который тебе ближе.

### Модель 1: "Пространство поиска"

**Идея:** Представь все возможные позиции как отрезок. Каждый шаг СУЖАЕТ отрезок вдвое.

```
┌─────────────────────────────────────────────────────────────────┐
│                    ПРОСТРАНСТВО ПОИСКА                          │
│                                                                 │
│   Начало: [0 ─────────────────────────────────────────────── n] │
│                              ↓                                  │
│   Шаг 1:  [0 ─────────────── mid ────────────────────────── n]  │
│           target > mid → правая половина                        │
│                              ↓                                  │
│   Шаг 2:          [mid ─────── mid' ────────────────────── n]   │
│           target < mid' → левая половина                        │
│                              ↓                                  │
│   Шаг 3:          [mid ─────── mid'' ───── mid']                │
│                              ↓                                  │
│   ...пока не останется 1 элемент                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Инвариант:** Ответ ВСЕГДА находится в [low, high].
**Когда использовать:** Для стандартного binary search и "binary search on answer".

### Модель 2: "Зелёные и красные"

**Идея:** Представь массив как последовательность "зелёных" и "красных" элементов. Ищем ГРАНИЦУ между ними.

```
┌─────────────────────────────────────────────────────────────────┐
│                    ЗЕЛЁНЫЕ И КРАСНЫЕ                            │
│                                                                 │
│   Массив:  [🟢, 🟢, 🟢, 🟢, 🟢, 🔴, 🔴, 🔴, 🔴]                  │
│             ↑                    ↑                              │
│           зелёные              красные                          │
│                      ↑                                          │
│                   ГРАНИЦА                                       │
│                                                                 │
│   Lower bound: первый 🔴 (первый элемент >= target)             │
│   Upper bound: первый 🔴 (первый элемент > target)              │
│                                                                 │
│   Для lower_bound:                                              │
│   🟢 = элементы < target                                        │
│   🔴 = элементы >= target                                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Инвариант:** Слева от low — все 🟢, справа от high — все 🔴.
**Когда использовать:** Для lower/upper bound, для понимания границ.

### Модель 3: "Предикат и монотонность"

**Идея:** Binary search работает с любой монотонной функцией f(x), не только с массивами.

```
┌─────────────────────────────────────────────────────────────────┐
│                    ПРЕДИКАТ И МОНОТОННОСТЬ                      │
│                                                                 │
│   Монотонный предикат P(x):                                     │
│                                                                 │
│   x:    1   2   3   4   5   6   7   8   9   10                  │
│   P(x): F   F   F   F   T   T   T   T   T   T                   │
│                      ↑                                          │
│              первый x где P(x) = True                           │
│                                                                 │
│   Это НЕ обязательно поиск в массиве!                           │
│                                                                 │
│   Примеры:                                                      │
│   • "Можно ли выполнить за x часов?" (Koko Eating Bananas)     │
│   • "Поместится ли в x грузовиков?" (Capacity To Ship)         │
│   • "Можно ли с бюджетом x?" (оптимизация)                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Инвариант:** Если P(x) = True, то P(x+1) = True (монотонность).
**Когда использовать:** Для "binary search on answer", оптимизационных задач.

### Как выбрать модель?

```
                    Какая задача?
                         │
         ┌───────────────┼───────────────┐
         │               │               │
    Найти элемент    Найти границу   Оптимизировать
    в массиве?       (first/last)?   значение?
         │               │               │
         ↓               ↓               ↓
    Модель 1:       Модель 2:       Модель 3:
   "Пространство"  "Зелёные-красные" "Предикат"

    lo <= hi         lo < hi          lo < hi
    exact match    lower/upper     can(mid)?
```

---

## Зачем это нужно?

**Реальная проблема:**

Представьте словарь с 100,000 слов. Как найти слово "programming"?

| Подход | Операций | Время (если 1μs/op) |
|--------|----------|---------------------|
| Линейный поиск | 100,000 | 100 ms |
| Binary Search | 17 | 17 μs |

Binary search в **5,800 раз быстрее** на словаре. Для базы данных с миллиардами записей разница ещё драматичнее.

**Где используется:**

| Область | Применение | Пример |
|---------|------------|--------|
| Базы данных | B-Tree индексы, поиск по ключу | SELECT WHERE id = X |
| Git | git bisect (поиск бага) | Бинарный поиск по коммитам |
| Сети | IP routing (longest prefix match) | Поиск маршрута пакета |
| Компиляторы | Symbol tables | Поиск переменных |
| Игры | Collision detection | Spatial partitioning |
| ML | Hyperparameter tuning | Поиск оптимального learning rate |

**Статистика:**
- Google обрабатывает 8.5 миллиардов поисков/день
- B-Tree в БД делает поиск за O(log n) вместо O(n)
- Без эффективного поиска современные приложения были бы в 1000x медленнее

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| Arrays | Binary search работает с массивами, понимание индексации критично | [[arrays-strings]] |
| Sorting | Binary search требует отсортированные данные | [[sorting-algorithms]] |
| Big O Notation | Понимание O(log n) vs O(n), анализ сложности | [[big-o-complexity]] |
| **CS: Logarithms** | log₂(n) — количество делений n пополам до 1 | Математическая база |
| **CS: Loop Invariants** | Понимание инварианта [low, high] для корректности | Формальная верификация |

---

## Что это такое?

### Объяснение для 5-летнего

Представь игру "Угадай число от 1 до 100":

**Глупый способ (линейный):**
- Это 1? Нет.
- Это 2? Нет.
- Это 3? Нет.
- ... (может занять 100 попыток)

**Умный способ (бинарный):**
- Это больше 50? Да.
- Это больше 75? Нет.
- Это больше 62? Да.
- Это больше 68? Нет.
- Это больше 65? Да.
- Это 67? Нет.
- Это 66? ДА!

7 вопросов вместо 100!

### Формальное определение

**Поиск (Search)** — алгоритм нахождения элемента в структуре данных.

**Binary Search** — алгоритм поиска в отсортированном массиве путём последовательного деления области поиска пополам.

Для отсортированного массива A[0..n-1] и целевого значения target:
- **Инвариант**: target, если существует, находится в A[low..high]
- **Шаг**: сравниваем A[mid] с target и сужаем интервал
- **Результат**: индекс элемента или признак отсутствия

**Сложность**:
- Time: O(log n) — каждая итерация уменьшает пространство поиска вдвое
- Space: O(1) итеративный, O(log n) рекурсивный

---

## Терминология

| Термин | Определение | Пример |
|--------|-------------|--------|
| **Search Space** | Область возможных значений | Массив, диапазон чисел |
| **Target** | Искомый элемент | Число, объект |
| **Lower Bound** | Первый элемент ≥ target | bisect_left в Python |
| **Upper Bound** | Первый элемент > target | bisect_right в Python |
| **Insertion Point** | Позиция для вставки с сохранением порядка | Результат lower/upper bound |
| **Predicate** | Функция проверки условия (true/false) | canFinish(speed) |
| **Monotonic** | Предикат меняется один раз (F→T или T→F) | Условие для binary search |
| **Binary Search on Answer** | Поиск оптимального значения в пространстве ответов | Минимальная скорость, максимальная прибыль |

---

## Как это работает?

### Сравнение алгоритмов поиска

```
                    SEARCH ALGORITHMS
                          │
         ┌────────────────┴────────────────┐
         │                                 │
    UNSORTED DATA                    SORTED DATA
         │                                 │
    Linear Search                    Binary Search
      O(n)                             O(log n)
                                          │
                         ┌────────────────┼────────────────┐
                         │                │                │
                    Lower Bound      Upper Bound      On Answer
                    (первый ≥)       (первый >)     (оптимизация)
```

---

## Linear Search

### Визуализация

```
Target: 7

Array: [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 7]
        ↑
       i=0, 3≠7

Array: [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 7]
           ↑
          i=1, 1≠7

...

Array: [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 7]
                                      ↑
                                    i=10, 7=7 ✓

Found at index 10 (checked 11 elements)
```

### Реализация (Kotlin) — с подробным объяснением

```kotlin
/**
 * Линейный поиск — самый простой алгоритм поиска
 *
 * Идея: проходим по массиву слева направо, сравнивая каждый элемент с target.
 *
 * Сложность: O(n) — в худшем случае проверяем ВСЕ элементы
 * Преимущество: работает на ЛЮБЫХ данных (отсортированных или нет)
 */
fun linearSearch(arr: IntArray, target: Int): Int {
    for (i in arr.indices) {
        if (arr[i] == target) {
            // Нашли! Возвращаем индекс.
            return i
        }
    }
    // Прошли весь массив, ничего не нашли.
    // Возвращаем -1 как "сигнальное значение" (sentinel value).
    // -1 выбран потому что это невалидный индекс массива.
    return -1
}

/**
 * Линейный поиск с ранним выходом — для ОТСОРТИРОВАННЫХ данных
 *
 * Оптимизация: если текущий элемент > target, дальше можно не искать!
 * В отсортированном массиве все следующие элементы ещё больше.
 */
fun linearSearchSorted(arr: IntArray, target: Int): Int {
    for (i in arr.indices) {
        if (arr[i] == target) return i

        // ОПТИМИЗАЦИЯ: если arr[i] > target в отсортированном массиве,
        // все следующие элементы тоже > target (они ещё больше!)
        // Нет смысла проверять дальше.
        if (arr[i] > target) return -1
    }
    return -1
}

// ПРИМЕР: linearSearch([3, 1, 4, 1, 5, 9], target = 5)
// i=0: arr[0]=3 ≠ 5 → продолжаем
// i=1: arr[1]=1 ≠ 5 → продолжаем
// i=2: arr[2]=4 ≠ 5 → продолжаем
// i=3: arr[3]=1 ≠ 5 → продолжаем
// i=4: arr[4]=5 = 5 → НАШЛИ! return 4
```

---

## Binary Search (Standard)

### Визуализация

```
Target: 23
Array: [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
        0  1  2   3   4   5   6   7   8   9

Step 1: low=0, high=9, mid=4
        [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
                      ↑
                   mid=4
        arr[4]=16 < 23, search right: low=5

Step 2: low=5, high=9, mid=7
        [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
                                  ↑
                               mid=7
        arr[7]=56 > 23, search left: high=6

Step 3: low=5, high=6, mid=5
        [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
                          ↑
                       mid=5
        arr[5]=23 == 23, FOUND at index 5!
```

### Реализация (Kotlin) — с подробным объяснением

```kotlin
/**
 * Binary Search — бинарный (двоичный) поиск
 *
 * ТРЕБОВАНИЕ: массив ДОЛЖЕН быть отсортирован!
 *
 * Идея: сравниваем target с СЕРЕДИНОЙ массива.
 * - Если равны — нашли!
 * - Если target < середины — ищем в ЛЕВОЙ половине
 * - Если target > середины — ищем в ПРАВОЙ половине
 *
 * Каждая итерация УМЕНЬШАЕТ пространство поиска ВДВОЕ!
 * Поэтому O(log n), а не O(n).
 */
fun binarySearch(arr: IntArray, target: Int): Int {
    // low и high — границы текущего пространства поиска [low, high]
    var low = 0
    var high = arr.lastIndex

    // Условие: low <= high
    // Почему <=, а не <? Потому что даже один элемент — валидное пространство!
    // Пример: low = 5, high = 5 — нужно проверить arr[5]
    while (low <= high) {
        // Вычисляем индекс середины
        // ВАЖНО: НЕ используем (low + high) / 2!
        // При больших low и high их сумма может переполниться (overflow)
        // Безопасная формула: low + (high - low) / 2
        val mid = low + (high - low) / 2

        when {
            // СЛУЧАЙ 1: Нашли target!
            arr[mid] == target -> return mid

            // СЛУЧАЙ 2: target больше mid — ищем в ПРАВОЙ половине
            // Все элементы arr[low..mid] < target, исключаем их
            arr[mid] < target -> low = mid + 1

            // СЛУЧАЙ 3: target меньше mid — ищем в ЛЕВОЙ половине
            // Все элементы arr[mid..high] > target, исключаем их
            else -> high = mid - 1
        }
    }

    // Цикл закончился (low > high), значит пространство поиска пусто
    // Target не найден
    return -1
}

// ПОШАГОВЫЙ ПРИМЕР: arr = [2, 5, 8, 12, 16, 23, 38], target = 23
//
// Итерация 1: low=0, high=6, mid=3
//   arr[3]=12 < 23 → target справа
//   low = 4
//
// Итерация 2: low=4, high=6, mid=5
//   arr[5]=23 == 23 → НАШЛИ!
//   return 5
//
// Всего 2 итерации вместо 6 (линейный поиск)
```

### Java

```java
public int binarySearch(int[] arr, int target) {
    int low = 0;
    int high = arr.length - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return -1;
}
```

### Python

```python
def binary_search(arr: list, target: int) -> int:
    low, high = 0, len(arr) - 1

    while low <= high:
        mid = low + (high - low) // 2

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1

    return -1
```

### Рекурсивная версия

```kotlin
/**
 * Binary Search — рекурсивная версия
 *
 * Логика та же, но вместо цикла while используем рекурсию.
 * Менее предпочтительна из-за O(log n) памяти на стек вызовов.
 */
fun binarySearchRecursive(
    arr: IntArray,
    target: Int,
    low: Int = 0,
    high: Int = arr.lastIndex
): Int {
    // БАЗА РЕКУРСИИ: пространство поиска пусто (low > high)
    // Это значит, что target нет в массиве
    if (low > high) return -1

    val mid = low + (high - low) / 2

    return when {
        // Нашли!
        arr[mid] == target -> mid

        // Target справа — рекурсивно ищем в [mid+1, high]
        arr[mid] < target -> binarySearchRecursive(arr, target, mid + 1, high)

        // Target слева — рекурсивно ищем в [low, mid-1]
        else -> binarySearchRecursive(arr, target, low, mid - 1)
    }
}

// НЕДОСТАТОК рекурсивной версии:
// - O(log n) памяти на стек вызовов
// - Риск StackOverflow на очень больших массивах
// - Чуть медленнее из-за overhead на вызов функций
//
// Итеративная версия предпочтительнее в production!
```

---

## Lower Bound (First Element ≥ Target)

### Когда нужен

- Найти первое вхождение элемента (в массиве с дубликатами)
- Найти позицию для вставки
- Найти ближайший элемент ≥ target

### Визуализация

```
Target: 5
Array: [1, 2, 4, 5, 5, 5, 8, 9]
        0  1  2  3  4  5  6  7

Standard binary search would return index 3, 4, or 5 (undefined)
Lower bound returns index 3 (FIRST 5)

Target: 6
Array: [1, 2, 4, 5, 5, 5, 8, 9]

Lower bound returns index 6 (first element ≥ 6, which is 8)
```

### Реализация (Kotlin) — с подробным объяснением

```kotlin
/**
 * Lower Bound — первый элемент >= target
 *
 * Это ДРУГОЙ паттерн binary search!
 * Вместо поиска конкретного элемента ищем ГРАНИЦУ.
 *
 * Применение:
 * - Найти позицию для вставки (сохраняя сортировку)
 * - Найти ПЕРВОЕ вхождение (в массиве с дубликатами)
 * - Найти первый элемент >= target
 */
fun lowerBound(arr: IntArray, target: Int): Int {
    var low = 0
    // ВАЖНО: high = arr.size, а НЕ arr.lastIndex!
    // Почему? Потому что ответ может быть ПОСЛЕ последнего элемента.
    // Пример: arr = [1, 2, 3], target = 5 → ответ = 3 (позиция для вставки)
    var high = arr.size

    // Условие: low < high (НЕ <=)
    // Почему? Мы ищем ГРАНИЦУ, а не конкретный элемент.
    // Когда low == high, граница найдена!
    while (low < high) {
        val mid = low + (high - low) / 2

        if (arr[mid] < target) {
            // arr[mid] МЕНЬШЕ target → mid точно не ответ
            // Ищем в правой части, ИСКЛЮЧАЯ mid
            low = mid + 1
        } else {
            // arr[mid] >= target → mid МОЖЕТ быть ответом!
            // Ищем в левой части, ВКЛЮЧАЯ mid
            // (вдруг это первый элемент >= target)
            high = mid
        }
    }

    // Когда цикл заканчивается: low == high
    // Это и есть позиция первого элемента >= target
    // (или arr.size, если все элементы < target)
    return low
}

/**
 * Найти первое вхождение target
 *
 * Используем lower_bound, но нужно проверить:
 * 1. lb не выходит за границы
 * 2. arr[lb] действительно равен target
 */
fun findFirst(arr: IntArray, target: Int): Int {
    val lb = lowerBound(arr, target)
    // Проверяем: lb < arr.size (не вышли за границы)
    //           arr[lb] == target (нашли именно target, а не больший элемент)
    return if (lb < arr.size && arr[lb] == target) lb else -1
}

// ПОШАГОВЫЙ ПРИМЕР: arr = [1, 2, 4, 5, 5, 5, 8, 9], target = 5
//
// Итерация 1: low=0, high=8, mid=4
//   arr[4]=5 >= 5 → high = 4
//
// Итерация 2: low=0, high=4, mid=2
//   arr[2]=4 < 5 → low = 3
//
// Итерация 3: low=3, high=4, mid=3
//   arr[3]=5 >= 5 → high = 3
//
// low=3, high=3 → return 3
// arr[3] = 5 — это ПЕРВОЕ вхождение 5!
//
// Сравни со стандартным binary search: он мог бы вернуть 3, 4 или 5
```

### Python (using bisect)

```python
import bisect

def lower_bound(arr: list, target: int) -> int:
    return bisect.bisect_left(arr, target)

def find_first(arr: list, target: int) -> int:
    lb = bisect.bisect_left(arr, target)
    return lb if lb < len(arr) and arr[lb] == target else -1
```

---

## Upper Bound (First Element > Target)

### Когда нужен

- Найти последнее вхождение элемента
- Подсчитать количество элементов ≤ target
- Найти диапазон равных элементов

### Реализация (Kotlin) — с подробным объяснением

```kotlin
/**
 * Upper Bound — первый элемент СТРОГО БОЛЬШЕ target (>)
 *
 * Отличие от Lower Bound:
 * - Lower Bound: первый >= target
 * - Upper Bound: первый > target
 *
 * Применение:
 * - Найти ПОСЛЕДНЕЕ вхождение: upperBound(x) - 1
 * - Подсчитать количество: upperBound(x) - lowerBound(x)
 */
fun upperBound(arr: IntArray, target: Int): Int {
    var low = 0
    var high = arr.size

    while (low < high) {
        val mid = low + (high - low) / 2

        // КЛЮЧЕВОЕ ОТЛИЧИЕ от lower bound: используем <= вместо <
        // Это "проталкивает" равные элементы влево,
        // так что результат — первый элемент СТРОГО БОЛЬШЕ target
        if (arr[mid] <= target) {
            low = mid + 1  // mid <= target, ищем правее
        } else {
            high = mid  // mid > target, это может быть ответ
        }
    }

    // low == high == первый элемент > target
    return low
}

/**
 * Найти ПОСЛЕДНЕЕ вхождение target
 *
 * Идея: upper_bound возвращает первый элемент > target
 * Значит последнее вхождение target — это upper_bound - 1
 */
fun findLast(arr: IntArray, target: Int): Int {
    val ub = upperBound(arr, target)
    // Проверяем: ub > 0 (есть элемент слева)
    //           arr[ub - 1] == target (он равен target)
    return if (ub > 0 && arr[ub - 1] == target) ub - 1 else -1
}

/**
 * Подсчитать количество вхождений target
 *
 * upper_bound(x) - lower_bound(x) = количество элементов, равных x
 *
 * Пример: arr = [1, 2, 5, 5, 5, 8, 9], target = 5
 * lower_bound(5) = 2 (первая 5)
 * upper_bound(5) = 5 (первый элемент > 5, это 8)
 * Количество = 5 - 2 = 3 пятёрки ✓
 */
fun countOccurrences(arr: IntArray, target: Int): Int {
    return upperBound(arr, target) - lowerBound(arr, target)
}

// ПОШАГОВЫЙ ПРИМЕР: arr = [1, 2, 5, 5, 5, 8, 9], target = 5
//
// upperBound(5):
//   low=0, high=7, mid=3: arr[3]=5 <= 5 → low=4
//   low=4, high=7, mid=5: arr[5]=8 > 5 → high=5
//   low=4, high=5, mid=4: arr[4]=5 <= 5 → low=5
//   low=5, high=5 → return 5
//   arr[5] = 8 — первый элемент > 5
//
// Последняя 5 находится на позиции upperBound - 1 = 4 ✓
```

---

## Binary Search on Answer

### Идея

Вместо поиска элемента в массиве, ищем **оптимальное значение ответа** в пространстве возможных ответов.

**Требования:**
1. Ответ лежит в известном диапазоне [low, high]
2. Есть **монотонный предикат** can(x)
3. Предикат вычисляется за O(n) или лучше

### Паттерн: Минимизация

```
Найти МИНИМАЛЬНОЕ x такое, что can(x) = true

can(x): [F, F, F, F, T, T, T, T, T]  ← Предикат
         ↑           ↑
        low         answer = first T
```

```kotlin
/**
 * Binary Search on Answer — минимизация
 *
 * Идея: ищем МИНИМАЛЬНОЕ значение, при котором условие выполняется.
 *
 * ВАЖНО: предикат должен быть МОНОТОННЫМ!
 * То есть если can(x) = true, то can(x+1) тоже = true
 * [F, F, F, T, T, T, T] — монотонный (один переход F→T)
 * [F, T, F, T, F] — НЕ монотонный (binary search не сработает!)
 *
 * @param low минимальное возможное значение ответа
 * @param high максимальное возможное значение ответа
 * @param canAchieve функция проверки: можно ли достичь цели с данным значением?
 */
fun findMinimum(low: Long, high: Long, canAchieve: (Long) -> Boolean): Long {
    var lo = low
    var hi = high

    while (lo < hi) {
        val mid = lo + (hi - lo) / 2

        if (canAchieve(mid)) {
            // mid работает! Но мы ищем МИНИМУМ, поэтому пробуем меньше.
            // ВКЛЮЧАЕМ mid в рассмотрение (вдруг это и есть минимум)
            hi = mid
        } else {
            // mid НЕ работает. Нужно больше.
            // ИСКЛЮЧАЕМ mid и всё что левее
            lo = mid + 1
        }
    }

    // lo == hi == минимальное значение, при котором canAchieve = true
    return lo
}
```

### Паттерн: Максимизация

```
Найти МАКСИМАЛЬНОЕ x такое, что can(x) = true

can(x): [T, T, T, T, T, F, F, F, F]  ← Предикат
                    ↑
                  answer = last T
```

```kotlin
/**
 * Binary Search on Answer — максимизация
 *
 * Идея: ищем МАКСИМАЛЬНОЕ значение, при котором условие ещё выполняется.
 *
 * ВАЖНО: здесь предикат "обратный": если can(x) = true, то can(x-1) тоже = true
 * [T, T, T, T, F, F, F] — ищем последнюю T
 */
fun findMaximum(low: Long, high: Long, canAchieve: (Long) -> Boolean): Long {
    var lo = low
    var hi = high

    while (lo < hi) {
        // КЛЮЧЕВОЕ ОТЛИЧИЕ: округляем ВВЕРХ!
        // Почему? Чтобы избежать бесконечного цикла.
        //
        // Пример проблемы (без +1):
        //   lo=5, hi=6, mid = 5 + (6-5)/2 = 5
        //   Если canAchieve(5) = true, то lo = mid = 5
        //   lo=5, hi=6 → БЕСКОНЕЧНЫЙ ЦИКЛ!
        //
        // С +1:
        //   lo=5, hi=6, mid = 5 + (6-5+1)/2 = 6
        //   Если canAchieve(6) = true, то lo = 6
        //   Если canAchieve(6) = false, то hi = 5
        //   В обоих случаях прогресс!
        val mid = lo + (hi - lo + 1) / 2

        if (canAchieve(mid)) {
            // mid работает! Пробуем больше.
            lo = mid  // ВКЛЮЧАЕМ mid (вдруг это максимум)
        } else {
            // mid НЕ работает. Нужно меньше.
            hi = mid - 1  // ИСКЛЮЧАЕМ mid
        }
    }

    // lo == hi == максимальное значение, при котором canAchieve = true
    return lo
}
```

### Пример: Koko Eating Bananas (LeetCode 875)

```
Koko ест бананы. У неё n кучек бананов.
Она ест k бананов в час. Если в кучке меньше k — съедает всю кучку за час.
Найти МИНИМАЛЬНУЮ скорость k, чтобы съесть все бананы за h часов.

Piles: [3, 6, 7, 11], h = 8
```

```kotlin
/**
 * Koko Eating Bananas — классический пример Binary Search on Answer
 *
 * Почему подходит binary search?
 * 1. Диапазон ответов известен: [1, max(piles)]
 * 2. Предикат монотонный: если можно съесть за k, то за k+1 тоже можно
 *
 * Мы ищем МИНИМУМ, поэтому используем паттерн минимизации.
 */
fun minEatingSpeed(piles: IntArray, h: Int): Int {
    // Пространство поиска:
    // - Минимальная скорость = 1 банан/час (меньше нельзя)
    // - Максимальная скорость = max(piles) (съедаем самую большую кучку за 1 час)
    //   Быстрее не имеет смысла — всё равно каждая кучка занимает минимум 1 час
    var low = 1
    var high = piles.max()

    while (low < high) {
        val mid = low + (high - low) / 2

        if (canFinish(piles, mid, h)) {
            // Успеваем со скоростью mid! Но может хватит и медленнее?
            high = mid
        } else {
            // Не успеваем со скоростью mid. Нужно быстрее.
            low = mid + 1
        }
    }

    return low
}

/**
 * Предикат: можно ли съесть все бананы за h часов со скоростью k?
 *
 * Для каждой кучки считаем время: ceil(pile / k)
 * Суммируем и проверяем, что сумма <= h
 */
fun canFinish(piles: IntArray, k: Int, h: Int): Boolean {
    var hours = 0L  // Long чтобы избежать overflow
    for (pile in piles) {
        // Сколько часов нужно на эту кучку?
        // ceil(pile / k) = (pile + k - 1) / k — трюк для целочисленного деления с округлением вверх
        // Пример: pile=7, k=3 → (7+3-1)/3 = 9/3 = 3 часа ✓ (вместо 7/3=2)
        hours += (pile + k - 1) / k
    }
    // Успеваем, если общее время <= h
    return hours <= h
}

// ПОШАГОВЫЙ ПРИМЕР: piles = [3, 6, 7, 11], h = 8
//
// low=1, high=11
//
// mid=6: canFinish(6)? 1+1+2+2=6 <= 8 ✓ → high=6
// mid=3: canFinish(3)? 1+2+3+4=10 > 8 ✗ → low=4
// mid=5: canFinish(5)? 1+2+2+3=8 <= 8 ✓ → high=5
// mid=4: canFinish(4)? 1+2+2+3=8 <= 8 ✓ → high=4
// low=4, high=4 → return 4
//
// Ответ: k = 4 банана/час
// Проверка: ceil(3/4)+ceil(6/4)+ceil(7/4)+ceil(11/4) = 1+2+2+3 = 8 часов ✓
```

---

## Modified Binary Search Patterns

Эти паттерны — модификации binary search для особых структур данных.

### 1. Search in Rotated Sorted Array

```
Исходный массив: [0, 1, 2, 4, 5, 6, 7]
После поворота:  [4, 5, 6, 7, 0, 1, 2]
                          ↑
                    точка поворота

Ключевое наблюдение: ОДНА из половин ВСЕГДА отсортирована!
```

```kotlin
/**
 * Поиск в повёрнутом отсортированном массиве
 *
 * Массив был отсортирован, затем "повёрнут" — часть с начала
 * перенесена в конец.
 *
 * Пример: [1,2,3,4,5] → [4,5,1,2,3] (поворот на 2 позиции)
 *
 * Идея: хотя весь массив не отсортирован, ОДНА из половин
 * (левая или правая от mid) ВСЕГДА отсортирована!
 * Это позволяет использовать binary search.
 */
fun searchRotated(nums: IntArray, target: Int): Int {
    var low = 0
    var high = nums.lastIndex

    while (low <= high) {
        val mid = low + (high - low) / 2

        if (nums[mid] == target) return mid

        // КЛЮЧЕВОЙ ШАГ: определяем, какая половина отсортирована
        if (nums[low] <= nums[mid]) {
            // ЛЕВАЯ половина [low..mid] отсортирована
            // (nums[low] <= nums[mid] значит нет "разрыва" слева)

            if (target >= nums[low] && target < nums[mid]) {
                // target попадает в отсортированный диапазон [low, mid)
                // Ищем слева
                high = mid - 1
            } else {
                // target НЕ в [low, mid) → он справа (в "неотсортированной" части)
                low = mid + 1
            }
        } else {
            // ПРАВАЯ половина [mid..high] отсортирована
            // (nums[low] > nums[mid] значит "разрыв" слева от mid)

            if (target > nums[mid] && target <= nums[high]) {
                // target попадает в отсортированный диапазон (mid, high]
                // Ищем справа
                low = mid + 1
            } else {
                // target НЕ в (mid, high] → он слева
                high = mid - 1
            }
        }
    }

    return -1
}

// ПОШАГОВЫЙ ПРИМЕР: nums = [4, 5, 6, 7, 0, 1, 2], target = 0
//
// low=0, high=6, mid=3: nums[3]=7
//   nums[0]=4 <= nums[3]=7 → левая часть [4,5,6,7] отсортирована
//   target=0 в [4,7)? НЕТ → ищем справа: low=4
//
// low=4, high=6, mid=5: nums[5]=1
//   nums[4]=0 <= nums[5]=1 → левая часть [0,1] отсортирована
//   target=0 в [0,1)? ДА → ищем слева: high=4
//
// low=4, high=4, mid=4: nums[4]=0 == target → return 4 ✓
```

### 2. Find Peak Element

```
Массив: [1, 2, 3, 1]
             ↑
         пик на индексе 2

Ключевое наблюдение: если arr[mid] < arr[mid+1], пик СПРАВА
```

```kotlin
/**
 * Найти пиковый элемент — элемент больше соседей
 *
 * Пик: элемент, который больше левого И правого соседа.
 * Гарантируется, что хотя бы один пик существует.
 * (Крайние элементы считаются больше "несуществующих" соседей)
 *
 * Идея: смотрим на mid и mid+1
 * - Если mid < mid+1 → мы на "восходящем склоне", пик СПРАВА
 * - Если mid > mid+1 → мы на "нисходящем склоне" или на пике, пик СЛЕВА или здесь
 */
fun findPeakElement(nums: IntArray): Int {
    var low = 0
    var high = nums.lastIndex

    while (low < high) {
        val mid = low + (high - low) / 2

        if (nums[mid] < nums[mid + 1]) {
            // Восходящий склон: nums[mid] < nums[mid+1]
            // Пик точно справа от mid (мы ещё поднимаемся)
            // mid НЕ может быть пиком, исключаем его
            low = mid + 1
        } else {
            // Нисходящий склон или пик: nums[mid] > nums[mid+1]
            // mid МОЖЕТ быть пиком — не исключаем его
            high = mid
        }
    }

    // Когда low == high, мы нашли пик
    return low
}

// ВИЗУАЛИЗАЦИЯ:
//
//     3       ← пик
//    / \
//   2   1
//  /
// 1
// [1, 2, 3, 1]
//  0  1  2  3
//
// mid=1: nums[1]=2 < nums[2]=3 → восходящий, low=2
// mid=2: nums[2]=3 > nums[3]=1 → нисходящий или пик, high=2
// low=2, high=2 → return 2 ✓
```

### 3. Find Minimum in Rotated Sorted Array

```kotlin
/**
 * Найти минимум в повёрнутом отсортированном массиве
 *
 * Минимум — это "точка поворота", где массив был разрезан.
 *
 * Пример: [4, 5, 6, 7, 0, 1, 2]
 *                     ↑
 *            минимум (точка поворота)
 *
 * Идея: сравниваем mid с ПРАВЫМ краем (high), а не с левым!
 * - Если nums[mid] > nums[high] → минимум СПРАВА (есть "разрыв")
 * - Если nums[mid] <= nums[high] → минимум СЛЕВА или это mid
 */
fun findMin(nums: IntArray): Int {
    var low = 0
    var high = nums.lastIndex

    while (low < high) {
        val mid = low + (high - low) / 2

        if (nums[mid] > nums[high]) {
            // nums[mid] > nums[high] означает, что "разрыв" справа от mid
            // Минимум находится в (mid, high] — справа
            // mid точно НЕ минимум (он больше чего-то справа)
            low = mid + 1
        } else {
            // nums[mid] <= nums[high] означает, что [mid, high] отсортирован
            // Минимум — либо mid, либо левее
            high = mid  // Не исключаем mid — он может быть минимумом
        }
    }

    // low == high → нашли минимум
    return nums[low]
}

// ПОШАГОВЫЙ ПРИМЕР: nums = [4, 5, 6, 7, 0, 1, 2]
//
// low=0, high=6, mid=3: nums[3]=7 > nums[6]=2 → low=4
// low=4, high=6, mid=5: nums[5]=1 <= nums[6]=2 → high=5
// low=4, high=5, mid=4: nums[4]=0 <= nums[5]=1 → high=4
// low=4, high=4 → return nums[4] = 0 ✓
```

### 4. Search in 2D Matrix

```
Представляем 2D матрицу как 1D отсортированный массив:

Матрица:          Как 1D:
[1,  3,  5]      [1, 3, 5, 7, 10, 11, 16, 20, 23]
[7, 10, 11]       0  1  2  3   4   5   6   7   8
[16,20, 23]

Преобразование индекса:
1D индекс 5 → row = 5/3 = 1, col = 5%3 = 2 → matrix[1][2] = 11
```

```kotlin
/**
 * Поиск в 2D матрице (каждая строка отсортирована, первый элемент строки > последнего предыдущей)
 *
 * Идея: такую матрицу можно представить как один отсортированный массив!
 *
 * Преобразование 1D индекса в 2D координаты:
 * - row = index / cols (целочисленное деление)
 * - col = index % cols (остаток от деления)
 *
 * Пример: 3 столбца, индекс 5
 * row = 5 / 3 = 1
 * col = 5 % 3 = 2
 * → matrix[1][2]
 */
fun searchMatrix(matrix: Array<IntArray>, target: Int): Boolean {
    val rows = matrix.size
    val cols = matrix[0].size
    // Общее количество элементов
    var low = 0
    var high = rows * cols - 1

    while (low <= high) {
        val mid = low + (high - low) / 2

        // Преобразуем 1D индекс mid в 2D координаты
        // mid / cols = номер строки
        // mid % cols = номер столбца
        val midVal = matrix[mid / cols][mid % cols]

        when {
            midVal == target -> return true
            midVal < target -> low = mid + 1
            else -> high = mid - 1
        }
    }

    return false
}

// ПОШАГОВЫЙ ПРИМЕР:
// matrix = [[1,3,5], [7,10,11], [16,20,23]], target = 10
// rows=3, cols=3, всего 9 элементов
//
// low=0, high=8, mid=4
//   row=4/3=1, col=4%3=1 → matrix[1][1]=10 == target → return true ✓
```

---

## Использование стандартной библиотеки

На практике используйте встроенные функции — они оптимизированы и протестированы.

### Kotlin

```kotlin
// ==================== МАССИВЫ ====================

val arr = intArrayOf(1, 3, 5, 7, 9)

// binarySearch возвращает индекс найденного элемента
val index = arr.binarySearch(5)  // Возвращает 2

// ==================== СПИСКИ ====================

val list = listOf(1, 3, 5, 7, 9)
val listIndex = list.binarySearch(5)  // Возвращает 2

// ==================== ЕСЛИ НЕ НАЙДЕН ====================

// ВАЖНО: если элемент не найден, возвращается отрицательное число!
// Формула: -(insertionPoint + 1)
// Где insertionPoint — позиция, куда НУЖНО вставить элемент
val notFound = arr.binarySearch(4)  // Возвращает -3
// Расшифровка: -(2 + 1) = -3, значит insertion point = 2
// 4 нужно вставить на позицию 2: [1, 3, 4, 5, 7, 9]

// Как получить insertion point из отрицательного результата:
val insertionPoint = -(notFound + 1)  // = 2

// ==================== ПОИСК ПО ПОЛЮ ====================

data class Person(val name: String, val age: Int)
val people = listOf(Person("Alice", 25), Person("Bob", 30))
    .sortedBy { it.age }

// binarySearchBy — поиск по конкретному полю
people.binarySearchBy(30) { it.age }  // Возвращает 1 (Bob)
```

### Java

```java
// ==================== МАССИВЫ ====================

int[] arr = {1, 3, 5, 7, 9};
int index = Arrays.binarySearch(arr, 5);  // Возвращает 2

// Если не найден: тот же формат -(insertionPoint + 1)

// ==================== КОЛЛЕКЦИИ ====================

List<Integer> list = Arrays.asList(1, 3, 5, 7, 9);
int listIndex = Collections.binarySearch(list, 5);  // Возвращает 2

// ==================== КАСТОМНЫЙ КОМПАРАТОР ====================

// Поиск по объектам с компаратором
Arrays.binarySearch(people, targetPerson,
    Comparator.comparingInt(Person::getAge));
```

### Python

```python
import bisect

arr = [1, 3, 5, 7, 9]

# ==================== LOWER BOUND ====================
# bisect_left: первый элемент >= target (как lower_bound в C++)
bisect.bisect_left(arr, 5)   # Возвращает 2 (индекс первой 5)
bisect.bisect_left(arr, 4)   # Возвращает 2 (позиция для вставки 4)

# ==================== UPPER BOUND ====================
# bisect_right: первый элемент > target (как upper_bound в C++)
bisect.bisect_right(arr, 5)  # Возвращает 3 (индекс первого элемента > 5)

# ==================== ВСТАВКА С СОХРАНЕНИЕМ ПОРЯДКА ====================
# insort_left/insort_right: вставляет элемент в правильную позицию
bisect.insort_left(arr, 4)   # arr становится [1, 3, 4, 5, 7, 9]

# ==================== КОЛИЧЕСТВО ЭЛЕМЕНТОВ ====================
# Количество элементов равных x:
count = bisect.bisect_right(arr, x) - bisect.bisect_left(arr, x)
```

---

## Сложность операций

| Алгоритм | Time (Average) | Time (Worst) | Space | Требования |
|----------|----------------|--------------|-------|------------|
| Linear Search | O(n) | O(n) | O(1) | Нет |
| Binary Search | O(log n) | O(log n) | O(1) | Отсортированные данные |
| Lower/Upper Bound | O(log n) | O(log n) | O(1) | Отсортированные данные |
| Interpolation | O(log log n) | O(n) | O(1) | Равномерное распределение |
| Exponential | O(log i) | O(log n) | O(1) | Неограниченный список |

### Почему Binary Search O(log n)?

```
n элементов
После 1-й итерации: n/2
После 2-й итерации: n/4
После 3-й итерации: n/8
...
После k-й итерации: n/2^k

Заканчиваем когда n/2^k = 1
Решаем: k = log₂(n)

Пример: n = 1,000,000
k = log₂(1,000,000) ≈ 20 итераций
```

---

## Распространённые ошибки

### 1. Overflow при вычислении mid

```kotlin
// ❌ WRONG: Can overflow for large arrays
val mid = (low + high) / 2  // If low + high > Int.MAX_VALUE

// ✅ CORRECT: Safe calculation
val mid = low + (high - low) / 2
```

### 2. Неправильное условие цикла

```kotlin
// ❌ WRONG: Misses target at boundaries
while (low < high) {  // For standard binary search
    // ...
}

// ✅ CORRECT: Includes case when low == high
while (low <= high) {
    // ...
}

// Note: For lower/upper bound, use low < high (different pattern!)
```

### 3. Бесконечный цикл при максимизации

```kotlin
// ❌ WRONG: Infinite loop when low + 1 == high
fun findMaximumWrong(low: Int, high: Int): Int {
    var lo = low
    var hi = high

    while (lo < hi) {
        val mid = lo + (hi - lo) / 2  // Rounds DOWN
        if (canAchieve(mid)) {
            lo = mid  // Never moves if mid == lo
        } else {
            hi = mid - 1
        }
    }
    return lo
}

// ✅ ПРАВИЛЬНО: Округляем ВВЕРХ для максимизации
fun findMaximumCorrect(low: Int, high: Int): Int {
    var lo = low
    var hi = high

    while (lo < hi) {
        // +1 в числителе — округление вверх, предотвращает застревание
        val mid = lo + (hi - lo + 1) / 2
        if (canAchieve(mid)) {
            lo = mid
        } else {
            hi = mid - 1
        }
    }
    return lo
}
```

### 4. Забыли проверить границы

```kotlin
// ❌ WRONG: Doesn't handle edge cases
fun findFirst(arr: IntArray, target: Int): Int {
    val lb = lowerBound(arr, target)
    return lb  // What if lb == arr.size?
}

// ✅ ПРАВИЛЬНО: Проверяем границы
fun findFirstCorrect(arr: IntArray, target: Int): Int {
    val lb = lowerBound(arr, target)
    // lb может быть = arr.size (если все элементы < target)
    // arr[lb] может быть != target (если target нет в массиве)
    // Поэтому ОБЯЗАТЕЛЬНО проверяем оба условия!
    return if (lb < arr.size && arr[lb] == target) lb else -1
}
```

### 5. Путаница с inclusive/exclusive границами

```kotlin
// ❌ CONFUSING: Mixed conventions
fun confusingSearch(arr: IntArray, target: Int): Int {
    var low = 0
    var high = arr.size  // Exclusive

    while (low <= high) {  // But condition is for inclusive!
        val mid = low + (high - low) / 2
        if (arr[mid] == target) return mid  // IndexOutOfBounds!
        // ...
    }
    return -1
}

// ✅ CORRECT: Pick one convention and stick to it

// Option A: [low, high] inclusive
fun inclusiveSearch(arr: IntArray, target: Int): Int {
    var low = 0
    var high = arr.lastIndex  // Inclusive

    while (low <= high) {  // Matches inclusive
        // ...
    }
    return -1
}

// Option B: [low, high) half-open (for lower/upper bound)
fun halfOpenSearch(arr: IntArray, target: Int): Int {
    var low = 0
    var high = arr.size  // Exclusive

    while (low < high) {  // Matches half-open
        // ...
    }
    return low
}
```

### 6. Не учли дубликаты

```kotlin
// ❌ WRONG: Returns arbitrary occurrence
fun findInDuplicates(arr: IntArray, target: Int): Int {
    // Standard binary search
    // [1, 2, 2, 2, 3] searching for 2 might return index 1, 2, or 3
}

// ✅ CORRECT: Use lower/upper bound for specific occurrence
fun findFirstOccurrence(arr: IntArray, target: Int): Int {
    return lowerBound(arr, target).let {
        if (it < arr.size && arr[it] == target) it else -1
    }
}
```

---

## Когда какой алгоритм использовать

### Decision Tree

```
                     Need to search?
                          │
             ┌────────────┴────────────┐
             │                         │
        Sorted data?               Unsorted?
             │                         │
             ↓                         ↓
     Binary Search              Linear Search
        O(log n)                    O(n)
             │
    ┌────────┴────────┬──────────┐
    │                 │          │
 Exact match?   First/Last?   Optimization?
    │                 │          │
    ↓                 ↓          ↓
 Standard BS    Lower/Upper   BS on Answer
               Bound
```

### Summary Table

| Ситуация | Алгоритм | Сложность |
|----------|----------|-----------|
| Неотсортированные данные | Linear Search | O(n) |
| Точный поиск в sorted | Binary Search | O(log n) |
| Первое/последнее вхождение | Lower/Upper Bound | O(log n) |
| Позиция для вставки | Lower Bound | O(log n) |
| Количество элементов в диапазоне | Upper - Lower | O(log n) |
| Минимум/максимум с условием | Binary Search on Answer | O(log(range) × check) |
| Rotated sorted array | Modified Binary Search | O(log n) |
| Peak/valley finding | Modified Binary Search | O(log n) |
| 2D sorted matrix | Binary Search (1D mapping) | O(log(m×n)) |

---

## Практика

### Концептуальные вопросы

1. **Почему binary search работает только на sorted данных?**

   *Ответ:* Binary search использует сравнение с mid для исключения половины элементов. Это работает только если элементы упорядочены — мы знаем, что target либо слева (если меньше mid), либо справа (если больше).

2. **В чём разница между lower_bound и upper_bound?**

   *Ответ:* `lower_bound(x)` — первый элемент ≥ x. `upper_bound(x)` — первый элемент > x. Для подсчёта вхождений x: `upper_bound(x) - lower_bound(x)`.

3. **Когда использовать `lo < hi` vs `lo <= hi`?**

   *Ответ:* `lo <= hi` для standard binary search (ищем конкретный элемент). `lo < hi` для boundary finding (lower/upper bound) — когда lo == hi, мы нашли границу.

4. **Почему для максимизации нужно округлять mid вверх?**

   *Ответ:* При `lo = mid` и округлении вниз, если `hi = lo + 1`, то `mid = lo`, и мы застрянем в бесконечном цикле. Округление вверх гарантирует, что mid > lo.

5. **Как определить, подходит ли задача для Binary Search on Answer?**

   *Ответ:* Три условия: (1) Ищем min/max значение, (2) Ответ в известном диапазоне, (3) Есть монотонный предикат — если x работает и мы ищем min, то x+1 тоже работает.

### LeetCode задачи

#### Easy
- **704. Binary Search** — базовый поиск
- **35. Search Insert Position** — lower bound
- **278. First Bad Version** — binary search on answer

#### Medium
- **33. Search in Rotated Sorted Array** — modified BS
- **34. Find First and Last Position** — lower/upper bound
- **162. Find Peak Element** — mountain pattern
- **153. Find Minimum in Rotated Sorted Array** — find pivot
- **74. Search a 2D Matrix** — 1D mapping
- **875. Koko Eating Bananas** — BS on answer (минимизация)
- **1011. Capacity To Ship Packages** — BS on answer
- **540. Single Element in Sorted Array** — XOR + BS

#### Hard
- **4. Median of Two Sorted Arrays** — binary search на позиции разделения
- **410. Split Array Largest Sum** — BS on answer (минимизация максимума)
- **378. Kth Smallest Element in a Sorted Matrix** — BS on value space
- **354. Russian Doll Envelopes** — LIS with binary search

---

## Связанные темы

### Prerequisites (что нужно знать до)
- [Arrays & Basic Operations](../data-structures/arrays.md)
- [Sorting Algorithms](./sorting-algorithms.md) — данные должны быть отсортированы
- [Time Complexity Analysis](../overview.md)

### Что открывает (изучить после)
- [Binary Search Pattern](../patterns/binary-search-pattern.md) — углублённые паттерны
- [Two Pointers](../patterns/two-pointers-pattern.md) — часто используется вместе
- [Divide and Conquer](./divide-and-conquer.md) — общий паттерн
- [Trees (Binary Search Tree)](../data-structures/trees-binary.md) — структура на основе BS

---

## Мифы и заблуждения

| Миф | Реальность |
|-----|-----------|
| "Binary Search простой" | 90% багов в BS — **off-by-one errors**. lo < hi vs lo <= hi, mid vs mid+1 критичны |
| "Нужен отсортированный массив" | BS работает на любом **монотонном предикате**. Binary Search on Answer не требует массив |
| "mid = (lo + hi) / 2 всегда работает" | **Overflow** при lo + hi > INT_MAX. Используй `lo + (hi - lo) / 2` |
| "Linear search бесполезен" | Для **неотсортированных данных** или n < 100 linear search проще и достаточно быстр |
| "Ternary search быстрее binary search" | Ternary search делает **2 сравнения** за итерацию. Binary — 1. Binary search часто быстрее |

---

## CS-фундамент

| CS-концепция | Применение в Searching |
|--------------|----------------------|
| **Logarithmic Complexity** | Binary Search O(log n): на каждом шаге уменьшаем пространство поиска вдвое |
| **Sorted Data Invariant** | Binary Search требует монотонность. Нарушение — неопределённое поведение |
| **Binary Search on Answer** | Ищем значение, а не индекс. Монотонный предикат check(x) |
| **Lower/Upper Bound** | lower_bound: первый ≥ x, upper_bound: первый > x. Основа для range queries |
| **Divide and Conquer** | Разбиваем задачу пополам на каждом шаге. Рекуррентность T(n) = T(n/2) + O(1) |

---

## Источники

1. [Tech Interview Handbook - Sorting & Searching](https://www.techinterviewhandbook.org/algorithms/sorting-searching/) — Interview tips
2. [CP Algorithms - Binary Search](https://cp-algorithms.com/num_methods/binary_search.html) — Lower/Upper bound
3. [Wikipedia - Binary Search](https://en.wikipedia.org/wiki/Binary_search_algorithm) — Theory
4. [InterviewBit - Binary Search Errors](https://www.interviewbit.com/tutorial/binary-search-implementations-and-common-errors/) — Common mistakes
5. [AlgoMonster Templates](https://algo.monster/templates/binary-search) — Code templates
6. [GeeksforGeeks - Binary Search on Answer](https://www.geeksforgeeks.org/dsa/binary-search-on-answer-tutorial-with-problems/) — Pattern
7. [Kotlin Docs - binarySearch](https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.collections/binary-search.html) — Language API
8. [LeetCode - Comprehensive BS Guide](https://leetcode.com/discuss/post/2371234/an-opinionated-guide-to-binary-search-co-1yfw/) — Community guide
9. [Towards Data Science - Binary Search Intuition](https://towardsdatascience.com/everything-you-need-to-know-about-the-binary-search-algorithm-6bc4f9a3127d/) — Visual explanations
10. [USACO Guide - Binary Search](https://usaco.guide/silver/binary-search) — Competitive programming perspective
11. [interviewing.io - Binary Search Interview Questions](https://interviewing.io/binary-search-interview-questions) — Interview patterns
12. [Medium - Binary Search Patterns](https://thebytestream.medium.com/patterns-and-variations-of-the-binary-search-algorithm-0e36b1fb0621) — Variations

---

## Навигация

← Предыдущая: [[sorting-algorithms|Sorting Algorithms]]
→ Следующая: [[recursion-fundamentals|Recursion Fundamentals]]
↑ Вверх: [[_moc-algorithms|Algorithms MOC]]

*Обновлено: 2026-01-06 (добавлены педагогические секции: интуиция, почему сложно, ментальные модели)*
