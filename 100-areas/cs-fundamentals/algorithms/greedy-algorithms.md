# Greedy Algorithms

---
title: "Greedy Algorithms"
created: 2025-12-30
updated: 2026-01-06
type: deep-dive
status: complete
difficulty: intermediate
confidence: high
cs-foundations:
  - greedy-choice-property
  - optimal-substructure
  - locally-optimal-decisions
  - matroid-theory
  - exchange-argument-proof
  - greedy-stays-ahead-proof
prerequisites:
  - "[[sorting-algorithms]]"
  - "[[big-o-complexity]]"
  - "[[arrays-strings]]"
related:
  - "[[dynamic-programming]]"
  - "[[graphs]]"
  - "[[heaps-priority-queues]]"
tags:
  - algorithm
  - greedy
  - optimization
  - interval-scheduling
  - knapsack
  - interview
---

## TL;DR

Greedy algorithms build solutions by making locally optimal choices at each step without reconsidering. Work when **greedy choice property** holds (local optimum leads to global). Must prove correctness via "Greedy Stays Ahead" or "Exchange Argument". Classic examples: Activity Selection, Huffman Coding, Fractional Knapsack, MST (Kruskal/Prim).

---

## Часть 1: Интуиция без кода

### Аналогия 1: Жадный едок в буфете

Представь шведский стол с ограниченным размером тарелки:

```
┌──────────────────────────────────────────────────────────────┐
│                    ШВЕДСКИЙ СТОЛ                             │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  Блюда: 🍗 Курица (вкус: 9, размер: 3)                       │
│         🥗 Салат   (вкус: 4, размер: 2)                       │
│         🍕 Пицца   (вкус: 7, размер: 2)                       │
│         🍰 Торт    (вкус: 8, размер: 3)                       │
│         🍟 Картошка (вкус: 5, размер: 1)                      │
│                                                              │
│  Твоя тарелка вмещает: 5 единиц                              │
│                                                              │
│  ЖАДНЫЙ ПОДХОД:                                               │
│  "Буду брать самое вкусное, что ещё помещается!"             │
│                                                              │
│  Шаг 1: Курица (9) → тарелка: 3/5                            │
│  Шаг 2: Торт (8)? Не влезает! (3+3=6 > 5)                    │
│  Шаг 3: Пицца (7) → тарелка: 5/5 ✓                           │
│                                                              │
│  Итого: Курица + Пицца = 16 вкуса                            │
│                                                              │
│  НО ОПТИМАЛЬНО: Пицца + Торт + Картошка = 7+8+5 = 20!        │
│  (размер: 2+3+1 = 6? Нет, 2+3 = 5, торт не влезает...)       │
│  На самом деле: Салат + Пицца + Картошка = 4+7+5 = 16        │
│  Или: Курица + Салат = 9+4 = 13 (хуже)                       │
│                                                              │
│  Жадный дал 16 — в этом случае ОПТИМАЛЬНО!                   │
│  Но это СЛУЧАЙНОСТЬ, не гарантия                             │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

**Мораль:** Жадный подход — брать "лучшее прямо сейчас". Иногда это работает, иногда нет!

### Аналогия 2: Планирование встреч

Ты менеджер, у тебя 5 встреч с клиентами. Все важны одинаково. Как успеть на максимум?

```
Встречи:
A: 9:00 - 10:30
B: 9:30 - 10:00
C: 10:00 - 11:00
D: 10:30 - 12:00
E: 11:00 - 12:00

Визуализация:
9:00   9:30   10:00   10:30   11:00   11:30   12:00
|---A---|----A----|
       |--B--|
              |---C---|
                     |---D---|----D----|
                             |---E---|

ВОПРОС: Какой жадный выбор?

❌ "Беру первую по времени начала" (A)
   A → (пропускаем B, C) → D или E
   Максимум: 2 встречи

✅ "Беру ту, что ЗАКАНЧИВАЕТСЯ раньше" (B)
   B(10:00) → C(11:00) → E(12:00)
   Максимум: 3 встречи!

ПОЧЕМУ РАБОТАЕТ?
Встреча с РАННИМ концом освобождает БОЛЬШЕ времени для других!
```

### Аналогия 3: Размен денег

Кассир даёт сдачу 47 рублей. Монеты: 25, 10, 5, 1.

```
ЖАДНЫЙ ПОДХОД: "Даю самую крупную, что не превышает остаток"

47 рублей:
├── 25 (осталось 22)
├── 10 (осталось 12)
├── 10 (осталось 2)
├── 1 (осталось 1)
└── 1 (осталось 0)

Итого: 5 монет (25 + 10 + 10 + 1 + 1)
Это ОПТИМАЛЬНО для стандартных монет!

НО! Если монеты [1, 3, 4], сумма 6:

ЖАДНЫЙ: 4 + 1 + 1 = 3 монеты
ОПТИМАЛЬНО: 3 + 3 = 2 монеты!

Жадный ПРОВАЛИЛСЯ на нестандартных номиналах!
```

### Когда Greedy работает? (простой тест)

```
┌─────────────────────────────────────────────────────────────────┐
│                ЧЕКЛИСТ: ПОДХОДИТ ЛИ GREEDY?                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Вопрос 1: Есть ли "жадный выбор"?                             │
│  ─────────────────────────────────                             │
│  Можно ли определить "лучший элемент" на каждом шаге?          │
│  Пример: минимальный конец, максимальный ratio, ближайший...   │
│                                                                 │
│  Вопрос 2: Локальный оптимум ведёт к глобальному?              │
│  ─────────────────────────────────────────────────             │
│  Если взять "лучшее сейчас", не испортит ли это будущее?       │
│  → ДА, испортит → Нужен DP!                                    │
│  → НЕТ → Greedy может работать!                                │
│                                                                 │
│  Вопрос 3: Можно доказать корректность?                        │
│  ──────────────────────────────────────                        │
│  "Greedy Stays Ahead" или "Exchange Argument"?                 │
│  → Не можешь доказать? → Greedy ОПАСЕН! Используй DP.          │
│                                                                 │
│  ⚠️ ГЛАВНОЕ ПРАВИЛО:                                           │
│  Интуиция может обмануть! Без доказательства — не верь!        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Часть 2: Почему Greedy бывает сложен?

### Главная ловушка: "Интуитивно кажется правильным"

```
┌─────────────────────────────────────────────────────────────────┐
│               "ЛОВУШКА ЖАДНОСТИ" (ACM SIGCSE)                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Исследование ACM показало:                                     │
│  75% студентов СНАЧАЛА пробуют жадное решение                  │
│  Но только 30% задач реально решаются жадно!                   │
│                                                                 │
│  ПРОБЛЕМА:                                                      │
│  - Greedy решения ОЧЕНЬ интуитивны                             │
│  - Код простой (10-20 строк)                                   │
│  - Часто проходит примеры в условии                            │
│  - Но ПАДАЕТ на edge cases!                                    │
│                                                                 │
│  ЦИТАТА (Jeff Erickson):                                        │
│  "Интуиция — коварная штука. Единственный способ убедиться,    │
│  что порядок работает — ДОКАЗАТЬ это!"                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Типичные ошибки студентов

| # | Ошибка | Пример | Как избежать |
|---|--------|--------|--------------|
| 1 | **Применяют greedy без доказательства** | 0/1 Knapsack → greedy по ratio | Сначала проверь: есть ли контрпример? |
| 2 | **Неправильный критерий сортировки** | Activity Selection → сортировка по START | Подумай: что ОСВОБОЖДАЕТ больше ресурса? |
| 3 | **Путают Fractional и 0/1** | "Беру по ratio" для целых предметов | Fractional = дроби OK. 0/1 = нужен DP |
| 4 | **Не проверяют edge cases** | Coin Change с номиналами [1, 3, 4] | Всегда тестируй на "некрасивых" примерах |
| 5 | **Думают "greedy = простой = правильный"** | "Код работает на примерах — значит ок" | Примеры в условии — не доказательство! |

### Почему доказательство необходимо?

**Проблема: Greedy может работать на 99% тестов, но упасть на 1%**

```
Пример: Coin Change

Тесты с монетами [1, 5, 10, 25]:
- 41 центов: Greedy даёт 25+10+5+1 = 4 монеты ✓
- 30 центов: Greedy даёт 25+5 = 2 монеты ✓
- 67 центов: Greedy даёт 25+25+10+5+1+1 = 6 монет ✓
Все тесты проходят!

Но с монетами [1, 3, 4]:
- 6 центов: Greedy даёт 4+1+1 = 3 монеты ❌
- Оптимум: 3+3 = 2 монеты!

БЕЗ ДОКАЗАТЕЛЬСТВА — НЕТ ГАРАНТИИ!
```

### Два метода доказательства (обязательно знать!)

```
┌─────────────────────────────────────────────────────────────────┐
│          МЕТОД 1: "GREEDY STAYS AHEAD"                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ИДЕЯ: На каждом шаге показать, что greedy "не хуже" optimal   │
│                                                                 │
│  СТРУКТУРА ДОКАЗАТЕЛЬСТВА:                                      │
│  1. Пусть G = greedy решение, O = оптимальное                  │
│  2. База: g₁ не хуже o₁ (первый выбор)                         │
│  3. Индукция: если gᵢ₋₁ не хуже oᵢ₋₁, то gᵢ не хуже oᵢ        │
│  4. Вывод: greedy не хуже optimal → greedy оптимален           │
│                                                                 │
│  КОГДА ИСПОЛЬЗОВАТЬ:                                            │
│  - Activity Selection                                           │
│  - Scheduling задачи                                            │
│  - Когда есть "порядок" выбора                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│          МЕТОД 2: "EXCHANGE ARGUMENT"                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ИДЕЯ: Любое optimal можно "трансформировать" в greedy          │
│        без ухудшения результата                                 │
│                                                                 │
│  СТРУКТУРА ДОКАЗАТЕЛЬСТВА:                                      │
│  1. Пусть O — optimal, отличается от greedy G                  │
│  2. Найдём ПЕРВОЕ отличие: greedy взял X, optimal взял Y       │
│  3. "Обменяем" Y на X в optimal                                │
│  4. Покажем: результат не ухудшился (или улучшился)            │
│  5. Повторяем пока O ≠ G                                       │
│  6. Вывод: G оптимален                                          │
│                                                                 │
│  КОГДА ИСПОЛЬЗОВАТЬ:                                            │
│  - Fractional Knapsack                                          │
│  - Huffman Coding                                               │
│  - Когда можно "менять" элементы местами                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Когда Greedy точно НЕ работает?

```
КРАСНЫЕ ФЛАГИ — переходи к DP:

1. 0/1 выбор (взять целиком или не взять)
   - 0/1 Knapsack: нельзя взять полпредмета
   - Coin Change с произвольными номиналами

2. Зависимости между выборами
   - Longest Common Subsequence: символы зависят от предыдущих
   - Edit Distance: операции влияют друг на друга

3. Нужны ВСЕ оптимальные комбинации
   - Все пути в графе
   - Все разбиения множества

4. Нет очевидного "локального критерия"
   - Нельзя сказать "берём максимальный/минимальный"
```

---

## Часть 3: Ментальные модели для Greedy

### Модель 1: "Освобождение ресурса" (Resource Liberation)

**Суть:** На каждом шаге выбирай то, что освобождает МАКСИМУМ ресурса для следующих шагов.

```
Activity Selection:
─────────────────────────────────────────────────────────────────
Ресурс = ВРЕМЯ

Встреча A: 9:00-11:00 (занимает 2 часа, освобождает время с 11:00)
Встреча B: 9:00-10:00 (занимает 1 час, освобождает время с 10:00!)

Выбираем B — она РАНЬШЕ освобождает временной слот!

КРИТЕРИЙ: минимальное время ОКОНЧАНИЯ
```

```
Fractional Knapsack:
─────────────────────────────────────────────────────────────────
Ресурс = МЕСТО В РЮКЗАКЕ

Предмет A: 10 кг за $60 (6$/кг)
Предмет B: 20 кг за $80 (4$/кг)

За каждый кг места A даёт БОЛЬШЕ ценности!
Берём A — получаем максимум value/weight.

КРИТЕРИЙ: максимальное VALUE/WEIGHT ratio
```

**Когда использовать:**
- Задачи на интервалы, расписания
- Knapsack-подобные задачи
- Когда есть ограниченный ресурс

### Модель 2: "Жадный до конца" (Greedy to the End)

**Суть:** Расширяй границу возможного, пока можешь.

```
Jump Game:
─────────────────────────────────────────────────────────────────
nums = [2, 3, 1, 1, 4]
         0  1  2  3  4

maxReach = 0

Позиция 0: могу прыгнуть на 0+2=2 → maxReach = 2
Позиция 1: могу прыгнуть на 1+3=4 → maxReach = 4 ← УЖЕ ДОСТИГЛИ!

КРИТЕРИЙ: постоянно обновляй "самую дальнюю достижимую точку"
```

```
Gas Station:
─────────────────────────────────────────────────────────────────
Если "застрял" на позиции j, начав с i:
ВСЕ позиции [i, j] тоже не подходят!

Почему? У них тот же дефицит топлива.

КРИТЕРИЙ: если currentTank < 0, начинай заново со следующей станции
```

**Когда использовать:**
- Задачи на достижимость
- Circular traversal
- Когда нужно найти "стартовую точку"

### Модель 3: "Покрытие интервалами" (Interval Covering)

**Суть:** Минимизируй количество "действий" для покрытия всех требований.

```
Minimum Arrows to Burst Balloons:
─────────────────────────────────────────────────────────────────
Шарики: [1-6], [2-8], [7-12], [10-16]

Сортируем по КОНЦУ: [1-6], [2-8], [7-12], [10-16]

Стрела 1: позиция 6
  - [1-6] ✓ лопнул
  - [2-8] ✓ лопнул (8 >= 6, но начало 2 <= 6)
  - [7-12] ❌ не попала (начало 7 > 6)

Стрела 2: позиция 12
  - [7-12] ✓ лопнул
  - [10-16] ✓ лопнул

КРИТЕРИЙ: стреляй в КОНЕЦ первого непокрытого — захватишь максимум!
```

```
Non-overlapping Intervals:
─────────────────────────────────────────────────────────────────
Эквивалентная задача:
"Удалить минимум интервалов" = "Оставить максимум непересекающихся"

Это Activity Selection!

КРИТЕРИЙ: сортировка по КОНЦУ, жадно выбираем непересекающиеся
```

**Когда использовать:**
- Задачи на интервалы
- Minimum covering
- Activity selection вариации

### Модель 4: "Построение по частям" (Incremental Building)

**Суть:** Постепенно строй решение, добавляя "лучший" элемент.

```
Huffman Coding:
─────────────────────────────────────────────────────────────────
Частоты: A=5, B=9, C=12, D=13, E=16, F=45

Шаг 1: Объединяем ДВА минимальных (A+B = 14)
Шаг 2: Объединяем следующие минимальные (C + D = 25)
...и так далее

КРИТЕРИЙ: всегда объединяй МИНИМАЛЬНЫЕ элементы
```

```
MST (Kruskal):
─────────────────────────────────────────────────────────────────
Рёбра: (A-B, 4), (B-C, 8), (C-D, 7), (A-D, 9)

Сортируем по весу: 4, 7, 8, 9

Шаг 1: Добавляем (A-B, 4) — нет цикла ✓
Шаг 2: Добавляем (C-D, 7) — нет цикла ✓
Шаг 3: Добавляем (B-C, 8) — нет цикла ✓
Шаг 4: (A-D, 9) — создаёт цикл! Пропускаем ❌

КРИТЕРИЙ: добавляй минимальное ребро, не создающее цикл
```

**Когда использовать:**
- Графовые алгоритмы (MST, Dijkstra)
- Huffman, сжатие
- Построение структур

### Какую модель выбрать?

```
┌────────────────────────────────────────────────────────────────┐
│                    ВЫБОР МОДЕЛИ                                │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  "Освобождение ресурса"                                        │
│  └── Когда: Есть ограниченный ресурс (время, место, вес)      │
│  └── Критерий: Что освобождает больше?                         │
│  └── Примеры: Activity Selection, Fractional Knapsack          │
│                                                                │
│  "Жадный до конца"                                             │
│  └── Когда: Задача на достижимость, "можно ли дойти?"         │
│  └── Критерий: Расширяй границу возможного                     │
│  └── Примеры: Jump Game, Gas Station                           │
│                                                                │
│  "Покрытие интервалами"                                        │
│  └── Когда: Интервалы, расписания, пересечения                │
│  └── Критерий: Сортируй по концу, бери непересекающиеся       │
│  └── Примеры: Minimum Arrows, Merge Intervals                  │
│                                                                │
│  "Построение по частям"                                        │
│  └── Когда: Нужно построить структуру (дерево, граф)          │
│  └── Критерий: Добавляй лучший валидный элемент               │
│  └── Примеры: Huffman, MST, Dijkstra                           │
│                                                                │
│  💡 СОВЕТ: Часто задачи комбинируют модели!                    │
│     Jump Game II = "жадный до конца" + "покрытие уровнями"    │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Визуальный гайд: От задачи к Greedy-решению

```
ЭТАП 1: Распознать потенциал Greedy
─────────────────────────────────────────────────────────────────
Сигналы: "минимум/максимум", "оптимальное", "количество"
Вопрос: Можно ли на каждом шаге выбрать "лучшее"?
           ↓
        ДА → Попробуй Greedy
        НЕТ → Сразу к DP

ЭТАП 2: Определить критерий жадного выбора
─────────────────────────────────────────────────────────────────
Вопрос: "Что даёт МАКСИМАЛЬНУЮ свободу для следующих шагов?"

Для интервалов: минимальный END (освобождает время раньше)
Для knapsack: максимальный RATIO (больше value за место)
Для графов: минимальный WEIGHT (дешевле добавить)

ЭТАП 3: Проверить корректность
─────────────────────────────────────────────────────────────────
Варианты:
1. Найти контрпример → Greedy не работает → DP
2. Доказать "Greedy Stays Ahead" → OK!
3. Доказать "Exchange Argument" → OK!

⚠️ "Работает на примерах" — НЕ ДОСТАТОЧНО!

ЭТАП 4: Реализовать
─────────────────────────────────────────────────────────────────
Типичная структура:
1. Сортировка по критерию
2. Итерация с жадным выбором
3. Обновление состояния
```

---

## Зачем это нужно?

**Реальная проблема:**

Представьте, что вы планируете день с максимальным количеством встреч. У вас 10 встреч с разным временем начала и конца, но некоторые пересекаются. Как выбрать максимум непересекающихся?

Наивный подход: перебрать все 2^10 = 1024 комбинации. Greedy: отсортировать по времени окончания и жадно выбирать — O(n log n).

**Где используется:**

| Область | Применение | Алгоритм |
|---------|------------|----------|
| Сети | Маршрутизация, кратчайшие пути | Dijkstra |
| Графы | Минимальное остовное дерево | Kruskal, Prim |
| Сжатие данных | Оптимальные коды | Huffman |
| Планирование | Расписание задач/встреч | Activity Selection |
| Распределение ресурсов | Загрузка серверов | Fractional Knapsack |
| Финансы | Размен монет | Coin Change (особые случаи) |

**Статистика:**
- Huffman используется в ZIP, PNG, JPEG — сотни миллиардов файлов
- Dijkstra — основа навигации в Google Maps, Waze
- Kruskal/Prim — проектирование сетевой инфраструктуры

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| Sorting | 90% greedy алгоритмов начинаются с сортировки | [[sorting-algorithms]] |
| Big O Notation | Анализ сложности, сравнение с DP | [[big-o-complexity]] |
| Arrays | Базовые операции, итерация | [[arrays-strings]] |
| **CS: Mathematical Induction** | Доказательство "Greedy Stays Ahead" | Дискретная математика |
| **CS: Proof Techniques** | Exchange argument для доказательства оптимальности | Теория алгоритмов |

---

## Что это такое?

### Объяснение для 5-летнего

Представь, что ты собираешь конфеты в корзину, но можешь взять только 5 штук.

**Жадный способ**: каждый раз бери самую большую конфету из оставшихся.

```
Конфеты: [3г, 7г, 2г, 5г, 1г, 8г, 4г]
                               ↑
Шаг 1: Беру 8г (самая большая)
Шаг 2: Беру 7г
Шаг 3: Беру 5г
Шаг 4: Беру 4г
Шаг 5: Беру 3г

Итого: 8+7+5+4+3 = 27г
```

Это жадный алгоритм — на каждом шаге мы делаем **лучший выбор прямо сейчас**, не думая о будущем.

### Формальное определение

**Greedy Algorithm** — алгоритм, который строит решение пошагово, на каждом шаге выбирая локально оптимальный вариант, не пересматривая предыдущие решения.

**Необходимые свойства для корректности:**

1. **Greedy Choice Property** — локально оптимальный выбор приводит к глобально оптимальному решению

2. **Optimal Substructure** — оптимальное решение задачи содержит оптимальные решения подзадач

**Общая схема:**
```
GREEDY(problem):
    solution = empty
    while problem not solved:
        candidate = select_best_available()
        if is_feasible(solution + candidate):
            solution.add(candidate)
    return solution
```

---

## Терминология

| Термин | Определение | Пример |
|--------|-------------|--------|
| **Greedy Choice** | Локально оптимальное решение на текущем шаге | Выбрать встречу с минимальным временем окончания |
| **Feasible Solution** | Решение, удовлетворяющее ограничениям | Набор непересекающихся встреч |
| **Optimal Solution** | Лучшее из всех допустимых решений | Максимальное количество встреч |
| **Greedy Stays Ahead** | Метод доказательства: greedy не хуже optimal на каждом шаге | Индуктивное доказательство |
| **Exchange Argument** | Метод доказательства: можно трансформировать optimal в greedy | Пошаговая замена |
| **Matroid** | Структура, гарантирующая корректность greedy | Независимые множества |

---

## Как это работает?

### Общий паттерн Greedy

```
                    GREEDY ALGORITHM PATTERN
                            │
    ┌───────────────────────┼───────────────────────┐
    │                       │                       │
 1. SORT                 2. ITERATE              3. SELECT
    │                       │                       │
 По какому-то          Проходим по              Жадно выбираем
 критерию              отсортированным          если feasible
    │                  элементам
    │                       │                       │
 • Время окончания     while not done:         if compatible:
 • Value/weight ratio     candidate = next()       add to solution
 • Profit                 check & decide
```

### Когда Greedy работает vs не работает

```
GREEDY WORKS:                      GREEDY FAILS:

Activity Selection                 0/1 Knapsack
┌──────┐ ┌──────┐ ┌──────┐        Items: {(weight, value)}
│  A   │ │  B   │ │  C   │        (10, 60), (20, 100), (30, 120)
└──────┘ └──────┘ └──────┘        Capacity: 50
Sort by end time → Optimal!
                                   Greedy by value/weight:
                                   Take (10,60) ratio=6 ✓
Fractional Knapsack               Take (20,100) ratio=5 ✓
Can take fractions →               Weight=30, can't take (30,120)
Greedy by ratio works!             Total: 160

                                   Optimal (DP): Take (20,100)+(30,120)=220

Coin Change (specific coins)       Coin Change (arbitrary coins)
Coins: [25, 10, 5, 1]              Coins: [1, 3, 4]
Amount: 41                         Amount: 6

Greedy: 25+10+5+1 = 4 coins       Greedy: 4+1+1 = 3 coins
Optimal: same!                     Optimal: 3+3 = 2 coins!
```

---

## Activity Selection Problem

### Постановка задачи

Дано n активностей с временем начала и окончания. Найти максимальное количество непересекающихся активностей.

### Визуализация

```
Activities with (start, end):
A: (1, 4)  |████████|
B: (3, 5)     |████████|
C: (0, 6)  |██████████████████|
D: (5, 7)           |████████|
E: (3, 8)     |██████████████████|
F: (5, 9)           |████████████████|
G: (6, 10)             |████████████████|
H: (8, 11)                    |████████████|
I: (8, 12)                    |████████████████|
J: (2, 13) |████████████████████████████████████|
K: (12,14)                              |████████|

Timeline: 0  1  2  3  4  5  6  7  8  9  10 11 12 13 14

Greedy (sort by end time):
1. Sort: A(4), B(5), C(6), D(7), E(8), F(9), G(10), H(11), I(12), J(13), K(14)
2. Select A (ends at 4)
3. Skip B, C (overlap with A)
4. Select D (starts at 5 >= 4)
5. Skip E, F, G (overlap with D)
6. Select H (starts at 8 >= 7)
7. Skip I, J (overlap with H)
8. Select K (starts at 12 >= 11)

Result: A, D, H, K — 4 activities (optimal!)
```

### Реализация (Kotlin)

```kotlin
data class Activity(val start: Int, val end: Int, val name: String)

fun activitySelection(activities: List<Activity>): List<Activity> {
    /**
     * ЖАДНЫЙ ВЫБОР: сортируем по времени ОКОНЧАНИЯ
     *
     * Почему это работает? Интуиция:
     * - Активность, которая заканчивается РАНЬШЕ всех,
     *   оставляет МАКСИМУМ места для других активностей
     * - Это свойство "greedy choice" — локально оптимальный
     *   выбор ведёт к глобально оптимальному решению
     *
     * ПОШАГОВЫЙ ПРИМЕР:
     * Активности: A[1-4], B[3-5], C[0-6], D[5-7]
     * После сортировки по end: A[1-4], B[3-5], C[0-6], D[5-7]
     *
     * Шаг 1: Берём A[1-4] → lastEndTime = 4
     * Шаг 2: B[3-5] → start=3 < 4 ❌ пересекается
     * Шаг 3: C[0-6] → start=0 < 4 ❌ пересекается
     * Шаг 4: D[5-7] → start=5 >= 4 ✅ берём! lastEndTime = 7
     * Результат: [A, D] — 2 активности (оптимально!)
     */
    val sorted = activities.sortedBy { it.end }

    val selected = mutableListOf<Activity>()
    var lastEndTime = 0

    for (activity in sorted) {
        /**
         * Проверка совместимости: активность НЕ пересекается
         * с последней выбранной, если её начало >= конца предыдущей
         *
         * Временная линия:
         * |---последняя---|
         *                 |---текущая---|  ← start >= lastEndTime ✅
         *            |---текущая---|  ← start < lastEndTime ❌
         */
        if (activity.start >= lastEndTime) {
            selected.add(activity)
            // Обновляем "правую границу" занятого времени
            lastEndTime = activity.end
        }
    }

    return selected
}

// Example usage
fun main() {
    val activities = listOf(
        Activity(1, 4, "A"), Activity(3, 5, "B"), Activity(0, 6, "C"),
        Activity(5, 7, "D"), Activity(3, 8, "E"), Activity(5, 9, "F"),
        Activity(6, 10, "G"), Activity(8, 11, "H"), Activity(8, 12, "I"),
        Activity(2, 13, "J"), Activity(12, 14, "K")
    )
    val result = activitySelection(activities)
    println(result.map { it.name })  // [A, D, H, K]
}
```

### Java

```java
public List<int[]> activitySelection(int[][] activities) {
    // Sort by end time
    Arrays.sort(activities, (a, b) -> a[1] - b[1]);

    List<int[]> selected = new ArrayList<>();
    int lastEnd = 0;

    for (int[] activity : activities) {
        if (activity[0] >= lastEnd) {
            selected.add(activity);
            lastEnd = activity[1];
        }
    }

    return selected;
}
```

### Python

```python
def activity_selection(activities: list[tuple[int, int]]) -> list[tuple[int, int]]:
    # Sort by end time
    sorted_activities = sorted(activities, key=lambda x: x[1])

    selected = []
    last_end = 0

    for start, end in sorted_activities:
        if start >= last_end:
            selected.append((start, end))
            last_end = end

    return selected
```

### Proof of Correctness (Greedy Stays Ahead)

```
Claim: Greedy (sort by end time) gives maximum activities.

Proof by "Greedy Stays Ahead":

Let G = {g₁, g₂, ..., gₖ} be greedy solution (sorted by end time)
Let O = {o₁, o₂, ..., oₘ} be optimal solution (also sorted)

We prove: end(gᵢ) ≤ end(oᵢ) for all i (greedy never finishes later)

Base case (i=1):
  g₁ is the activity with earliest end time
  → end(g₁) ≤ end(o₁) ✓

Inductive step:
  Assume end(gᵢ₋₁) ≤ end(oᵢ₋₁)
  Since oᵢ starts after oᵢ₋₁ ends, and end(gᵢ₋₁) ≤ end(oᵢ₋₁),
  oᵢ is compatible with g₁,...,gᵢ₋₁
  Greedy picks gᵢ with minimum end time among all compatible
  → end(gᵢ) ≤ end(oᵢ) ✓

Conclusion:
  If m > k, then there exists oₖ₊₁ starting after end(oₖ) ≥ end(gₖ)
  But then greedy would have selected oₖ₊₁ — contradiction!
  → k ≥ m, so greedy is optimal ✓
```

---

## Fractional Knapsack

### Постановка задачи

Дано n предметов с весами и ценностями. Рюкзак вмещает W единиц. Можно брать дробные части. Максимизировать ценность.

### Визуализация

```
Items: {(weight, value)}
Item A: weight=10, value=60, ratio=6.0
Item B: weight=20, value=100, ratio=5.0
Item C: weight=30, value=120, ratio=4.0

Capacity: 50

Sort by ratio (decreasing): A(6.0), B(5.0), C(4.0)

Greedy selection:
1. Take A completely: 10kg, value=60, remaining=40kg
2. Take B completely: 20kg, value=100, remaining=20kg
3. Take 20/30 of C: 20kg, value=120*(20/30)=80

Total: 60 + 100 + 80 = 240 (optimal!)
```

### Реализация (Kotlin)

```kotlin
data class Item(val weight: Double, val value: Double) {
    /**
     * Соотношение value/weight определяет "эффективность" предмета
     *
     * Пример: предмет A (вес=10, ценность=60) имеет ratio = 6.0
     * Это значит: за каждый 1 кг получаем 6 единиц ценности
     *
     * Чем ВЫШЕ ratio, тем ВЫГОДНЕЕ брать этот предмет!
     */
    val ratio: Double get() = value / weight
}

fun fractionalKnapsack(items: List<Item>, capacity: Double): Double {
    /**
     * ЖАДНЫЙ ВЫБОР: сортируем по ratio (ценность/вес) УБЫВАНИЮ
     *
     * Интуиция: берём самые "эффективные" предметы первыми
     *
     * ПОШАГОВЫЙ ПРИМЕР:
     * Предметы: A(10кг, 60$, ratio=6), B(20кг, 100$, ratio=5), C(30кг, 120$, ratio=4)
     * Вместимость: 50 кг
     *
     * После сортировки: A(6) → B(5) → C(4)
     *
     * Шаг 1: Берём A целиком (10кг) → value=60, осталось 40кг
     * Шаг 2: Берём B целиком (20кг) → value+=100, осталось 20кг
     * Шаг 3: Берём 20/30 от C → value+=80, осталось 0кг
     *
     * Итого: 60 + 100 + 80 = 240$ (оптимально!)
     */
    val sorted = items.sortedByDescending { it.ratio }

    var remainingCapacity = capacity
    var totalValue = 0.0

    for (item in sorted) {
        if (remainingCapacity <= 0) break

        if (item.weight <= remainingCapacity) {
            // Предмет ПОМЕЩАЕТСЯ целиком — берём полностью
            totalValue += item.value
            remainingCapacity -= item.weight
        } else {
            /**
             * Предмет НЕ помещается целиком — берём ЧАСТЬ
             *
             * fraction = какую долю предмета можем взять
             * Например: осталось 20кг, предмет весит 30кг
             * fraction = 20/30 = 0.667 (берём 2/3 предмета)
             * value = 120 * 0.667 = 80$
             */
            val fraction = remainingCapacity / item.weight
            totalValue += item.value * fraction
            remainingCapacity = 0.0
        }
    }

    return totalValue
}
```

### Proof (Exchange Argument)

```
Claim: Greedy (sort by ratio) is optimal for fractional knapsack.

Proof by Exchange Argument:

Suppose optimal O differs from greedy G at some item i.
Let G take more of item i (higher ratio) than O.

Exchange:
  In O, reduce amount of lower-ratio item j
  Increase amount of higher-ratio item i by same weight

Result:
  Total weight unchanged
  Total value increased (higher ratio replaces lower)

This contradicts O being optimal!
→ Greedy is optimal ✓
```

---

## Jump Game

### Проблема (LeetCode 55)

Дан массив где `arr[i]` = максимальный прыжок из позиции i. Можно ли достичь последней позиции?

### Визуализация

```
Array: [2, 3, 1, 1, 4]
        0  1  2  3  4

From index 0: can jump to 1 or 2
From index 1: can jump to 2, 3, or 4
From index 2: can jump to 3
From index 3: can jump to 4
From index 4: destination!

Greedy approach: Track maximum reachable index

i=0: maxReach = max(0, 0+2) = 2
i=1: maxReach = max(2, 1+3) = 4  ← Can reach end!
Answer: true
```

### Реализация (Kotlin)

```kotlin
fun canJump(nums: IntArray): Boolean {
    /**
     * maxReach = самый дальний индекс, который мы можем достичь
     *
     * ПОШАГОВЫЙ ПРИМЕР: [2, 3, 1, 1, 4]
     * i=0: maxReach = max(0, 0+2) = 2
     * i=1: maxReach = max(2, 1+3) = 4 ← можем достичь конца!
     */
    var maxReach = 0

    for (i in nums.indices) {
        /**
         * Если текущий индекс i БОЛЬШЕ maxReach — мы "застряли"
         *
         * Пример: [3, 2, 1, 0, 4]
         * i=0: maxReach = 3
         * i=1: maxReach = 3
         * i=2: maxReach = 3
         * i=3: maxReach = 3 (nums[3]=0, не можем прыгнуть!)
         * i=4: i=4 > maxReach=3 ❌ застряли!
         */
        if (i > maxReach) return false

        // Обновляем: из позиции i можем прыгнуть на i + nums[i]
        maxReach = maxOf(maxReach, i + nums[i])

        // Ранний выход: если уже можем достичь конца
        if (maxReach >= nums.lastIndex) return true
    }

    return true
}
```

---

## Jump Game II (Minimum Jumps)

### Проблема (LeetCode 45)

Найти минимальное количество прыжков до конца.

### Визуализация

```
Array: [2, 3, 1, 1, 4]
        0  1  2  3  4

Greedy with BFS-like approach:

Jump 0: at index 0, can reach [1, 2]
        currentEnd=2, farthest=2

Jump 1: process indices 1-2
        at 1: can reach up to 1+3=4
        at 2: can reach up to 2+1=3
        farthest=4 (can reach end!)

Total: 2 jumps
```

### Реализация (Kotlin)

```kotlin
fun jump(nums: IntArray): Int {
    if (nums.size <= 1) return 0

    var jumps = 0
    /**
     * currentEnd = правая граница текущего "уровня" прыжков
     * farthest = самая дальняя точка, достижимая следующим прыжком
     *
     * Это похоже на BFS по уровням:
     * - Уровень 0: индекс 0
     * - Уровень 1: все индексы, достижимые за 1 прыжок
     * - Уровень 2: все индексы, достижимые за 2 прыжка
     * - и т.д.
     */
    var currentEnd = 0
    var farthest = 0

    /**
     * Итерируем до ПРЕДПОСЛЕДНЕГО индекса
     * Почему? Нам нужно только ДОСТИЧЬ последнего индекса,
     * не обязательно его обрабатывать
     *
     * ПОШАГОВЫЙ ПРИМЕР: [2, 3, 1, 1, 4]
     *
     * i=0: farthest = max(0, 0+2) = 2
     *      i == currentEnd (0==0) → jumps=1, currentEnd=2
     *
     * i=1: farthest = max(2, 1+3) = 4
     *
     * i=2: farthest = max(4, 2+1) = 4
     *      i == currentEnd (2==2) → jumps=2, currentEnd=4
     *      currentEnd=4 >= lastIndex=4 → break!
     *
     * Результат: 2 прыжка
     */
    for (i in 0 until nums.lastIndex) {
        farthest = maxOf(farthest, i + nums[i])

        // Дошли до конца текущего "уровня" — нужен ещё прыжок
        if (i == currentEnd) {
            jumps++
            currentEnd = farthest

            // Ранний выход: можем достичь конца
            if (currentEnd >= nums.lastIndex) break
        }
    }

    return jumps
}
```

---

## Interval Problems (Greedy Pattern)

### 1. Merge Intervals (LeetCode 56)

```kotlin
fun merge(intervals: Array<IntArray>): Array<IntArray> {
    if (intervals.isEmpty()) return emptyArray()

    /**
     * Сортируем по времени НАЧАЛА для последовательной обработки
     *
     * После сортировки: если current.start > last.end,
     * то все следующие интервалы тоже не пересекаются с last
     *
     * ПОШАГОВЫЙ ПРИМЕР: [[1,3], [2,6], [8,10], [15,18]]
     * После сортировки (уже отсортировано): то же
     *
     * Шаг 1: result = [[1,3]]
     * Шаг 2: [2,6] → 2 <= 3 ✓ пересекается → merge: [1,6]
     * Шаг 3: [8,10] → 8 > 6 ✗ не пересекается → add
     * Шаг 4: [15,18] → 15 > 10 ✗ → add
     *
     * Результат: [[1,6], [8,10], [15,18]]
     */
    intervals.sortBy { it[0] }

    val result = mutableListOf(intervals[0])

    for (i in 1 until intervals.size) {
        val last = result.last()
        val current = intervals[i]

        if (current[0] <= last[1]) {
            // Пересекаются — объединяем, расширяя конец до максимума
            // [1,3] + [2,6] → [1, max(3,6)] = [1,6]
            last[1] = maxOf(last[1], current[1])
        } else {
            // НЕ пересекаются — добавляем как отдельный интервал
            result.add(current)
        }
    }

    return result.toTypedArray()
}
```

### 2. Non-overlapping Intervals (LeetCode 435)

```kotlin
fun eraseOverlapIntervals(intervals: Array<IntArray>): Int {
    if (intervals.isEmpty()) return 0

    /**
     * Сортируем по времени ОКОНЧАНИЯ — как в Activity Selection!
     *
     * Почему END, а не START? Интервал с РАННИМ концом
     * оставляет больше места для следующих.
     *
     * Эквивалентная формулировка:
     * "Удалить минимум интервалов" = "Оставить максимум непересекающихся"
     * Это и есть Activity Selection!
     *
     * ПОШАГОВЫЙ ПРИМЕР: [[1,2], [2,3], [3,4], [1,3]]
     * После сортировки по end: [[1,2], [2,3], [1,3], [3,4]]
     *
     * lastEnd = 2 (конец первого)
     * [2,3]: start=2 >= lastEnd=2 ✓ не пересекается → lastEnd=3
     * [1,3]: start=1 < lastEnd=3 ❌ пересекается → count++
     * [3,4]: start=3 >= lastEnd=3 ✓ → lastEnd=4
     *
     * Удалили 1 интервал ([1,3])
     */
    intervals.sortBy { it[1] }

    var count = 0
    var lastEnd = intervals[0][1]

    for (i in 1 until intervals.size) {
        if (intervals[i][0] < lastEnd) {
            // Пересечение! Удаляем текущий (сохраняем с более ранним end)
            count++
        } else {
            // Нет пересечения — обновляем границу
            lastEnd = intervals[i][1]
        }
    }

    return count
}
```

### 3. Minimum Arrows (LeetCode 452)

```kotlin
fun findMinArrowShots(points: Array<IntArray>): Int {
    if (points.isEmpty()) return 0

    /**
     * Сортируем по КОНЦУ шарика (end point)
     *
     * Почему? Стреляем в КОНЕЦ первого шарика — так захватим
     * максимум пересекающихся шариков
     *
     * ПОШАГОВЫЙ ПРИМЕР: [[10,16], [2,8], [1,6], [7,12]]
     * После сортировки по end: [[1,6], [2,8], [7,12], [10,16]]
     *
     * Стрела 1: позиция 6 (конец первого)
     * - [1,6] ✓ лопнул
     * - [2,8]: start=2 <= 6 ✓ лопнул
     * - [7,12]: start=7 > 6 ❌ нужна новая стрела
     *
     * Стрела 2: позиция 12
     * - [7,12] ✓ лопнул
     * - [10,16]: start=10 <= 12 ✓ лопнул
     *
     * Результат: 2 стрелы
     */
    points.sortBy { it[1] }

    var arrows = 1
    // Стреляем в КОНЕЦ первого шарика — максимизируем покрытие
    var arrowPos = points[0][1]

    for (i in 1 until points.size) {
        if (points[i][0] > arrowPos) {
            // Шарик начинается ПОСЛЕ позиции стрелы — нужна новая
            arrows++
            arrowPos = points[i][1]
        }
        // Иначе: шарик уже лопнут текущей стрелой
    }

    return arrows
}
```

---

## Gas Station (LeetCode 134)

### Проблема

Кольцевая дорога с n заправками. На станции i получаем `gas[i]` топлива, тратим `cost[i]` до следующей. Найти стартовую позицию для полного круга.

### Визуализация

```
gas  = [1, 2, 3, 4, 5]
cost = [3, 4, 5, 1, 2]
net  = [-2,-2,-2, 3, 3]  (gas - cost)

Total sum = 0, so solution exists!

Start from 0: tank = -2 (fail immediately)
Start from 1: tank = -2 (fail immediately)
Start from 2: tank = -2 (fail immediately)
Start from 3: tank = 3 → 6 → 4 → 2 → 0 → 3 ✓

Key insight: If we fail at position j starting from i,
no position in [i, j] can be the answer (all have same deficit).
```

### Реализация (Kotlin)

```kotlin
fun canCompleteCircuit(gas: IntArray, cost: IntArray): Int {
    /**
     * totalTank = суммарный баланс топлива (есть ли решение вообще?)
     * currentTank = бак от текущей стартовой точки
     *
     * КЛЮЧЕВАЯ ИДЕЯ:
     * Если sum(gas) >= sum(cost), решение ГАРАНТИРОВАННО существует!
     * И если мы "застряли" на станции j, начав с i,
     * то ВСЕ станции в [i, j] тоже не подходят.
     *
     * Почему? Если бы какая-то станция k в [i, j] подходила,
     * мы бы не застряли — у нас был бы положительный бак на k.
     */
    var totalTank = 0
    var currentTank = 0
    var startStation = 0

    /**
     * ПОШАГОВЫЙ ПРИМЕР:
     * gas  = [1, 2, 3, 4, 5]
     * cost = [3, 4, 5, 1, 2]
     * net  = [-2, -2, -2, 3, 3]
     *
     * i=0: totalTank=-2, currentTank=-2 < 0 → start=1, reset
     * i=1: totalTank=-4, currentTank=-2 < 0 → start=2, reset
     * i=2: totalTank=-6, currentTank=-2 < 0 → start=3, reset
     * i=3: totalTank=-3, currentTank=3 >= 0 ✓
     * i=4: totalTank=0, currentTank=6 >= 0 ✓
     *
     * totalTank=0 >= 0 → решение есть!
     * startStation=3 — ответ
     */
    for (i in gas.indices) {
        val net = gas[i] - cost[i]
        totalTank += net
        currentTank += net

        /**
         * Если currentTank < 0, мы не можем доехать до станции i
         * Значит, ни одна станция от startStation до i не подходит!
         * Пробуем следующую станцию (i+1) как новый старт
         */
        if (currentTank < 0) {
            startStation = i + 1
            currentTank = 0  // Сбрасываем бак для нового старта
        }
    }

    // Если суммарно топлива >= расхода, решение существует
    return if (totalTank >= 0) startStation else -1
}
```

---

## Partition Labels (LeetCode 763)

### Проблема

Разбить строку на максимальное количество частей так, чтобы каждая буква появлялась только в одной части.

### Визуализация

```
s = "ababcbacadefegdehijhklij"

Last occurrence of each char:
a→8, b→5, c→7, d→14, e→15, f→11, g→13, h→19, i→22, j→23, k→20, l→21

Process:
i=0 'a': end = 8
i=1 'b': end = max(8, 5) = 8
...
i=8 'a': end = 8, i == end → partition [0-8] = "ababcbaca"

i=9 'd': end = 14
...
i=15 'e': end = 15, i == end → partition [9-15] = "defegde"

i=16 'h': end = 19
...
i=23 'j': end = 23, i == end → partition [16-23] = "hijhklij"

Result: [9, 7, 8]
```

### Реализация (Kotlin)

```kotlin
fun partitionLabels(s: String): List<Int> {
    /**
     * ШАГ 1: Находим ПОСЛЕДНЕЕ вхождение каждого символа
     *
     * Зачем? Если символ 'a' последний раз встречается на позиции 8,
     * то первая часть ДОЛЖНА заканчиваться не раньше индекса 8,
     * иначе 'a' будет в нескольких частях!
     *
     * Пример: "ababcbaca"
     * lastIndex['a'-'a'] = 8 (последнее 'a' на позиции 8)
     * lastIndex['b'-'a'] = 5
     * lastIndex['c'-'a'] = 7
     */
    val lastIndex = IntArray(26)
    for (i in s.indices) {
        lastIndex[s[i] - 'a'] = i
    }

    val result = mutableListOf<Int>()
    var start = 0
    var end = 0

    /**
     * ПОШАГОВЫЙ ПРИМЕР: "ababcbaca"
     *
     * i=0 'a': end = max(0, 8) = 8
     * i=1 'b': end = max(8, 5) = 8
     * i=2 'a': end = max(8, 8) = 8
     * i=3 'b': end = max(8, 5) = 8
     * i=4 'c': end = max(8, 7) = 8
     * i=5 'b': end = max(8, 5) = 8
     * i=6 'a': end = max(8, 8) = 8
     * i=7 'c': end = max(8, 7) = 8
     * i=8 'a': end = max(8, 8) = 8
     *     i == end! → часть [0,8] размером 9
     */
    for (i in s.indices) {
        // Расширяем end, чтобы включить ВСЕ вхождения текущего символа
        end = maxOf(end, lastIndex[s[i] - 'a'])

        // Когда i догнал end — мы нашли валидную часть!
        // Все символы в [start, end] появляются ТОЛЬКО здесь
        if (i == end) {
            result.add(end - start + 1)
            start = i + 1
        }
    }

    return result
}
```

---

## Task Scheduler (LeetCode 621)

### Проблема

Выполнить задачи с cooldown n между одинаковыми. Минимизировать время.

### Визуализация

```
tasks = ['A','A','A','B','B','B'], n = 2

Most frequent: A (3 times)
Frame size: n + 1 = 3

A _ _ A _ _ A
      ↑
  Fill with other tasks

A B _ A B _ A B
      ↑
  Still have idle slots

Minimum time = max(tasks.length, (maxFreq-1)*(n+1) + numMaxFreq)
             = max(6, 2*3 + 2) = max(6, 8) = 8
```

### Реализация (Kotlin)

```kotlin
fun leastInterval(tasks: CharArray, n: Int): Int {
    /**
     * Считаем частоту каждой задачи
     *
     * Пример: ['A','A','A','B','B','B']
     * freq['A'-'A'] = 3
     * freq['B'-'A'] = 3
     */
    val freq = IntArray(26)
    for (task in tasks) {
        freq[task - 'A']++
    }

    // Находим максимальную частоту (самая "проблемная" задача)
    val maxFreq = freq.max()

    // Сколько задач имеют эту максимальную частоту?
    val numMaxFreq = freq.count { it == maxFreq }

    /**
     * ФОРМУЛА МИНИМАЛЬНОГО ВРЕМЕНИ:
     *
     * Визуализация для tasks=['A','A','A','B','B','B'], n=2:
     *
     * Размер "рамки" = n + 1 = 3 (cooldown + 1 задача)
     *
     * A _ _ | A _ _ | A    ← (maxFreq - 1) полных рамок + хвост
     * A B _ | A B _ | A B  ← заполняем другими задачами
     *
     * (maxFreq - 1) = 2 полных рамки по (n+1) = 3 слота = 6
     * + хвост с numMaxFreq = 2 задачами (A и B)
     * = 6 + 2 = 8
     *
     * НО! Если n маленький и задач много, idle может не быть:
     * minTime не может быть меньше tasks.size
     */
    val minTime = (maxFreq - 1) * (n + 1) + numMaxFreq

    return maxOf(tasks.size, minTime)
}
```

---

## Сложность операций

| Алгоритм | Time | Space | Sorting Needed |
|----------|------|-------|----------------|
| Activity Selection | O(n log n) | O(1) | By end time |
| Fractional Knapsack | O(n log n) | O(1) | By ratio |
| Jump Game | O(n) | O(1) | No |
| Merge Intervals | O(n log n) | O(n) | By start time |
| Partition Labels | O(n) | O(1) | No |
| Task Scheduler | O(n) | O(1) | No |

---

## Распространённые ошибки

### 1. Применение greedy без доказательства

```kotlin
// ❌ WRONG: Greedy doesn't work for 0/1 Knapsack
fun knapsack01Greedy(items: List<Item>, capacity: Int): Int {
    val sorted = items.sortedByDescending { it.value / it.weight }
    var remaining = capacity
    var total = 0

    for (item in sorted) {
        if (item.weight <= remaining) {
            total += item.value
            remaining -= item.weight
        }
    }
    return total  // NOT optimal!
}

// ✅ CORRECT: Use DP for 0/1 Knapsack
// Greedy only works for FRACTIONAL knapsack
```

### 2. Неправильный критерий сортировки

```kotlin
// ❌ WRONG: Sorting by start time for maximum activities
val activities = listOf(...)
activities.sortedBy { it.start }  // Wrong!

// ✅ CORRECT: Sort by END time
activities.sortedBy { it.end }
```

### 3. Забыли обработать edge cases

```kotlin
// ❌ WRONG: Doesn't handle single element
fun jump(nums: IntArray): Int {
    var jumps = 0
    var end = 0
    var farthest = 0

    for (i in 0 until nums.lastIndex) {  // Crashes if size == 1
        // ...
    }
    return jumps
}

// ✅ CORRECT: Handle edge case
fun jump(nums: IntArray): Int {
    // Если массив пустой или из 1 элемента — мы УЖЕ на месте!
    if (nums.size <= 1) return 0
    // ...
}
```

### 4. Неправильное сравнение интервалов

```kotlin
// ❌ WRONG: Wrong overlap check
if (current[0] < last[1])  // Might miss touching intervals

// ✅ CORRECT: Depends on problem definition
// For merge: overlapping or touching → merge
if (current[0] <= last[1])
// For non-overlapping: only strict overlap counts
if (current[0] < last[1])
```

### 5. Greedy для монет с произвольными номиналами

```kotlin
// ❌ WRONG: Greedy for arbitrary coin denominations
// Coins: [1, 3, 4], Amount: 6
// Greedy: 4 + 1 + 1 = 3 coins
// Optimal: 3 + 3 = 2 coins

fun coinChangeGreedy(coins: IntArray, amount: Int): Int {
    coins.sortDescending()
    var remaining = amount
    var count = 0
    for (coin in coins) {
        while (remaining >= coin) {
            remaining -= coin
            count++
        }
    }
    return if (remaining == 0) count else -1  // Often wrong!
}

// ✅ CORRECT: Use DP for general coin change
```

---

## Когда использовать Greedy vs DP

### Decision Framework

```
                    Optimization problem?
                           │
              ┌────────────┴────────────┐
              │                         │
    Can prove greedy works?        Need to explore
              │                    all combinations?
              ↓                         │
      Greedy O(n log n)                 ↓
                                   Dynamic Programming
                                   O(n²) or more
```

### Comparison Table

| Проблема | Greedy? | DP? | Почему |
|----------|---------|-----|--------|
| Activity Selection | ✓ | - | Greedy choice property holds |
| Fractional Knapsack | ✓ | - | Can take fractions |
| 0/1 Knapsack | ✗ | ✓ | Must consider combinations |
| Coin Change (1,5,10,25) | ✓ | - | Canonical coin system |
| Coin Change (arbitrary) | ✗ | ✓ | Greedy may fail |
| Huffman Coding | ✓ | - | Merge smallest first |
| LCS | ✗ | ✓ | Need all subsequences |
| MST (Kruskal/Prim) | ✓ | - | Safe edge property |

---

## Практика

### Концептуальные вопросы

1. **Как доказать, что greedy алгоритм корректен?**

   *Ответ:* Два основных метода:
   - **Greedy Stays Ahead**: показать, что на каждом шаге greedy не хуже optimal
   - **Exchange Argument**: показать, что любое optimal решение можно преобразовать в greedy без ухудшения

2. **Почему greedy работает для fractional knapsack, но не для 0/1?**

   *Ответ:* В fractional можно взять ровно столько высокоратиового предмета, сколько нужно. В 0/1 предмет либо целиком, либо никак — greedy выбор может заблокировать более выгодную комбинацию.

3. **Почему для activity selection сортируем по времени окончания, а не начала?**

   *Ответ:* Ранний конец оставляет больше места для последующих активностей. Ранее начало может занять много времени и заблокировать другие.

4. **Когда greedy совпадает с DP?**

   *Ответ:* Когда greedy choice property выполняется, DP по сути делает один и тот же выбор на каждом шаге. Greedy — частный случай DP с одним оптимальным выбором.

### LeetCode задачи

#### Easy
- **455. Assign Cookies** — сортировка + two pointers
- **860. Lemonade Change** — greedy simulation
- **1710. Maximum Units on a Truck** — fractional knapsack style

#### Medium
- **55. Jump Game** — maximum reach tracking
- **45. Jump Game II** — BFS-like greedy
- **134. Gas Station** — circular greedy
- **435. Non-overlapping Intervals** — activity selection
- **452. Minimum Number of Arrows** — interval covering
- **56. Merge Intervals** — interval merging
- **763. Partition Labels** — last occurrence tracking
- **621. Task Scheduler** — frequency analysis

#### Hard
- **135. Candy** — two-pass greedy
- **330. Patching Array** — greedy expansion
- **502. IPO** — heap + greedy

---

## Мифы и заблуждения

| Миф | Реальность |
|-----|-----------|
| "Greedy всегда даёт оптимальный результат" | **Нет!** Greedy работает ТОЛЬКО когда выполняется greedy choice property. Для 0/1 Knapsack, Coin Change с произвольными номиналами — greedy даёт SUB-оптимальный результат. |
| "Greedy = жадный перебор" | **Нет!** Greedy — это систематический подход с математическим обоснованием. Каждый шаг делает локально оптимальный выбор, НЕ пересматривая его. Brute force пробует ВСЕ варианты. |
| "Если DP работает, значит greedy тоже работает" | **Наоборот!** Greedy — частный случай DP, когда локальный оптимум = глобальный. Если нужно рассматривать все подзадачи — это DP. Если достаточно одного выбора — greedy. |
| "Greedy всегда быстрее DP" | **Обычно да**, но не всегда. Greedy O(n log n) из-за сортировки vs DP O(n). Но greedy экономит память — O(1) vs O(n) для DP. |
| "Сортировка — обязательный первый шаг" | **Не всегда!** Jump Game, Gas Station, Partition Labels работают без сортировки. Сортировка нужна когда есть явный критерий упорядочивания (время, ratio). |
| "Greedy легко реализовать, сложно доказать" | **Верно!** Код greedy обычно 10-20 строк. Но доказательство корректности требует "Greedy Stays Ahead" или "Exchange Argument" — это сложнее самого кода. |
| "Fractional и 0/1 Knapsack решаются одинаково" | **Нет!** Fractional → greedy работает (можно брать доли). 0/1 → greedy НЕ работает (предмет целиком или никак). Нужен DP. |
| "Greedy только для интервалов и рюкзака" | **Нет!** Greedy применим к графам (MST, Dijkstra), строкам (Huffman), scheduling, даже к некоторым DP-задачам. Ключ — наличие greedy choice property. |

---

## CS-фундамент

| CS-концепция | Применение в Greedy Algorithms |
|--------------|--------------------------------|
| **Greedy Choice Property** | Ключевое свойство: локально оптимальный выбор является частью глобально оптимального решения. Без этого свойства greedy не гарантирует оптимум. Пример: Activity Selection — выбор с минимальным end time всегда оптимален. |
| **Optimal Substructure** | Оптимальное решение содержит оптимальные решения подзадач. Общее с DP, но greedy делает ОДИН выбор и продолжает, DP рассматривает ВСЕ варианты. |
| **Greedy Stays Ahead Proof** | Метод доказательства: на каждом шаге показываем, что greedy решение "не хуже" оптимального. Индукция: base case + inductive step. Используется для Activity Selection, Huffman. |
| **Exchange Argument Proof** | Метод доказательства: берём любое оптимальное решение и показываем, что его можно трансформировать в greedy без ухудшения. Если O ≠ G, найдём различие и "обменяем" — значение не уменьшится. |
| **Matroid Theory** | Абстрактная структура, гарантирующая корректность greedy. Если задача — максимизация веса независимого множества в матроиде, greedy ВСЕГДА оптимален. MST — пример графового матроида. |
| **Safe Move Principle** | В графовых greedy (MST): ребро "безопасно" добавить, если оно не создаёт цикл с уже выбранными. Kruskal/Prim используют этот принцип для построения MST жадно. |

---

## Связанные темы

### Prerequisites (что нужно знать до)
- [Sorting Algorithms](./sorting-algorithms.md) — большинство greedy требует сортировки
- [Time Complexity](../overview.md) — анализ сложности
- [Arrays](../data-structures/arrays.md) — базовые операции

### Что открывает (изучить после)
- [Dynamic Programming](./dynamic-programming.md) — когда greedy не работает
- [Graph Algorithms](./graph-advanced.md) — MST, Dijkstra
- [Intervals Pattern](../patterns/intervals-pattern.md) — частые interview задачи
- [Heaps](../data-structures/heaps-priority-queues.md) — для оптимизации greedy

---

## Источники

1. [Stanford CS161 - Guide to Greedy Algorithms](https://web.stanford.edu/class/archive/cs/cs161/cs161.1138/handouts/120%20Guide%20to%20Greedy%20Algorithms.pdf) — Proof techniques
2. [Interview Cake - Greedy](https://www.interviewcake.com/concept/java/greedy) — Interview tips
3. [LeetCode The Hard Way - Greedy](https://leetcodethehardway.com/tutorials/basic-topics/greedy) — Patterns
4. [GeeksforGeeks - Greedy Algorithms](https://www.geeksforgeeks.org/dsa/greedy-algorithms/) — Examples
5. [LeetCode Discuss - ABCs of Greedy](https://leetcode.com/discuss/general-discussion/1061059/ABCs-of-Greedy) — Problem categorization
6. [Medium - Greedy Explained](https://medium.com/algorithms-and-leetcode/greedy-algorithm-explained-using-leetcode-problems-80d6fee071c4) — LeetCode walkthrough
7. [W3Schools - DSA Greedy](https://www.w3schools.com/dsa/dsa_ref_greedy.php) — Quick reference
8. [Brilliant - Greedy Algorithm](https://brilliant.org/wiki/greedy-algorithm/) — Theory and proofs
9. [HackerEarth - Basics of Greedy](https://www.hackerearth.com/practice/algorithms/greedy/basics-of-greedy-algorithms/tutorial/) — Tutorial
10. [DevInterview - Greedy Questions](https://github.com/Devinterview-io/greedy-algorithms-interview-questions) — Interview prep 2025
11. [Labuladong - Interval Scheduling](https://labuladong.online/algo/en/frequency-interview/interval-scheduling/) — Pattern deep-dive

---

## Навигация

← Предыдущая: [[backtracking|Backtracking]]
→ Следующая: [[two-pointers-pattern|Two Pointers Pattern]]
↑ Вверх: [[_moc-algorithms|Algorithms MOC]]

*Обновлено: 2026-01-06 (добавлены педагогические секции: интуиция, почему сложно, ментальные модели)*
