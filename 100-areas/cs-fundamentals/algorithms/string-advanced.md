---
title: "Продвинутые строковые алгоритмы (Suffix Array, Aho-Corasick)"
created: 2026-02-09
modified: 2026-02-09
type: deep-dive
status: published
tags:
  - topic/cs-fundamentals
  - type/deep-dive
  - level/expert
related:
  - "[[string-algorithms]]"
  - "[[string-algorithms-advanced]]"
  - "[[tries]]"
prerequisites:
  - "[[string-algorithms]]"
  - "[[string-algorithms-advanced]]"
  - "[[tries]]"
  - "[[arrays-strings]]"
---

# Advanced String Algorithms

## TL;DR

**Suffix Array** — отсортированные суффиксы за O(n log n), база для LCP и string queries. **Aho-Corasick** — поиск множества паттернов за O(n + m + z), trie + failure links. **Manacher** — все палиндромы за O(n), использует симметрию. **Suffix Automaton** — O(n) памяти для ВСЕХ подстрок, мощнейшая структура. Выбор: single pattern → KMP, multiple patterns → Aho-Corasick, substring analysis → Suffix Array/Automaton.

---

## Часть 1: Интуиция без кода

### Аналогия 1: Suffix Array как указатель в книге

```
    УКАЗАТЕЛЬ В КОНЦЕ КНИГИ

    Представьте книгу про программирование.
    В конце — алфавитный указатель:

    ┌─────────────────────────────────────────────────┐
    │  УКАЗАТЕЛЬ                                      │
    │                                                 │
    │  algorithm ............. стр. 42, 78, 156      │
    │  array ................. стр. 15, 89           │
    │  binary search ......... стр. 67               │
    │  ...                                            │
    │  tree .................. стр. 34, 201          │
    │  trie .................. стр. 298              │
    └─────────────────────────────────────────────────┘

    Suffix Array — это ТАКОЙ ЖЕ указатель,
    но для ВСЕХ ВОЗМОЖНЫХ КОНЦОВОК строки!
```

**Пример со строкой "banana":**

```
    Суффиксы "banana":          Отсортированные:

    0: "banana" (весь)          5: "a"           ← самый короткий
    1: "anana"                  3: "ana"
    2: "nana"                   1: "anana"
    3: "ana"                    0: "banana"
    4: "na"                     4: "na"
    5: "a"                      2: "nana"        ← самый "поздний" по алфавиту

    Suffix Array = [5, 3, 1, 0, 4, 2]
    (индексы начала суффиксов в лексикографическом порядке)
```

**Зачем это нужно:** Бинарный поиск! Ищем "ana" за O(log n) вместо O(n).

### Аналогия 2: Aho-Corasick как сканер штрих-кодов

```
    СКАНЕР НА КАССЕ СУПЕРМАРКЕТА

    ┌────────────────────────────────────────────────────────┐
    │                                                        │
    │    Продукт проезжает мимо сканера:                    │
    │                                                        │
    │         ═══════════════════════════>                  │
    │         │ молоко │ хлеб │ сыр │ вода │                │
    │         ═══════════════════════════>                  │
    │                    │                                   │
    │                    ▼                                   │
    │              ┌──────────┐                              │
    │              │ СКАНЕР   │   Распознаёт:               │
    │              │ (Aho-    │   - молоко: 49₽             │
    │              │ Corasick)│   - хлеб: 35₽               │
    │              └──────────┘   - сыр: 89₽                │
    │                             - вода: 25₽               │
    │                                                        │
    └────────────────────────────────────────────────────────┘

    ОДИН ПРОХОД — находим ВСЕ паттерны сразу!
    Не нужно сканировать каждый продукт отдельно.
```

**Failure links — это "план Б":**

```
    Ищем паттерны: "she", "he", "hers"

    Текст: "ushers"
                ↓
           u → нет в trie, идём дальше
           s → есть! начинаем путь
           h → s→sh
           e → sh→she ✓ НАШЛИ "she"!

    Но wait! "he" — тоже часть "she"!
    Failure link: she → he (суффикс!)
    Поэтому находим и "he" автоматически ✓
```

### Аналогия 3: Manacher как расширяющееся зеркало

```
    ПОИСК ПАЛИНДРОМОВ = РАСШИРЕНИЕ ЗЕРКАЛА

    Представьте, что вы стоите в центре комнаты с двумя зеркалами:

    ┌─────────────────────────────────────────────┐
    │                                             │
    │   ЗЕРКАЛО ◄────── ВЫ ──────► ЗЕРКАЛО       │
    │                                             │
    │   Если отражения симметричны — палиндром!  │
    │                                             │
    └─────────────────────────────────────────────┘

    Для строки "abacaba":

       a   b   a   c   a   b   a
       ↑───────────────────────↑
       Симметрия относительно 'c' → палиндром!

    Центр: 'c' (индекс 3)
    Радиус: 3 (покрывает 3 символа в каждую сторону)
```

**Хитрость Манакера — использовать уже найденные палиндромы:**

```
    Уже нашли палиндром с центром c и радиусом r:

                 ◄──── радиус r ────►
           |----|----|----|----|----|----|
           ↑                   ↑         ↑
        левая              центр c    правая
        граница                       граница

    Теперь обрабатываем позицию i внутри этого палиндрома:

                      ↓ зеркало относительно c
           |----|----|----|----|----|----|
                ↑                   ↑
             mirror i            текущая i

    Если p[mirror] = 2, то p[i] тоже МИНИМУМ 2!
    Симметрия даёт информацию бесплатно → O(n) вместо O(n²)
```

### Аналогия 4: Suffix Automaton как карта метро

```
    КАРТА МЕТРО ДЛЯ ВСЕХ ПОДСТРОК

    Представьте метро, где:
    - Станция = состояние автомата
    - Рельсы = переходы по буквам
    - Любой маршрут = подстрока

    ┌─────────────────────────────────────────────────────┐
    │                                                     │
    │         START                                       │
    │           │                                         │
    │           ├──'a'──► [a] ──'b'──► [ab]              │
    │           │          │                              │
    │           │          └──'a'──► [aa] ──'b'──► [aab] │
    │           │                                         │
    │           └──'b'──► [b]                             │
    │                                                     │
    │    Любой путь от START = какая-то подстрока!       │
    │    Все возможные маршруты = все подстроки         │
    │                                                     │
    └─────────────────────────────────────────────────────┘

    МАГИЯ: Хранит ЭКСПОНЕНЦИАЛЬНОЕ количество подстрок
           в ЛИНЕЙНОМ пространстве O(n)!
```

**Suffix links — это "телепорты к суффиксам":**

```
    Состояние "aab" → suffix link → состояние "ab"
                    → suffix link → состояние "b"
                    → suffix link → START

    Эти ссылки позволяют:
    - Найти все вхождения подстроки
    - Считать различные подстроки
    - Находить LCS (longest common substring)
```

### Числовой пример: LCP Array для "banana"

```
    Строка: "banana"
    Suffix Array: [5, 3, 1, 0, 4, 2]

    Соседние суффиксы в отсортированном порядке:

    SA[0]=5: "a"
    SA[1]=3: "ana"      LCP с предыдущим = 1 ("a" общее)
    SA[2]=1: "anana"    LCP с предыдущим = 3 ("ana" общее)
    SA[3]=0: "banana"   LCP с предыдущим = 0 (ничего общего)
    SA[4]=4: "na"       LCP с предыдущим = 0 (ничего общего)
    SA[5]=2: "nana"     LCP с предыдущим = 2 ("na" общее)

    ┌─────────────────────────────────────────────┐
    │  LCP Array = [0, 1, 3, 0, 0, 2]             │
    │                                             │
    │  Различных подстрок = n(n+1)/2 - Σ LCP     │
    │                     = 6×7/2 - (0+1+3+0+0+2) │
    │                     = 21 - 6 = 15           │
    └─────────────────────────────────────────────┘

    Проверка: a, an, ana, anan, anana, b, ba, ban,
              bana, banan, banana, n, na, nan, nana = 15 ✓
```

### Когда что использовать

```
    ┌────────────────────────────────────────────────────────┐
    │                 ВЫБОР ИНСТРУМЕНТА                      │
    ├────────────────────────────────────────────────────────┤
    │                                                        │
    │  1 паттерн в тексте?                                  │
    │     → KMP или Z-function (простые, O(n+m))            │
    │                                                        │
    │  1000 паттернов в тексте?                             │
    │     → Aho-Corasick (один проход по тексту!)           │
    │                                                        │
    │  Много запросов к одной строке?                       │
    │     → Suffix Array (построил раз, ищи O(log n))       │
    │                                                        │
    │  Все подстроки, их количество, LCS?                   │
    │     → Suffix Automaton (самый мощный, O(n))           │
    │                                                        │
    │  Все палиндромы?                                       │
    │     → Manacher (единственный выбор для O(n))          │
    │                                                        │
    └────────────────────────────────────────────────────────┘
```

---

## Часть 2: Почему это сложно

### Типичные ошибки студентов

#### Ошибка 1: Путаница с индексами в Suffix Array

```
    ПУТАНИЦА:

    SA[i] — что это?
    ❌ "i-й суффикс строки"
    ✅ "Индекс начала суффикса, стоящего на i-й позиции после сортировки"

    Пример (s = "banana"):
    SA = [5, 3, 1, 0, 4, 2]

    SA[0] = 5 означает:
    "Самый маленький лексикографически суффикс НАЧИНАЕТСЯ с позиции 5"
    s[5:] = "a" — это первый в алфавитном порядке

    SA[3] = 0 означает:
    "4-й по алфавиту суффикс НАЧИНАЕТСЯ с позиции 0"
    s[0:] = "banana"
```

**СИМПТОМ:** Выводите суффикс вместо индекса или наоборот.

**РЕШЕНИЕ:** SA — это массив ИНДЕКСОВ. Суффикс = s[SA[i]:].

#### Ошибка 2: Aho-Corasick без сбора output через failure

```kotlin
// ❌ НЕПРАВИЛЬНО: только локальные совпадения
for (patternIdx in nodes[node].output) {
    result.add(patternIdx)  // Пропускаем паттерны-суффиксы!
}

// ✅ ПРАВИЛЬНО: собираем output через failure links при BUILD
fun build() {
    // ... при построении failure links ...
    nodes[v].output.addAll(nodes[nodes[v].fail].output)
}

// Теперь nodes[node].output содержит ВСЕ паттерны
```

**СИМПТОМ:** Находите "she", но не находите "he" в той же позиции.

**РЕШЕНИЕ:** При построении failure links копируйте output из fail-узла.

#### Ошибка 3: Manacher без краевых разделителей

```
    ❌ НЕПРАВИЛЬНО:
    "abba" → "a#b#b#a"

    Проблема: палиндром на краю не обработается!
    Радиус для 'a' на позиции 0 считается неправильно.

    ✅ ПРАВИЛЬНО:
    "abba" → "#a#b#b#a#"

    Теперь:
    - Чётные палиндромы ("bb") имеют центр '#' между ними
    - Краевые случаи обрабатываются корректно
    - Все палиндромы нечётной длины в transformed
```

**СИМПТОМ:** Пропускаете чётные палиндромы или палиндромы на краях.

#### Ошибка 4: Suffix Automaton — неправильное клонирование

```
    ПРОБЛЕМА КЛОНИРОВАНИЯ:

    При добавлении символа иногда нужно "расщепить" состояние.

    Когда НЕ нужно клонировать:
    len[q] = len[p] + 1  (состояние "непрерывное")

    Когда НУЖНО клонировать:
    len[q] > len[p] + 1  (в состоянии смешаны разные длины)

    ❌ НЕПРАВИЛЬНО: забыли обновить все ссылки после клонирования
    ✅ ПРАВИЛЬНО: нужно обновить:
       1. link[q] = clone
       2. link[cur] = clone
       3. Все переходы из коротких состояний: p.next[c] = clone
```

**СИМПТОМ:** Автомат работает неправильно на сложных строках.

**РЕШЕНИЕ:** Тщательно следуйте алгоритму клонирования. Это самая сложная часть SAM.

#### Ошибка 5: Выбор неправильной структуры

```
    ТИПИЧНЫЕ ОШИБКИ ВЫБОРА:

    ❌ "Нужно найти 1 паттерн → использую Suffix Automaton"
       Это overkill! KMP достаточно.

    ❌ "Нужно найти 1000 паттернов → запущу KMP 1000 раз"
       Это O(1000 × n), очень медленно!
       Aho-Corasick сделает за O(n).

    ❌ "Все подстроки и их количество → Suffix Array"
       SAM делает это проще и быстрее (O(n) vs O(n log n)).

    ❌ "Longest Palindrome → перебор всех центров"
       O(n²)! Manacher — O(n).
```

**СИМПТОМ:** TLE или MLE на больших входных данных.

**РЕШЕНИЕ:** Изучите таблицу сравнения структур. Выбирайте минимально достаточный инструмент.

#### Ошибка 6: Недооценка памяти для Aho-Corasick

```
    ПАМЯТЬ AHO-CORASICK:

    Наивный подход с массивом children[256]:
    100,000 паттернов × 256 × 8 байт = 200 MB+ только на указатели!

    ✅ РЕШЕНИЯ:
    1. HashMap вместо массива для children
       (медленнее, но экономит память)

    2. Сжатое представление (если алфавит маленький)

    3. Для конкурсов: children[26] для a-z
       26 × 8 × 100000 = 20 MB — терпимо
```

**СИМПТОМ:** MLE на тестах с большим количеством паттернов.

---

## Часть 3: Ментальные модели

### Модель 1: Suffix Array как индексация поисковика

```
    GOOGLE ИНДЕКСИРУЕТ ВЕБ

    ┌─────────────────────────────────────────────────────────┐
    │                                                         │
    │  Веб = огромная строка (все страницы склеены)          │
    │  Запрос = паттерн для поиска                           │
    │                                                         │
    │  Без индекса:                                           │
    │    Проходим весь веб для каждого запроса → O(веб × q)  │
    │                                                         │
    │  С Suffix Array:                                        │
    │    Строим индекс один раз → O(веб × log веб)           │
    │    Каждый запрос → O(запрос × log веб)                 │
    │                                                         │
    │  1 миллиард запросов? Индекс экономит ГОДЫ!            │
    │                                                         │
    └─────────────────────────────────────────────────────────┘
```

**Когда использовать:** Много запросов к одному тексту. Построение дорогое, поиск дешёвый.

### Модель 2: Aho-Corasick как антивирус

```
    АНТИВИРУСНЫЙ СКАНЕР

    База сигнатур вирусов: 10 миллионов паттернов
    Файл для проверки: 1 GB

    ┌─────────────────────────────────────────────────┐
    │                                                 │
    │   Наивно: 10M × 1GB = 10 петабайт сравнений!   │
    │                                                 │
    │   Aho-Corasick:                                 │
    │   1. Построить автомат из всех сигнатур        │
    │   2. Один проход по файлу                       │
    │   3. Находим ВСЕ вирусы за O(1GB)              │
    │                                                 │
    └─────────────────────────────────────────────────┘

    Каждый символ файла обрабатывается ОДИН РАЗ!
    Не важно, сколько паттернов — время зависит от файла.
```

**Когда использовать:** Много паттернов, нужно найти все вхождения одним проходом.

### Модель 3: Manacher как развёртывание рулетки

```
    ИЗМЕРЕНИЕ ПАЛИНДРОМОВ

    Представьте гибкую измерительную рулетку:

         ┌──────────────────────────────────────┐
         │  Центр палиндрома                    │
         │        ↓                             │
         │    ◄───┼───►                         │
         │    левая│правая                      │
         │    часть│часть                       │
         │                                      │
         │  Растягиваем рулетку в обе стороны,  │
         │  пока символы совпадают!             │
         └──────────────────────────────────────┘

    ОПТИМИЗАЦИЯ:
    Если мы уже растянули большой палиндром,
    и текущая позиция внутри него —
    можно "скопировать" длину с зеркальной позиции!

    Каждый символ "растягивается" максимум один раз → O(n)
```

**Когда использовать:** Любые задачи на палиндромы. Единственный O(n) алгоритм.

### Модель 4: Suffix Automaton как GPS-навигатор

```
    GPS ПОДСТРОК

    ┌─────────────────────────────────────────────────────┐
    │                                                     │
    │  Вопрос: "Как добраться от START до подстроки X?"  │
    │                                                     │
    │  SAM: "Следуй по буквам X. Каждая буква = шаг."    │
    │                                                     │
    │  Если путь существует → X есть в строке            │
    │  Если нет перехода → X нет в строке                │
    │                                                     │
    │  SUFFIX LINKS = объезды:                            │
    │  "Если застрял, вот короткий путь к суффиксу"      │
    │                                                     │
    └─────────────────────────────────────────────────────┘

    Всё пространство подстрок сжато в O(n) узлов!
    Экспоненциальное → линейное.
```

**Когда использовать:** Сложные запросы о подстроках. Самая мощная структура данных.

### Модель 5: Сравнение как выбор инструмента в мастерской

```
    МАСТЕРСКАЯ СТРОКОВЫХ АЛГОРИТМОВ

    ┌───────────────────────────────────────────────────────────┐
    │                                                           │
    │  МОЛОТОК (KMP):                                          │
    │  Простой, надёжный. Для одного гвоздя — идеально.        │
    │                                                           │
    │  ПНЕВМАТИЧЕСКИЙ ПИСТОЛЕТ (Aho-Corasick):                 │
    │  Для 1000 гвоздей подряд. Быстро, но нужна настройка.    │
    │                                                           │
    │  ЛАЗЕРНЫЙ УРОВЕНЬ (Suffix Array):                        │
    │  Дорогая установка, но потом — идеально ровные линии.    │
    │                                                           │
    │  ШВЕЙЦАРСКИЙ НОЖ (Suffix Automaton):                     │
    │  Делает всё, но сложно освоить.                          │
    │                                                           │
    │  СИММЕТРИЧНОЕ ЗЕРКАЛО (Manacher):                        │
    │  Только для палиндромов, но лучше него нет.              │
    │                                                           │
    └───────────────────────────────────────────────────────────┘
```

### Сравнение ментальных моделей

| Модель | Структура | Лучше всего для |
|--------|-----------|-----------------|
| Индекс книги | Suffix Array | Много запросов поиска |
| Антивирус | Aho-Corasick | Много паттернов одновременно |
| Рулетка | Manacher | Все палиндромы |
| GPS навигатор | Suffix Automaton | Сложные запросы о подстроках |
| Мастерская | Все | Выбор правильного инструмента |

---

## Зачем это нужно?

**Проблема:**

```
1. Поиск 1000 паттернов в тексте из 10^6 символов
   KMP 1000 раз: O(1000 × 10^6) = 10^9
   Aho-Corasick: O(10^6 + total_patterns) ≈ 10^6

2. Количество различных подстрок
   Наивно: O(n³)
   Suffix Array: O(n log n)
   Suffix Automaton: O(n)
```

**Применения:**

| Структура | Применение |
|-----------|------------|
| Suffix Array | LCP queries, pattern matching, genome analysis |
| Aho-Corasick | Spam filters, intrusion detection, text search |
| Manacher | Palindrome problems, DNA analysis |
| Suffix Automaton | Distinct substrings, substring matching |

---

## Suffix Array

### Что это?

```
Suffix Array — массив индексов суффиксов строки,
отсортированных в лексикографическом порядке.

s = "banana"
Суффиксы:
0: "banana"
1: "anana"
2: "nana"
3: "ana"
4: "na"
5: "a"

Отсортированные: "a", "ana", "anana", "banana", "na", "nana"
Suffix Array:    [5,   3,    1,       0,        4,    2]
```

### Построение O(n log n)

```kotlin
/**
 * Suffix Array — построение методом doubling
 *
 * ИДЕЯ: Сортируем суффиксы по первым 2^k символам,
 *       удваивая k на каждой итерации
 *
 * ПОШАГОВЫЙ ПРИМЕР (s = "banana"):
 * ```
 * k=1: сортируем по 1 символу
 *   rank: b=98, a=97, n=110, a=97, n=110, a=97
 *   sa после: [1,3,5, 0, 2,4] (сначала 'a', потом 'b', потом 'n')
 *
 * k=2: сортируем по парам (rank[i], rank[i+1])
 *   "a"  = (97, -1)    ← -1 потому что нет символа после
 *   "ana"= (97, 110)   ← 'a' потом 'n'
 *   ...
 *
 * k=4: достаточно для различения всех суффиксов
 *   sa = [5, 3, 1, 0, 4, 2] — финальный результат
 * ```
 *
 * СЛОЖНОСТЬ: O(n log² n) с обычной сортировкой
 *            O(n log n) с radix sort
 */
fun buildSuffixArray(s: String): IntArray {
    val n = s.length
    val sa = IntArray(n) { it }           // Индексы суффиксов
    var rank = IntArray(n) { s[it].code } // Начальный ранг = ASCII код
    var tmp = IntArray(n)
    var k = 1

    while (k < n) {
        /**
         * СРАВНЕНИЕ ПО ПАРАМ (rank[i], rank[i+k])
         *
         * Ключевая идея: если мы уже отсортировали по k символам,
         * то для сортировки по 2k символам достаточно сравнить:
         * - rank[i] — ранг первых k символов
         * - rank[i+k] — ранг следующих k символов
         *
         * Пример для k=2:
         *   суффикс "banana" = ("ba" ранг, "na" ранг)
         *   суффикс "anana"  = ("an" ранг, "an" ранг)
         *
         * -1 используется если суффикс короче k символов
         */
        val comparator = Comparator<Int> { a, b ->
            if (rank[a] != rank[b]) rank[a] - rank[b]
            else {
                val ra = if (a + k < n) rank[a + k] else -1
                val rb = if (b + k < n) rank[b + k] else -1
                ra - rb
            }
        }

        sa.sortedArrayWith(comparator).copyInto(sa)

        /**
         * ПЕРЕСЧЁТ РАНГОВ после сортировки
         *
         * Новый ранг = порядковый номер в отсортированном массиве
         * Равные элементы получают одинаковый ранг
         *
         * sa = [5,3,1,0,4,2] после сортировки
         * tmp[5]=0, tmp[3]=1 (если разные), tmp[1]=2, ...
         */
        tmp[sa[0]] = 0
        for (i in 1 until n) {
            tmp[sa[i]] = tmp[sa[i - 1]]
            if (comparator.compare(sa[i - 1], sa[i]) < 0) {
                tmp[sa[i]]++  // Увеличиваем ранг только если различаются
            }
        }

        rank = tmp.also { tmp = rank }
        k *= 2

        /**
         * РАННЯЯ ОСТАНОВКА: если все ранги уникальны
         *
         * Если rank[sa[n-1]] = n-1, значит есть ранги 0,1,2,...,n-1
         * Все суффиксы полностью различимы — дальше сортировать нет смысла
         */
        if (rank[sa[n - 1]] == n - 1) break
    }

    return sa
}
```

### LCP Array (Kasai's Algorithm)

```kotlin
/**
 * LCP Array — массив наибольших общих префиксов
 *
 * LCP[i] = длина общего префикса между SA[i] и SA[i-1]
 *
 * ПРИМЕР (s = "banana", sa = [5,3,1,0,4,2]):
 * ```
 * SA[0]=5: "a"
 * SA[1]=3: "ana"      LCP[1] = 1 ("a" общий с "a")
 * SA[2]=1: "anana"    LCP[2] = 3 ("ana" общий с "ana")
 * SA[3]=0: "banana"   LCP[3] = 0 (ничего общего с "anana")
 * SA[4]=4: "na"       LCP[4] = 0 (ничего общего с "banana")
 * SA[5]=2: "nana"     LCP[5] = 2 ("na" общий с "na")
 *
 * lcp = [0, 1, 3, 0, 0, 2]
 * ```
 *
 * АЛГОРИТМ КАСАИ — O(n) вместо наивного O(n²)
 */
fun buildLCP(s: String, sa: IntArray): IntArray {
    val n = s.length
    val rank = IntArray(n)
    for (i in 0 until n) rank[sa[i]] = i  // rank[i] = позиция суффикса i в SA

    val lcp = IntArray(n)
    var k = 0  // Текущий LCP

    for (i in 0 until n) {
        if (rank[i] == 0) {
            k = 0  // Первый суффикс не имеет предыдущего
            continue
        }

        val j = sa[rank[i] - 1]  // Предыдущий суффикс в отсортированном порядке

        /**
         * КЛЮЧЕВОЕ СВОЙСТВО КАСАИ:
         *
         * LCP(suffix[i], prev) ≥ LCP(suffix[i-1], its_prev) - 1
         *
         * Почему? Если suffix[i-1] имел LCP = k с предыдущим,
         * то suffix[i] = suffix[i-1] без первого символа.
         * Значит LCP(suffix[i]) ≥ k-1 (минус тот первый символ)
         *
         * Это позволяет не пересчитывать LCP с нуля каждый раз!
         * Мы начинаем с k и только УВЕЛИЧИВАЕМ его.
         * Суммарно k увеличивается n раз и уменьшается n раз → O(n)
         */
        while (i + k < n && j + k < n && s[i + k] == s[j + k]) {
            k++
        }

        lcp[rank[i]] = k

        if (k > 0) k--  // Уменьшаем для следующей итерации
    }

    return lcp
}
```

### Применения

```kotlin
/**
 * Количество РАЗЛИЧНЫХ подстрок в строке
 *
 * ФОРМУЛА: n(n+1)/2 - Σ LCP[i]
 *
 * ИНТУИЦИЯ:
 * - Всего подстрок: n + (n-1) + ... + 1 = n(n+1)/2
 * - LCP[i] — сколько подстрок повторяются между соседними суффиксами
 * - Вычитаем дубликаты = получаем уникальные
 *
 * ПРИМЕР (s = "aba"):
 * ```
 * SA = [2,0,1] → "a", "aba", "ba"
 * LCP = [0, 1, 0]
 *
 * Всего: 3*4/2 = 6 подстрок
 * Дубликаты: 0 + 1 + 0 = 1 (подстрока "a" повторяется)
 * Различных: 6 - 1 = 5
 *
 * Проверка: "a", "ab", "aba", "b", "ba" — действительно 5!
 * ```
 */
fun countDistinctSubstrings(s: String): Long {
    val sa = buildSuffixArray(s)
    val lcp = buildLCP(s, sa)
    val n = s.length.toLong()

    val total = n * (n + 1) / 2
    val duplicates = lcp.sumOf { it.toLong() }

    return total - duplicates
}

/**
 * Поиск паттерна в строке через Suffix Array
 *
 * ИДЕЯ: Suffix Array отсортирован → бинарный поиск!
 *
 * СЛОЖНОСТЬ: O(m log n) где m = длина паттерна
 *            Лучше чем KMP O(n+m) для многократных запросов!
 *
 * ПРИМЕР:
 * ```
 * s = "banana", pattern = "ana"
 * SA = [5,3,1,0,4,2] → "a","ana","anana","banana","na","nana"
 *
 * Бинарный поиск: mid=2 → "ana" ← найдено!
 * Возвращаем SA[2] = 1 (позиция в исходной строке)
 * ```
 */
fun search(s: String, sa: IntArray, pattern: String): Int {
    val n = s.length
    val m = pattern.length

    var lo = 0
    var hi = n - 1

    while (lo <= hi) {
        val mid = (lo + hi) / 2
        val suffix = s.substring(sa[mid], minOf(sa[mid] + m, n))

        when {
            suffix < pattern -> lo = mid + 1
            suffix > pattern -> hi = mid - 1
            else -> return sa[mid]  // Позиция в исходной строке
        }
    }

    return -1  // Не найдено
}
```

**Сложность:**
- Build: O(n log n) или O(n) с SA-IS
- LCP: O(n)
- Search: O(m log n)

---

## Aho-Corasick Algorithm

### Что это?

```
Автомат для поиска ВСЕХ паттернов одновременно.

Компоненты:
1. Trie из всех паттернов
2. Failure links (как в KMP, но для trie)
3. Output links (какие паттерны заканчиваются)

Пример:
Patterns: ["he", "she", "his", "hers"]
Text: "ushers"

Автомат находит ВСЕ: "she", "he", "hers" за один проход!
```

### Реализация (Kotlin)

```kotlin
/**
 * Aho-Corasick — автомат для поиска множества паттернов
 *
 * ИДЕЯ: Строим Trie из паттернов + failure links (как π в KMP)
 *       Один проход по тексту находит ВСЕ паттерны!
 *
 * ПОШАГОВЫЙ ПРИМЕР:
 * ```
 * Patterns: ["he", "she", "his", "hers"]
 * Text: "ushers"
 *
 * Trie:           Failure links:
 *      (root)         (root)
 *      /    \
 *     h      s         h.fail → root
 *    /|\      \        s.fail → root
 *   e i r     h        sh.fail → h (!) ← ключевая оптимизация
 *   |   |      \
 *   r   s      e       she.fail → he (!)
 *
 * Поиск "ushers":
 * u: нет перехода, остаёмся в root
 * s: root→s
 * h: s→sh
 * e: sh→she (MATCH "she"!) + failure→he (MATCH "he"!)
 * r: she→sher (продолжаем)
 * s: sher→shers (MATCH "hers"!)
 * ```
 *
 * СЛОЖНОСТЬ: O(sum|patterns|) построение + O(|text|) поиск
 */
class AhoCorasick {
    data class Node(
        val children: MutableMap<Char, Int> = mutableMapOf(),
        var fail: Int = 0,
        /**
         * output — индексы паттернов, заканчивающихся в этом узле
         * + все паттерны из failure chain
         * Позволяет за O(1) получить все совпадения
         */
        val output: MutableList<Int> = mutableListOf()
    )

    private val nodes = mutableListOf(Node())
    private val patterns = mutableListOf<String>()

    /**
     * Добавление паттерна в Trie
     *
     * Стандартная вставка: идём по буквам, создаём узлы если нужно
     * В конечном узле сохраняем индекс паттерна в output
     */
    fun addPattern(pattern: String) {
        var node = 0
        for (c in pattern) {
            if (c !in nodes[node].children) {
                nodes[node].children[c] = nodes.size
                nodes.add(Node())
            }
            node = nodes[node].children[c]!!
        }
        nodes[node].output.add(patterns.size)
        patterns.add(pattern)
    }

    /**
     * Построение failure links через BFS
     *
     * Failure link указывает на самый длинный суффикс текущего
     * состояния, который является префиксом какого-то паттерна
     *
     * Пример: "she" → fail → "he" → fail → "e" → fail → root
     */
    fun build() {
        val queue = ArrayDeque<Int>()

        /**
         * База: дети корня имеют fail = 0 (корень)
         *
         * Если не нашли переход на глубине 1, откатываемся в корень
         */
        for ((_, child) in nodes[0].children) {
            queue.add(child)
        }

        while (queue.isNotEmpty()) {
            val u = queue.removeFirst()

            for ((c, v) in nodes[u].children) {
                queue.add(v)

                /**
                 * ВЫЧИСЛЕНИЕ FAILURE LINK
                 *
                 * Идея: fail[v] = самый длинный суффикс пути до v,
                 *       который сам является путём от корня
                 *
                 * Алгоритм:
                 * 1. Берём fail[parent] = f
                 * 2. Если из f есть переход по c → это fail[v]
                 * 3. Иначе f = fail[f] и повторяем
                 *
                 * Аналог цепочки откатов π[i] в KMP!
                 */
                var f = nodes[u].fail
                while (f != 0 && c !in nodes[f].children) {
                    f = nodes[f].fail
                }

                nodes[v].fail = nodes[f].children[c] ?: 0
                if (nodes[v].fail == v) nodes[v].fail = 0  // Избегаем self-loop

                /**
                 * СБОР OUTPUT ЧЕРЕЗ FAILURE CHAIN
                 *
                 * Важно! В узле v могут заканчиваться паттерны,
                 * которые являются суффиксами текущего пути
                 *
                 * Пример: в "she" также заканчивается "he"
                 *         потому что "he" = суффикс "she"
                 *
                 * Копируем output из fail[v] в v
                 */
                nodes[v].output.addAll(nodes[nodes[v].fail].output)
            }
        }
    }

    /**
     * Поиск всех вхождений паттернов в тексте
     *
     * @return список пар (позиция, паттерн)
     */
    fun search(text: String): List<Pair<Int, String>> {
        val result = mutableListOf<Pair<Int, String>>()
        var node = 0

        for ((i, c) in text.withIndex()) {
            /**
             * ПЕРЕХОД ПО АВТОМАТУ
             *
             * Если нет перехода по c — идём по failure links
             * Аналог откатов в KMP при несовпадении
             *
             * Важно: failure link ВСЕГДА ведёт к более короткому
             * состоянию → гарантированное завершение
             */
            while (node != 0 && c !in nodes[node].children) {
                node = nodes[node].fail
            }

            node = nodes[node].children[c] ?: 0

            /**
             * СБОР ВСЕХ СОВПАДЕНИЙ
             *
             * В output[node] хранятся ВСЕ паттерны,
             * заканчивающиеся в текущей позиции
             * (включая те, что через failure chain)
             *
             * i - pattern.length + 1 = позиция начала паттерна
             */
            for (patternIdx in nodes[node].output) {
                val pattern = patterns[patternIdx]
                result.add(i - pattern.length + 1 to pattern)
            }
        }

        return result
    }
}

// Использование
val ac = AhoCorasick()
ac.addPattern("he")
ac.addPattern("she")
ac.addPattern("his")
ac.addPattern("hers")
ac.build()

val matches = ac.search("ushers")
// [(1, "she"), (2, "he"), (2, "hers")]
```

**Сложность:**
- Build: O(Σ|patterns| × k) где k = размер алфавита
- Search: O(|text| + |matches|)

---

## Manacher's Algorithm

### Что это?

```
Находит ВСЕ палиндромы за O(n), используя симметрию.

Ключевая идея:
Если мы внутри большого палиндрома,
можем использовать информацию с "зеркальной" стороны.

Трансформация для чётных палиндромов:
"abba" → "#a#b#b#a#"
Теперь ВСЕ палиндромы нечётной длины!
```

### Визуализация

```
s = "abacaba"
Transformed: "#a#b#a#c#a#b#a#"

Позиция:      0 1 2 3 4 5 6 7 8 9 ...
Символ:       # a # b # a # c # a ...
Радиус:       0 1 0 3 0 1 0 7 0 1 ...
                      ↑
              center of "aba"
                              ↑
              center of "abacaba" (radius 7)

Когда мы в позиции i и уже знаем палиндром с центром c и правой границей r:
- Если i < r, можем использовать зеркальную позицию 2*c - i
- Минимум = min(r - i, p[mirror])
```

### Реализация (Kotlin)

```kotlin
/**
 * Алгоритм Манакера — все палиндромы за O(n)
 *
 * ИДЕЯ: Использовать симметрию уже найденных палиндромов
 *
 * ТРАНСФОРМАЦИЯ:
 * "abba" → "#a#b#b#a#"
 * Зачем? Чтобы и чётные, и нечётные палиндромы
 * имели один центральный символ
 *
 * ПОШАГОВЫЙ ПРИМЕР (s = "abacaba"):
 * ```
 * Transformed: # a # b # a # c # a # b # a #
 * Index:       0 1 2 3 4 5 6 7 8 9 ...
 *
 * i=7 (символ 'c'):
 *   Это центр "abacaba" → p[7] = 7
 *   right = 7 + 7 = 14
 *
 * i=9 (символ 'a'):
 *   i < right=14, значит используем симметрию!
 *   mirror = 2*7 - 9 = 5, p[5] = 1
 *   p[9] = min(14-9, 1) = 1
 *   Пробуем расширить → p[9] = 1 (не расширяется)
 * ```
 */
fun manacher(s: String): IntArray {
    /**
     * ТРАНСФОРМАЦИЯ строки
     *
     * "aba" → "#a#b#a#"
     * Теперь центр чётного палиндрома "bb" — это '#' между ними
     * Все палиндромы имеют нечётную длину в transformed
     */
    val t = StringBuilder("#")
    for (c in s) {
        t.append(c).append('#')
    }
    val transformed = t.toString()

    val n = transformed.length
    /**
     * p[i] = радиус палиндрома с центром в i
     *
     * Радиус НЕ включает центр
     * Пример: "#a#b#a#" с центром 3 ('b')
     *         p[3] = 3 (покрывает "#a#" слева и справа)
     */
    val p = IntArray(n)

    var center = 0  // Центр самого правого палиндрома
    var right = 0   // Правая граница этого палиндрома

    for (i in 0 until n) {
        /**
         * КЛЮЧЕВАЯ ОПТИМИЗАЦИЯ: использование симметрии
         *
         * Если i находится внутри известного палиндрома (i < right):
         *   mirror = 2*center - i (зеркальная позиция)
         *   p[i] ≥ min(right - i, p[mirror])
         *
         * Почему min?
         * - p[mirror] — радиус на зеркальной позиции
         * - right - i — расстояние до границы
         *
         * Если p[mirror] не выходит за границу → p[i] = p[mirror]
         * Если выходит → p[i] = right - i (пока не знаем дальше)
         */
        if (i < right) {
            val mirror = 2 * center - i
            p[i] = minOf(right - i, p[mirror])
        }

        /**
         * РАСШИРЕНИЕ палиндрома
         *
         * Пробуем расширить от текущего p[i]
         * left и r — левая и правая границы для проверки
         */
        var left = i - p[i] - 1
        var r = i + p[i] + 1
        while (left >= 0 && r < n && transformed[left] == transformed[r]) {
            p[i]++
            left--
            r++
        }

        /**
         * ОБНОВЛЕНИЕ center и right
         *
         * Если новый палиндром простирается дальше вправо,
         * обновляем center и right для будущих итераций
         *
         * Это гарантирует O(n): каждый символ "расширяется" максимум один раз
         */
        if (i + p[i] > right) {
            center = i
            right = i + p[i]
        }
    }

    return p
}

/**
 * Поиск самого длинного палиндрома в строке
 *
 * Используем массив p от Манакера:
 * - Находим максимальный p[i]
 * - Конвертируем индексы обратно в оригинальную строку
 */
fun longestPalindrome(s: String): String {
    val p = manacher(s)
    var maxLen = 0
    var maxCenter = 0

    for (i in p.indices) {
        if (p[i] > maxLen) {
            maxLen = p[i]
            maxCenter = i
        }
    }

    /**
     * КОНВЕРТАЦИЯ индексов
     *
     * В transformed: center = maxCenter, radius = maxLen
     * В original: start = (maxCenter - maxLen) / 2
     *
     * Почему делим на 2?
     * - В transformed каждый символ original занимает 2 позиции
     * - "#a#b#a#" → индекс 'b' = 3, в original = 1 = (3-0)/2
     *
     * Длина = maxLen (радиус в transformed = длина в original)
     */
    val start = (maxCenter - maxLen) / 2
    return s.substring(start, start + maxLen)
}
```

**Сложность:** O(n) — каждый символ обрабатывается константное число раз.

---

## Suffix Automaton

### Что это?

```
Минимальный ДКА, принимающий все суффиксы строки.
Эквивалентно: принимает ВСЕ подстроки!

Свойства:
- O(n) состояний
- O(n) переходов
- Строится за O(n)
- Каждое состояние = класс эквивалентности подстрок
```

### Структура состояния

```kotlin
/**
 * Состояние суффиксного автомата
 *
 * Каждое состояние представляет КЛАСС ЭКВИВАЛЕНТНОСТИ подстрок:
 * все подстроки, которые являются суффиксами друг друга в позициях вхождения
 */
data class State(
    /**
     * len — длина САМОЙ ДЛИННОЙ строки в классе эквивалентности
     *
     * Все строки в состоянии: от len[link]+1 до len
     * Пример: состояние с len=5 и link.len=2
     *         содержит строки длиной 3, 4, 5
     */
    var len: Int = 0,

    /**
     * link — суффиксная ссылка (suffix link)
     *
     * Указывает на состояние, содержащее самый длинный
     * суффикс, НЕ входящий в текущий класс эквивалентности
     *
     * Аналог π-функции в KMP, но для автомата
     */
    var link: Int = -1,

    val next: MutableMap<Char, Int> = mutableMapOf()
)
```

### Реализация (Kotlin)

```kotlin
/**
 * Суффиксный автомат — минимальный ДКА для всех подстрок
 *
 * ИДЕЯ: Каждое состояние = класс подстрок с одинаковыми
 *       позициями правых концов (endpos-эквивалентность)
 *
 * ПОШАГОВЫЙ ПРИМЕР (s = "aab"):
 * ```
 * Начало: state0 (пустая строка)
 *
 * extend('a'):
 *   state1: len=1, link→state0
 *   state0.next['a'] = state1
 *
 * extend('a'):
 *   state2: len=2, link→state1
 *   state1.next['a'] = state2
 *   state0.next['a'] уже есть → проверяем...
 *
 * extend('b'):
 *   state3: len=3, link→state0
 *   state2.next['b'] = state3
 *   state1.next['b'] = state3
 *   state0.next['b'] = state3
 * ```
 *
 * СЛОЖНОСТЬ: O(n) времени и памяти
 */
class SuffixAutomaton {
    // state0 = начальное состояние (пустая строка)
    private val states = mutableListOf(State())
    private var last = 0  // Последнее добавленное состояние

    /**
     * Расширение автомата новым символом
     *
     * Добавляем символ c к строке, обновляя автомат
     */
    fun extend(c: Char) {
        val cur = states.size
        states.add(State(len = states[last].len + 1))

        var p = last
        /**
         * ДОБАВЛЕНИЕ ПЕРЕХОДОВ по суффиксным ссылкам
         *
         * Идём от last по suffix links и добавляем переход по c
         * пока не найдём состояние, где уже есть переход по c
         *
         * Почему это работает: все эти состояния соответствуют
         * суффиксам текущей строки, и после добавления c
         * они должны вести в новое состояние cur
         */
        while (p != -1 && c !in states[p].next) {
            states[p].next[c] = cur
            p = states[p].link
        }

        if (p == -1) {
            /**
             * Случай 1: дошли до начала (нет перехода по c нигде)
             *
             * Значит подстрока, заканчивающаяся на c, встретилась впервые
             * Suffix link ведёт в начальное состояние
             */
            states[cur].link = 0
        } else {
            val q = states[p].next[c]!!

            if (states[p].len + 1 == states[q].len) {
                /**
                 * Случай 2: состояние q "непрерывно"
                 *
                 * len[q] = len[p] + 1 означает, что q содержит
                 * только строки, продолжающие строки из p
                 *
                 * Можем просто сделать link[cur] = q
                 */
                states[cur].link = q
            } else {
                /**
                 * Случай 3: нужно КЛОНИРОВАТЬ состояние q
                 *
                 * q содержит строки разной длины, и нам нужно
                 * "расщепить" его на две части:
                 * - clone: короткие строки (len = len[p] + 1)
                 * - q: длинные строки (оригинальный len)
                 *
                 * Это самая сложная часть алгоритма!
                 */
                val clone = states.size
                states.add(State(
                    len = states[p].len + 1,
                    link = states[q].link,
                    next = states[q].next.toMutableMap()  // Копируем переходы
                ))

                /**
                 * ПЕРЕНАПРАВЛЕНИЕ переходов
                 *
                 * Все переходы по c, которые вели в q из коротких состояний,
                 * теперь должны вести в clone
                 */
                while (p != -1 && states[p].next[c] == q) {
                    states[p].next[c] = clone
                    p = states[p].link
                }

                states[q].link = clone    // q теперь ссылается на clone
                states[cur].link = clone  // cur тоже ссылается на clone
            }
        }

        last = cur
    }

    fun build(s: String) {
        for (c in s) extend(c)
    }

    /**
     * Количество РАЗЛИЧНЫХ подстрок строки
     *
     * ФОРМУЛА: Σ (len[i] - len[link[i]]) для всех состояний
     *
     * Интуиция: каждое состояние содержит строки длиной от len[link]+1 до len
     * Количество таких строк = len - len[link]
     */
    fun countDistinct(): Long {
        var count = 0L
        for (i in 1 until states.size) {
            count += states[i].len - states[states[i].link].len
        }
        return count
    }

    /**
     * Проверка: является ли pattern подстрокой?
     *
     * Просто идём по автомату, следуя переходам
     * Если все переходы существуют → подстрока есть
     */
    fun contains(pattern: String): Boolean {
        var state = 0
        for (c in pattern) {
            state = states[state].next[c] ?: return false
        }
        return true
    }

    /**
     * Количество вхождений подстроки
     *
     * Находим состояние для pattern, затем считаем
     * размер endpos-множества (сколько позиций)
     */
    fun countOccurrences(pattern: String): Int {
        var state = 0
        for (c in pattern) {
            state = states[state].next[c] ?: return 0
        }
        /**
         * Размер endpos = количество терминальных состояний в поддереве suffix links
         * Требует предобработки: DFS по дереву suffix links
         */
        return countTerminal(state)
    }

    private fun countTerminal(state: Int): Int {
        // Нужна предобработка: для каждого состояния посчитать
        // количество путей до терминальных состояний
        TODO("Требует дополнительной предобработки")
    }
}
```

### Применения

```kotlin
// 1. Количество различных подстрок: O(n)
val sam = SuffixAutomaton()
sam.build("ababa")
println(sam.countDistinct())  // 9

// 2. Проверка подстроки: O(m)
println(sam.contains("bab"))  // true

// 3. Longest Common Substring двух строк
fun longestCommonSubstring(s1: String, s2: String): Int {
    val sam = SuffixAutomaton()
    sam.build(s1)

    var state = 0
    var len = 0
    var maxLen = 0

    for (c in s2) {
        while (state != 0 && c !in sam.states[state].next) {
            state = sam.states[state].link
            len = sam.states[state].len
        }

        if (c in sam.states[state].next) {
            state = sam.states[state].next[c]!!
            len++
            maxLen = maxOf(maxLen, len)
        }
    }

    return maxLen
}
```

**Сложность:**
- Build: O(n)
- Space: O(n)
- Contains: O(m)
- Count distinct: O(n)

---

## Сравнение структур

| Структура | Build | Space | Distinct Substrings | Pattern Search |
|-----------|-------|-------|---------------------|----------------|
| Suffix Array | O(n log n) | O(n) | O(n) with LCP | O(m log n) |
| Suffix Automaton | O(n) | O(n) | O(n) | O(m) |
| Suffix Tree | O(n) | O(n) | O(n) | O(m) |
| Aho-Corasick | O(Σ\|p\|) | O(Σ\|p\|) | — | O(\|t\| + matches) |

---

## Распространённые ошибки

### 1. Suffix Array: неправильная инициализация rank

```kotlin
// ❌ НЕПРАВИЛЬНО: rank начинается с 0
var rank = IntArray(n) { 0 }

// ✅ ПРАВИЛЬНО: rank = код символа
var rank = IntArray(n) { s[it].code }
```

### 2. Aho-Corasick: забыть собрать output через failure

```kotlin
// ❌ НЕПРАВИЛЬНО: только локальный output
nodes[v].output  // Пропускаем паттерны из failure chain

// ✅ ПРАВИЛЬНО: собираем через failure links
nodes[v].output.addAll(nodes[nodes[v].fail].output)
```

### 3. Manacher: неправильная трансформация

```kotlin
// ❌ НЕПРАВИЛЬНО: только # между символами
"abc" → "a#b#c"  // Не работает для краевых случаев

// ✅ ПРАВИЛЬНО: # везде
"abc" → "#a#b#c#"
```

---

## Практика

### LeetCode задачи

| # | Название | Сложность | Алгоритм |
|---|----------|-----------|----------|
| 5 | Longest Palindromic Substring | Medium | Manacher |
| 647 | Palindromic Substrings | Medium | Manacher |
| 214 | Shortest Palindrome | Hard | KMP / Manacher |
| 1032 | Stream of Characters | Hard | Aho-Corasick |
| 1923 | Longest Common Subpath | Hard | Suffix Array + Binary Search |

---

## Связанные темы

### Prerequisites
- [String Algorithms](./string-algorithms.md) — KMP, Z-function, Rabin-Karp

### Unlocks
- Bioinformatics algorithms
- Text compression (BWT)
- Plagiarism detection

---

## Источники

| # | Источник | Тип | Вклад |
|---|----------|-----|-------|
| 1 | [CP-Algorithms: Suffix Array](https://cp-algorithms.com/string/suffix-array.html) | Reference | SA construction |
| 2 | [CP-Algorithms: Aho-Corasick](https://cp-algorithms.com/string/aho_corasick.html) | Reference | Automaton |
| 3 | [CP-Algorithms: Manacher](https://cp-algorithms.com/string/manacher.html) | Reference | Palindromes |
| 4 | [CP-Algorithms: Suffix Automaton](https://cp-algorithms.com/string/suffix-automaton.html) | Reference | SAM |
| 5 | [USACO Guide: String Suffix Structures](https://usaco.guide/adv/string-suffix) | Course | Applications |

---

*Обновлено: 2026-01-08 — добавлены педагогические секции (интуиция: указатель книги/сканер/зеркало/метро, 6 типичных ошибок включая выбор структуры, 5 ментальных моделей)*
