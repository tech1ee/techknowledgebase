---
title: "Оптимизации динамического программирования"
created: 2026-02-09
modified: 2026-02-09
type: deep-dive
status: published
tags:
  - topic/cs-fundamentals
  - type/deep-dive
  - level/expert
related:
  - "[[dynamic-programming]]"
  - "[[dp-patterns]]"
---

# DP Optimization Techniques

## TL;DR

Оптимизации DP: **Convex Hull Trick** — O(n²) → O(n log n) для dp[i] = min(dp[j] + b[j]×a[i]). **D&C Optimization** — когда opt(i,j) монотонен. **SOS DP** — сумма по подмножествам за O(n×2^n). **Matrix Exponentiation** — линейные рекуррентности за O(k³ log n). Ключ: распознать паттерн и применить правильную технику.

---

## Часть 1: Интуиция без кода

### Аналогия 1: Convex Hull Trick как выбор тарифа такси

```
    ВЫБОР ТАРИФА ТАКСИ

    Разные компании предлагают тарифы:

    ┌─────────────────────────────────────────────────────────┐
    │                                                         │
    │  ТАКСИ А: 50₽ + 10₽/км     (дешёвая посадка)           │
    │  ТАКСИ Б: 100₽ + 5₽/км     (дешёвый километраж)        │
    │  ТАКСИ В: 200₽ + 2₽/км     (для дальних поездок)       │
    │                                                         │
    │  ┌────────────────────────────────────────────────┐    │
    │  │Цена ↑                                          │    │
    │  │     │      ╱ Такси А                           │    │
    │  │     │    ╱                                     │    │
    │  │     │  ╱   ─────── Такси Б                     │    │
    │  │     │╱   ─────                                 │    │
    │  │     ╱──                ═══════ Такси В         │    │
    │  │   ╱──═══                                       │    │
    │  │ ╱═                                             │    │
    │  └─┬────────────────────────────────────→ Расстояние   │
    │    0   5   10   20   30   40   50   60   км      │    │
    │                                                         │
    │  НИЖНЯЯ ОГИБАЮЩАЯ показывает ЛУЧШИЙ тариф!             │
    │                                                         │
    │  0-10 км:  Такси А лучше                               │
    │  10-30 км: Такси Б лучше                               │
    │  30+ км:   Такси В лучше                               │
    │                                                         │
    └─────────────────────────────────────────────────────────┘

    CHT строит эту нижнюю огибающую автоматически!
    Добавляем тарифы, спрашиваем "какой лучше для X км?" → O(1)
```

**Связь с DP:**
- Каждое состояние j → "тариф" с наклоном b[j] и начальной ценой dp[j]
- Для состояния i нужно выбрать лучший "тариф" при "расстоянии" a[i]

### Аналогия 2: D&C Optimization как сужение поиска

```
    ПОИСК ИДЕАЛЬНОЙ ТОЧКИ РАЗРЕЗА

    Представьте: нужно разрезать пиццу на части.
    Каждый разрез имеет свою "стоимость".

    ┌─────────────────────────────────────────────────────────┐
    │                                                         │
    │  Пицца:  ════════════════════════════════════════       │
    │          0    10    20    30    40    50    60   см     │
    │                                                         │
    │  Для разных длин пиццы — разные оптимальные разрезы:    │
    │                                                         │
    │  Длина 20см → лучший разрез в позиции 8                 │
    │  Длина 30см → лучший разрез в позиции 12                │
    │  Длина 40см → лучший разрез в позиции 18                │
    │  Длина 50см → лучший разрез в позиции 22                │
    │                                                         │
    │  Замечаем: точка разреза МОНОТОННО РАСТЁТ!              │
    │  opt(20) ≤ opt(30) ≤ opt(40) ≤ opt(50)                  │
    │                                                         │
    └─────────────────────────────────────────────────────────┘

    D&C OPTIMIZATION:
    1. Найти opt для СРЕДНЕЙ длины (например, 35см) → скажем, 15
    2. Для меньших длин: искать opt только в [0, 15]
    3. Для больших длин: искать opt только в [15, 60]

    Вместо n проверок для каждой длины → log(n) в среднем!
```

### Аналогия 3: SOS DP как сбор рецептов

```
    КУЛИНАРНАЯ КНИГА КОМБИНАЦИЙ

    Есть 3 ингредиента: Сыр (С), Томат (Т), Базилик (Б)

    Для каждой комбинации храним "очки вкуса":
    ┌─────────────────────────────────────────────┐
    │  {}         → 0 очков  (ничего)             │
    │  {С}        → 5 очков                       │
    │  {Т}        → 3 очка                        │
    │  {Б}        → 2 очка                        │
    │  {С,Т}      → 8 очков                       │
    │  {С,Б}      → 7 очков                       │
    │  {Т,Б}      → 5 очков                       │
    │  {С,Т,Б}    → 10 очков                      │
    └─────────────────────────────────────────────┘

    ЗАДАЧА: Для каждого набора посчитать СУММУ очков
            всех его подмножеств.

    F[{С,Т,Б}] = 0 + 5 + 3 + 2 + 8 + 7 + 5 + 10 = 40

    НАИВНО: Для каждого набора перебираем подмножества → O(3^n)

    SOS DP: Добавляем ингредиенты ПО ОДНОМУ:

    Шаг 1 (добавляем Сыр):
      F[{С}] += F[{}]         → учли {С} и {}
      F[{С,Т}] += F[{Т}]      → учли {С,Т} и {Т}
      и т.д.

    Шаг 2 (добавляем Томат):
      F[{Т}] += F[{}]         → учли {Т} и {} (уже было)
      F[{С,Т}] += F[{С}]      → учли все подмножества {С,Т}
      и т.д.

    Шаг 3 (добавляем Базилик):
      ...

    Каждый бит обрабатывается раз → O(n × 2^n)
```

### Аналогия 4: Matrix Exponentiation как ускорение машины времени

```
    МАШИНА ВРЕМЕНИ ДЛЯ КРОЛИКОВ ФИБОНАЧЧИ

    Правило: Каждый месяц количество кроликов = сумма двух предыдущих
    F(n) = F(n-1) + F(n-2)

    ┌─────────────────────────────────────────────────────────┐
    │                                                         │
    │  НАИВНО: Считаем по одному месяцу                       │
    │                                                         │
    │  Месяц 0: 0 кроликов                                    │
    │  Месяц 1: 1 кролик                                      │
    │  Месяц 2: 1 кролик                                      │
    │  ...                                                    │
    │  Месяц 1000000000: ??? (слишком долго!)                 │
    │                                                         │
    │  МАТРИЧНАЯ МАГИЯ:                                       │
    │                                                         │
    │  [F(n)  ]   [1 1]^(n-1)   [F(1)]                        │
    │  [F(n-1)] = [1 0]       × [F(0)]                        │
    │                                                         │
    │  Один "шаг" матрицы = один месяц                        │
    │  M² = два месяца                                        │
    │  M⁴ = четыре месяца                                     │
    │  M^(2^k) = 2^k месяцев                                  │
    │                                                         │
    │  M^1000000000 = M^(2^29) × M^(2^28) × ... (30 умножений)│
    │                                                         │
    └─────────────────────────────────────────────────────────┘

    Вместо миллиарда шагов → 30 матричных умножений!
```

### Аналогия 5: Knuth Optimization как сужающийся коридор

```
    ПОИСК ОПТИМАЛЬНОЙ ТОЧКИ В КОРИДОРЕ

    Задача: разбить отрезок на части с минимальной стоимостью

    ┌─────────────────────────────────────────────────────────┐
    │                                                         │
    │  Для dp[i][j] (отрезок от i до j):                      │
    │  Ищем оптимальную точку разбиения k                     │
    │                                                         │
    │  СВОЙСТВО КВАДРАТНОГО НЕРАВЕНСТВА:                      │
    │                                                         │
    │    opt[i][j-1] ≤ opt[i][j] ≤ opt[i+1][j]               │
    │                                                         │
    │  Визуализация:                                          │
    │                                                         │
    │         j-1      j       j+1                            │
    │    i   [═══════════════════]  opt ∈ [2, 5]             │
    │    i+1  [════════════════]    opt ∈ [3, 6]             │
    │    i+2   [══════════════]     opt ∈ [4, 7]             │
    │                                                         │
    │  Коридор допустимых opt СУЖАЕТСЯ!                       │
    │                                                         │
    │  Вместо O(n) вариантов для каждой пары (i,j)           │
    │  → суммарно O(n²) по всем парам!                        │
    │                                                         │
    └─────────────────────────────────────────────────────────┘
```

### Числовой пример: Convex Hull Trick

```
    ЗАДАЧА: dp[i] = min_{j<i} { dp[j] + j² × i }

    Состояния и их "прямые":
    j=0: dp[0]=0,  slope=0²=0   → y = 0×x + 0
    j=1: dp[1]=5,  slope=1²=1   → y = 1×x + 5
    j=2: dp[2]=8,  slope=2²=4   → y = 4×x + 8
    j=3: dp[3]=10, slope=3²=9   → y = 9×x + 10

    Для i=5 (x=5):
    j=0: 0×5 + 0  = 0
    j=1: 1×5 + 5  = 10
    j=2: 4×5 + 8  = 28
    j=3: 9×5 + 10 = 55

    Минимум = 0 (при j=0)

    ╔═══════════════════════════════════════════════╗
    ║  Но CHT не перебирает все j!                  ║
    ║  Он хранит только "победителей" на огибающей  ║
    ║  и находит ответ за O(log n) или O(1)         ║
    ╚═══════════════════════════════════════════════╝
```

### Когда какую оптимизацию применять

```
    ┌────────────────────────────────────────────────────────────┐
    │                  РАСПОЗНАВАНИЕ ПАТТЕРНА                    │
    ├────────────────────────────────────────────────────────────┤
    │                                                            │
    │  dp[i] = min(dp[j] + b[j] × a[i] + c)?                    │
    │     → CHT (если b[j] монотонно)                           │
    │     → Li Chao Tree (если b[j] не монотонно)               │
    │                                                            │
    │  dp[i][j] = min_{k} { dp[i-1][k] + cost(k,j) }             │
    │  и opt монотонен?                                          │
    │     → D&C Optimization                                     │
    │                                                            │
    │  dp[i][j] = min_{k} { dp[i][k] + dp[k][j] + cost(i,j) }   │
    │  и выполняется quadrangle inequality?                      │
    │     → Knuth Optimization                                   │
    │                                                            │
    │  F[mask] = Σ A[submask]?                                   │
    │     → SOS DP                                               │
    │                                                            │
    │  f(n) = линейная комбинация f(n-1), f(n-2), ...?          │
    │     → Matrix Exponentiation                                │
    │                                                            │
    └────────────────────────────────────────────────────────────┘
```

---

## Часть 2: Почему это сложно

### Типичные ошибки студентов

#### Ошибка 1: CHT с неправильным порядком прямых

```kotlin
// ❌ НЕПРАВИЛЬНО: slopes НЕ монотонны
val lines = listOf(
    slope=5,  // ← неправильный порядок!
    slope=3,
    slope=7,
    slope=1
)

// ПРОБЛЕМА: Монотонный CHT требует:
// - Убывающих slopes для минимума
// - Возрастающих slopes для максимума

// ✅ РЕШЕНИЯ:
// 1. Отсортировать прямые перед добавлением
// 2. Использовать Li Chao Tree (не требует монотонности)
// 3. Использовать set с бинарным поиском
```

**СИМПТОМ:** Получаете WA на некоторых тестах или неправильный ответ.

**РЕШЕНИЕ:** Проверьте, что slopes добавляются в правильном порядке, или используйте Li Chao Tree.

#### Ошибка 2: D&C с неправильными границами

```kotlin
// ❌ НЕПРАВИЛЬНО: границы оптимума выходят за пределы
fun compute(i: Int, l: Int, r: Int, optL: Int, optR: Int) {
    val mid = (l + r) / 2

    // Ошибка: k может быть больше mid-1!
    for (k in optL..optR) {  // ← должно быть min(optR, mid-1)
        // ...
    }
}

// ✅ ПРАВИЛЬНО:
for (k in optL..minOf(optR, mid - 1)) {
    // k не может быть ≥ mid, так как разбиваем [0..mid] на [0..k] и [k+1..mid]
}
```

**СИМПТОМ:** Index out of bounds или неправильный ответ.

**РЕШЕНИЕ:** Помните, что opt(i, j) — это точка разбиения МЕЖДУ i и j, поэтому opt < j.

#### Ошибка 3: SOS DP в неправильном направлении

```kotlin
// ❌ НЕПРАВИЛЬНО: хотели superset sum, получили subset sum
// Или наоборот

// SUBSET SUM: F[mask] = Σ A[submask] где submask ⊆ mask
for (i in 0 until n) {
    for (mask in 0 until size) {
        if ((mask and (1 shl i)) != 0) {
            dp[mask] += dp[mask xor (1 shl i)]  // Добавляем подмаску
        }
    }
}

// SUPERSET SUM: F[mask] = Σ A[supermask] где mask ⊆ supermask
for (i in 0 until n) {
    for (mask in size-1 downTo 0) {  // ← обратный порядок!
        if ((mask and (1 shl i)) == 0) {  // ← бит НЕ установлен
            dp[mask] += dp[mask or (1 shl i)]  // Добавляем супермаску
        }
    }
}
```

**СИМПТОМ:** Получаете сумму не тех подмножеств.

**РЕШЕНИЕ:** Чётко определите, что нужно: subset sum (⊆) или superset sum (⊇).

#### Ошибка 4: Matrix Exponentiation с переполнением

```kotlin
// ❌ НЕПРАВИЛЬНО: переполнение при умножении
fun multiply(a: Array<LongArray>, b: Array<LongArray>) {
    for (i in 0 until k) {
        for (j in 0 until k) {
            for (l in 0 until k) {
                result[i][j] += a[i][l] * b[l][j]  // ← переполнение!
            }
        }
    }
}

// ✅ ПРАВИЛЬНО: модуль после каждого умножения
for (l in 0 until k) {
    result[i][j] = (result[i][j] + a[i][l] * b[l][j] % mod) % mod
}

// ИЛИ: использовать multiplyMod для больших чисел
fun multiplyMod(a: Long, b: Long, mod: Long): Long {
    return ((a % mod) * (b % mod)) % mod
}
```

**СИМПТОМ:** Отрицательные числа, неправильный ответ, краш.

**РЕШЕНИЕ:** Всегда применяйте модуль после каждого умножения.

#### Ошибка 5: Неправильное распознавание паттерна

```
    ТИПИЧНЫЕ ОШИБКИ РАСПОЗНАВАНИЯ:

    ❌ "Вижу min — это CHT!"
       Нет! CHT только для dp[j] + b[j]×a[i]
       Нужна структура "наклон × координата"

    ❌ "Вижу разбиение на подотрезки — это Knuth!"
       Нет! Knuth требует quadrangle inequality
       Проверьте: cost(a,c) + cost(b,d) ≤ cost(a,d) + cost(b,c)

    ❌ "Вижу битовые маски — это SOS!"
       Нет! SOS только для СУММЫ по подмножествам
       Для других операций (min, max, xor) — другие техники

    ❌ "Это линейная рекуррентность — матрицы!"
       Да, но только если переменных мало (k небольшое)
       O(k³ log n) плохо для больших k
```

**СИМПТОМ:** TLE или WA после применения "оптимизации".

**РЕШЕНИЕ:** Тщательно проверяйте условия применимости каждой техники.

#### Ошибка 6: Knuth без проверки quadrangle inequality

```
    QUADRANGLE INEQUALITY (условие Кнута):

    cost(a, c) + cost(b, d) ≤ cost(a, d) + cost(b, c)
    для всех a ≤ b ≤ c ≤ d

    ПРИМЕРЫ ГДЕ РАБОТАЕТ:
    ✓ cost(i, j) = (sum[j] - sum[i])²  (сумма квадратов)
    ✓ cost(i, j) = freq[i..j] × (j - i)  (Optimal BST)

    ПРИМЕРЫ ГДЕ НЕ РАБОТАЕТ:
    ✗ cost(i, j) = max(a[i..j])  (максимум на отрезке)
    ✗ cost(i, j) = |sum[j] - sum[i]|  (абсолютное значение)
```

**СИМПТОМ:** WA на определённых тестах.

**РЕШЕНИЕ:** Математически докажите quadrangle inequality перед применением Knuth.

---

## Часть 3: Ментальные модели

### Модель 1: CHT как выбор лучшей стратегии

```
    ВЫБОР ТАРИФНОГО ПЛАНА

    ┌─────────────────────────────────────────────────────────┐
    │                                                         │
    │  Каждое состояние j = тарифный план                    │
    │  - Фиксированная часть: dp[j] (абонентская плата)      │
    │  - Переменная часть: b[j] × a[i] (плата за использование)│
    │                                                         │
    │  Запрос a[i] = "сколько использовал"                   │
    │  Ответ = лучший тариф для данного использования        │
    │                                                         │
    │  CHT строит "карту победителей":                        │
    │  - При малом использовании → тариф А лучше             │
    │  - При среднем → тариф Б                               │
    │  - При большом → тариф В                               │
    │                                                         │
    └─────────────────────────────────────────────────────────┘
```

**Когда использовать:** Любой DP с формой dp[j] + b[j]×a[i]. Ключ — распознать "наклон × координата".

### Модель 2: D&C как бинарный поиск для оптимума

```
    ПОИСК МЕДИАНЫ ОПТИМУМА

    ┌─────────────────────────────────────────────────────────┐
    │                                                         │
    │  Знаем: opt(i, j) монотонно растёт с j                 │
    │                                                         │
    │  Вместо поиска opt для каждого j отдельно:             │
    │                                                         │
    │  1. Найти opt для СРЕДНЕГО j = mid                     │
    │  2. Левая половина: opt ≤ opt(mid)                     │
    │  3. Правая половина: opt ≥ opt(mid)                    │
    │  4. Рекурсия!                                           │
    │                                                         │
    │  Суммарная работа:                                      │
    │  - Уровень 0: просмотрели [0, n] для mid              │
    │  - Уровень 1: два вызова, но суммарный диапазон = n    │
    │  - ...                                                  │
    │  - log(n) уровней, каждый = O(n) работы                │
    │  - Итого: O(n log n)                                    │
    │                                                         │
    └─────────────────────────────────────────────────────────┘
```

**Когда использовать:** DP с монотонностью оптимальной точки разбиения.

### Модель 3: SOS как последовательное включение переключателей

```
    ПАНЕЛЬ ПЕРЕКЛЮЧАТЕЛЕЙ

    ┌─────────────────────────────────────────────────────────┐
    │                                                         │
    │  n переключателей: [1] [2] [3] ... [n]                 │
    │                                                         │
    │  Состояние mask = какие переключатели включены         │
    │                                                         │
    │  SOS DP по битам:                                       │
    │                                                         │
    │  Бит 0: dp[mask] += dp[mask с выкл. битом 0]           │
    │         "Добавили вклад состояний, где бит 0 выключен" │
    │                                                         │
    │  Бит 1: dp[mask] += dp[mask с выкл. битом 1]           │
    │         "Добавили вклад состояний, где бит 1 выключен" │
    │                                                         │
    │  После всех битов:                                      │
    │  dp[mask] = сумма по ВСЕМ подмножествам mask           │
    │                                                         │
    │  Каждый бит обрабатывается ОДИН раз → O(n × 2^n)       │
    │                                                         │
    └─────────────────────────────────────────────────────────┘
```

**Когда использовать:** Сумма (или другая ассоциативная операция) по подмножествам битовой маски.

### Модель 4: Matrix Exponentiation как телепортация во времени

```
    ВРЕМЕННОЙ ПРЫЖОК

    ┌─────────────────────────────────────────────────────────┐
    │                                                         │
    │  Обычное DP: шаг за шагом                               │
    │                                                         │
    │  F(0) → F(1) → F(2) → ... → F(n)                       │
    │         M       M           M      (n умножений)        │
    │                                                         │
    │  Matrix Exponentiation: прыжки степенями двойки         │
    │                                                         │
    │  F(0) → F(1) → F(2) → F(4) → F(8) → ... → F(n)         │
    │         M       M²      M⁴      M⁸       (log n прыжков)│
    │                                                         │
    │  Как вычислить M⁸?                                      │
    │  M⁸ = (M⁴)² = ((M²)²)²                                  │
    │                                                         │
    │  Три возведения в квадрат вместо семи умножений!       │
    │                                                         │
    └─────────────────────────────────────────────────────────┘
```

**Когда использовать:** Линейные рекуррентности с большим n и малым числом состояний k.

### Модель 5: Общая модель "Структура в DP"

```
    СТРУКТУРА ДАННЫХ ВНУТРИ DP

    ┌─────────────────────────────────────────────────────────┐
    │                                                         │
    │  Идея: вместо перебора всех предыдущих состояний       │
    │        храним их в СПЕЦИАЛЬНОЙ СТРУКТУРЕ               │
    │                                                         │
    │  ┌──────────────┬─────────────────────────────────┐    │
    │  │  Операция    │  Структура                      │    │
    │  ├──────────────┼─────────────────────────────────┤    │
    │  │  min(a×x+b)  │  Convex Hull / Li Chao Tree     │    │
    │  │  sum(mask)   │  SOS Array                      │    │
    │  │  range min   │  Segment Tree / Sparse Table    │    │
    │  │  prefix sum  │  BIT / Prefix Array             │    │
    │  └──────────────┴─────────────────────────────────┘    │
    │                                                         │
    │  Ключ: распознать КАКУЮ операцию нужно ускорить        │
    │        и выбрать ПРАВИЛЬНУЮ структуру данных           │
    │                                                         │
    └─────────────────────────────────────────────────────────┘
```

**Когда использовать:** Любой DP с "медленным" переходом. Ищите повторяющуюся операцию.

### Сравнение ментальных моделей

| Модель | Техника | Ключевая интуиция |
|--------|---------|-------------------|
| Выбор тарифа | CHT | Прямые, нижняя огибающая |
| Бинарный поиск | D&C | Монотонность сужает диапазон |
| Переключатели | SOS | Биты добавляем последовательно |
| Телепортация | Matrix | Прыжки степенями двойки |
| Структура в DP | Все | Операция → подходящая структура |

---

## Зачем это нужно?

**Проблема:**

```
dp[i] = min(dp[j] + cost(j, i)) для j < i

Наивно: O(n²) — проверяем все j для каждого i
После оптимизации: O(n log n) или даже O(n)

Для n = 10^5: 10^10 → 10^6 операций
```

**Обзор оптимизаций:**

| Техника | Условие | Сложность |
|---------|---------|-----------|
| Convex Hull Trick | dp[j] + b[j]×a[i] | O(n) или O(n log n) |
| D&C Optimization | opt(i,j) ≤ opt(i,j+1) | O(n log n) |
| Knuth Optimization | opt(i,j-1) ≤ opt(i,j) ≤ opt(i+1,j) | O(n²) → O(n²) с меньшей константой |
| SOS DP | Сумма по подмножествам | O(n×2^n) |
| Matrix Exponentiation | Линейная рекуррентность | O(k³ log n) |

---

## Convex Hull Trick (CHT)

### Когда применять

```
Рекуррентность вида:
dp[i] = min_{j<i} { dp[j] + b[j] × a[i] }

где b[j] — "наклон", a[i] — "x-координата"

Интерпретация:
- Каждое j задаёт прямую y = b[j]×x + dp[j]
- Для каждого i ищем минимум в точке x = a[i]
- Минимум достигается на нижней огибающей (convex hull)
```

### Визуализация

```
y = b[0]×x + dp[0]  ─────────╲
y = b[1]×x + dp[1]  ────────╲ ╲
y = b[2]×x + dp[2]  ──────╲  ╲ ╲
                           ╲  ╲ ╲
                            ╲──╲─╲───→ x
                              нижняя огибающая

Каждая прямая "побеждает" на каком-то интервале x.
```

### Реализация (монотонные наклоны)

```kotlin
/**
 * CONVEX HULL TRICK — оптимизация DP вида dp[i] = min(dp[j] + b[j] × a[i])
 *
 * Интерпретация:
 * - Каждое j задаёт прямую: y = b[j] × x + dp[j]
 *   где slope = b[j], intercept = dp[j]
 * - Для x = a[i] ищем прямую с минимальным y
 * - Минимум достигается на нижней выпуклой оболочке
 */
class ConvexHullTrickMin {
    // Храним прямые как (slope, intercept) = (m, b) для y = mx + b
    private val lines = ArrayDeque<Pair<Long, Long>>()

    /**
     * ПРОВЕРКА: нужна ли средняя прямая l2?
     *
     * l2 не нужна, если она НИКОГДА не побеждает:
     * - Пересечение l1 и l3 левее пересечения l1 и l2
     * - Значит l3 "обгоняет" l2 до того, как l2 станет лучше l1
     *
     * Математика (без деления, чтобы избежать float):
     * x(l1,l2) ≥ x(l1,l3)
     * (b1-b2)/(m2-m1) ≥ (b1-b3)/(m3-m1)
     * Перемножаем крест-накрест (учитывая знаки)
     */
    private fun bad(l1: Pair<Long, Long>, l2: Pair<Long, Long>, l3: Pair<Long, Long>): Boolean {
        return (l3.second - l1.second) * (l1.first - l2.first) <=
               (l2.second - l1.second) * (l1.first - l3.first)
    }

    /**
     * ДОБАВЛЕНИЕ ПРЯМОЙ y = slope × x + intercept
     *
     * Требование: slopes добавляются в УБЫВАЮЩЕМ порядке
     * (типично когда b[j] убывает с ростом j)
     */
    fun addLine(slope: Long, intercept: Long) {
        val line = slope to intercept

        // Удаляем с конца прямые, которые стали бесполезными
        // после добавления новой прямой
        while (lines.size >= 2 && bad(lines[lines.size - 2], lines.last(), line)) {
            lines.removeLast()
        }

        lines.addLast(line)
    }

    /**
     * ЗАПРОС МИНИМУМА в точке x
     *
     * Требование: x возрастают (offline монотонные запросы)
     * Это позволяет амортизированно O(1) на запрос
     */
    fun query(x: Long): Long {
        // Удаляем с начала прямые, которые уже не оптимальны
        // Если первая прямая хуже второй при текущем x,
        // она будет хуже и при всех бОльших x
        while (lines.size >= 2 && eval(lines[0], x) >= eval(lines[1], x)) {
            lines.removeFirst()
        }

        return eval(lines.first(), x)
    }

    private fun eval(line: Pair<Long, Long>, x: Long): Long {
        return line.first * x + line.second
    }
}
```

### Реализация (произвольный порядок) — Li Chao Tree

```kotlin
class LiChaoTree(private val lo: Long, private val hi: Long) {
    data class Line(val m: Long, val b: Long) {
        fun eval(x: Long) = m * x + b
    }

    private val tree = mutableMapOf<Int, Line>()

    /**
     * ДОБАВЛЕНИЕ ПРЯМОЙ в Li Chao Tree
     *
     * В отличие от монотонного CHT, здесь:
     * - Прямые можно добавлять в ЛЮБОМ порядке
     * - Запросы тоже в любом порядке
     * - Сложность O(log(range)) на операцию
     */
    fun addLine(m: Long, b: Long) {
        addLine(Line(m, b), 1, lo, hi)
    }

    private fun addLine(newLine: Line, node: Int, l: Long, r: Long) {
        if (l > r) return

        val mid = l + (r - l) / 2
        val curLine = tree[node]

        // Если узел пустой — просто записываем прямую
        if (curLine == null) {
            tree[node] = newLine
            return
        }

        val leftBetter = newLine.eval(l) < curLine.eval(l)
        val midBetter = newLine.eval(mid) < curLine.eval(mid)

        if (midBetter) {
            tree[node] = newLine
        }

        val winnerLine = if (midBetter) curLine else newLine

        if (l == r) return

        /**
         * РЕКУРСИВНОЕ ОБНОВЛЕНИЕ
         *
         * Если знак "лучше" меняется между l и mid:
         * - Прямые пересекаются в левой половине
         * - Надо обновить левое поддерево
         *
         * Если знак одинаковый:
         * - Пересечение в правой половине (или нет вообще)
         * - Обновляем правое поддерево
         */
        if (leftBetter != midBetter) {
            addLine(winnerLine, 2 * node, l, mid)
        } else {
            addLine(winnerLine, 2 * node + 1, mid + 1, r)
        }
    }

    /**
     * ЗАПРОС МИНИМУМА в точке x
     *
     * Идём по дереву от корня, собирая минимум
     * Каждый узел на пути может дать лучший ответ
     */
    fun query(x: Long): Long {
        return query(x, 1, lo, hi)
    }

    private fun query(x: Long, node: Int, l: Long, r: Long): Long {
        if (l > r || node !in tree) return Long.MAX_VALUE

        val mid = l + (r - l) / 2
        val cur = tree[node]?.eval(x) ?: Long.MAX_VALUE

        return if (x <= mid) {
            minOf(cur, query(x, 2 * node, l, mid))
        } else {
            minOf(cur, query(x, 2 * node + 1, mid + 1, r))
        }
    }
}
```

**Сложность:**
- Монотонный CHT: O(n) amortized
- Li Chao Tree: O(log(range)) per operation

---

## Divide & Conquer Optimization

### Когда применять

```
dp[i][j] = min_{k≤j} { dp[i-1][k] + cost(k+1, j) }

Условие: opt(i, j) ≤ opt(i, j+1)
(оптимальная точка разбиения монотонна)

Достаточное условие (quadrangle inequality):
cost(a,c) + cost(b,d) ≤ cost(a,d) + cost(b,c) для a < b < c < d
```

### Реализация

```kotlin
class DivideConquerDP(
    private val n: Int,
    private val k: Int,
    private val cost: (Int, Int) -> Long  // cost(l, r)
) {
    private val INF = Long.MAX_VALUE / 2
    private val dp = Array(k + 1) { LongArray(n + 1) { INF } }

    fun solve(): Long {
        // База: разбить 0 элементов на 0 групп стоит 0
        dp[0][0] = 0

        for (i in 1..k) {
            compute(i, 1, n, 0, n - 1)
        }

        return dp[k][n]
    }

    /**
     * DIVIDE & CONQUER OPTIMIZATION
     *
     * Вычисляем dp[i][l..r], зная что оптимальная точка разбиения
     * opt лежит в диапазоне [optL, optR]
     *
     * Идея:
     * 1. Находим opt для mid = (l+r)/2
     * 2. Для левой части [l, mid-1]: opt ∈ [optL, opt]
     * 3. Для правой части [mid+1, r]: opt ∈ [opt, optR]
     *
     * Почему это работает?
     * Условие монотонности: opt(i, j) ≤ opt(i, j+1)
     * Если opt для mid = k, то для j < mid оптимум ≤ k,
     * а для j > mid оптимум ≥ k
     */
    private fun compute(i: Int, l: Int, r: Int, optL: Int, optR: Int) {
        if (l > r) return

        val mid = (l + r) / 2
        var opt = optL

        // Находим оптимальное k для dp[i][mid]
        // перебираем k от optL до min(optR, mid-1)
        for (k in optL..minOf(optR, mid - 1)) {
            val candidate = dp[i - 1][k] + cost(k + 1, mid)
            if (candidate < dp[i][mid]) {
                dp[i][mid] = candidate
                opt = k
            }
        }

        // Рекурсивно обрабатываем левую и правую части
        // с сужением диапазона поиска оптимума
        compute(i, l, mid - 1, optL, opt)
        compute(i, mid + 1, r, opt, optR)
    }
}
```

**Сложность:** O(k × n log n)

---

## SOS DP (Sum over Subsets)

### Когда применять

```
Дан массив A[mask] для всех масок 0..2^n-1
Найти F[mask] = Σ A[submask] для всех submask ⊆ mask

Наивно: O(3^n) — перебор всех пар (mask, submask)
SOS DP: O(n × 2^n)
```

### Визуализация

```
n = 3, mask = 101 (binary)

Подмаски: 000, 001, 100, 101
F[101] = A[000] + A[001] + A[100] + A[101]

Идея: добавляем по одному биту
dp[mask][i] = сумма по submask, которые отличаются от mask
              только в первых i битах
```

### Реализация

```kotlin
/**
 * SUM OVER SUBSETS (SOS) DP
 *
 * Вычисляем F[mask] = Σ A[submask] для всех submask ⊆ mask
 *
 * Наивно: O(3^n) — перебираем все пары (mask, submask)
 * SOS DP: O(n × 2^n) — добавляем по одному биту
 */
fun sosDP(a: IntArray, n: Int): LongArray {
    val size = 1 shl n
    val dp = LongArray(size) { a[it].toLong() }

    /**
     * КЛЮЧЕВАЯ ИДЕЯ: добавляем биты последовательно
     *
     * dp[mask] после итерации i = сумма по submask,
     * которые отличаются от mask только в первых i битах
     *
     * ПРИМЕР: n=3, mask=101
     * После i=0: dp[101] содержит A[101] + A[100] (бит 0 может быть 0 или 1)
     * После i=1: без изменений (бит 1 уже 0)
     * После i=2: dp[101] содержит всю сумму по подмаскам
     */
    for (i in 0 until n) {
        for (mask in 0 until size) {
            /**
             * Если i-й бит установлен:
             * dp[mask] += dp[mask с выключенным i-м битом]
             *
             * mask XOR (1 << i) выключает i-й бит
             *
             * Это добавляет все подмаски, у которых i-й бит = 0
             */
            if ((mask and (1 shl i)) != 0) {
                dp[mask] += dp[mask xor (1 shl i)]
            }
        }
    }

    return dp
}

// Использование
val a = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8)  // для n=3
val f = sosDP(a, 3)
// f[mask] = сумма a[submask] для всех submask ⊆ mask
```

### Обратное SOS DP (Mobius Transform)

```kotlin
fun inverseSosDP(f: LongArray, n: Int): LongArray {
    val size = 1 shl n
    val a = f.copyOf()

    for (i in 0 until n) {
        for (mask in 0 until size) {
            if ((mask and (1 shl i)) != 0) {
                a[mask] -= a[mask xor (1 shl i)]
            }
        }
    }

    return a
}
```

**Сложность:** O(n × 2^n)

---

## Matrix Exponentiation

### Когда применять

```
Линейная рекуррентность:
f(n) = c₁×f(n-1) + c₂×f(n-2) + ... + cₖ×f(n-k)

Примеры:
- Fibonacci: f(n) = f(n-1) + f(n-2)
- Tribonacci: f(n) = f(n-1) + f(n-2) + f(n-3)
- Количество путей в графе длины n
```

### Матричная форма

```
[f(n)  ]   [c₁ c₂ ... cₖ]   [f(n-1)]
[f(n-1)] = [1  0  ... 0 ] × [f(n-2)]
[...]      [0  1  ... 0 ]   [...]
[f(n-k+1)] [0  0  ... 0 ]   [f(n-k)]

Или: F(n) = M × F(n-1) = M^(n-1) × F(1)
```

### Реализация

```kotlin
/**
 * MATRIX EXPONENTIATION
 *
 * Вычисляем M^n за O(k³ × log n)
 *
 * Применение:
 * - Линейные рекуррентности: f(n) = c₁f(n-1) + c₂f(n-2) + ...
 * - Количество путей в графе
 * - Системы линейных рекуррентностей
 */
class MatrixExponentiation(private val k: Int, private val mod: Long) {
    /**
     * УМНОЖЕНИЕ МАТРИЦ k×k
     *
     * result[i][j] = Σ a[i][l] × b[l][j]
     * Сложность: O(k³)
     */
    fun multiply(a: Array<LongArray>, b: Array<LongArray>): Array<LongArray> {
        val result = Array(k) { LongArray(k) }

        for (i in 0 until k) {
            for (j in 0 until k) {
                for (l in 0 until k) {
                    result[i][j] = (result[i][j] + a[i][l] * b[l][j]) % mod
                }
            }
        }

        return result
    }

    /**
     * БЫСТРОЕ ВОЗВЕДЕНИЕ В СТЕПЕНЬ
     *
     * M^n = M^(n/2) × M^(n/2) для чётного n
     * M^n = M × M^(n-1) для нечётного n
     *
     * Бинарное представление n → log(n) умножений
     */
    fun power(matrix: Array<LongArray>, n: Long): Array<LongArray> {
        // Единичная матрица E: E×M = M×E = M
        var result = Array(k) { i -> LongArray(k) { j -> if (i == j) 1L else 0L } }
        var base = matrix.map { it.copyOf() }.toTypedArray()
        var exp = n

        while (exp > 0) {
            if (exp and 1L == 1L) {
                result = multiply(result, base)
            }
            base = multiply(base, base)
            exp = exp shr 1
        }

        return result
    }
}

// Пример: Fibonacci
fun fibonacci(n: Long, mod: Long = 1_000_000_007): Long {
    if (n <= 1) return n

    val matExp = MatrixExponentiation(2, mod)

    // [F(n), F(n-1)] = [[1,1],[1,0]]^(n-1) × [F(1), F(0)]
    val matrix = arrayOf(
        longArrayOf(1, 1),
        longArrayOf(1, 0)
    )

    val result = matExp.power(matrix, n - 1)

    // result[0][0] * F(1) + result[0][1] * F(0) = result[0][0] * 1 + result[0][1] * 0
    return result[0][0]
}
```

### Пример: количество путей длины n в графе

```kotlin
/**
 * КОЛИЧЕСТВО ПУТЕЙ ДЛИНЫ n В ГРАФЕ
 *
 * Факт: если M — матрица смежности,
 * то M^n[i][j] = количество путей длины n из i в j
 *
 * Почему? Индукция:
 * - M^1[i][j] = количество рёбер из i в j
 * - M^(n+1)[i][j] = Σ M^n[i][k] × M[k][j]
 *                 = сумма по k: (путей длины n в k) × (рёбер k→j)
 */
fun countPaths(adj: Array<IntArray>, n: Long, mod: Long): Array<LongArray> {
    val k = adj.size
    val matExp = MatrixExponentiation(k, mod)

    // adj[i][j] = количество рёбер из i в j (0 или 1 для простого графа)
    val matrix = Array(k) { i -> LongArray(k) { j -> adj[i][j].toLong() } }

    // M^n[i][j] = количество различных путей длины ровно n из i в j
    return matExp.power(matrix, n)
}
```

**Сложность:** O(k³ log n)

---

## Knuth Optimization

### Когда применять

```
dp[i][j] = min_{i<k<j} { dp[i][k] + dp[k][j] } + cost(i, j)

Условие: opt(i, j-1) ≤ opt(i, j) ≤ opt(i+1, j)

Примеры:
- Optimal BST
- Matrix Chain Multiplication с особой cost функцией
```

### Реализация

```kotlin
/**
 * KNUTH OPTIMIZATION
 *
 * Для DP вида:
 * dp[i][j] = min_{i<k<j} { dp[i][k] + dp[k][j] } + cost(i, j)
 *
 * Условие: квадратное неравенство (quadrangle inequality)
 * cost(a,c) + cost(b,d) ≤ cost(a,d) + cost(b,c) для a ≤ b ≤ c ≤ d
 *
 * Это гарантирует: opt(i, j-1) ≤ opt(i, j) ≤ opt(i+1, j)
 * Следовательно: достаточно перебирать k в узком диапазоне
 *
 * Сложность: O(n²) вместо O(n³)
 */
fun knuthOptimization(cost: Array<LongArray>): Long {
    val n = cost.size
    val dp = Array(n) { LongArray(n) { 0 } }
    val opt = Array(n) { IntArray(n) { 0 } }

    // База: для отрезка длины 1 оптимальное разбиение — он сам
    for (i in 0 until n) {
        opt[i][i] = i
    }

    /**
     * ЗАПОЛНЕНИЕ ПО ДИАГОНАЛЯМ
     *
     * Важно: сначала короткие отрезки, потом длинные
     * Это нужно, чтобы opt[i][j-1] и opt[i+1][j] были уже вычислены
     */
    for (len in 2..n) {
        for (i in 0..n - len) {
            val j = i + len - 1
            dp[i][j] = Long.MAX_VALUE

            /**
             * КЛЮЧ ОПТИМИЗАЦИИ:
             * k перебираем ТОЛЬКО от opt[i][j-1] до opt[i+1][j]
             *
             * Вместо O(n) вариантов — амортизированно O(1)
             * Суммарно по всем (i,j): O(n²)
             */
            for (k in opt[i][j - 1]..minOf(opt.getOrNull(i + 1)?.get(j) ?: j, j - 1)) {
                val candidate = dp[i][k] + dp[k + 1][j] + cost[i][j]
                if (candidate < dp[i][j]) {
                    dp[i][j] = candidate
                    opt[i][j] = k
                }
            }
        }
    }

    return dp[0][n - 1]
}
```

**Сложность:** O(n²) вместо O(n³)

---

## Сравнение техник

| Техника | Исходная | Оптимизированная | Условие |
|---------|----------|------------------|---------|
| CHT | O(n²) | O(n) / O(n log n) | dp + slope × x |
| D&C | O(kn²) | O(kn log n) | Монотонность opt |
| SOS | O(3^n) | O(n × 2^n) | Сумма по подмножествам |
| Matrix | O(n) per query | O(k³ log n) | Линейная рекуррентность |
| Knuth | O(n³) | O(n²) | Квадратное неравенство |

---

## Практика

### LeetCode задачи

| # | Название | Сложность | Техника |
|---|----------|-----------|---------|
| 1259 | Handshakes That Don't Cross | Hard | Catalan / DP |
| 1000 | Minimum Cost to Merge Stones | Hard | Knuth-like |
| 1477 | Find Two Non-overlapping Subarrays | Medium | DP opt |

### Codeforces

| ID | Название | Техника |
|----|----------|---------|
| 868F | Yet Another Minimization | D&C Optimization |
| 319C | Kalila and Dimna | CHT |
| 1208F | Bits And Pieces | SOS DP |

---

## Связанные темы

### Prerequisites
- [Dynamic Programming](../patterns/dp-patterns.md)
- [Divide and Conquer](./divide-and-conquer.md)

### Unlocks
- Advanced competitive programming
- Research-level algorithms

---

## Источники

| # | Источник | Тип | Вклад |
|---|----------|-----|-------|
| 1 | [CP-Algorithms: CHT](https://cp-algorithms.com/geometry/convex_hull_trick.html) | Reference | CHT, Li Chao |
| 2 | [CP-Algorithms: D&C DP](https://cp-algorithms.com/dynamic_programming/divide-and-conquer-dp.html) | Reference | D&C |
| 3 | [Codeforces: SOS DP](https://codeforces.com/blog/entry/45223) | Tutorial | SOS |
| 4 | [USACO Guide](https://usaco.guide/plat/DC-DP) | Course | Practice |

---

*Обновлено: 2026-01-08 — добавлены педагогические секции (интуиция: тарифы такси/разрезание пиццы/кулинария/машина времени, 6 типичных ошибок включая распознавание паттерна, 5 ментальных моделей)*
