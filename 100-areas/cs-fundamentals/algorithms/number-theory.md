# Number Theory for Algorithms

## TL;DR

Ключевые алгоритмы: **GCD** (Euclid) — O(log min(a,b)), **Modular Exponentiation** — O(log n), **Prime Check** — O(√n), **Sieve** — O(n log log n). Modular inverse через Fermat: a^(p-1) ≡ 1 (mod p). Extended Euclid для ax + by = gcd. Chinese Remainder Theorem для систем сравнений.

---

## Часть 1: Интуиция без кода

### Аналогия 1: GCD — "общая мера"

Представь, что у тебя есть две верёвки длиной 48 см и 18 см. Нужно нарезать их на куски **одинаковой длины**, чтобы не осталось остатков.

```
Вопрос: Какой максимальный размер кусков?

Верёвка 1: |████████████████████████████████████████████████| 48 см
Верёвка 2: |██████████████████| 18 см

Наивно: пробуем все делители 48 и 18...

Алгоритм Евклида (хитрый способ):
  "Если 48 и 18 делятся на d, то и 48-18 делится на d!"

  48 → вычитаем 18 дважды → остаток 12
  18 → вычитаем 12        → остаток 6
  12 → вычитаем 6 дважды  → остаток 0

  Остаток = 0? Ответ = последний ненулевой = 6!

Проверка: 48 = 8 × 6, 18 = 3 × 6 ✓
```

**Почему это работает?** Общие делители (a, b) = общие делители (b, a mod b). Так мы "сжимаем" числа, пока одно не станет 0.

---

### Аналогия 2: Модульная арифметика — "часы"

Представь циферблат с 12 позициями (как обычные часы).

```
12-часовой циферблат (mod 12):

      12
    11  1
  10      2
  9        3
  8        4
    7   5
      6

Сложение: 10 + 5 = 15 → 15 mod 12 = 3 (стрелка на 3)
Умножение: 4 × 5 = 20 → 20 mod 12 = 8 (стрелка на 8)

Программисты используют mod = 10^9 + 7
Это как часы с миллиардом делений!
```

**Зачем это?**
- Числа не переполняются (всегда < mod)
- Результат предсказуем
- 10^9 + 7 — простое число (важно для деления!)

---

### Аналогия 3: Fast Exponentiation — "удвоение"

Нужно вычислить 2^16. Сколько умножений?

```
Наивный способ: 2×2×2×2×2×2×2×2×2×2×2×2×2×2×2×2 = 16 умножений

Хитрый способ (возведение в квадрат):
  2^1 = 2           (1 умножение)
  2^2 = 2 × 2 = 4   (1 умножение)
  2^4 = 4 × 4 = 16  (1 умножение)
  2^8 = 16 × 16     (1 умножение)
  2^16 = 256 × 256  (1 умножение)

  Итого: 4 умножения! (вместо 16)

Для 2^1000: log₂(1000) ≈ 10 умножений (вместо 1000)
```

**Для произвольного показателя:**
```
3^13 = ?
13 = 8 + 4 + 1 (в двоичном: 1101)

3^13 = 3^8 × 3^4 × 3^1

Вычисляем степени двойки:
  3^1 = 3
  3^2 = 9
  3^4 = 81
  3^8 = 6561

Ответ: 6561 × 81 × 3 = 1594323
```

---

### Аналогия 4: Решето Эратосфена — "отсеивание"

Представь, что нужно найти все простые числа до 30.

```
Начинаем со списка: 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ... 30

Шаг 1: 2 простое. Вычёркиваем все кратные 2:
       2 3 ✗ 5 ✗ 7 ✗ 9 ✗  11 ✗  13 ✗  15 ...
       (4, 6, 8, 10, 12, 14... вычеркнуты)

Шаг 2: 3 простое. Вычёркиваем кратные 3:
       2 3 ✗ 5 ✗ 7 ✗ ✗ ✗  11 ✗  13 ✗  ✗  ...
       (9, 15, 21, 27 вычеркнуты)

Шаг 3: 4 уже вычеркнуто, пропускаем

Шаг 4: 5 простое. Вычёркиваем кратные 5:
       (25 вычеркнуто)

√30 ≈ 5.5 → Достаточно! Всё что осталось — простые:
2, 3, 5, 7, 11, 13, 17, 19, 23, 29
```

---

### Аналогия 5: Китайская теорема об остатках — "загадка"

Классическая загадка (3-й век, Китай):

```
"Солдаты построились в колонну по 3 — остался 2.
 Построились по 5 — остался 3.
 Построились по 7 — остался 2.
 Сколько солдат?"

Математически:
  x ≡ 2 (mod 3)  → x = 3k + 2
  x ≡ 3 (mod 5)  → x = 5m + 3
  x ≡ 2 (mod 7)  → x = 7n + 2

CRT говорит: такой x СУЩЕСТВУЕТ и ЕДИНСТВЕНЕН (mod 3×5×7 = 105)

Решение: x = 23

Проверка:
  23 = 7×3 + 2 → остаток 2 при делении на 3 ✓
  23 = 4×5 + 3 → остаток 3 при делении на 5 ✓
  23 = 3×7 + 2 → остаток 2 при делении на 7 ✓
```

---

### Числовой пример: Вычисление C(10, 3) mod 7

```
C(10, 3) = 10! / (3! × 7!) = (10 × 9 × 8) / (3 × 2 × 1) = 720 / 6 = 120

Но что если mod = 7?

Наивно: 120 mod 7 = 1

С модульной арифметикой (без вычисления 120):
  10! mod 7 = ?
  10! = 3628800
  3628800 mod 7 = 0  (потому что 7 входит в 10!)

  0 / что_угодно = 0 ≠ 120 mod 7 = 1  ❌

Проблема: делить на 0 нельзя!

ПРАВИЛЬНЫЙ способ — обратный элемент:
  C(n, r) = n! × (r!)^(-1) × (n-r)!^(-1) mod p

  Вычисляем:
  3!^(-1) mod 7 = 6^(-1) mod 7 = 6^(7-2) mod 7 = 6^5 mod 7 = 6

  Проверка: 6 × 6 = 36 mod 7 = 1 ✓

Результат: fact[10] × invFact[3] × invFact[7] mod 7 = 1
```

---

## Часть 2: Почему теория чисел сложная

### Типичные ошибки студентов

#### Ошибка 1: Переполнение при умножении

**Симптом:** Неправильные результаты для больших чисел

```
// ❌ ОШИБКА: a × b переполняется до взятия mod
val a = 1_000_000_000L
val b = 1_000_000_000L
val mod = 1_000_000_007L
val result = a * b % mod  // a * b = 10^18, переполнение Long!

// ✅ ПРАВИЛЬНО: берём mod ДО умножения
val result = (a % mod) * (b % mod) % mod

// ✅ ЕЩЁ ЛУЧШЕ: используем 128-bit умножение (BigInteger)
val result = BigInteger.valueOf(a).multiply(BigInteger.valueOf(b))
    .mod(BigInteger.valueOf(mod)).toLong()
```

---

#### Ошибка 2: Отрицательный остаток

**Симптом:** Отрицательные числа в результате

```
// ❌ ОШИБКА: (a - b) может быть отрицательным
val a = 3L
val b = 10L
val mod = 7L
val result = (a - b) % mod  // -7 % 7 = 0, но (-3) % 7 = -3 в Kotlin!

// В Kotlin/Java: -10 % 7 = -3 (не 4!)

// ✅ ПРАВИЛЬНО: добавляем mod для гарантии положительного результата
val result = ((a - b) % mod + mod) % mod  // ((3-10) % 7 + 7) % 7 = (-7+7) % 7 = 0 ✓
// Или для -3: ((-3) % 7 + 7) % 7 = (-3 + 7) % 7 = 4 ✓
```

---

#### Ошибка 3: Деление по модулю без инверсии

**Симптом:** Неправильные результаты при делении

```
// ❌ ОШИБКА: нельзя просто делить в модульной арифметике!
val a = 10L
val b = 3L
val mod = 7L
val result = (a / b) % mod  // 10/3 = 3 (целочисленное), 3 % 7 = 3 ❌

// Правильный ответ: 10/3 mod 7 = 10 × 3^(-1) mod 7

// ✅ ПРАВИЛЬНО: умножаем на обратный элемент
val invB = modPow(b, mod - 2, mod)  // 3^5 mod 7 = 5
val result = a * invB % mod  // 10 × 5 mod 7 = 50 mod 7 = 1 ✓

// Проверка: 1 × 3 = 3 ≡ 10 mod 7? 10 mod 7 = 3 ✓
```

---

#### Ошибка 4: modPow с нулевым показателем

**Симптом:** Неправильный результат для a^0

```
// ❌ ОШИБКА: начинаем с base вместо 1
fun modPow(base: Long, exp: Long, mod: Long): Long {
    var result = base  // НЕПРАВИЛЬНО! a^0 должно быть 1
    var e = exp
    // ...
}

// ✅ ПРАВИЛЬНО: начинаем с нейтрального элемента
fun modPow(base: Long, exp: Long, mod: Long): Long {
    var result = 1L  // a^0 = 1
    var b = base % mod
    var e = exp

    while (e > 0) {
        if (e and 1L == 1L) result = result * b % mod
        b = b * b % mod
        e = e shr 1
    }
    return result
}
```

---

#### Ошибка 5: Использование Fermat для НЕпростого mod

**Симптом:** Неправильный обратный элемент

```
// ❌ ОШИБКА: теорема Ферма работает только для простого mod!
val a = 3L
val mod = 10L  // НЕ простое!
val inv = modPow(a, mod - 2, mod)  // 3^8 mod 10 = 6561 mod 10 = 1

// Проверка: 3 × 1 = 3 ≠ 1 mod 10 ❌

// ✅ ПРАВИЛЬНО: используем расширенный Евклид для непростых mod
fun modInverseExtGcd(a: Long, mod: Long): Long {
    val (gcd, x, _) = extendedGcd(a, mod)
    if (gcd != 1L) throw Exception("Обратного не существует!")
    return (x % mod + mod) % mod
}

// Для a=3, mod=10: gcd(3, 10) = 1
// 3×7 + 10×(-2) = 21 - 20 = 1
// Инверсия: 7. Проверка: 3 × 7 = 21 mod 10 = 1 ✓
```

---

#### Ошибка 6: Факториал содержит mod как множитель

**Симптом:** 0 вместо правильного ответа

```
// ❌ ОШИБКА: n! mod p = 0 если n >= p (p входит в n!)
val mod = 7L
val fact7 = 5040L  // 7!
val factMod = fact7 % mod  // 0! Потому что 7! = 7 × 6 × 5 × ... делится на 7

// C(10, 3) mod 7 = ?
// fact[10] mod 7 = 0 (потому что 10! содержит 7)
// 0 × invFact[3] × invFact[7] = 0 ❌ (правильно = 1)

// ✅ ПРАВИЛЬНО: теорема Лукаса для p <= n
// C(n, r) mod p = C(n mod p, r mod p) × C(n/p, r/p) mod p (рекурсивно)

fun lucasTheorem(n: Long, r: Long, p: Long): Long {
    if (r == 0L) return 1
    val ni = n % p
    val ri = r % p
    if (ri > ni) return 0
    return nCr(ni.toInt(), ri.toInt()) * lucasTheorem(n / p, r / p, p) % p
}
```

---

## Часть 3: Ментальные модели

### Модель 1: Модульная арифметика = "циклические часы"

```
Представь часы с 'mod' делениями:

       0
    m-1  1
   m-2    2
   ...    ...
      m/2

Операции:
  a + b → (a + b) mod m  (сдвиг стрелки вправо)
  a - b → (a - b + m) mod m (сдвиг влево)
  a × b → (a × b) mod m (многократный сдвиг)
  a / b → a × b^(-1) mod m (НЕЛЬЗЯ просто делить!)

Обратный элемент b^(-1):
  "Сколько раз сдвинуться, чтобы b × b^(-1) = 1?"
  Существует только если gcd(b, m) = 1
```

---

### Модель 2: GCD через "общие кирпичи"

```
Представь числа как стену из кирпичей:

48 = |████|████|████|████|████|████|████|████|  (8 кирпичей по 6)
18 = |████|████|████|                            (3 кирпича по 6)

GCD = размер наибольшего кирпича, из которого
      можно сложить ОБЕ стены без остатка

Алгоритм Евклида:
  "Вычтем меньшую стену из большей"
  48 - 18 = 30
  30 - 18 = 12
  18 - 12 = 6
  12 - 6 = 6
  6 - 6 = 0 → GCD = 6
```

---

### Модель 3: Таблица выбора алгоритма

```
┌────────────────────────────────────────────────────────────┐
│                  ТЕОРИЯ ЧИСЕЛ: ЧТО ИСПОЛЬЗОВАТЬ            │
├────────────────────────────────────────────────────────────┤
│                                                            │
│ НУЖЕН GCD(a, b)?                                          │
│   → Евклид: O(log min(a, b))                              │
│   → gcd(a, b) = gcd(b, a mod b)                           │
│                                                            │
│ НУЖЕН a^n mod m?                                          │
│   → Binary exponentiation: O(log n)                       │
│   → Возводим в квадрат, умножаем по битам n               │
│                                                            │
│ НУЖЕН a^(-1) mod m?                                       │
│   → m простое: a^(m-2) mod m (Ферма)                      │
│   → m любое: Extended Euclidean (если gcd(a,m)=1)         │
│                                                            │
│ НУЖНЫ ВСЕ простые до n?                                   │
│   → Решето Эратосфена: O(n log log n)                     │
│                                                            │
│ НУЖНО ПРОВЕРИТЬ простое ли n?                             │
│   → n небольшое: пробное деление O(√n)                    │
│   → n большое: Miller-Rabin O(k log³ n)                   │
│                                                            │
│ СИСТЕМА x ≡ aᵢ (mod mᵢ)?                                  │
│   → Китайская теорема об остатках (CRT)                   │
│   → Требует: mᵢ попарно взаимно просты                    │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

---

### Модель 4: Комбинаторика с модулем — "три массива"

```
Для вычисления C(n, r) mod p за O(1) нужны три массива:

fact[i] = i! mod p
invFact[i] = (i!)^(-1) mod p
inv[i] = i^(-1) mod p (опционально)

Предвычисление O(n):

Шаг 1: Факториалы (прямой ход)
  fact[0] = 1
  fact[i] = fact[i-1] × i mod p

Шаг 2: Инверсия последнего
  invFact[n] = fact[n]^(p-2) mod p  (теорема Ферма)

Шаг 3: Обратные факториалы (обратный ход)
  invFact[i] = invFact[i+1] × (i+1) mod p

Запрос O(1):
  C(n, r) = fact[n] × invFact[r] × invFact[n-r] mod p
```

---

### Модель 5: Extended Euclidean — "коэффициенты Безу"

```
Задача: найти x, y такие что ax + by = gcd(a, b)

Это уравнение Безу. Решение ВСЕГДА существует!

ИНТУИЦИЯ:
  gcd(48, 18) = 6
  Найти x, y: 48x + 18y = 6

  Решение: x = 1, y = -2
  Проверка: 48×1 + 18×(-2) = 48 - 36 = 12 ≠ 6 ???

  Ой, неправильно! Пересчитаем:
  extGcd(48, 18) → extGcd(18, 12) → extGcd(12, 6) → extGcd(6, 0)

  База: (6, x=1, y=0) — 6×1 + 0×0 = 6 ✓
  Назад: для (12, 6): x=0, y=1-2×0=1 — 12×0 + 6×1 = 6 ✓
  Назад: для (18, 12): x=1, y=0-1×1=-1 — 18×1 + 12×(-1) = 6 ✓
  Назад: для (48, 18): x=-1, y=1-2×(-1)=3 — 48×(-1) + 18×3 = 6 ✓

ПРИМЕНЕНИЕ:
  a × x ≡ 1 (mod m)
  → ax + my = 1 (если gcd(a,m)=1)
  → x = модульный обратный a по mod m
```

---

## Зачем это нужно?

**Проблема:**

```
Вычислить 2^1000000007 mod (10^9 + 7)

Наивно: умножаем 2 миллиард раз → TLE
С fast power: ~30 умножений → мгновенно
```

**Применения:**

| Область | Использование |
|---------|---------------|
| Криптография | RSA, Diffie-Hellman |
| Hashing | Modular arithmetic |
| Combinatorics | nCr mod p |
| Competitive | Модульная арифметика |

---

## GCD (Greatest Common Divisor)

### Euclid's Algorithm

```kotlin
/**
 * Алгоритм Евклида для НОД (наибольший общий делитель)
 *
 * МАТЕМАТИКА:
 * gcd(a, b) = gcd(b, a mod b)
 *
 * ПОЧЕМУ ЭТО РАБОТАЕТ:
 * Если d делит и a, и b, то d также делит (a - k×b) для любого k.
 * Особенно d делит (a mod b) = a - (a/b)×b.
 * Поэтому общие делители (a, b) = общие делители (b, a mod b).
 *
 * ПОШАГОВЫЙ ПРИМЕР (gcd(48, 18)):
 * gcd(48, 18) → gcd(18, 48 mod 18) = gcd(18, 12)
 * gcd(18, 12) → gcd(12, 18 mod 12) = gcd(12, 6)
 * gcd(12, 6)  → gcd(6, 12 mod 6) = gcd(6, 0)
 * gcd(6, 0)   → 6 (база: gcd(a, 0) = a)
 *
 * СЛОЖНОСТЬ: O(log min(a, b))
 */
fun gcd(a: Long, b: Long): Long {
    return if (b == 0L) a else gcd(b, a % b)
}

// Iterative version (то же самое, но без рекурсии)
fun gcdIterative(a: Long, b: Long): Long {
    var x = a
    var y = b
    while (y != 0L) {
        val temp = y
        y = x % y
        x = temp
    }
    return x
}

/**
 * LCM (наименьшее общее кратное) через GCD
 *
 * ФОРМУЛА: lcm(a, b) = a × b / gcd(a, b)
 *
 * ПОРЯДОК ВАЖЕН ДЛЯ OVERFLOW:
 * a / gcd(a, b) * b — сначала делим, потом умножаем
 * a * b / gcd(a, b) — может переполниться при умножении!
 *
 * ПРИМЕР: lcm(12, 18)
 * gcd(12, 18) = 6
 * lcm = 12 / 6 * 18 = 2 * 18 = 36 ✓
 */
fun lcm(a: Long, b: Long): Long = a / gcd(a, b) * b
```

**Сложность**: O(log min(a, b))

### Extended Euclidean Algorithm

```kotlin
/**
 * Расширенный алгоритм Евклида
 *
 * ЗАДАЧА:
 * Найти x, y такие что ax + by = gcd(a, b) (уравнение Безу)
 *
 * ПРИМЕНЕНИЕ:
 * - Нахождение модульного обратного: ax ≡ 1 (mod m)
 * - Решение линейных диофантовых уравнений
 *
 * МАТЕМАТИКА ОБРАТНОГО ХОДА:
 * Если на рекурсивном шаге: b×x' + (a mod b)×y' = gcd
 *
 * Подставляем a mod b = a - (a/b)×b:
 * b×x' + (a - (a/b)×b)×y' = gcd
 * a×y' + b×(x' - (a/b)×y') = gcd
 *
 * Значит: x = y', y = x' - (a/b)×y'
 *
 * ПОШАГОВЫЙ ПРИМЕР (extGcd(35, 15)):
 *
 * Прямой ход:
 * extGcd(35, 15) → extGcd(15, 5) → extGcd(5, 0)
 *
 * База: extGcd(5, 0) = (gcd=5, x=1, y=0)
 * Проверка: 5×1 + 0×0 = 5 ✓
 *
 * Обратный ход:
 * extGcd(15, 5): x=0, y = 1 - (15/5)×0 = 1
 * Результат: (5, 0, 1). Проверка: 15×0 + 5×1 = 5 ✓
 *
 * extGcd(35, 15): x=1, y = 0 - (35/15)×1 = -2
 * Результат: (5, 1, -2). Проверка: 35×1 + 15×(-2) = 35 - 30 = 5 ✓
 */
data class ExtGcdResult(val gcd: Long, val x: Long, val y: Long)

fun extendedGcd(a: Long, b: Long): ExtGcdResult {
    if (b == 0L) {
        // База: a×1 + 0×0 = a = gcd(a, 0)
        return ExtGcdResult(a, 1, 0)
    }

    val result = extendedGcd(b, a % b)
    // Обратный ход: пересчитываем коэффициенты
    // x = y', y = x' - (a/b)×y'
    return ExtGcdResult(
        result.gcd,
        result.y,
        result.x - (a / b) * result.y
    )
}
```

---

## Modular Arithmetic

### Fast Exponentiation

```kotlin
/**
 * Быстрое возведение в степень по модулю: a^n mod m за O(log n)
 *
 * ИДЕЯ (Binary Exponentiation):
 * Представляем показатель n в двоичном виде и используем:
 * a^n = a^(2^k₁) × a^(2^k₂) × ... где k₁, k₂... — позиции единичных битов
 *
 * ПОШАГОВЫЙ ПРИМЕР (3^13 mod 1000):
 * 13 в двоичном = 1101
 *
 * Итерация | e (bin) | бит | base    | result
 * ---------|---------|-----|---------|--------
 * 0        | 1101    | 1   | 3       | 1×3 = 3
 * 1        | 110     | 0   | 3²=9    | 3 (без изм.)
 * 2        | 11      | 1   | 9²=81   | 3×81 = 243
 * 3        | 1       | 1   | 81²=6561| 243×561 = ...
 *
 * Результат: 3^13 = 1594323 mod 1000 = 323
 *
 * СЛОЖНОСТЬ: O(log n) — число битов в показателе
 */
fun modPow(base: Long, exp: Long, mod: Long): Long {
    var result = 1L
    var b = base % mod
    var e = exp

    while (e > 0) {
        // Если текущий бит = 1, умножаем result на текущую степень base
        if (e and 1L == 1L) {
            result = result * b % mod
        }
        // Возводим base в квадрат для следующего бита
        // base^1 → base^2 → base^4 → base^8 → ...
        b = b * b % mod
        e = e shr 1
    }

    return result
}
```

### Modular Inverse

```kotlin
/**
 * Модульный обратный элемент через малую теорему Ферма
 *
 * ТЕОРЕМА ФЕРМА:
 * Если p простое и gcd(a, p) = 1, то a^(p-1) ≡ 1 (mod p)
 *
 * СЛЕДСТВИЕ:
 * a^(p-1) ≡ 1 (mod p)
 * a × a^(p-2) ≡ 1 (mod p)
 * Значит: a^(-1) ≡ a^(p-2) (mod p)
 *
 * ПРИМЕР: 3^(-1) mod 7
 * 3^(7-2) = 3^5 = 243 mod 7 = 5
 * Проверка: 3 × 5 = 15 mod 7 = 1 ✓
 *
 * ОГРАНИЧЕНИЕ: p должно быть простым!
 */
fun modInverse(a: Long, p: Long): Long {
    return modPow(a, p - 2, p)
}

/**
 * Модульный обратный через расширенный Евклид
 *
 * ПРЕИМУЩЕСТВО: работает для любого mod, если gcd(a, mod) = 1
 * (не требует, чтобы mod было простым)
 *
 * ИДЕЯ:
 * ax + (mod)y = gcd(a, mod) = 1
 * ax ≡ 1 (mod mod)
 * Значит x — это a^(-1) mod mod
 */
fun modInverseExtGcd(a: Long, mod: Long): Long {
    val result = extendedGcd(a, mod)
    if (result.gcd != 1L) throw IllegalArgumentException("Inverse doesn't exist")
    return (result.x % mod + mod) % mod  // Гарантируем положительный результат
}
```

### Modular Division

```kotlin
/**
 * Деление по модулю: a/b mod p = a × b^(-1) mod p
 *
 * В модульной арифметике нельзя просто делить!
 * Нужно умножить на обратный элемент.
 *
 * ПРИМЕР: 10/3 mod 7
 * 3^(-1) mod 7 = 5 (см. выше)
 * 10 × 5 mod 7 = 50 mod 7 = 1
 *
 * Проверка: 1 × 3 = 3 ≡ 10 mod 7? 10 mod 7 = 3 ✓
 */
fun modDivide(a: Long, b: Long, p: Long): Long {
    return a * modInverse(b, p) % p
}
```

---

## Prime Numbers

### Primality Test

```kotlin
/**
 * Проверка простоты числа за O(√n)
 *
 * ПОЧЕМУ ДОСТАТОЧНО ПРОВЕРИТЬ ДО √n:
 * Если n = a × b и a > √n, то b < √n.
 * Значит, если есть делитель > √n, мы уже нашли его "пару" < √n.
 *
 * ОПТИМИЗАЦИИ:
 * 1. n < 2 → не простое (по определению)
 * 2. n = 2 → простое (единственное чётное простое)
 * 3. n чётное → не простое
 * 4. Проверяем только нечётные делители (3, 5, 7, ...)
 *    Все чётные делители уже отсеяны проверкой на чётность
 *
 * ПОШАГОВЫЙ ПРИМЕР (isPrime(17)):
 * 17 >= 2 ✓, 17 ≠ 2, 17 нечётное
 * i=3: 3² = 9 <= 17, 17 % 3 = 2 ≠ 0
 * i=5: 5² = 25 > 17 → выход из цикла
 * Результат: true (17 простое)
 *
 * СЛОЖНОСТЬ: O(√n)
 */
fun isPrime(n: Long): Boolean {
    if (n < 2) return false
    if (n == 2L) return true
    if (n % 2 == 0L) return false

    var i = 3L
    while (i * i <= n) {
        if (n % i == 0L) return false
        i += 2  // Проверяем только нечётные (3, 5, 7, ...)
    }

    return true
}
```

**Сложность**: O(√n)

### Sieve of Eratosthenes

```kotlin
/**
 * Решето Эратосфена — найти все простые до n
 *
 * АЛГОРИТМ:
 * 1. Создаём массив [0..n], все помечены как простые
 * 2. Для каждого i от 2 до √n:
 *    Если i простое, вычёркиваем все кратные i (2i, 3i, 4i...)
 * 3. Оставшиеся — простые числа
 *
 * ОПТИМИЗАЦИЯ: начинаем с i² вместо 2i
 * Все кратные i, меньшие i², уже вычеркнуты:
 * - 2i вычеркнуто при i=2
 * - 3i вычеркнуто при i=3
 * - ...
 * - (i-1)×i вычеркнуто при предыдущих простых
 *
 * ВИЗУАЛИЗАЦИЯ (n = 20):
 *
 * Начало: 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
 *
 * i=2: вычёркиваем 4, 6, 8, 10, 12, 14, 16, 18, 20
 *      2 3 . 5 . 7 . 9 .  11 .  13 .  15 .  17 .  19 .
 *
 * i=3: вычёркиваем 9, 15 (начинаем с 9 = 3²)
 *      2 3 . 5 . 7 . . .  11 .  13 .  .  .  17 .  19 .
 *
 * i=4: √20 ≈ 4.5, выход из цикла
 *
 * Результат: 2, 3, 5, 7, 11, 13, 17, 19
 *
 * СЛОЖНОСТЬ: O(n log log n) — почти линейная
 */
fun sieve(n: Int): BooleanArray {
    val isPrime = BooleanArray(n + 1) { true }
    isPrime[0] = false
    if (n >= 1) isPrime[1] = false

    var i = 2
    while (i * i <= n) {
        if (isPrime[i]) {
            // Начинаем с i², меньшие кратные уже вычеркнуты
            var j = i * i
            while (j <= n) {
                isPrime[j] = false
                j += i
            }
        }
        i++
    }

    return isPrime
}

/**
 * Получить список простых чисел из решета
 */
fun getPrimes(n: Int): List<Int> {
    val isPrime = sieve(n)
    return (2..n).filter { isPrime[it] }
}
```

### Prime Factorization

```kotlin
/**
 * Разложение на простые множители (факторизация)
 *
 * ИДЕЯ:
 * Последовательно делим n на все возможные простые делители,
 * пока не останется 1 (или простое число > √n).
 *
 * ОПТИМИЗАЦИИ:
 * 1. Обрабатываем 2 отдельно → потом только нечётные
 * 2. Проверяем делители до √n (если остаток > 1, это простое)
 *
 * ПОШАГОВЫЙ ПРИМЕР (n = 360):
 * 360 / 2 = 180 → factors[2] = 1
 * 180 / 2 = 90  → factors[2] = 2
 * 90 / 2 = 45   → factors[2] = 3
 * 45 / 3 = 15   → factors[3] = 1
 * 15 / 3 = 5    → factors[3] = 2
 * 5 не делится на 3, проверяем 5: √5 ≈ 2.2 < 3, выход
 * 5 > 1 → factors[5] = 1
 *
 * Результат: {2: 3, 3: 2, 5: 1}
 * Проверка: 2³ × 3² × 5 = 8 × 9 × 5 = 360 ✓
 *
 * СЛОЖНОСТЬ: O(√n)
 */
fun primeFactorization(n: Long): Map<Long, Int> {
    val factors = mutableMapOf<Long, Int>()
    var num = n

    // Обрабатываем 2 отдельно — после этого num нечётное
    while (num % 2 == 0L) {
        factors[2] = factors.getOrDefault(2, 0) + 1
        num /= 2
    }

    // Проверяем только нечётные делители до √num
    var i = 3L
    while (i * i <= num) {
        while (num % i == 0L) {
            factors[i] = factors.getOrDefault(i, 0) + 1
            num /= i
        }
        i += 2
    }

    // Если остаток > 1, это простой множитель > √n
    // Такой множитель может быть только один (иначе n > остаток²)
    if (num > 1) {
        factors[num] = 1
    }

    return factors
}
```

---

## Chinese Remainder Theorem

### Задача

```
Система:
x ≡ a₁ (mod m₁)
x ≡ a₂ (mod m₂)
...

Если m₁, m₂, ... попарно взаимно просты,
существует единственное решение x mod (m₁ × m₂ × ...)
```

### Реализация

```kotlin
/**
 * Китайская теорема об остатках (CRT)
 *
 * ЗАДАЧА:
 * Найти x, удовлетворяющий системе:
 * x ≡ a₁ (mod m₁)
 * x ≡ a₂ (mod m₂)
 * ...
 *
 * УСЛОВИЕ: m₁, m₂, ... попарно взаимно просты
 *
 * АЛГОРИТМ:
 * 1. M = m₁ × m₂ × ... (общий модуль)
 * 2. Для каждого i:
 *    Mᵢ = M / mᵢ
 *    yᵢ = Mᵢ⁻¹ mod mᵢ (обратный элемент)
 * 3. x = Σ(aᵢ × Mᵢ × yᵢ) mod M
 *
 * ПОШАГОВЫЙ ПРИМЕР:
 * x ≡ 2 (mod 3)
 * x ≡ 3 (mod 5)
 * x ≡ 2 (mod 7)
 *
 * M = 3 × 5 × 7 = 105
 *
 * i=0: M₀ = 105/3 = 35, y₀ = 35⁻¹ mod 3 = 2 (35×2 = 70 ≡ 1 mod 3)
 * i=1: M₁ = 105/5 = 21, y₁ = 21⁻¹ mod 5 = 1 (21×1 = 21 ≡ 1 mod 5)
 * i=2: M₂ = 105/7 = 15, y₂ = 15⁻¹ mod 7 = 1 (15×1 = 15 ≡ 1 mod 7)
 *
 * x = (2×35×2 + 3×21×1 + 2×15×1) mod 105
 *   = (140 + 63 + 30) mod 105 = 233 mod 105 = 23
 *
 * Проверка: 23 mod 3 = 2 ✓, 23 mod 5 = 3 ✓, 23 mod 7 = 2 ✓
 */
fun chineseRemainderTheorem(
    remainders: LongArray,
    moduli: LongArray
): Long {
    val n = remainders.size
    var M = 1L
    for (m in moduli) M *= m

    var x = 0L
    for (i in 0 until n) {
        val Mi = M / moduli[i]
        val yi = modInverseExtGcd(Mi, moduli[i])
        x = (x + remainders[i] * Mi % M * yi % M) % M
    }

    return (x + M) % M
}
```

---

## Combinatorics with Modular Arithmetic

### Factorial and Inverse Factorial

```kotlin
/**
 * Комбинаторика с модульной арифметикой
 *
 * ЗАДАЧА:
 * Вычислять C(n, r) и P(n, r) по модулю за O(1) после предвычисления
 *
 * ИДЕЯ:
 * 1. Предвычисляем fact[i] = i! mod p для всех i
 * 2. Предвычисляем invFact[i] = (i!)⁻¹ mod p
 * 3. C(n, r) = n! / (r! × (n-r)!) = fact[n] × invFact[r] × invFact[n-r]
 *
 * ТРЮК ВЫЧИСЛЕНИЯ invFact:
 * Вместо n вызовов modPow (дорого!) используем:
 * 1. Вычисляем invFact[maxN] = (maxN!)⁻¹ через modPow
 * 2. invFact[i] = invFact[i+1] × (i+1)
 *    Потому что: (i!)⁻¹ = ((i+1)!)⁻¹ × (i+1)
 *
 * ПОШАГОВЫЙ ПРИМЕР (maxN = 5, mod = 7):
 *
 * Прямой ход (факториалы):
 * fact[0] = 1
 * fact[1] = 1 × 1 = 1
 * fact[2] = 1 × 2 = 2
 * fact[3] = 2 × 3 = 6
 * fact[4] = 6 × 4 = 24 mod 7 = 3
 * fact[5] = 3 × 5 = 15 mod 7 = 1
 *
 * Инверсия последнего:
 * invFact[5] = 1⁻¹ mod 7 = 1^(7-2) mod 7 = 1
 *
 * Обратный ход (обратные факториалы):
 * invFact[4] = invFact[5] × 5 = 1 × 5 = 5
 * invFact[3] = invFact[4] × 4 = 5 × 4 = 20 mod 7 = 6
 * ...
 *
 * СЛОЖНОСТЬ:
 * - Предвычисление: O(n)
 * - Запрос: O(1)
 */
class ModCombinatorics(maxN: Int, private val mod: Long = 1_000_000_007) {
    private val fact = LongArray(maxN + 1)
    private val invFact = LongArray(maxN + 1)

    init {
        // Шаг 1: Предвычисляем факториалы
        // fact[i] = i! mod p
        fact[0] = 1
        for (i in 1..maxN) {
            fact[i] = fact[i - 1] * i % mod
        }

        // Шаг 2: Инверсия последнего факториала через теорему Ферма
        // (maxN!)⁻¹ = (maxN!)^(p-2) mod p
        invFact[maxN] = modPow(fact[maxN], mod - 2, mod)

        // Шаг 3: Обратный ход для остальных
        // (i!)⁻¹ = ((i+1)!)⁻¹ × (i+1)
        for (i in maxN - 1 downTo 0) {
            invFact[i] = invFact[i + 1] * (i + 1) % mod
        }
    }

    /**
     * Биномиальный коэффициент C(n, r) = n! / (r! × (n-r)!)
     * Количество способов выбрать r элементов из n
     */
    fun nCr(n: Int, r: Int): Long {
        if (r < 0 || r > n) return 0
        return fact[n] * invFact[r] % mod * invFact[n - r] % mod
    }

    /**
     * Перестановки P(n, r) = n! / (n-r)!
     * Количество способов упорядоченно выбрать r элементов из n
     */
    fun nPr(n: Int, r: Int): Long {
        if (r < 0 || r > n) return 0
        return fact[n] * invFact[n - r] % mod
    }
}
```

---

## Распространённые ошибки

### 1. Overflow при умножении

```kotlin
// ❌ НЕПРАВИЛЬНО: a * b может overflow Long
val result = a * b % mod

// ✅ ПРАВИЛЬНО: приводим к mod перед умножением
val result = (a % mod) * (b % mod) % mod
```

### 2. Отрицательный остаток

```kotlin
// ❌ НЕПРАВИЛЬНО: (a - b) % mod может быть отрицательным
val result = (a - b) % mod

// ✅ ПРАВИЛЬНО: добавляем mod
val result = ((a - b) % mod + mod) % mod
```

### 3. modPow с exp = 0

```kotlin
// ❌ НЕПРАВИЛЬНО: не обрабатываем exp = 0
fun modPow(base: Long, exp: Long, mod: Long): Long {
    var result = base  // Должен быть 1!
    // ...
}

// ✅ ПРАВИЛЬНО:
fun modPow(base: Long, exp: Long, mod: Long): Long {
    var result = 1L  // a^0 = 1, начинаем с нейтрального элемента умножения
    // ...
}
```

---

## Практика

### LeetCode задачи

| # | Название | Сложность | Тема |
|---|----------|-----------|------|
| 50 | Pow(x, n) | Medium | Fast exponentiation |
| 204 | Count Primes | Medium | Sieve |
| 1201 | Ugly Number III | Medium | LCM, Binary Search |
| 1862 | Sum of Floored Pairs | Hard | Number theory |
| 2183 | Count Array Pairs Divisible by K | Hard | GCD |

---

## Связанные темы

### Prerequisites
- Modular arithmetic basics
- Recursion

### Unlocks
- [Combinatorics](./combinatorics.md)
- Cryptography algorithms
- Competitive programming math

---

## Источники

| # | Источник | Тип | Вклад |
|---|----------|-----|-------|
| 1 | [CP-Algorithms: Euclidean](https://cp-algorithms.com/algebra/euclid-algorithm.html) | Reference | GCD |
| 2 | [CP-Algorithms: Sieve](https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html) | Reference | Primes |
| 3 | [CP-Algorithms: Binary Exp](https://cp-algorithms.com/algebra/binary-exp.html) | Reference | Fast power |
| 4 | [CLRS] Introduction to Algorithms | Book | Theory |

---

*Обновлено: 2026-01-09 — добавлены педагогические секции (интуиция GCD/модульной арифметики/решета, 6 типичных ошибок, 5 ментальных моделей)*
