---
title: "Рекурсия: полное руководство для понимания с нуля"
created: 2025-12-29
modified: 2026-01-06
type: guide
status: published
difficulty: beginner
confidence: high
cs-foundations:
  - call-stack-mechanism
  - stack-frames
  - base-case-termination
  - divide-and-conquer
  - tail-call-optimization
  - memoization-caching
  - mathematical-induction
prerequisites:
  - "[[stacks-queues]]"
tags:
  - topic/cs-fundamentals
  - type/guide
  - level/beginner
  - interview
related:
  - "[[dynamic-programming]]"
  - "[[backtracking]]"
  - "[[sorting-algorithms]]"
  - "[[trees-binary]]"
---

# Рекурсия: полное руководство для понимания с нуля

> **Цель этого материала:** После прочтения ты будешь ПОНИМАТЬ рекурсию, не просто копировать паттерны. Ты сможешь писать рекурсивные решения и, главное, объяснить другим, как они работают.

---

## Часть 1: Интуиция без кода

> Прежде чем писать любой код, давай разберёмся с идеей рекурсии на примерах из реальной жизни.

### Аналогия 1: Матрёшка

Представь русскую матрёшку — деревянную куклу, внутри которой находится кукла поменьше. Открываешь её — там ещё одна. И так до самой маленькой, которую уже нельзя открыть.

```
┌─────────────────────────────────────────────────────┐
│                                                     │
│     ┌───────────────────────────────────────┐       │
│     │                                       │       │
│     │     ┌───────────────────────────┐     │       │
│     │     │                           │     │       │
│     │     │     ┌───────────────┐     │     │       │
│     │     │     │               │     │     │       │
│     │     │     │   [маленькая] │     │     │       │
│     │     │     │   СТОП!       │     │     │       │
│     │     │     └───────────────┘     │     │       │
│     │     │                           │     │       │
│     │     └───────────────────────────┘     │       │
│     │                                       │       │
│     └───────────────────────────────────────┘       │
│                                                     │
└─────────────────────────────────────────────────────┘

Что ты делаешь:
1. Если кукла не открывается → СТОП (это base case)
2. Если открывается → открой и повтори с той, что внутри
```

**Это и есть рекурсия:**
- Ты делаешь одно и то же действие (открываешь)
- Каждый раз задача становится меньше (кукла меньше)
- Есть точка остановки (самая маленькая кукла)

---

### Аналогия 2: Поиск ключей в папках

Представь, что ты ищешь ключи в коробке. Но в коробке могут быть другие коробки.

```
┌──────────────────────────────────────────────────────────┐
│  ГЛАВНАЯ КОРОБКА                                         │
│  ┌──────────┐  ┌──────────┐  [носок]  [карандаш]         │
│  │  коробка │  │  коробка │                              │
│  │  ┌────┐  │  │  [🔑]    │                              │
│  │  │коро│  │  │  ключи!  │                              │
│  │  │бка │  │  └──────────┘                              │
│  │  └────┘  │                                            │
│  └──────────┘                                            │
└──────────────────────────────────────────────────────────┘
```

**Алгоритм поиска (словами, без кода):**

```
Чтобы найти ключи в коробке:
  1. Открой коробку
  2. Для каждого предмета:
     - Если это ключи → УРА, нашёл! СТОП.
     - Если это коробка → найди ключи в ЭТОЙ коробке (повтори алгоритм)
     - Если что-то другое → пропусти
```

Заметь: **"найди ключи в этой коробке"** — это тот же алгоритм! Мы описываем решение через само себя. Это рекурсия.

---

### Аналогия 3: Телефонная цепочка

Ты хочешь узнать, свободен ли твой друг Ваня на обед. Но Ваня говорит: "Не знаю, зависит от Пети. Подожди, спрошу его."

```
ТЫ → звонишь Ване
     Ваня → "Подожди..." → звонит Пете
                           Петя → "Подожди..." → звонит Маше
                                                 Маша → "Да, свободна!"
                                  Петя ← "Маша свободна, и я тоже!"
          Ваня ← "Все свободны!"
ТЫ ← "Все свободны, идём обедать!"
```

**Что здесь происходит:**
1. Каждый человек "ставит разговор на паузу" и звонит следующему
2. Когда кто-то даёт окончательный ответ (Маша) — это base case
3. Ответы возвращаются по цепочке назад

**Важно:** Ваня НЕ МОЖЕТ ответить тебе, пока не получит ответ от Пети. Петя не может ответить, пока не получит от Маши. Это называется **call stack** — стек вызовов.

---

### Почему рекурсия существует?

Некоторые вещи в мире **по своей природе рекурсивны**:

| Структура | Почему рекурсивна |
|-----------|-------------------|
| **Файловая система** | Папка может содержать другие папки |
| **Семейное дерево** | У каждого человека есть родители, у них свои родители... |
| **Организация компании** | У руководителя есть подчинённые, у них свои подчинённые... |
| **HTML/XML документ** | Тег может содержать другие теги |
| **Математические формулы** | n! = n × (n-1)! |

**Когда данные рекурсивны по структуре, рекурсивное решение — самое естественное.**

---

### Простой числовой пример (без кода)

**Задача:** Посчитать сумму чисел от 1 до 5.

**Итеративное мышление (циклом):**
```
сумма = 0
сумма = сумма + 1 = 1
сумма = сумма + 2 = 3
сумма = сумма + 3 = 6
сумма = сумма + 4 = 10
сумма = сумма + 5 = 15
```

**Рекурсивное мышление:**
```
сумма(5) = 5 + сумма(4)
                 ↓
         = 5 + (4 + сумма(3))
                       ↓
         = 5 + (4 + (3 + сумма(2)))
                           ↓
         = 5 + (4 + (3 + (2 + сумма(1))))
                               ↓
         = 5 + (4 + (3 + (2 + 1)))     ← base case: сумма(1) = 1
         = 5 + (4 + (3 + 3))
         = 5 + (4 + 6)
         = 5 + 10
         = 15
```

**Ключевое различие в мышлении:**
- Цикл: "Я буду добавлять числа одно за другим"
- Рекурсия: "Сумма до N — это N плюс сумма до N-1. Сумма до 1 — это просто 1."

---

## Часть 2: Почему рекурсия считается сложной?

> Понимание того, что делает рекурсию трудной, поможет избежать типичных ловушек.

### Главная причина: мы пытаемся "быть компьютером"

Исследования показывают, что студенты пытаются мысленно проследить **каждый** рекурсивный вызов. С factorial(5) это ещё можно. Но с Fibonacci(20)? Там 21891 вызов. Невозможно.

```
ТИПИЧНАЯ ОШИБКА НОВИЧКА:

"Так, factorial(5)..."
"Он вызывает factorial(4)..."
"Который вызывает factorial(3)..."
"Который вызывает factorial(2)..."
"Который вызывает factorial(1)..."
"Ааа, я запутался, где я был?"

→ Когнитивная перегрузка
→ "Рекурсия сложная!"
```

**Решение:** Не пытайся быть компьютером. Используй ментальные модели (см. Часть 3).

---

### Типичные заблуждения студентов

Согласно [исследованиям](https://www.pd4cs.org/recursion-misconceptions-and-challenges/), студенты допускают одни и те же ошибки:

| Заблуждение | Реальность |
|-------------|------------|
| "Я должен мысленно отследить все вызовы" | Нет! Доверяй рекурсивному вызову (см. "Leap of Faith") |
| "Рекурсия — это просто другой способ написать цикл" | Нет! Рекурсия — инструмент для задач с рекурсивной структурой |
| "Base case — самое сложное" | На самом деле сложнее понять recursive case |
| "Если программа работает — значит всё правильно" | Stack overflow может случиться при больших n |

---

### Проблема факториала и Фибоначчи

Вот что пишет [Shriram Krishnamurthi](https://parentheticallyspeaking.org/articles/how-not-to-teach-recursion/) о типичных примерах:

> "Почти никому никогда не нужно было вычислять факториал. За 35 лет программирования единственный раз, когда мне это понадобилось — рекреационная математика."

**Проблемы с классическими примерами:**

| Пример | Проблема |
|--------|----------|
| Факториал | Можно написать циклом. Студенты спрашивают: "Зачем?" |
| Фибоначчи | Экспоненциальная сложность. Зависает на n=40 |
| Ханойские башни | Головоломка без практического применения |

**Лучшие примеры для обучения:**
- Обход файловой системы
- Поиск в дереве (DOM, JSON)
- Парсинг вложенных структур

---

### История: откуда взялась рекурсия?

**1930-е годы:** Математики Курт Гёдель и Алонзо Чёрч разработали теорию рекурсивных функций как основу вычислимости.

**1958 год:** Язык LISP — первый язык программирования с полноценной поддержкой рекурсии. Его создатель Джон Маккарти сделал рекурсию центральным понятием.

**1960-е годы:** Алгоритмы сортировки (Merge Sort, Quick Sort) показали практическую силу рекурсии.

**Сегодня:** Рекурсия — фундамент для понимания деревьев, графов, Dynamic Programming, компиляторов.

---

## Часть 3: Ментальные модели

> Три способа думать о рекурсии. Выбери тот, который тебе ближе.

### Модель 1: "Прыжок веры" (Leap of Faith)

**Суть:** Когда пишешь рекурсивную функцию, **доверяй**, что рекурсивный вызов вернёт правильный ответ. Не пытайся проследить все вызовы.

```
┌────────────────────────────────────────────────────────────────┐
│                     LEAP OF FAITH                              │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│   Ты пишешь функцию sum(n):                                    │
│                                                                │
│   1. Определи base case:                                       │
│      "Если n = 1, ответ = 1"                                   │
│                                                                │
│   2. Предположи, что sum(n-1) РАБОТАЕТ ПРАВИЛЬНО              │
│      (даже если ты ещё не дописал функцию!)                   │
│                                                                │
│   3. Используй результат sum(n-1) для получения sum(n):       │
│      "sum(n) = n + sum(n-1)"                                   │
│                                                                │
│   ГОТОВО. Не нужно проверять, что sum(4), sum(3), sum(2)      │
│   работают правильно — они работают, если логика верна.       │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

**Почему это работает?**

Это похоже на математическую индукцию:
1. Если base case верен
2. И если верно, что из корректного f(n-1) следует корректный f(n)
3. То f(n) верен для всех n

**Когда использовать:** Когда пишешь код и нужно быстро построить решение.

---

### Модель 2: "Напарник-программист"

**Суть:** Представь, что у тебя есть помощник, который умеет решать чуть более простую версию твоей задачи.

```
┌────────────────────────────────────────────────────────────────┐
│                   PROGRAMMING BUDDY                            │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│   ЗАДАЧА: Посчитать sum(5)                                     │
│                                                                │
│   ТЫ думаешь:                                                  │
│   "Я не хочу считать всю сумму..."                            │
│   "Но я могу добавить 5 к чему-то..."                         │
│   "Эй, напарник! Посчитай sum(4), я подожду."                 │
│                                                                │
│   НАПАРНИК:                                                    │
│   "Легко! sum(4) = 10. Держи."                                │
│                                                                │
│   ТЫ:                                                          │
│   "Отлично! Значит sum(5) = 5 + 10 = 15"                      │
│                                                                │
│   ─────────────────────────────────────────────────            │
│   ВАЖНО: Тебе НЕ ВАЖНО, как напарник посчитал sum(4).         │
│   Ты просто ДОВЕРЯЕШЬ его ответу.                             │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

**Ключевой момент:**
- Ты делаешь только ОДНУ простую операцию (добавляешь n)
- Всю сложную работу делегируешь напарнику
- Напарник — это та же функция, но с меньшим входом

---

### Модель 3: "Call Stack как башня из тарелок"

**Суть:** Каждый вызов функции — это тарелка, которую ты кладёшь на стопку. Снять можно только верхнюю тарелку.

```
┌────────────────────────────────────────────────────────────────┐
│                     CALL STACK                                 │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│   ФАЗА 1: ДОБАВЛЯЕМ ТАРЕЛКИ (углубление)                      │
│                                                                │
│   sum(5) вызван                      ┌─────────────┐           │
│                                      │   sum(5)    │ ← TOP     │
│                                      │ ждёт sum(4) │           │
│                                      └─────────────┘           │
│                                                                │
│   sum(4) вызван                      ┌─────────────┐           │
│                                      │   sum(4)    │ ← TOP     │
│                                      │ ждёт sum(3) │           │
│                                      ├─────────────┤           │
│                                      │   sum(5)    │           │
│                                      │ ждёт...     │           │
│                                      └─────────────┘           │
│                                                                │
│   ... и так до sum(1)                                          │
│                                                                │
│   sum(1) = base case!                ┌─────────────┐           │
│                                      │   sum(1)    │ ← TOP     │
│                                      │ return 1    │           │
│                                      ├─────────────┤           │
│                                      │   sum(2)    │           │
│                                      ├─────────────┤           │
│                                      │   sum(3)    │           │
│                                      ├─────────────┤           │
│                                      │   sum(4)    │           │
│                                      ├─────────────┤           │
│                                      │   sum(5)    │           │
│                                      └─────────────┘           │
│                                                                │
│   ─────────────────────────────────────────────────            │
│                                                                │
│   ФАЗА 2: СНИМАЕМ ТАРЕЛКИ (раскрутка)                         │
│                                                                │
│   sum(1) возвращает 1 → тарелка снята                         │
│   sum(2) получает 1, возвращает 2+1=3 → тарелка снята         │
│   sum(3) получает 3, возвращает 3+3=6 → тарелка снята         │
│   sum(4) получает 6, возвращает 4+6=10 → тарелка снята        │
│   sum(5) получает 10, возвращает 5+10=15 → РЕЗУЛЬТАТ!         │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

**Когда использовать эту модель:**
- Для отладки (понять, где что сломалось)
- Для анализа памяти (stack overflow)
- Для понимания порядка операций

---

### Какую модель выбрать?

| Ситуация | Рекомендуемая модель |
|----------|---------------------|
| Пишу код с нуля | Leap of Faith |
| Объясняю другому | Programming Buddy |
| Отлаживаю, что-то не работает | Call Stack |
| Анализирую сложность | Call Stack |

---

## Часть 4: Пошаговое объяснение с кодом

> Теперь, когда интуиция есть, давай напишем код. Каждая строка будет объяснена.

### Два обязательных компонента рекурсии

Любая рекурсивная функция состоит из:

```
┌─────────────────────────────────────────────────────────────────┐
│                    АНАТОМИЯ РЕКУРСИИ                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌───────────────────────────────────────────────────────┐     │
│   │  BASE CASE (базовый случай)                           │     │
│   │                                                       │     │
│   │  • Условие, при котором рекурсия ОСТАНАВЛИВАЕТСЯ     │     │
│   │  • Самый простой случай, решаемый напрямую           │     │
│   │  • БЕЗ НЕГО → бесконечная рекурсия → crash           │     │
│   └───────────────────────────────────────────────────────┘     │
│                           │                                     │
│                           ▼                                     │
│   ┌───────────────────────────────────────────────────────┐     │
│   │  RECURSIVE CASE (рекурсивный случай)                  │     │
│   │                                                       │     │
│   │  • Вызов функции самой себя                          │     │
│   │  • С МЕНЬШИМ или БОЛЕЕ ПРОСТЫМ входом                │     │
│   │  • ДОЛЖЕН приближаться к base case                   │     │
│   └───────────────────────────────────────────────────────┘     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

### Пример 1: Сумма чисел от 1 до n

**Задача:** Написать функцию `sum(n)`, которая возвращает 1 + 2 + ... + n.

**Шаг 1: Определить base case**

Какой самый простой случай?
- `sum(1) = 1` — тут нечего считать, ответ очевиден.
- Можно также добавить `sum(0) = 0` для защиты от некорректного ввода.

**Шаг 2: Определить рекурсивную связь**

Как `sum(n)` связано с `sum(n-1)`?
- `sum(n) = n + sum(n-1)`
- Пример: `sum(5) = 5 + sum(4)`

**Шаг 3: Написать код**

```python
def sum_to_n(n):
    # Base case: самый простой случай
    if n <= 1:
        return n

    # Recursive case: текущее число + сумма всех предыдущих
    return n + sum_to_n(n - 1)
```

**Разбор КАЖДОЙ строки:**

| Строка | Что делает | Почему |
|--------|-----------|--------|
| `def sum_to_n(n):` | Объявляем функцию | Принимает одно число n |
| `if n <= 1:` | Проверяем base case | Если n=0 или n=1, нет смысла рекурсии |
| `return n` | Возвращаем n напрямую | sum(1)=1, sum(0)=0 — очевидные ответы |
| `return n + sum_to_n(n - 1)` | Рекурсивный вызов | n + сумма всех меньших чисел |

**Визуальный trace для sum_to_n(4):**

```
sum_to_n(4)
├── n=4, n > 1, идём в рекурсию
├── return 4 + sum_to_n(3)
│             │
│             └── sum_to_n(3)
│                 ├── n=3, n > 1, идём в рекурсию
│                 ├── return 3 + sum_to_n(2)
│                 │             │
│                 │             └── sum_to_n(2)
│                 │                 ├── n=2, n > 1, идём в рекурсию
│                 │                 ├── return 2 + sum_to_n(1)
│                 │                 │             │
│                 │                 │             └── sum_to_n(1)
│                 │                 │                 ├── n=1 ≤ 1 ✓ BASE CASE
│                 │                 │                 └── return 1
│                 │                 │
│                 │                 └── return 2 + 1 = 3
│                 │
│                 └── return 3 + 3 = 6
│
└── return 4 + 6 = 10 ✓
```

---

### Пример 2: Факториал

**Задача:** `factorial(n) = n × (n-1) × ... × 2 × 1`

**Рекурсивная связь:**
- `factorial(n) = n × factorial(n-1)`
- `factorial(1) = 1` (base case)
- `factorial(0) = 1` (по математическому определению)

```python
def factorial(n):
    # Base case: 0! = 1, 1! = 1
    if n <= 1:
        return 1

    # Recursive case: n! = n × (n-1)!
    return n * factorial(n - 1)
```

**Почему `factorial(0) = 1`?**

Это не интуитивно, но математически важно:
- `factorial(3) = 3 × 2 × 1 = 6`
- `factorial(2) = 2 × 1 = 2`
- `factorial(1) = 1`
- Если паттерн продолжить: `factorial(n) = factorial(n+1) / (n+1)`
- `factorial(0) = factorial(1) / 1 = 1 / 1 = 1`

Это также нужно для формулы комбинаций: C(n, 0) = n! / (0! × n!) = 1.

---

### Пример 3: Обход файловой системы (практический!)

Вот пример, где рекурсия — **единственно разумное решение**.

**Задача:** Найти все файлы с расширением `.txt` в папке и всех вложенных папках.

```python
import os

def find_txt_files(folder_path):
    """
    Рекурсивно ищет все .txt файлы в папке и вложенных папках.

    Args:
        folder_path: путь к папке для поиска

    Returns:
        list: список путей к найденным .txt файлам
    """
    result = []

    # Получаем содержимое папки
    items = os.listdir(folder_path)

    for item in items:
        full_path = os.path.join(folder_path, item)

        if os.path.isfile(full_path):
            # BASE CASE: это файл
            if item.endswith('.txt'):
                result.append(full_path)
        else:
            # RECURSIVE CASE: это папка — ищем внутри
            result.extend(find_txt_files(full_path))

    return result
```

**Разбор логики:**

```
┌─────────────────────────────────────────────────────────────────┐
│  ПОЧЕМУ ЭТО РАБОТАЕТ                                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Файловая система — РЕКУРСИВНАЯ СТРУКТУРА:                     │
│                                                                 │
│  📁 Documents/                                                  │
│  ├── 📄 notes.txt         ← файл (base case)                   │
│  ├── 📁 Work/             ← папка (recursive case)             │
│  │   ├── 📄 report.txt                                         │
│  │   └── 📁 Archive/      ← ещё папка (recursive case)         │
│  │       └── 📄 old.txt                                        │
│  └── 📄 todo.txt                                               │
│                                                                 │
│  Каждая папка — это "та же задача, но меньше"                  │
│  Файл — это конечная точка, дальше идти некуда                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Попробуй написать это циклом.** Можно, но потребуется вручную создавать стек папок для обхода — фактически эмулировать то, что рекурсия делает автоматически.

---

### Пример 4: Fibonacci с объяснением проблемы

```python
def fibonacci(n):
    """
    Возвращает n-ое число Фибоначчи.

    ВНИМАНИЕ: Эта наивная версия имеет O(2^n) сложность!
    Используй только для демонстрации, не в production.
    """
    # Base cases: fib(0) = 0, fib(1) = 1
    if n <= 1:
        return n

    # Recursive case: fib(n) = fib(n-1) + fib(n-2)
    return fibonacci(n - 1) + fibonacci(n - 2)
```

**Почему это плохая реализация?**

```
                    fib(5)
                   /      \
              fib(4)      fib(3)      ← fib(3) вычисляется
             /    \       /    \         ДВАЖДЫ!
         fib(3)  fib(2) fib(2) fib(1)
         /   \    / \    / \
      fib(2) fib(1) ... ...

Количество вызовов для fib(n):
- fib(10): 177 вызовов
- fib(20): 21,891 вызов
- fib(30): 2,692,537 вызовов
- fib(40): ~331 миллион вызовов (зависнет!)
```

**Решение: мемоизация** (см. секцию про оптимизацию ниже).

---

## Часть 5: Типичные ошибки и ПОЧЕМУ они происходят

> Каждая ошибка с конкретным примером и объяснением корневой причины.

### Ошибка 1: Забыл base case

**Код:**
```python
def countdown(n):
    print(n)
    countdown(n - 1)  # Нет условия остановки!
```

**Что происходит:**
```
countdown(5)
└── print(5), countdown(4)
    └── print(4), countdown(3)
        └── print(3), countdown(2)
            └── print(2), countdown(1)
                └── print(1), countdown(0)
                    └── print(0), countdown(-1)
                        └── print(-1), countdown(-2)
                            └── ... → Stack Overflow
```

**ПОЧЕМУ это происходит:**

Без base case функция никогда не получает сигнал остановиться. Каждый вызов создаёт новый stack frame. Память конечна. Когда стек заполнен → crash.

**Исправление:**
```python
def countdown(n):
    if n <= 0:      # ← BASE CASE
        return
    print(n)
    countdown(n - 1)
```

---

### Ошибка 2: Рекурсия не приближается к base case

**Код:**
```python
def broken_sum(n):
    if n == 0:
        return 0
    return n + broken_sum(n)  # ОШИБКА: n не уменьшается!
```

**Что происходит:**
```
broken_sum(5)
└── return 5 + broken_sum(5)  # n всё ещё 5
    └── return 5 + broken_sum(5)
        └── return 5 + broken_sum(5)
            └── ... → бесконечность → Stack Overflow
```

**ПОЧЕМУ это происходит:**

Base case `n == 0` существует, но мы к нему никогда не придём, потому что `n` не меняется. Это как идти к двери, но каждый шаг делать на месте.

**Исправление:**
```python
def correct_sum(n):
    if n == 0:
        return 0
    return n + correct_sum(n - 1)  # ← n УМЕНЬШАЕТСЯ
```

---

### Ошибка 3: Неправильный base case

**Код:**
```python
def factorial(n):
    if n == 1:  # Только n == 1, а что с n == 0?
        return 1
    return n * factorial(n - 1)
```

**Проблема:**
```
factorial(0)
└── 0 != 1, идём в рекурсию
└── return 0 * factorial(-1)
    └── -1 != 1, идём в рекурсию
    └── return -1 * factorial(-2)
        └── ... → Stack Overflow
```

**ПОЧЕМУ это происходит:**

Base case слишком узкий. Он не покрывает все случаи, когда рекурсия должна остановиться. Если передать 0, мы "промахнёмся" мимо base case.

**Исправление:**
```python
def factorial(n):
    if n <= 1:  # ← Покрываем и 0, и 1, и отрицательные
        return 1
    return n * factorial(n - 1)
```

---

### Ошибка 4: Думать, что рекурсия завершается мгновенно

**Код:**
```python
def process_tree(node):
    if node is None:
        return

    print(node.value)           # ← Сначала печатаем
    process_tree(node.left)     # ← Потом левое поддерево
    # ЧТО-ТО ДЕЛАЕМ ТУТ        # ← Этот код выполнится ПОСЛЕ
    process_tree(node.right)    #   завершения ВСЕГО левого поддерева!
```

**ПОЧЕМУ это происходит:**

Студенты думают, что `process_tree(node.left)` — это как обычный вызов функции, который мгновенно вернёт результат. Но рекурсия может выполняться долго, и следующая строка выполнится только когда ВСЕ вложенные вызовы завершатся.

**Визуализация:**
```
process_tree(root)
├── print(root.value)  ← выполняется сразу
├── process_tree(root.left)  ← ЖДЁМ завершения всего левого поддерева
│   ├── print(left.value)
│   ├── process_tree(left.left)
│   │   └── (весь путь вниз и обратно)
│   └── process_tree(left.right)
│       └── (весь путь вниз и обратно)
├── ← ТОЛЬКО ТЕПЕРЬ мы здесь
└── process_tree(root.right)
```

---

### Ошибка 5: Не сохранять результат рекурсивного вызова

**Код:**
```python
def sum_list(lst):
    if not lst:
        return 0

    sum_list(lst[1:])  # ОШИБКА: результат игнорируется!
    return lst[0]      # Возвращаем только первый элемент
```

**Результат:** `sum_list([1, 2, 3, 4, 5])` вернёт `1`, а не `15`.

**ПОЧЕМУ это происходит:**

Рекурсивный вызов выполняется, но его результат никуда не записывается и не используется. Это как позвонить другу спросить ответ, а потом положить трубку не дослушав.

**Исправление:**
```python
def sum_list(lst):
    if not lst:
        return 0

    rest_sum = sum_list(lst[1:])  # ← Сохраняем результат
    return lst[0] + rest_sum       # ← Используем его

    # Или короче:
    # return lst[0] + sum_list(lst[1:])
```

---

### Таблица типичных ошибок

| Ошибка | Симптом | Причина | Решение |
|--------|---------|---------|---------|
| Нет base case | Stack Overflow | Нечему остановить рекурсию | Добавить условие выхода |
| Не движемся к base case | Stack Overflow | Параметр не меняется | Уменьшать/изменять параметр |
| Узкий base case | Stack Overflow при edge cases | Не все случаи покрыты | Расширить условие (`<=` вместо `==`) |
| Игнорируем результат | Неправильный ответ | Не используем результат вызова | Сохранить и использовать результат |
| Лишние вызовы | Медленная работа | Дублирование вычислений | Мемоизация |

---

## Часть 6: Оптимизация рекурсии

### Проблема: экспоненциальная сложность

Fibonacci без оптимизации — классический пример того, как рекурсия может быть ужасно медленной.

```
Time complexity: O(2^n)

n = 10:  ~1,000 операций        → мгновенно
n = 20:  ~1,000,000 операций    → заметная задержка
n = 30:  ~1,000,000,000 операций → секунды
n = 40:  ~1,000,000,000,000 операций → минуты
n = 50:  → дни
```

### Решение 1: Мемоизация (Top-Down DP)

**Идея:** Сохраняем результаты уже вычисленных вызовов, чтобы не считать повторно.

```python
def fibonacci_memo(n, cache=None):
    """
    Fibonacci с мемоизацией.
    Time: O(n), Space: O(n)
    """
    if cache is None:
        cache = {}

    # Base cases
    if n <= 1:
        return n

    # Проверяем кэш
    if n in cache:
        return cache[n]  # ← Уже считали — возвращаем из кэша

    # Вычисляем и сохраняем в кэш
    result = fibonacci_memo(n - 1, cache) + fibonacci_memo(n - 2, cache)
    cache[n] = result

    return result
```

**Как это работает:**

```
БЕЗ мемоизации:              С мемоизацией:
        fib(5)                       fib(5)
       /     \                      /     \
    fib(4)   fib(3)             fib(4)   fib(3) ← CACHE HIT!
    /   \     /   \              /   \
 fib(3) fib(2) fib(2) fib(1)  fib(3) fib(2) ← CACHE HIT!
                               /   \
                            fib(2) fib(1) ← CACHE HIT!

Вызовы: 15                   Вызовы: 9
```

**Python shortcut с @lru_cache:**

```python
from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)
```

---

### Решение 2: Табуляция (Bottom-Up DP)

**Идея:** Вместо рекурсии сверху вниз, строим ответ снизу вверх.

```python
def fibonacci_tab(n):
    """
    Fibonacci с табуляцией.
    Time: O(n), Space: O(n)
    """
    if n <= 1:
        return n

    # Создаём таблицу
    dp = [0] * (n + 1)
    dp[0] = 0
    dp[1] = 1

    # Заполняем снизу вверх
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]

    return dp[n]
```

**Оптимизация пространства до O(1):**

```python
def fibonacci_optimal(n):
    """
    Fibonacci с O(1) памяти.
    Time: O(n), Space: O(1)
    """
    if n <= 1:
        return n

    prev2, prev1 = 0, 1  # fib(0), fib(1)

    for _ in range(2, n + 1):
        current = prev1 + prev2
        prev2 = prev1
        prev1 = current

    return prev1
```

---

### Решение 3: Tail Recursion (для языков с TCO)

**Идея:** Сделать рекурсивный вызов последней операцией, чтобы компилятор мог оптимизировать.

```kotlin
// Обычная рекурсия — НЕ tail-recursive
fun factorial(n: Int): Long {
    if (n <= 1) return 1
    return n * factorial(n - 1)  // Умножение ПОСЛЕ вызова
}

// Tail-recursive версия
tailrec fun factorialTail(n: Int, acc: Long = 1): Long {
    if (n <= 1) return acc
    return factorialTail(n - 1, n * acc)  // Вызов — последняя операция
}
```

**Почему это работает:**

```
ОБЫЧНАЯ РЕКУРСИЯ:                TAIL RECURSION:

Stack растёт:                     Stack НЕ растёт:
┌──────────────┐                  ┌──────────────┐
│ factorial(1) │                  │ fact(5,1)    │
├──────────────┤                  │ → fact(4,5)  │
│ factorial(2) │                  │ → fact(3,20) │
├──────────────┤                  │ → fact(2,60) │
│ factorial(3) │                  │ → fact(1,120)│
├──────────────┤                  │ → return 120 │
│ factorial(4) │                  └──────────────┘
├──────────────┤
│ factorial(5) │                  Один и тот же frame
└──────────────┘                  переиспользуется!
```

**Поддержка TCO в языках:**

| Язык | Поддержка | Как использовать |
|------|-----------|------------------|
| Kotlin | Да | `tailrec` keyword |
| Scala | Да | `@tailrec` annotation |
| Haskell | Да | По умолчанию |
| Python | **НЕТ** | — |
| Java | **НЕТ** | — |
| JavaScript | Частично | ES6, не везде |

---

## Часть 7: Когда использовать рекурсию

### Используй рекурсию когда:

| Ситуация | Пример |
|----------|--------|
| Данные имеют рекурсивную структуру | Деревья, графы, вложенные списки |
| Задача divide-and-conquer | Merge Sort, Quick Sort |
| Backtracking (перебор с откатом) | Судоку, N Queens, генерация комбинаций |
| Код становится значительно чище | Обход файловой системы |

### НЕ используй рекурсию когда:

| Ситуация | Почему | Альтернатива |
|----------|--------|--------------|
| Простой линейный проход | Overhead вызовов | Цикл for/while |
| Глубина > 1000 (в Python) | Stack Overflow | Итерация + явный стек |
| Performance критичен | Overhead вызовов | Итеративная версия |
| Легко переписать циклом | Нет преимуществ | Цикл |

### Decision Tree

```
┌─────────────────────────────────────────────────────────────────┐
│                 РЕКУРСИЯ ИЛИ ИТЕРАЦИЯ?                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Данные = дерево, граф, вложенная структура?                   │
│   ├── ДА → РЕКУРСИЯ (обычно проще и понятнее)                  │
│   └── НЕТ ↓                                                     │
│                                                                 │
│   Задача = divide-and-conquer?                                  │
│   ├── ДА → РЕКУРСИЯ (MergeSort, QuickSort)                     │
│   └── НЕТ ↓                                                     │
│                                                                 │
│   Нужен backtracking (перебор с откатом)?                       │
│   ├── ДА → РЕКУРСИЯ (комбинации, перестановки)                 │
│   └── НЕТ ↓                                                     │
│                                                                 │
│   Глубина может превысить ~1000?                                │
│   ├── ДА → ИТЕРАЦИЯ с явным стеком                             │
│   └── НЕТ ↓                                                     │
│                                                                 │
│   Простой линейный проход?                                      │
│   ├── ДА → ИТЕРАЦИЯ (цикл for/while)                           │
│   └── НЕТ → Смотри по ситуации                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Мифы и заблуждения

| Миф | Реальность |
|-----|-----------|
| "Рекурсия всегда медленнее итерации" | **Неверно.** С TCO рекурсия компилируется в цикл. Рекурсивное возведение в степень O(log n) быстрее итеративного O(n). |
| "Space complexity = количество вызовов" | **Неверно.** Space = максимальная глубина стека. Fibonacci делает O(2^n) вызовов, но использует O(n) памяти. |
| "Если код работает — значит рекурсия правильная" | **Опасно!** Может работать для малых n, но упасть от Stack Overflow на больших. |
| "Нельзя любую рекурсию переписать итерацией" | **Неверно.** Любую рекурсию можно переписать с explicit stack. Call stack — просто структура данных. |
| "Tail recursion автоматически оптимизируется" | **Зависит от языка.** Python и Java НЕ делают TCO. Kotlin требует `tailrec`. |
| "Base case должен быть один" | **Неверно.** Fibonacci имеет два base case. Некоторые алгоритмы имеют 3+ для разных edge cases. |
| "Рекурсия только для деревьев" | **Неверно.** Также: backtracking, divide-and-conquer, parsing, математические вычисления. |
| "Факториал — хороший пример для изучения" | **Спорно.** Факториал легко пишется циклом, не мотивирует изучать рекурсию. Лучше: файловая система, деревья. |

---

## CS-фундамент

| CS-концепция | Применение в рекурсии |
|--------------|----------------------|
| **Call Stack** | Каждый рекурсивный вызов создаёт новый stack frame. Stack работает по LIFO: последний вызов возвращается первым. Это фундамент понимания порядка выполнения. |
| **Stack Frame** | Блок памяти для одного вызова: return address, аргументы, локальные переменные. Размер ~32-64 байта. Понимание stack frame объясняет, почему рекурсия требует памяти. |
| **Mathematical Induction** | Рекурсия = программное воплощение мат. индукции. Base case = база индукции. Recursive case = индукционный шаг. Если оба верны → алгоритм корректен для всех n. |
| **Divide and Conquer** | Классический паттерн: разбить → решить рекурсивно → объединить. MergeSort, QuickSort, Binary Search. Master theorem для анализа: T(n) = aT(n/b) + O(n^k). |
| **Tail Call Optimization** | Компилятор может переиспользовать stack frame для tail call. Превращает рекурсию в цикл с O(1) памяти. Требование: recursive call = последняя операция. |
| **Memoization** | Техника кэширования результатов функции. Превращает O(2^n) в O(n) для задач с overlapping subproblems. Связывает рекурсию с Dynamic Programming. |

---

## Практические задачи для закрепления

### Уровень 1: Базовые (для понимания механики)

| # | Задача | Что практикуем |
|---|--------|----------------|
| 1 | Сумма цифр числа | Простая рекурсия с делением |
| 2 | Reverse string | Работа со строками |
| 3 | Check palindrome | Base case + symmetric recursion |
| 4 | Count occurrences in list | Линейный проход рекурсией |
| 5 | Power(x, n) | Оптимизированная рекурсия O(log n) |

### Уровень 2: Деревья (где рекурсия сияет)

| # | Задача | Что практикуем |
|---|--------|----------------|
| 6 | Maximum depth of binary tree | Tree traversal |
| 7 | Check if trees are equal | Сравнение структур |
| 8 | Inorder/Preorder/Postorder | Три типа обхода |
| 9 | Count nodes in tree | Простая агрегация |
| 10 | Is valid BST | Передача состояния вниз |

### Уровень 3: Backtracking

| # | Задача | Что практикуем |
|---|--------|----------------|
| 11 | Generate all subsets | Включать/не включать |
| 12 | Generate permutations | Перебор с откатом |
| 13 | N-Queens | Constraint checking |
| 14 | Sudoku solver | Complex backtracking |
| 15 | Generate parentheses | Счётчики как состояние |

---

## Чеклист перед написанием рекурсии

```
□ Определил BASE CASE(s)
  - Какой самый простой случай?
  - Покрыты ли edge cases (0, 1, пустой ввод)?

□ Определил RECURSIVE CASE
  - Как уменьшается задача?
  - Приближаемся ли к base case?

□ Использую результат рекурсивного вызова
  - Не игнорирую return value

□ Оценил глубину рекурсии
  - Не превысит ~1000 в Python?
  - Не нужна ли итерация с явным стеком?

□ Проверил на дублирование вычислений
  - Нужна ли мемоизация?

□ Протестировал edge cases
  - n = 0, n = 1, пустой список, null
```

---

## Связи

- [[big-o-complexity]] — анализ сложности рекурсивных алгоритмов
- [[dynamic-programming]] — связь через мемоизацию (Top-Down DP)
- [[backtracking]] — рекурсивный перебор с откатом
- [[trees-binary]] — естественное применение рекурсии
- [[sorting-algorithms]] — Merge Sort, Quick Sort
- [[stacks-queues]] — Call Stack как структура данных

---

## Связь с другими темами

**[[dynamic-programming]]** — динамическое программирование начинается именно с рекурсии. Классический путь решения DP-задачи: сначала написать рекурсивное решение (brute force), затем добавить мемоизацию (top-down DP), и наконец переписать итеративно (bottom-up DP). Без глубокого понимания рекурсии невозможно увидеть overlapping subproblems и сформулировать рекуррентное соотношение. Рекомендуется сначала полностью освоить рекурсию, а затем переходить к DP.

**[[backtracking]]** — backtracking по сути является рекурсией с механизмом отсечения (pruning). Каждый рекурсивный вызов в backtracking делает выбор, а при возврате этот выбор отменяется. Понимание call stack и возврата значений из рекурсии критически важно для реализации backtracking-алгоритмов: генерации перестановок, комбинаций, решения судоку и N-Queens. Изучать backtracking следует после освоения рекурсии и базовых паттернов обхода деревьев.

**[[sorting-algorithms]]** — классические алгоритмы сортировки Merge Sort и Quick Sort построены на рекурсивном разбиении массива (divide and conquer). Merge Sort рекурсивно делит массив пополам и сливает отсортированные половины. Quick Sort рекурсивно разбивает массив вокруг pivot-элемента. Анализ сложности этих алгоритмов через Master Theorem требует понимания глубины рекурсии и количества работы на каждом уровне. Рекурсию стоит изучить до сортировок.

**[[trees-binary]]** — обход деревьев по определению рекурсивен, поскольку дерево — рекурсивная структура данных (узел содержит поддеревья, которые сами являются деревьями). Три классических обхода (preorder, inorder, postorder) — это варианты рекурсивного DFS. Практически любая задача на деревья решается рекурсией: высота дерева, проверка BST, поиск LCA. Деревья — лучший практический контекст для закрепления навыков рекурсии.

---

## Источники

### Педагогика и методология
- [PD4CS - Recursion Misconceptions](https://www.pd4cs.org/recursion-misconceptions-and-challenges/) — типичные ошибки студентов
- [How NOT to Teach Recursion](https://parentheticallyspeaking.org/articles/how-not-to-teach-recursion/) — критика классических примеров
- [Teaching Recursion - Shashi Krishna](https://xn--wgiaa.ws/3-teaching-recursion) — педагогические подходы
- [freeCodeCamp - Recursion is not hard](https://www.freecodecamp.org/news/recursion-is-not-hard-858a48830d83/) — step-by-step walkthrough

### Аналогии и ментальные модели
- [mathspp - Recursion Analogies](https://mathspp.com/blog/twitter-threads/recursion-analogies) — time-travelling, programming buddy, tunnels
- [Recursion in Real Life](https://abetterscientist.wordpress.com/2018/10/07/recursion-in-real-life/) — реальные примеры
- [Byte by Byte - Understanding Recursion](https://www.byte-by-byte.com/understanding-recursion/) — практические примеры

### Книги
- **Abelson & Sussman (1996). "Structure and Interpretation of Computer Programs (SICP)."** — рекурсия как фундаментальный строительный блок программирования; книга учит думать рекурсивно через Scheme/Lisp, раскрывая связь рекурсии с математической индукцией и абстракцией
- **Cormen, Leiserson, Rivest & Stein (2009). "Introduction to Algorithms (CLRS)."** — формальное изложение divide and conquer и рекурсивных алгоритмов; Master Theorem для анализа рекуррентных соотношений; главы по Merge Sort, Quick Sort и рекурсивным структурам данных
- **Roberts (1986). "Thinking Recursively."** — классическая книга, целиком посвящённая развитию рекурсивного мышления; множество примеров от простых к сложным, включая backtracking и рекурсивные структуры данных

### Технические ресурсы
- [Tech Interview Handbook - Recursion](https://www.techinterviewhandbook.org/algorithms/recursion/) — cheatsheet для интервью
- [VisuAlgo - Recursion Visualization](https://visualgo.net/en/recursion) — визуализация
- [Wikipedia - Tail Call](https://en.wikipedia.org/wiki/Tail_call) — TCO

---

## Навигация

← Предыдущая: [[searching-algorithms|Searching Algorithms]]
→ Следующая: [[dynamic-programming|Dynamic Programming]]
↑ Вверх: [[_moc-algorithms|Algorithms MOC]]

---

*Обновлено: 2026-01-06*
*Тип: Учебник (70% текст / 30% код)*
