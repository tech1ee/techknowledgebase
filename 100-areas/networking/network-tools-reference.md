---
title: "Network Tools Reference"
created: 2025-12-26
modified: 2025-12-26
type: reference
status: published
level: middle
tags:
  - topic/networking
  - tools
  - cli
  - debugging
  - reference
  - type/reference
  - level/intermediate
---

# Network Tools Reference

> Справочник инструментов сетевой диагностики для разработчиков и DevOps

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **Сетевые основы** | Понимание IP, DNS, TCP | [[network-fundamentals-for-developers]] |
| **Debugging basics** | Системный подход к диагностике | [[network-debugging-basics]] |
| **Командная строка** | Linux/macOS терминал | Bash basics |

### Для кого этот материал

| Уровень | Подходит? | Рекомендация |
|---------|-----------|--------------|
| **Новичок** | ✅ Да | Начни с ping, curl, dig |
| **Intermediate** | ✅ Да | Основная аудитория |
| **Advanced** | ✅ Да | tcpdump, Wireshark |

### Терминология для новичков

> 💡 **Network Tools** = набор утилит для диагностики "что не так с сетью". Как набор инструментов механика.

| Термин | Значение | Аналогия для новичка |
|--------|----------|---------------------|
| **ping** | Проверка доступности хоста | **"Алло, ты слышишь?"** |
| **traceroute** | Показывает путь пакетов | **GPS-маршрут** — через что едем |
| **dig** | DNS-запросы | **Справочник** — IP по имени |
| **curl** | HTTP-запросы из консоли | **Тестовый звонок** — что ответит сервер |
| **netstat/ss** | Список соединений | **Журнал звонков** — кто с кем |
| **tcpdump** | Захват пакетов | **Диктофон** — записать разговор |
| **Wireshark** | Анализ пакетов с GUI | **Студия звукозаписи** — детальный разбор |
| **nmap** | Сканер портов | **Проверка дверей** — что открыто |
| **mtr** | ping + traceroute | **Полный GPS-трекинг** — в реальном времени |
| **nc (netcat)** | TCP/UDP соединения | **Универсальный телефон** — позвонить куда угодно |

---

## Часть 1: Интуиция без кода — Как думать о сетевых инструментах

> **Цель:** Понять философию сетевых инструментов через метафоры из повседневной жизни. Как опытный сантехник знает, какой ключ достать для какой трубы — так и опытный инженер знает, какой инструмент запустить для какой проблемы.

### Аналогия 1: Набор инструментов как медицинский осмотр

```
ВРАЧ ПРОВОДИТ ОСМОТР ПАЦИЕНТА:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  1. "Вы живы?" → ping                                           │
│     Базовая проверка: пациент реагирует на раздражители?        │
│     ping → "Хост доступен? Отвечает на ICMP?"                   │
│                                                                 │
│  2. "Где болит?" → traceroute/mtr                               │
│     Локализация: в каком месте проблема?                        │
│     traceroute → "На каком hop теряются пакеты?"                │
│                                                                 │
│  3. "Органы работают?" → ss/netstat                             │
│     Проверка систем: все ли сервисы функционируют?              │
│     ss -tulnp → "Какие порты слушают? Какие процессы?"          │
│                                                                 │
│  4. "Анализ крови" → dig                                        │
│     Лабораторный тест: DNS возвращает правильные данные?        │
│     dig → "Какой IP у домена? Правильные ли NS?"                │
│                                                                 │
│  5. "Рентген / МРТ" → tcpdump/Wireshark                         │
│     Глубокое сканирование: что происходит внутри?               │
│     tcpdump → "Какие пакеты идут? Что в них?"                   │
│                                                                 │
│  Врач НЕ начинает с МРТ, если достаточно пощупать пульс!        │
│  Инженер НЕ запускает tcpdump, если достаточно ping!            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Почему это важно:** Как врач следует протоколу осмотра (от простого к сложному), так и сетевая диагностика идёт по уровням: сначала ping (L3), потом nc/telnet (L4), потом curl (L7). Запуск tcpdump для проверки "работает ли сайт" — как отправка пациента на МРТ вместо измерения температуры.

### Аналогия 2: OSI как этажи здания

```
ЗДАНИЕ С ЭТАЖАМИ = СЕТЕВОЙ СТЕК:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   7 этаж  │ ПЕНТХАУС    │ curl, httpie, wget                    │
│   (L7)    │ Приложения  │ "Работает ли API? Какой HTTP-код?"    │
│           │             │                                       │
│   ─────────────────────────────────────────────────────────     │
│                                                                 │
│   4 этаж  │ ОФИСЫ       │ nc, telnet, ss, lsof                  │
│   (L4)    │ Транспорт   │ "Порт открыт? Сервис слушает?"        │
│           │             │                                       │
│   ─────────────────────────────────────────────────────────     │
│                                                                 │
│   DNS     │ РЕСЕПШЕН    │ dig, nslookup, host                   │
│   (L7/L3) │ Справочная  │ "Какой IP у этого имени?"             │
│           │             │                                       │
│   ─────────────────────────────────────────────────────────     │
│                                                                 │
│   3 этаж  │ ЛОББИ       │ ping, traceroute, mtr                 │
│   (L3)    │ Сеть        │ "Можно ли дойти до здания?"           │
│           │             │                                       │
│   ─────────────────────────────────────────────────────────     │
│                                                                 │
│   ПОДВАЛ  │ ФУНДАМЕНТ   │ tcpdump, Wireshark                    │
│   (L2-L7) │ Всё видно   │ "Что именно происходит внутри?"       │
│                                                                 │
│   ПРАВИЛО: Если не можете войти в здание (L3 не работает),      │
│   бесполезно проверять работу офисов (L7)!                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Почему это важно:** Если ping не проходит (не можете войти в здание), проверять curl (работу офисов) бессмысленно. Всегда начинайте с нижних уровней и поднимайтесь вверх.

### Аналогия 3: Три типа "телефонных звонков"

```
ТРИ РЕЗУЛЬТАТА ЗВОНКА = ТРИ РЕЗУЛЬТАТА nc -zv:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  📞 ГУДКИ → ОТВЕТ                                               │
│  "Connection succeeded"                                         │
│  ├── Телефон существует                                         │
│  ├── Человек дома                                               │
│  └── Он взял трубку                                             │
│  → Порт открыт, сервис слушает, готов к работе                  │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  📞 ГУДКИ → "НОМЕР НЕ СУЩЕСТВУЕТ"                               │
│  "Connection refused"                                           │
│  ├── Телефонная сеть работает                                   │
│  ├── Адрес существует                                           │
│  └── Но никто не отвечает на этот номер                         │
│  → Хост доступен, но порт закрыт (никто не слушает)             │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  📞 ТИШИНА... ТИШИНА... TIMEOUT                                 │
│  "Connection timed out"                                         │
│  ├── Либо телефонная сеть не работает                           │
│  ├── Либо адрес неправильный                                    │
│  └── Либо кто-то обрезал провода (firewall DROP)                │
│  → Пакеты не доходят или firewall молча отбрасывает             │
│                                                                 │
│  ВАЖНО: "refused" — хорошо (хост жив), "timeout" — плохо!       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Почему это важно:** "Connection refused" часто воспринимается как ошибка, но это хороший знак — хост доступен, просто сервис не запущен. "Timeout" — серьёзнее: проблема на сетевом уровне или firewall.

### Аналогия 4: dig как справочник с историей запросов

```
DNS = ТЕЛЕФОННЫЙ СПРАВОЧНИК С ДОВЕРИЕМ:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  ВЫ СПРАШИВАЕТЕ НОМЕР ТЕЛЕФОНА КОМПАНИИ:                        │
│                                                                 │
│  1. Местная справочная (resolver) → dig google.com              │
│     "Какой номер у Google?"                                     │
│     Ответ может быть из кэша (старый) или свежий                │
│                                                                 │
│  2. Городская справочная (@8.8.8.8) → dig @8.8.8.8 google.com   │
│     Спросить другую справочную (другой DNS-сервер)              │
│     Полезно, когда локальный DNS врёт или устарел               │
│                                                                 │
│  3. Офис самой компании (+trace) → dig +trace google.com        │
│     Пройти всю цепочку: root → .com → google.com                │
│     Как позвонить в головной офис напрямую                      │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  ЧТО МОЖНО СПРОСИТЬ:                                            │
│                                                                 │
│  dig google.com A      → "Какой IP-адрес?"                      │
│  dig google.com MX     → "Куда слать почту?"                    │
│  dig google.com NS     → "Кто авторитетный источник?"           │
│  dig google.com TXT    → "Есть ли SPF/DKIM для почты?"          │
│                                                                 │
│  TTL (3600) = "Эта информация актуальна ещё 1 час"              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Почему это важно:** Проблемы с DNS — одни из самых коварных. Сервер работает, но пользователи не могут подключиться, потому что DNS возвращает старый IP. dig позволяет проверить, что именно возвращает DNS.

### Аналогия 5: tcpdump/Wireshark как камера видеонаблюдения

```
PACKET CAPTURE = ЗАПИСЬ С КАМЕРЫ:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  tcpdump = КАМЕРА НА ВХОДЕ В ОФИС                               │
│                                                                 │
│  ┌────────────────────────────────────────────────────────┐     │
│  │ 10:15:32  │ Иванов │ вошёл   │ пропуск #1234          │     │
│  │ 10:15:33  │ Иванов │ → этаж 3│ лифт                   │     │
│  │ 10:15:45  │ Петров │ вошёл   │ пропуск #5678          │     │
│  │ 10:15:46  │ Петров │ ОТКАЗ   │ пропуск истёк!         │     │
│  │ 10:16:01  │ Иванов │ вышел   │ этаж 3 → выход         │     │
│  └────────────────────────────────────────────────────────┘     │
│                                                                 │
│  tcpdump записывает КАЖДЫЙ пакет:                               │
│  - Кто отправил (src IP)                                        │
│  - Кому отправил (dst IP)                                       │
│  - Какой протокол (TCP/UDP)                                     │
│  - Что внутри (payload, если не шифровано)                      │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  Wireshark = ПРОСМОТР ЗАПИСИ В СТУДИИ                           │
│                                                                 │
│  - Можно перемотать                                             │
│  - Можно увеличить                                              │
│  - Можно отфильтровать "только Петров"                          │
│  - Можно проследить весь путь одного человека                   │
│                                                                 │
│  КОГДА ИСПОЛЬЗОВАТЬ:                                            │
│  - Когда простые инструменты не дают ответа                     │
│  - Когда нужно ДОКАЗАТЬ, что проблема не на вашей стороне       │
│  - Когда происходит что-то странное с TCP                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Почему это важно:** tcpdump — последний рубеж диагностики. Он показывает реальность: какие пакеты приходят и уходят. Но это как смотреть запись с камеры за неделю — без фильтров утонете в данных.

---

## Часть 2: Почему это сложно — Типичные ошибки при работе с сетевыми инструментами

> **Цель:** Научиться распознавать паттерны ошибок, которые совершают даже опытные инженеры. Каждая ошибка — это потерянные часы диагностики.

### Ошибка 1: "Ping не работает = сервер не работает"

**СИМПТОМ:**
```
$ ping server.company.com
PING server.company.com (10.0.1.50): 56 data bytes
Request timeout for icmp_seq 0
Request timeout for icmp_seq 1
^C

"Сервер мёртв, вызываем DevOps!"
```

**РЕШЕНИЕ:**
```bash
# ICMP заблокирован, но TCP может работать!

# Проверить порт напрямую
$ nc -zv server.company.com 443
Connection to server.company.com port 443 [tcp/https] succeeded!

# Или curl
$ curl -I https://server.company.com
HTTP/2 200

# Сервер РАБОТАЕТ, просто firewall блокирует ICMP
```

**Правило:** ping не работает → проверьте конкретный порт через nc или curl. Многие production-серверы намеренно блокируют ICMP.

### Ошибка 2: Забыть про DNS-кэширование

**СИМПТОМ:**
```bash
# Обновили DNS-запись 5 минут назад
$ dig mysite.com +short
93.184.216.34   # Старый IP!

"DNS не обновился, хостинг сломан!"
```

**РЕШЕНИЕ:**
```bash
# Проверить через разные DNS-серверы
$ dig @8.8.8.8 mysite.com +short      # Google DNS
192.0.2.100   # Новый IP ✓

$ dig @1.1.1.1 mysite.com +short      # Cloudflare DNS
192.0.2.100   # Новый IP ✓

# Проверить TTL у текущей записи
$ dig mysite.com | grep -A1 "ANSWER SECTION"
mysite.com.    1800    IN    A    93.184.216.34
#              ^^^^
#              TTL = 1800 сек = 30 минут до обновления

# Локальный кэш можно очистить
$ sudo dscacheutil -flushcache    # macOS
$ sudo systemd-resolve --flush-caches  # Linux systemd
```

**Правило:** Всегда проверяйте DNS через несколько серверов и смотрите TTL. Распространение DNS может занять от минут до суток.

### Ошибка 3: Использовать netstat вместо ss

**СИМПТОМ:**
```bash
# На сервере с 50,000 соединений
$ netstat -tulnp
# ... ждёте 30+ секунд ...
# ... система тормозит ...
# ... netstat парсит /proc/net/* построчно ...
```

**РЕШЕНИЕ:**
```bash
# ss использует netlink API — моментальный результат
$ ss -tulnp
# Результат за миллисекунды

# Мощные фильтры ss
$ ss -t state established '( sport = :443 )'
$ ss -t state time-wait | wc -l

# netstat официально deprecated в Linux
# Но остаётся на macOS и Windows
```

**Правило:** На Linux используйте ss, не netstat. На серверах с большим количеством соединений разница — секунды vs минуты.

### Ошибка 4: tcpdump захватывает свой же SSH-трафик

**СИМПТОМ:**
```bash
# Подключились по SSH и запустили tcpdump
$ sudo tcpdump -i eth0
# ЛАВИНА пакетов, экран мелькает
# Большинство — это ваш SSH!
```

**РЕШЕНИЕ:**
```bash
# ВСЕГДА исключайте SSH при удалённой диагностике
$ sudo tcpdump -i eth0 'not port 22'

# Или захватывайте только нужный трафик
$ sudo tcpdump -i eth0 'port 80 or port 443'

# Записывать в файл, не выводить на экран
$ sudo tcpdump -i eth0 'not port 22' -w capture.pcap -c 1000
# Потом скопировать и анализировать локально
```

**Правило:** При tcpdump через SSH всегда добавляйте `not port 22`. Лучше записывать в файл и анализировать в Wireshark.

### Ошибка 5: curl без -L не следует редиректам

**СИМПТОМ:**
```bash
$ curl http://example.com
# Пустой ответ или HTML с редиректом

$ curl -I http://example.com
HTTP/1.1 301 Moved Permanently
Location: https://example.com/

"Сервер возвращает пустоту!"
```

**РЕШЕНИЕ:**
```bash
# -L = следовать редиректам
$ curl -L http://example.com
# Получаем контент с https://example.com/

# Увидеть цепочку редиректов
$ curl -L -v http://example.com 2>&1 | grep -E '^< HTTP|^< Location'
< HTTP/1.1 301 Moved Permanently
< Location: https://example.com/
< HTTP/2 200

# Для API-тестирования часто нужно видеть редирект
$ curl -i http://example.com  # покажет заголовки
```

**Правило:** По умолчанию curl НЕ следует редиректам. Для веб-страниц всегда используйте `-L`. Для API — зависит от того, что тестируете.

### Ошибка 6: nmap без понимания результатов

**СИМПТОМ:**
```bash
$ nmap target.com
PORT     STATE    SERVICE
22/tcp   open     ssh
80/tcp   filtered http   # ← Что это значит?
443/tcp  open     https

"Порт 80 filtered = сломан?"
```

**РЕШЕНИЕ:**
```bash
# СОСТОЯНИЯ ПОРТОВ:
# open     = сервис слушает, готов к работе
# closed   = порт доступен, но никто не слушает
# filtered = firewall блокирует (DROP, не REJECT)

# filtered НЕ означает "сломан"!
# Это значит, что firewall не пропускает сканирование

# Попробовать другой тип сканирования
$ nmap -sT target.com    # TCP connect (медленнее, но надёжнее)
$ nmap -Pn target.com    # Без ping-проверки

# Или проверить напрямую
$ nc -zv target.com 80
Connection to target.com 80 port [tcp/http] succeeded!
# Порт открыт! nmap показал filtered из-за защиты от сканирования
```

**Правило:** `filtered` означает, что firewall скрывает состояние порта. Это не ошибка, а защита. Проверяйте конкретные порты через nc.

---

## Часть 3: Ментальные модели для работы с сетевыми инструментами

> **Цель:** Сформировать устойчивые паттерны мышления, которые помогут выбрать правильный инструмент за секунды, а не минуты.

### Модель 1: "Воронка детализации"

```
ВОРОНКА: ОТ ОБЩЕГО К ЧАСТНОМУ
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│                      ┌─────────────────┐                        │
│                      │      ping       │  Быстро, грубо         │
│                      │   "Жив/мёртв?"  │  1 секунда             │
│                      └────────┬────────┘                        │
│                               │                                 │
│                      ┌────────▼────────┐                        │
│                      │   traceroute    │  Путь до цели          │
│                      │  "Где теряем?"  │  10 секунд             │
│                      └────────┬────────┘                        │
│                               │                                 │
│                      ┌────────▼────────┐                        │
│                      │    nc / curl    │  Конкретный порт       │
│                      │ "Порт открыт?"  │  1-5 секунд            │
│                      └────────┬────────┘                        │
│                               │                                 │
│                      ┌────────▼────────┐                        │
│                      │   curl -v       │  HTTP детали           │
│                      │ "Что в ответе?" │  1-5 секунд            │
│                      └────────┬────────┘                        │
│                               │                                 │
│                      ┌────────▼────────┐                        │
│                      │    tcpdump      │  Каждый пакет          │
│                      │  "Что внутри?"  │  Минуты анализа        │
│                      └─────────────────┘                        │
│                                                                 │
│  ПРАВИЛО: Не прыгайте на tcpdump, пока curl не сказал своё!     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Применение:** Каждый уровень воронки требует больше времени и экспертизы. Если ping решает проблему — зачем запускать Wireshark?

### Модель 2: "Вопрос определяет инструмент"

```
ДЕРЕВО РЕШЕНИЙ: КАКОЙ ИНСТРУМЕНТ?
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  "Какой у меня вопрос?"                                         │
│         │                                                       │
│         ├─► "Хост жив?" ─────────────────► ping                 │
│         │                                                       │
│         ├─► "Где теряются пакеты?" ──────► mtr / traceroute     │
│         │                                                       │
│         ├─► "Порт открыт?" ──────────────► nc -zv               │
│         │                                                       │
│         ├─► "Что слушает локально?" ─────► ss -tulnp            │
│         │                                                       │
│         ├─► "Какой IP у домена?" ────────► dig +short           │
│         │                                                       │
│         ├─► "Почему DNS не обновился?" ──► dig @8.8.8.8 +trace  │
│         │                                                       │
│         ├─► "Что возвращает API?" ───────► curl -v              │
│         │                                                       │
│         ├─► "Сертификат валидный?" ──────► openssl s_client     │
│         │                                                       │
│         ├─► "Что происходит на wire?" ───► tcpdump / Wireshark  │
│         │                                                       │
│         └─► "Какая пропускная способность?"─► iperf3            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Применение:** Сформулируйте вопрос ПЕРЕД запуском инструмента. "Сайт не работает" — это не вопрос. "Хост доступен?" — это вопрос.

### Модель 3: "Три точки наблюдения"

```
ДИАГНОСТИКА С ТРЁХ ПОЗИЦИЙ:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   КЛИЕНТ              СЕТЬ              СЕРВЕР                  │
│   ┌─────┐         ┌─────────┐          ┌─────┐                  │
│   │ 👤  │ ──────► │ ≈≈≈≈≈≈≈ │ ───────► │ 🖥️  │                  │
│   └─────┘         └─────────┘          └─────┘                  │
│      │                 │                   │                    │
│      ▼                 ▼                   ▼                    │
│   curl -v          mtr/traceroute      ss -tulnp                │
│   ping             tcpdump на          tcpdump на               │
│   dig              роутере             сервере                  │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  ВОПРОСЫ ДЛЯ КАЖДОЙ ТОЧКИ:                                      │
│                                                                 │
│  КЛИЕНТ:                                                        │
│  • DNS резолвится правильно? → dig                              │
│  • Пакеты уходят? → ping, curl                                  │
│  • Локальный firewall блокирует? → iptables -L                  │
│                                                                 │
│  СЕТЬ:                                                          │
│  • Где теряются пакеты? → mtr                                   │
│  • Какой hop добавляет latency? → traceroute                    │
│  • MTU проблемы? → ping -s 1472 -M do                           │
│                                                                 │
│  СЕРВЕР:                                                        │
│  • Сервис запущен? → ss -tulnp | grep PORT                      │
│  • Пакеты доходят? → tcpdump -i any port PORT                   │
│  • Firewall блокирует? → iptables -L                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Применение:** Когда проблема непонятна, проверьте все три точки. Часто проблема становится очевидной, когда видишь: пакеты уходят (клиент ok), mtr чистый (сеть ok), но tcpdump на сервере пуст (firewall!).

### Модель 4: "Время ответа как диагностический сигнал"

```
ЧТО ОЗНАЧАЕТ ВРЕМЯ ОТВЕТА:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  МГНОВЕННО (< 1ms):                                             │
│  • Локальный ответ                                              │
│  • Кэш                                                          │
│  • Loopback (127.0.0.1)                                         │
│                                                                 │
│  БЫСТРО (1-50ms):                                               │
│  • Локальная сеть                                               │
│  • Тот же датацентр                                             │
│  • CDN edge близко                                              │
│                                                                 │
│  СРЕДНЕ (50-200ms):                                             │
│  • Другой регион                                                │
│  • Другой континент                                             │
│  • Нормальный интернет                                          │
│                                                                 │
│  МЕДЛЕННО (200-500ms):                                          │
│  • Противоположная сторона Земли                                │
│  • Спутниковая связь                                            │
│  • Перегруженная сеть                                           │
│                                                                 │
│  ОЧЕНЬ МЕДЛЕННО (> 500ms):                                      │
│  • Проблема! (для интернета)                                    │
│  • Packet loss и retransmissions                                │
│  • Перегрузка на узлах                                          │
│                                                                 │
│  TIMEOUT (> 5-30s):                                             │
│  • Firewall DROP (не REJECT)                                    │
│  • Маршрут не существует                                        │
│  • Сервер перегружен                                            │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  curl -w "DNS: %{time_namelookup}s | Connect: %{time_connect}s  │
│  | TLS: %{time_appconnect}s | TTFB: %{time_starttransfer}s      │
│  | Total: %{time_total}s\n" -o /dev/null -s https://example.com │
│                                                                 │
│  DNS:    медленный → проблема с DNS-сервером                    │
│  Connect: медленный → сетевая задержка                          │
│  TLS:    медленный → проблема с handshake                       │
│  TTFB:   медленный → сервер долго обрабатывает                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Применение:** Время ответа — это первая подсказка. 1ms ping означает локальную сеть. 200ms — другой континент. 5s timeout — firewall или проблема маршрутизации.

### Модель 5: "Toolchain для типовых сценариев"

```
ГОТОВЫЕ ЦЕПОЧКИ ИНСТРУМЕНТОВ:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  СЦЕНАРИЙ: "Сайт не открывается"                                │
│  ─────────────────────────────────────────────────────────────  │
│  1. dig site.com +short     → Правильный ли IP?                 │
│  2. ping IP                 → Хост доступен?                    │
│  3. nc -zv IP 443           → Порт открыт?                      │
│  4. curl -Lv https://site   → Что отвечает HTTP?                │
│  5. openssl s_client        → Сертификат валиден?               │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  СЦЕНАРИЙ: "API отвечает медленно"                              │
│  ─────────────────────────────────────────────────────────────  │
│  1. curl -w "timing..." API → Где именно медленно?              │
│  2. mtr api.server.com      → Сеть или сервер?                  │
│  3. tcpdump + Wireshark     → Retransmissions? Slow start?      │
│  4. iperf3                  → Bandwidth ограничен?              │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  СЦЕНАРИЙ: "Сервис не запускается — порт занят"                 │
│  ─────────────────────────────────────────────────────────────  │
│  1. ss -tulnp | grep PORT   → Кто слушает?                      │
│  2. lsof -i :PORT           → Какой процесс?                    │
│  3. ps aux | grep PID       → Что это за процесс?               │
│  4. kill PID или изменить порт                                  │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  СЦЕНАРИЙ: "Изменили DNS, но старый IP"                         │
│  ─────────────────────────────────────────────────────────────  │
│  1. dig @8.8.8.8 domain     → Google видит новый IP?            │
│  2. dig @1.1.1.1 domain     → Cloudflare видит?                 │
│  3. dig domain +trace       → Авторитативный NS отдаёт что?     │
│  4. dig domain | grep TTL   → Когда истечёт кэш?                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Применение:** Не изобретайте велосипед. Для каждого типового сценария есть проверенная последовательность инструментов. Выучите их наизусть.

---

## Как пользоваться этим справочником

### Философия выбора инструмента

Этот справочник — не просто список команд, а **руководство по выбору правильного инструмента для конкретной задачи**. Ошибка новичка — знать один-два инструмента и использовать их для всего. Опытный инженер выбирает инструмент под задачу.

**Три вопроса перед выбором инструмента:**
1. **На каком уровне проблема?** Физический, сетевой, транспортный, прикладной?
2. **Что конкретно нужно узнать?** Доступность хоста? Открытость порта? Содержимое пакетов?
3. **Какой уровень детализации нужен?** Быстрая проверка или глубокий анализ?

**Принцип минимально достаточного инструмента.** Не запускайте Wireshark, чтобы проверить доступность хоста — для этого есть ping. Не используйте tcpdump, чтобы проверить HTTP-заголовки — curl -v справится за секунду. Сложные инструменты оправданы, когда простые не дают ответа.

**Когда использовать этот справочник:**
- Вы знаете, что нужно сделать, но забыли синтаксис команды
- Вы хотите освоить новый инструмент — здесь есть примеры от простого к сложному
- Вы застряли в диагностике и хотите посмотреть, какие ещё инструменты есть

## Карта инструментов

**Зачем нужна карта.** Инструменты организованы по уровням OSI модели. Это не случайно — при диагностике вы идёте снизу вверх: сначала проверяете связность (L3), потом порты (L4), потом приложение (L7). Карта помогает быстро найти нужный инструмент для нужного уровня.

```
┌─────────────────────────────────────────────────────────────────────┐
│                          APPLICATION LAYER                          │
│  curl, httpie, wget │ HTTP/API testing                              │
│  openssl s_client   │ TLS/SSL debugging                             │
├─────────────────────────────────────────────────────────────────────┤
│                          TRANSPORT LAYER                            │
│  nc/netcat, telnet  │ Port testing, raw connections                 │
│  ss, netstat, lsof  │ Connection monitoring                         │
├─────────────────────────────────────────────────────────────────────┤
│                           NETWORK LAYER                             │
│  ping, mtr, traceroute │ Connectivity & path                        │
│  nmap                  │ Port scanning & discovery                  │
├─────────────────────────────────────────────────────────────────────┤
│                           DNS LAYER                                 │
│  dig, nslookup, host │ DNS queries & debugging                      │
├─────────────────────────────────────────────────────────────────────┤
│                       PACKET ANALYSIS                               │
│  tcpdump, tshark     │ CLI packet capture                           │
│  Wireshark           │ GUI packet analysis                          │
├─────────────────────────────────────────────────────────────────────┤
│                        PERFORMANCE                                  │
│  iperf3              │ Bandwidth testing                            │
│  ab, wrk, hey        │ HTTP load testing                            │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Connectivity Testing

### Когда нужна проверка связности

**Это первый шаг любой диагностики.** Прежде чем искать проблемы в приложении, убедитесь, что сетевое соединение вообще работает. Инструменты этого раздела отвечают на базовые вопросы: "Хост доступен?", "Где теряются пакеты?", "Какова задержка?".

**Что проверяем на этом уровне:**
- Физическая связность (кабель, Wi-Fi)
- IP-маршрутизация (пакеты доходят до назначения)
- Базовая сетевая производительность (RTT, packet loss)

**Типичные сценарии использования:**
- Сервер перестал отвечать — ping покажет, доступен ли он вообще
- Сеть "тормозит" — mtr покажет, где именно проблема
- Подключение к новому серверу не работает — traceroute покажет путь и где он обрывается

### ping — ваш первый инструмент

**Назначение:** Проверка доступности хоста через ICMP echo request/reply

**Когда использовать.** Ping — первый инструмент при любой сетевой проблеме. Он быстрый (результат за секунду), простой, и сразу показывает: хост доступен или нет.

**Что ping проверяет на самом деле.** Ping использует протокол ICMP (Internet Control Message Protocol) на уровне IP. Он не проверяет порты, не проверяет приложения — только базовую IP-доступность. Успешный ping означает: пакеты доходят и хост отвечает на ICMP.

**Важное ограничение.** Многие серверы и firewall'ы блокируют ICMP из соображений безопасности. Если ping не проходит — это НЕ означает, что сервер недоступен. Веб-сервер может прекрасно работать на порту 443, но не отвечать на ping. Поэтому если ping не работает, переходите к telnet/nc для проверки конкретного порта.

```bash
# Базовый ping
ping example.com

# Ограничить количество пакетов
ping -c 4 example.com

# Ping с указанием интервала (0.2 сек)
ping -i 0.2 example.com

# Ping с размером пакета 1500 байт
ping -s 1500 example.com

# Ping конкретного IP (обходит DNS)
ping 8.8.8.8
```

**Флаги:**
| Флаг | Описание |
|------|----------|
| `-c N` | Количество пакетов |
| `-i N` | Интервал между пакетами (сек) |
| `-s N` | Размер пакета (байт) |
| `-W N` | Timeout ожидания ответа |
| `-f` | Flood ping (требует root) |

**Что означают результаты:**
```
PING example.com (93.184.216.34): 56 data bytes
64 bytes from 93.184.216.34: icmp_seq=0 ttl=56 time=11.632 ms
64 bytes from 93.184.216.34: icmp_seq=1 ttl=56 time=11.726 ms

--- example.com ping statistics ---
2 packets transmitted, 2 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 11.632/11.679/11.726/0.047 ms
```

- **ttl** — Time To Live (сколько хопов осталось)
- **time** — Round-Trip Time
- **packet loss** — процент потерянных пакетов

> **Важно:** Многие серверы блокируют ICMP. Нет ответа ping ≠ сервер недоступен.

---

### traceroute / tracert — карта пути через интернет

**Назначение:** Показать все маршрутизаторы (hops) на пути до destination

**Когда использовать.** Ping показал высокую latency или packet loss? Traceroute покажет, какой именно узел на пути виноват. Это необходимо для диагностики проблем, которые находятся не на вашей стороне и не на стороне сервера, а где-то между.

**Как это работает технически.** Traceroute использует умный трюк с TTL (Time To Live). Каждый IP-пакет имеет TTL — счётчик, который уменьшается на 1 на каждом маршрутизаторе. Когда TTL становится 0, маршрутизатор отправляет ICMP Time Exceeded обратно. Traceroute отправляет пакеты с TTL=1, TTL=2, TTL=3... и получает ответы от каждого маршрутизатора на пути.

**Почему иногда видно `* * *`.** Это означает, что hop не ответил в отведённое время. Причины: маршрутизатор не отправляет ICMP Time Exceeded (экономия CPU), ICMP заблокирован, или rate limiting. Если `* * *` на промежуточных hops, но финальный хост отвечает — проблемы нет, это нормальное поведение.

**traceroute vs tracert.** traceroute — Unix/Linux (использует UDP по умолчанию), tracert — Windows (использует ICMP). На практике результат одинаковый, но иногда UDP проходит через firewall'ы лучше чем ICMP или наоборот. На Linux можно использовать `-T` для TCP или `-I` для ICMP.

```bash
# Linux/macOS
traceroute example.com

# Windows
tracert example.com

# Использовать TCP вместо ICMP (обходит некоторые firewall)
traceroute -T example.com

# Использовать конкретный порт
traceroute -p 443 example.com
```

**Как читать:**
```
traceroute to example.com (93.184.216.34), 30 hops max
 1  router.local (192.168.1.1)  1.234 ms  1.123 ms  1.089 ms
 2  isp-gw.net (10.0.0.1)  12.456 ms  11.234 ms  12.789 ms
 3  * * *
 4  target.com (93.184.216.34)  45.678 ms  44.321 ms  45.012 ms
```

- Три значения — три probe пакета
- `* * *` — hop не отвечает (ICMP blocked или timeout)
- Резкий скачок времени — возможная проблема на этом участке

---

### mtr (My TraceRoute) — traceroute на стероидах

**Назначение:** Комбинация traceroute и непрерывного ping — показывает путь И статистику quality of connection

**Почему MTR лучше traceroute.** Обычный traceroute — это одномоментный снимок. Если проблема intermittent (иногда появляется, иногда нет), один traceroute её не покажет. MTR работает непрерывно, собирая статистику packet loss и latency на каждом hop. Это критически важно для диагностики "плавающих" проблем.

**Когда использовать.**
- "Связь иногда обрывается" — запустите MTR на несколько минут
- "Интернет тормозит" — MTR покажет, какой hop добавляет latency
- "Нужно доказать провайдеру, что проблема на их стороне" — MTR report с 100+ пакетами

**Как правильно читать результаты.** Самая частая ошибка — видеть packet loss на промежуточном hop и думать, что это проблема. Маршрутизаторы часто применяют ICMP rate limiting — они сами работают нормально, но не отвечают на все ICMP-пакеты. Правило: проблема только если loss продолжается до конечного хоста. Если hop 3 показывает 20% loss, но hop 4, 5 и destination показывают 0% — hop 3 просто rate limits ICMP.

**Killer feature: report mode.** `mtr -r -c 100` — запускает 100 циклов и выдаёт отчёт, который можно отправить в support провайдера или хостинга. Это стандартный формат для диагностики сетевых проблем между организациями.

```bash
# Интерактивный режим
mtr example.com

# Report mode (для отправки в support)
mtr -r -c 100 example.com

# JSON output
mtr -j example.com

# UDP mode
mtr -u example.com

# TCP mode на конкретный порт
mtr -T -P 443 example.com
```

**Флаги:**
| Флаг | Описание |
|------|----------|
| `-r` | Report mode (не интерактивный) |
| `-c N` | Количество пинг-циклов |
| `-n` | Не резолвить имена (быстрее) |
| `-T` | TCP mode |
| `-u` | UDP mode |
| `-P N` | Порт для TCP/UDP |

**Интерпретация результатов:**
```
                             Packets               Pings
Host                       Loss%   Snt   Last   Avg  Best  Wrst StDev
1. router.local             0.0%   100    1.2   1.4   0.9   3.1   0.3
2. isp-gw.net               5.0%   100   12.3  13.8  10.2  45.4   5.2
3. backbone.net             0.0%   100   25.1  24.8  22.1  32.3   2.1
4. target.com               0.0%   100   45.2  44.8  42.1  52.3   2.4
```

> **Правило:** Loss на промежуточном hop без loss на последующих — не проблема (ICMP rate limiting). Проблема только если loss продолжается до конца.

---

## Port Testing

### Зачем проверять порты

**Переход от сетевого уровня к транспортному.** Ping и traceroute работают на уровне IP — они показывают, что пакеты доходят до хоста. Но это не гарантирует, что сервис работает. Для этого нужно проверить: может ли клиент установить TCP-соединение на конкретный порт?

**Что означает "порт открыт".** Когда вы слышите "порт 80 открыт", это значит: на этом хосте есть процесс, который слушает (listen) на порту 80 и готов принимать TCP-соединения. Если порт "закрыт" — либо процесс не запущен, либо слушает на другом порту, либо firewall блокирует.

**Три возможных результата:**
- **Соединение установлено** — порт открыт, сервис готов
- **Connection refused** — хост получил пакет, но порт закрыт (сервис не слушает)
- **Timeout** — пакеты не доходят или firewall делает DROP

### nc (netcat) — швейцарский нож сетевой диагностики

**Назначение:** Универсальный инструмент для работы с TCP/UDP — проверка портов, raw connections, передача данных

**Почему netcat, а не telnet.** Telnet — устаревший инструмент для интерактивных терминальных сессий. Netcat создавался специально как универсальный сетевой инструмент. Он может: проверять порты (-z), работать как сервер (-l), сканировать диапазоны, работать с UDP. Telnet не может ничего из этого.

**Когда использовать.**
- "Порт открыт?" — `nc -zv host 443`
- "Какие порты открыты?" — `nc -zv host 1-1000`
- "Нужно отправить raw TCP-данные" — `echo "data" | nc host port`
- "Нужно проверить UDP" — `nc -zuv host 53` (DNS)

**Подводный камень: версии netcat.** Существует несколько реализаций netcat с разным синтаксисом. GNU netcat (netcat-traditional), OpenBSD netcat, ncat (от Nmap). Большинство примеров работают везде, но некоторые флаги могут отличаться. Если команда не работает — проверьте `nc -h` для вашей версии.

```bash
# Проверить TCP порт открыт
nc -zv example.com 443

# Проверить диапазон портов
nc -zv example.com 80-90

# Проверить UDP порт
nc -zvu example.com 53

# Открыть слушающий порт (сервер)
nc -l 8080

# Keep listening после disconnect
nc -k -l 8080

# Отправить HTTP запрос
echo -e "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n" | nc example.com 80

# Передать файл (receiver)
nc -l 9999 > received_file

# Передать файл (sender)
nc target.com 9999 < file_to_send
```

**Флаги:**
| Флаг | Описание |
|------|----------|
| `-z` | Zero-I/O mode (только scan) |
| `-v` | Verbose |
| `-u` | UDP mode |
| `-l` | Listen mode |
| `-k` | Keep listening |
| `-w N` | Timeout в секундах |
| `-p N` | Source port |

**Версии netcat:**
| Система | Пакет | Особенности |
|---------|-------|-------------|
| Ubuntu | netcat-openbsd | `-z` работает |
| CentOS/RHEL | ncat | Часть nmap |
| macOS | nc | BSD version |

---

### telnet

**Назначение:** Старый инструмент для проверки TCP портов

```bash
# Проверить порт (DEPRECATED, лучше nc)
telnet example.com 80

# Интерактивный HTTP запрос
telnet example.com 80
GET / HTTP/1.1
Host: example.com
[Enter][Enter]
```

> **Примечание:** telnet устарел, используйте `nc -zv` для проверки портов.

---

## Connection Monitoring

### Зачем мониторить соединения

**Взгляд с серверной стороны.** Предыдущие инструменты (ping, nc) работают с точки зрения клиента — "могу ли я подключиться?". Инструменты мониторинга соединений отвечают на вопросы с серверной стороны: "кто ко мне подключён?", "какие порты я слушаю?", "какой процесс занял порт 8080?".

**Типичные сценарии:**
- "Почему сервис не стартует?" — скорее всего, порт уже занят другим процессом
- "Кто подключён к моему серверу?" — нужно видеть активные соединения
- "Сервис запущен, но клиенты не могут подключиться" — возможно, сервис слушает на 127.0.0.1 вместо 0.0.0.0
- "Слишком много соединений" — нужно найти источник

### ss (Socket Statistics) — современный стандарт

**Назначение:** Показать все сетевые соединения (TCP, UDP, Unix sockets) и их состояния

**Почему ss, а не netstat.** netstat — классический инструмент, существующий с 1980-х. Но он официально deprecated в современных Linux-дистрибутивах. ss быстрее (особенно на серверах с тысячами соединений), использует современный netlink API вместо парсинга /proc/net/*, и имеет более мощные фильтры.

**Когда использовать.**
- "Что слушает на сервере?" — `ss -tuln`
- "Какой процесс на порту 8080?" — `sudo ss -tulnp | grep 8080`
- "Сколько установленных соединений?" — `ss -t state established | wc -l`
- "Есть ли соединения в неправильных состояниях?" — `ss -t state time-wait`

**Важно понимать колонки Recv-Q и Send-Q.** Это очереди данных на приём и отправку. Для LISTEN-сокета: Recv-Q = текущий backlog (ожидающие accept() соединения), Send-Q = максимальный backlog. Для ESTABLISHED: Recv-Q = данные ожидающие чтения приложением, Send-Q = данные ожидающие отправки. Ненулевые значения при ESTABLISHED могут указывать на проблемы производительности.

```bash
# Все TCP соединения
ss -t

# Все слушающие порты
ss -l

# TCP + UDP, числовые адреса, с процессами
ss -tunp

# Все слушающие TCP/UDP порты с процессами
sudo ss -tulnp

# Найти кто слушает на порту 8080
ss -tulnp | grep 8080

# Показать только ESTABLISHED соединения
ss -t state established

# Показать соединения к конкретному IP
ss -t dst 192.168.1.100

# Показать сокеты с очередью данных
ss -t state established '( recv-q > 0 )'
```

**Флаги:**
| Флаг | Описание |
|------|----------|
| `-t` | TCP |
| `-u` | UDP |
| `-l` | Listening |
| `-n` | Числовые адреса (без DNS) |
| `-p` | Показать процессы (нужен sudo) |
| `-a` | Все состояния |
| `-s` | Статистика |

**Колонки вывода:**
```
State    Recv-Q Send-Q  Local Address:Port   Peer Address:Port   Process
LISTEN   0      128     0.0.0.0:22           0.0.0.0:*           sshd
ESTAB    0      0       192.168.1.5:22       192.168.1.10:54321  sshd: user
```

- **Recv-Q** — данные в буфере ожидающие чтения
- **Send-Q** — данные ожидающие отправки
- Если > 0 при ESTABLISHED — возможная проблема

---

### netstat (Legacy)

**Назначение:** Старая версия ss (deprecated, но есть везде)

```bash
# Все слушающие порты
netstat -tuln

# С процессами
sudo netstat -tulnp

# Статистика по протоколам
netstat -s

# Routing table
netstat -r
```

> **Примечание:** netstat deprecated. Используйте `ss` на Linux.

---

### lsof

**Назначение:** List Open Files — включая сетевые сокеты

```bash
# Кто слушает на порту 8080
sudo lsof -i :8080

# Все сетевые соединения процесса
lsof -i -a -p PID

# Все соединения к конкретному хосту
lsof -i @192.168.1.100

# TCP соединения в состоянии LISTEN
lsof -i TCP -s TCP:LISTEN

# Все IPv4 соединения
lsof -i 4
```

---

## DNS Tools

### Почему DNS — критическая точка диагностики

**Всё начинается с DNS.** Когда пользователь вводит example.com, первое что происходит — DNS-запрос для получения IP-адреса. Если DNS не работает или возвращает неправильный IP — ничего работать не будет, хотя вся остальная инфраструктура в порядке.

**Типичные DNS-проблемы:**
- **Propagation delay** — вы обновили DNS-запись, но изменения ещё не дошли до всех серверов
- **Кэширование** — локальный resolver или browser закэшировал старый IP
- **Неправильный NS** — домен указывает на неработающий name server
- **TTL too high** — при проблемах изменения долго не применяются

**Когда использовать DNS-инструменты:**
- "Сайт не работает, но сервер запущен" — проверьте, на какой IP резолвится домен
- "Изменили DNS, но ничего не изменилось" — проверьте TTL и текущий IP через разные DNS-серверы
- "Email не доходит" — проверьте MX-записи
- "SSL-сертификат не работает" — проверьте, что CAA-запись разрешает вашего CA

### dig — главный инструмент DNS-диагностики

**Назначение:** Детальные DNS-запросы с полным контролем над параметрами

**Почему dig, а не nslookup.** nslookup — устаревший инструмент, который до сих пор есть везде (включая Windows). dig более информативен, гибок, и показывает все детали DNS-ответа. Для разработчиков и DevOps dig — стандарт.

**Killer feature: +trace.** Опция `dig +trace` показывает полный путь резолвинга: от root DNS-серверов через TLD (.com, .org) до авторитативных серверов вашего домена. Это бесценно для диагностики проблем DNS-делегирования.

**Чтение вывода.** dig показывает много информации. Ключевые секции: ANSWER (сам ответ), AUTHORITY (кто авторитетен для домена), ADDITIONAL (дополнительная информация). Число 3600 перед IN A — это TTL в секундах.

```bash
# Базовый запрос
dig example.com

# Только IP (короткий ответ)
dig +short example.com

# Через конкретный DNS сервер
dig @8.8.8.8 example.com

# Конкретный тип записи
dig example.com A        # IPv4
dig example.com AAAA     # IPv6
dig example.com MX       # Mail servers
dig example.com TXT      # TXT records (SPF, DKIM)
dig example.com NS       # Name servers
dig example.com CNAME    # Aliases
dig example.com SOA      # Start of Authority

# Trace — показать всю цепочку резолвинга
dig +trace example.com

# Reverse DNS lookup
dig -x 8.8.8.8

# Все записи
dig example.com ANY
```

**Полезные опции:**
| Опция | Описание |
|-------|----------|
| `+short` | Только ответ |
| `+trace` | Показать путь резолвинга |
| `+noall +answer` | Только answer section |
| `+tcp` | Использовать TCP |
| `+time=N` | Timeout в секундах |

**Чтение вывода:**
```
;; ANSWER SECTION:
example.com.        3600    IN    A    93.184.216.34
```
- `3600` — TTL в секундах
- `IN` — Internet class
- `A` — тип записи
- `93.184.216.34` — значение

---

### nslookup

**Назначение:** DNS lookup (есть на Windows)

```bash
# Базовый запрос
nslookup example.com

# Через конкретный DNS
nslookup example.com 8.8.8.8

# Конкретный тип записи
nslookup -type=MX example.com
nslookup -type=TXT example.com

# Интерактивный режим
nslookup
> set type=MX
> example.com
> exit
```

---

### host

**Назначение:** Простой DNS lookup

```bash
# Базовый запрос
host example.com

# Все записи
host -a example.com

# Конкретный тип
host -t MX example.com

# Reverse lookup
host 8.8.8.8
```

---

## HTTP Testing

### Почему HTTP-инструменты необходимы разработчику

**Переход на прикладной уровень.** До этого мы проверяли: хост доступен? порт открыт? Теперь проверяем: приложение отвечает правильно? HTTP-код корректный? Headers правильные? Response body соответствует ожиданиям?

**Почему не использовать просто браузер.** Браузер — отличный инструмент для пользователей, но плохой для диагностики:
- Кэширует ответы (вы можете видеть старую версию)
- Автоматически следует редиректам (скрывает промежуточные шаги)
- Не показывает все headers
- Не позволяет легко модифицировать запросы

CLI-инструменты дают полный контроль над запросом и показывают raw ответ.

**curl vs httpie vs Postman.**
- **curl** — стандарт индустрии, есть везде, идеален для скриптов
- **httpie** — более читаемый вывод, лучше для интерактивной работы
- **Postman** — GUI, хорош для сложных коллекций запросов и командной работы

### curl — инструмент который должен знать каждый

**Назначение:** Универсальный HTTP(S) клиент для тестирования API и диагностики

**Почему curl — must-have навык.**
1. Он есть везде — Linux, macOS, Windows (современные версии)
2. Любую проблему с API можно воспроизвести одной командой curl
3. Документация API часто даёт примеры именно на curl
4. curl-команду легко скопировать из DevTools и модифицировать

**Три уровня использования:**
- **Базовый:** `curl https://api.example.com` — просто получить ответ
- **Диагностический:** `curl -v https://api.example.com` — увидеть все детали
- **Продвинутый:** `curl -w "TTFB: %{time_starttransfer}\n" ...` — измерить производительность

#### Базовые запросы

```bash
# GET запрос
curl https://api.example.com/users

# POST с JSON
curl -X POST https://api.example.com/users \
  -H "Content-Type: application/json" \
  -d '{"name": "John", "email": "john@example.com"}'

# POST form data
curl -X POST https://example.com/login \
  -d "username=john&password=secret"

# PUT запрос
curl -X PUT https://api.example.com/users/1 \
  -H "Content-Type: application/json" \
  -d '{"name": "Updated"}'

# DELETE
curl -X DELETE https://api.example.com/users/1
```

#### Headers и Auth

```bash
# Custom headers
curl -H "Authorization: Bearer TOKEN" \
     -H "X-Custom-Header: value" \
     https://api.example.com

# Basic auth
curl -u username:password https://api.example.com

# Bearer token
curl -H "Authorization: Bearer $TOKEN" https://api.example.com

# Показать response headers
curl -i https://example.com

# Только headers (HEAD request)
curl -I https://example.com
```

#### Debugging

```bash
# Verbose output (показать всё)
curl -v https://example.com

# Очень verbose (hex dump)
curl --trace - https://example.com

# Показать только request headers
curl -v -s -o /dev/null --stderr - https://example.com | grep '^>'

# Timing breakdown
curl -o /dev/null -s -w "
DNS Lookup:    %{time_namelookup}s
TCP Connect:   %{time_connect}s
TLS Handshake: %{time_appconnect}s
Time to First Byte: %{time_starttransfer}s
Total Time:    %{time_total}s
" https://example.com
```

#### Полезные опции

```bash
# Следовать редиректам
curl -L https://example.com

# Сохранить в файл
curl -o filename.html https://example.com
curl -O https://example.com/file.zip  # сохранить с оригинальным именем

# Игнорировать SSL ошибки (ТОЛЬКО для debug!)
curl -k https://self-signed.example.com

# Timeout
curl --connect-timeout 5 --max-time 30 https://example.com

# Rate limit
curl --limit-rate 100K https://example.com/large-file

# Resume download
curl -C - -O https://example.com/large-file.zip

# Upload файл
curl -F "file=@/path/to/file" https://example.com/upload

# Проверить HTTP status без вывода
curl -s -o /dev/null -w "%{http_code}" https://example.com
```

**Cheat Sheet флагов:**
| Флаг | Описание |
|------|----------|
| `-X METHOD` | HTTP method |
| `-H "Header: Value"` | Custom header |
| `-d "data"` | POST body |
| `-F "field=@file"` | Multipart form |
| `-u user:pass` | Basic auth |
| `-o file` | Output to file |
| `-O` | Save with original name |
| `-L` | Follow redirects |
| `-v` | Verbose |
| `-s` | Silent |
| `-i` | Include headers |
| `-I` | HEAD request |
| `-k` | Ignore SSL errors |
| `-w "format"` | Custom output format |

---

### HTTPie

**Назначение:** Более читаемая альтернатива curl для API

```bash
# GET (method можно опустить)
http https://api.example.com/users

# POST с JSON (автоматически)
http POST https://api.example.com/users name=John email=john@example.com

# Нестроковые значения
http POST https://api.example.com/users age:=25 active:=true

# Headers
http https://api.example.com Authorization:"Bearer TOKEN"

# Form data
http --form POST https://example.com/login username=john password=secret

# Download файл
http --download https://example.com/file.zip

# Verbose
http -v https://example.com
```

**curl vs HTTPie:**
| Задача | curl | HTTPie |
|--------|------|--------|
| POST JSON | `-H "Content-Type: application/json" -d '{...}'` | `key=value` |
| Headers | `-H "Header: Value"` | `Header:Value` |
| Auth | `-u user:pass` | `-a user:pass` |
| Output | plain | colored, formatted |

> HTTPie лучше для интерактивной работы, curl — для скриптов и automation.

---

## TLS/SSL Testing

### Почему TLS-диагностика так важна

**HTTPS стал стандартом.** Практически все современные сервисы работают через HTTPS. Проблемы с TLS — одни из самых сложных для диагностики, потому что ошибка "SSL certificate problem" может означать десяток разных проблем.

**Типичные TLS-проблемы:**
- **Expired certificate** — сертификат истёк (самая частая проблема)
- **Wrong hostname** — сертификат выдан для другого домена
- **Self-signed** — самоподписанный сертификат не принимается клиентом
- **Broken chain** — не хватает intermediate сертификатов
- **TLS version mismatch** — сервер требует TLS 1.3, клиент поддерживает только TLS 1.2
- **Cipher suite mismatch** — нет общих криптографических алгоритмов

**Когда нужна TLS-диагностика:**
- "ERR_CERT_DATE_INVALID" — проверьте срок действия
- "ERR_CERT_COMMON_NAME_INVALID" — проверьте Subject/SAN
- "Соединение не устанавливается на 443" — проверьте версию TLS и cipher suites

### openssl s_client — глубокая TLS-диагностика

**Назначение:** Установить TLS-соединение и показать все детали handshake и сертификата

**Почему openssl, а не просто curl -v.** curl показывает базовую информацию о TLS. openssl s_client — это полный debugger TLS-соединения: вся цепочка сертификатов, все параметры handshake, возможность тестировать конкретные версии TLS и cipher suites.

**Главные сценарии использования:**
- Проверить срок действия сертификата: когда истекает, когда начал действовать
- Проверить цепочку: все ли intermediate сертификаты на месте
- Проверить поддержку TLS версий: работает ли TLS 1.3, отключён ли TLS 1.0
- Проверить SNI: правильный ли сертификат возвращается для виртуального хоста

```bash
# Базовое подключение
openssl s_client -connect example.com:443

# Краткий вывод
openssl s_client -connect example.com:443 -brief

# Показать всю цепочку сертификатов
openssl s_client -connect example.com:443 -showcerts

# Проверить конкретную версию TLS
openssl s_client -connect example.com:443 -tls1_2
openssl s_client -connect example.com:443 -tls1_3

# Debug mode
openssl s_client -connect example.com:443 -debug -state

# SNI (для виртуальных хостов)
openssl s_client -connect example.com:443 -servername example.com

# STARTTLS для SMTP
openssl s_client -connect mail.example.com:587 -starttls smtp

# Проверить срок действия сертификата
echo | openssl s_client -connect example.com:443 2>/dev/null | \
  openssl x509 -noout -dates

# Показать детали сертификата
echo | openssl s_client -connect example.com:443 2>/dev/null | \
  openssl x509 -noout -text

# Проверить цепочку сертификатов
openssl s_client -connect example.com:443 -verify_return_error
```

**Что проверять в выводе:**
```
CONNECTED(00000003)
depth=2 C = US, O = DigiCert Inc, ...
verify return:1                      ← Сертификат валиден
---
Certificate chain
 0 s:CN = example.com                ← Сертификат сервера
   i:C = US, O = Let's Encrypt, ...  ← Кто выдал
 1 s:C = US, O = Let's Encrypt, ...  ← Intermediate
   i:C = US, O = Internet Security Research Group, ...
---
SSL handshake has read 3456 bytes
Protocol  : TLSv1.3                  ← Версия TLS
Cipher    : TLS_AES_256_GCM_SHA384   ← Cipher suite
```

---

## Packet Capture

### Когда нужен packet capture

**Последний рубеж диагностики.** Все предыдущие инструменты дают высокоуровневую картину: хост доступен, порт открыт, HTTP отвечает. Packet capture показывает что происходит внутри: каждый байт, каждый пакет, каждый handshake.

**Когда переходить к packet capture:**
- Простые инструменты не дают ответа
- "Работает, но странно" — нужно увидеть реальный обмен данными
- Подозрение на проблемы с retransmissions, window size, MTU
- Нужно доказать, что проблема на другой стороне
- Debugging криптографических протоколов

**Важное предупреждение.** Packet capture — мощный, но сложный инструмент. Легко захватить гигабайты данных и потеряться в них. Всегда используйте фильтры, ограничивайте время и объём захвата.

**tcpdump vs Wireshark.** tcpdump — CLI, идеален для захвата на сервере. Wireshark — GUI, идеален для анализа. Типичный workflow: захватить на сервере через tcpdump, скопировать файл локально, проанализировать в Wireshark.

### tcpdump — packet capture в командной строке

**Назначение:** Захват и базовый анализ сетевых пакетов в CLI

**Почему tcpdump, а не сразу Wireshark.** На сервере обычно нет GUI. tcpdump есть почти везде и работает через SSH. Вы захватываете трафик в файл (.pcap), копируете на свою машину, и анализируете в Wireshark.

**Главные сценарии:**
- "Запросы доходят до сервера?" — захватите трафик на порту и посмотрите
- "Что происходит при handshake?" — захватите первые пакеты соединения
- "Почему TCP-соединение рвётся?" — посмотрите RST и FIN пакеты
- "Ретрансмиты?" — tcpdump покажет повторные пакеты

**Типичные ошибки:**
- Забыли `-n` — tcpdump тратит время на DNS-резолвинг каждого IP
- Захватили слишком много — используйте фильтры с самого начала
- Забыли про `-s0` — по умолчанию захватывается не весь пакет

```bash
# Показать доступные интерфейсы
tcpdump -D

# Захват на интерфейсе
sudo tcpdump -i eth0

# Захват на всех интерфейсах
sudo tcpdump -i any

# Ограничить количество пакетов
sudo tcpdump -c 100 -i any

# Фильтр по порту
sudo tcpdump -i any port 80
sudo tcpdump -i any port 443

# Фильтр по хосту
sudo tcpdump -i any host 192.168.1.100

# Фильтр по source/destination
sudo tcpdump -i any src 192.168.1.100
sudo tcpdump -i any dst 192.168.1.100

# Фильтр по протоколу
sudo tcpdump -i any tcp
sudo tcpdump -i any udp
sudo tcpdump -i any icmp

# Комбинация фильтров
sudo tcpdump -i any 'port 80 and host 192.168.1.100'
sudo tcpdump -i any 'port 80 or port 443'
sudo tcpdump -i any 'not port 22'  # исключить SSH

# Сохранить в файл (для Wireshark)
sudo tcpdump -i any -w capture.pcap

# Прочитать из файла
tcpdump -r capture.pcap

# Показать ASCII содержимое
sudo tcpdump -A -i any port 80

# Показать hex dump
sudo tcpdump -X -i any port 80

# Числовые адреса (без DNS)
sudo tcpdump -n -i any

# Verbose output
sudo tcpdump -v -i any
sudo tcpdump -vv -i any  # более подробно
```

**Полезные комбинации:**
```bash
# HTTP траффик (исключая SSH)
sudo tcpdump -i any -n 'tcp port 80 and not port 22'

# DNS запросы
sudo tcpdump -i any -n port 53

# TCP SYN пакеты (новые соединения)
sudo tcpdump -i any 'tcp[tcpflags] & (tcp-syn) != 0'

# Сохранить полные пакеты
sudo tcpdump -i any -s0 -w full-capture.pcap
```

**Флаги:**
| Флаг | Описание |
|------|----------|
| `-i interface` | Интерфейс |
| `-c N` | Количество пакетов |
| `-n` | Без DNS resolution |
| `-w file` | Записать в файл |
| `-r file` | Читать из файла |
| `-A` | ASCII вывод |
| `-X` | Hex + ASCII |
| `-s N` | Snap length (0 = unlimited) |
| `-v/-vv/-vvv` | Verbose levels |

→ Подробнее: [[network-tcpdump-wireshark]]

---

## Bandwidth Testing

### Зачем измерять пропускную способность

**Разница между latency и bandwidth.** Latency — время доставки одного пакета. Bandwidth — сколько данных можно передать за единицу времени. Можно иметь низкую latency и низкий bandwidth (как и наоборот). Для разных задач важны разные метрики: для real-time приложений критична latency, для передачи больших файлов — bandwidth.

**Когда нужно измерять bandwidth:**
- "Сеть медленная" — нужно измерить и сравнить с ожидаемым
- Планирование инфраструктуры — хватит ли 1 Gbps для наших нагрузок?
- Проверка после изменений — действительно ли upgrade до 10 Gbps работает?
- Диагностика узких мест — где именно bottleneck?

**Что влияет на bandwidth:**
- Физический канал (1G, 10G, 100G)
- MTU и jumbo frames
- TCP window size
- Буферы на сетевых устройствах
- Congestion на промежуточных узлах

### iperf3 — стандарт измерения сетевой производительности

**Назначение:** Точное измерение пропускной способности между двумя точками

**Как это работает.** iperf3 требует два компьютера: один работает как сервер, другой как клиент. Клиент генерирует максимальный трафик к серверу, и оба измеряют реальную пропускную способность. Это "чистый" тест сети, без влияния дисков, приложений, и т.д.

**Важно:** iperf3 потребляет всю доступную bandwidth. На production-сервере это может повлиять на реальные сервисы. Запускайте тесты вне рабочих часов или в изолированном окружении.

**TCP vs UDP режимы.** TCP режим показывает реальную throughput с учётом retransmissions и congestion control. UDP режим позволяет задать целевую скорость и проверить, сколько пакетов теряется — полезно для диагностики VoIP и video streaming.

```bash
# Запустить сервер
iperf3 -s

# Запустить сервер на конкретном порту
iperf3 -s -p 5201

# Клиент — тест к серверу
iperf3 -c server-ip

# Тест в обратном направлении
iperf3 -c server-ip -R

# Длительность теста (по умолчанию 10 сек)
iperf3 -c server-ip -t 60

# Параллельные потоки (для 10G+ сетей)
iperf3 -c server-ip -P 4

# UDP тест
iperf3 -c server-ip -u

# UDP с указанием bandwidth
iperf3 -c server-ip -u -b 1G

# JSON output
iperf3 -c server-ip -J

# Интервал отчётов
iperf3 -c server-ip -i 2
```

**Чтение результатов:**
```
[ ID] Interval           Transfer     Bitrate         Retr
[  5]   0.00-10.00  sec  1.09 GBytes   938 Mbits/sec    0    sender
[  5]   0.00-10.04  sec  1.09 GBytes   935 Mbits/sec         receiver
```

- **Transfer** — общий объём данных
- **Bitrate** — скорость
- **Retr** — retransmissions (должен быть 0 или минимум)

> **Важно:** iperf3 потребляет всю доступную bandwidth. Запускайте вне рабочих часов!

---

## Port Scanning

### Когда нужно сканирование портов

**Сценарии использования:**
- **Network discovery** — какие хосты есть в сети, какие сервисы запущены
- **Security audit** — какие порты открыты, не забыли ли закрыть что-то лишнее
- **Инвентаризация** — что работает на этих 50 серверах
- **Debugging** — может, сервис слушает на нестандартном порту?

**Разница от `nc -zv`.** netcat проверяет один порт за раз. nmap — это полноценный сканер: он может просканировать тысячи портов, определить версии сервисов, угадать операционную систему, выполнить скрипты для проверки уязвимостей.

**Юридический аспект.** Сканирование чужих систем без разрешения может быть незаконным. Для практики используйте scanme.nmap.org (официально разрешённый для тестирования), свои системы, или системы с явным разрешением на тестирование.

### nmap — мощнейший сетевой сканер

**Назначение:** Сканирование портов, определение сервисов и ОС, security auditing

**Почему nmap — стандарт индустрии.**
1. Множество режимов сканирования для разных ситуаций
2. Определение версий сервисов (-sV)
3. Определение ОС (-O)
4. Scripting engine (NSE) для автоматизации проверок
5. Работает уже 25+ лет и постоянно развивается

**Типы сканирования и когда их использовать:**
- **SYN scan (-sS)** — быстрый и скрытный, default если запущен от root
- **Connect scan (-sT)** — полный TCP handshake, работает без root
- **UDP scan (-sU)** — для UDP-сервисов (DNS, SNMP), очень медленный
- **Ping scan (-sn)** — только обнаружение хостов, без сканирования портов

**Важно:** По умолчанию nmap сканирует только 1000 самых популярных портов. Для полного сканирования используйте `-p-`.

```bash
# Базовый скан (1000 популярных портов)
nmap target.com

# Скан конкретных портов
nmap -p 22,80,443 target.com

# Скан диапазона
nmap -p 1-1000 target.com

# Скан всех портов
nmap -p- target.com

# Быстрый скан (100 портов)
nmap -F target.com

# Определение версий сервисов
nmap -sV target.com

# Определение ОС
sudo nmap -O target.com

# Скан подсети
nmap 192.168.1.0/24

# Ping scan (discovery)
nmap -sn 192.168.1.0/24

# Скан без ping (когда ICMP заблокирован)
nmap -Pn target.com

# Verbose output
nmap -v target.com
```

**Типы сканирования:**
| Флаг | Тип | Описание |
|------|-----|----------|
| `-sS` | SYN scan | Быстрый, stealth (default, нужен root) |
| `-sT` | Connect scan | Full TCP connect (без root) |
| `-sU` | UDP scan | UDP порты (медленный) |
| `-sP` / `-sn` | Ping scan | Только discovery |

**Состояния портов:**
| Состояние | Значение |
|-----------|----------|
| open | Сервис слушает |
| closed | Порт доступен, но ничего не слушает |
| filtered | Firewall блокирует |
| open\|filtered | Не понятно open или filtered |

> **Важно:** Сканирование чужих систем без разрешения может быть незаконным. Для практики используйте scanme.nmap.org.

---

## Quick Reference

### Решение задачи: какой инструмент?

| Задача | Инструмент | Команда |
|--------|------------|---------|
| Хост доступен? | ping | `ping -c 4 host` |
| Путь до хоста? | mtr | `mtr host` |
| Порт открыт? | nc | `nc -zv host port` |
| Что слушает локально? | ss | `ss -tulnp` |
| DNS lookup | dig | `dig domain +short` |
| HTTP запрос | curl | `curl -v url` |
| TLS сертификат | openssl | `openssl s_client -connect host:443` |
| Захват пакетов | tcpdump | `sudo tcpdump -i any port 80` |
| Bandwidth тест | iperf3 | `iperf3 -c server` |
| Сканирование портов | nmap | `nmap -p 1-1000 host` |

### One-liners

```bash
# Какой процесс на порту 8080?
lsof -i :8080

# Мой публичный IP
curl -s ifconfig.me

# DNS через Google
dig @8.8.8.8 example.com +short

# Проверить TLS версию
curl -v --tlsv1.2 --tls-max 1.2 https://example.com 2>&1 | grep TLS

# HTTP timing
curl -w "TTFB: %{time_starttransfer}s, Total: %{time_total}s\n" -o /dev/null -s https://example.com

# Топ соединений по IP
ss -nt | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -rn | head

# Listening ports summary
ss -tulnp | grep LISTEN
```

---

## Ссылки и источники

### Официальная документация
- [curl manual](https://curl.se/docs/manual.html)
- [nmap reference](https://nmap.org/book/man.html)
- [tcpdump manual](https://www.tcpdump.org/manpages/tcpdump.1.html)
- [iperf3 docs](https://iperf.fr/iperf-doc.php)

### Cheat Sheets
- [curl cheat sheet (QuickRef)](https://quickref.me/curl.html)
- [tcpdump examples (HackerTarget)](https://hackertarget.com/tcpdump-examples/)
- [nmap cheat sheet](https://www.recordedfuture.com/threat-intelligence-101/tools-and-techniques/nmap-commands)

### Tutorials
- [netcat examples (DigitalOcean)](https://www.digitalocean.com/community/tutorials/how-to-use-netcat-to-establish-and-test-tcp-and-udp-connections)
- [openssl s_client guide](https://www.misterpki.com/openssl-s-client/)
- [mtr guide (AWS)](https://repost.aws/articles/ARYuHnu150R9ahMl-2hNNEVw/diagnosing-packet-loss-and-latency-with-mtr)

---

## Связанные материалы

### В этом разделе
→ [[network-debugging-basics]] — systematic debugging approach
→ [[network-tcpdump-wireshark]] — глубокий packet analysis
→ [[network-troubleshooting-advanced]] — сложные кейсы
→ [[network-performance-optimization]] — tuning и benchmarking

### Смежные темы
→ [[observability]] — мониторинг и алертинг
→ [[docker-for-developers]] — networking в контейнерах

---

*Последнее обновление: 2026-01-09 — Добавлены педагогические секции: 5 аналогий (инструменты как медицинский осмотр, OSI как этажи здания, три типа телефонных звонков, dig как справочник, tcpdump как камера видеонаблюдения), 6 типичных ошибок с СИМПТОМ/РЕШЕНИЕ (ping не работает ≠ сервер мёртв, DNS-кэширование, netstat vs ss, tcpdump захватывает SSH, curl без -L, nmap filtered), 5 ментальных моделей (воронка детализации, вопрос определяет инструмент, три точки наблюдения, время ответа как сигнал, toolchain для сценариев)*
