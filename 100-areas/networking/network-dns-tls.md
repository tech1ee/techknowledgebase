---
title: "DNS и TLS: имена и безопасность"
date_created: 2025-01-15
date_modified: 2025-01-15
tags:
  - networking/dns
  - networking/security
  - networking/tls
  - networking/certificates
related:
  - "[[networking-overview]]"
  - "[[network-transport-layer]]"
  - "[[network-http-evolution]]"
  - "[[web-security-owasp]]"
  - "[[authentication-authorization]]"
---

# DNS и TLS: как интернет находит адреса и защищает данные

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **IP-адресация** | DNS преобразует имена в IP | [[network-ip-routing]] |
| **Сетевые основы** | Понимание клиент-сервер | [[network-fundamentals-for-developers]] |
| **TCP/UDP** | DNS работает по UDP (и TCP) | [[network-transport-layer]] |

### Для кого этот материал

| Уровень | Подходит? | Рекомендация |
|---------|-----------|--------------|
| **Новичок** | ✅ Да | Критически важная тема |
| **Intermediate** | ✅ Да | Углубляем знания |
| **Advanced** | ✅ Да | TLS internals |

### Терминология для новичков

> 💡 **DNS** = "телефонная книга интернета". Переводит понятные имена (google.com) в IP-адреса (142.250.74.46), по которым работает сеть.

| Термин | Значение | Аналогия для новичка |
|--------|----------|---------------------|
| **DNS** | Domain Name System — система доменных имён | **Телефонный справочник** — имя → номер |
| **A Record** | IPv4-адрес для домена | **Основной номер** — куда звонить |
| **AAAA Record** | IPv6-адрес для домена | **Новый длинный номер** — будущее |
| **CNAME** | Alias — ссылка на другое имя | **"Спроси у Васи"** — перенаправление |
| **MX** | Mail Exchange — почтовый сервер | **Почтовый ящик** — куда слать письма |
| **TLS** | Transport Layer Security — шифрование | **Секретный код** — никто не подслушает |
| **Certificate** | Удостоверение подлинности сервера | **Паспорт сайта** — "я действительно google.com" |
| **CA** | Certificate Authority — издатель сертификатов | **Нотариус** — подтверждает что паспорт настоящий |
| **HTTPS** | HTTP поверх TLS | **Зашифрованный разговор** — HTTP в конверте |
| **TTL** | Time To Live — время кэширования | **Срок годности** — как долго помнить ответ |
| **Resolver** | DNS-сервер, который ищет ответы | **Справочная служба** — "найди мне номер google.com" |

---

## Часть 1: Интуиция без кода

> 💡 **Цель раздела**: Понять DNS и TLS через 5 аналогий из реальной жизни, прежде чем погружаться в технические детали.

### Аналогия 1: DNS как телефонная книга интернета

```
Мир без DNS:                         Мир с DNS:
┌──────────────────────────┐        ┌──────────────────────────┐
│                          │        │                          │
│  "Позвони Васе"          │        │  "Позвони Васе"          │
│       ↓                  │        │       ↓                  │
│  "Какой номер?"          │        │  Смотрю в контакты       │
│  "Не помню..."           │        │  Вася → +7-999-123-4567  │
│  "Где записная книжка?"  │        │  Набираю!                │
│       ↓                  │        │       ↓                  │
│  Не дозвонились 😢       │        │  Поговорили! 😊          │
│                          │        │                          │
└──────────────────────────┘        └──────────────────────────┘

В интернете:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  Человек:  "Открой google.com"                                  │
│                                                                 │
│  Браузер:  "google.com — это какой IP?"                         │
│            ↓                                                    │
│  DNS:      "google.com → 142.250.74.46"                         │
│            ↓                                                    │
│  Браузер:  Подключаюсь к 142.250.74.46:443                      │
│            ↓                                                    │
│  Результат: Страница Google загружена!                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

Без DNS нам пришлось бы запоминать IP-адреса всех сайтов!
```

**Почему это важно:**
- Компьютеры работают с числами (IP-адресами)
- Люди запоминают имена (домены)
- DNS — мост между человеческим и машинным миром

---

### Аналогия 2: TLS как конверт с печатью

```
Открытка (HTTP):                     Заказное письмо в сейф-пакете (HTTPS):
┌──────────────────────────┐        ┌──────────────────────────┐
│                          │        │ ┌──────────────────────┐ │
│  Пароль: qwerty123       │        │ │ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ │ │
│                          │        │ │ ▓▓▓ ЗАШИФРОВАНО ▓▓▓▓ │ │
│  Почтальон видит!        │        │ │ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ │ │
│  Сосед видит!            │        │ └──────────────────────┘ │
│  Все видят!              │        │          🔒              │
│                          │        │  + Печать отправителя    │
└──────────────────────────┘        └──────────────────────────┘

Что даёт TLS:

1. КОНФИДЕНЦИАЛЬНОСТЬ (шифрование)
   ┌─────────────────┐     ┌─────────────────┐
   │ Пароль: qwerty  │ ──► │ a7$f2!kL9#mNp   │
   └─────────────────┘     └─────────────────┘
   Исходный текст          Зашифрованный текст
   (только вы и сервер     (бессмыслица для
    можете прочитать)       всех остальных)

2. ЦЕЛОСТНОСТЬ (никто не изменил)
   Отправили: "Перевести 100 рублей"
   Получили:  "Перевести 100 рублей" ✓
              (а не "Перевести 10000 рублей")

3. АУТЕНТИФИКАЦИЯ (это точно тот сервер)
   Сертификат говорит:
   "Я действительно google.com, вот доказательство от VeriSign"
```

---

### Аналогия 3: Сертификат как паспорт сайта

```
Как мы проверяем личность человека:

┌───────────────────────────────────────────────────────────────┐
│                         ПАСПОРТ                               │
├───────────────────────────────────────────────────────────────┤
│                                                               │
│  Имя: Иванов Иван Иванович                                    │
│                                                               │
│  Выдан: МВД России (мы доверяем МВД)                          │
│                                                               │
│  Действителен до: 01.01.2030                                  │
│                                                               │
│  Фото: [🧑] ← Совпадает с человеком перед нами                │
│                                                               │
│  Защитные элементы: Водяные знаки, голограмма                 │
│                                                               │
└───────────────────────────────────────────────────────────────┘

Как браузер проверяет сайт:

┌───────────────────────────────────────────────────────────────┐
│                    X.509 СЕРТИФИКАТ                           │
├───────────────────────────────────────────────────────────────┤
│                                                               │
│  Имя (Subject): google.com                                    │
│                                                               │
│  Выдан (Issuer): DigiCert (мы доверяем DigiCert)              │
│                                                               │
│  Действителен до: 01.04.2025                                  │
│                                                               │
│  Публичный ключ: [🔑] ← Для шифрования соединения             │
│                                                               │
│  Подпись CA: ← Криптографическое доказательство               │
│                                                               │
└───────────────────────────────────────────────────────────────┘

Цепочка доверия:
┌────────────────┐
│   Root CA      │  ← Предустановлен в браузере/ОС (как МВД)
│  (DigiCert)    │
└───────┬────────┘
        │ подписал
        ▼
┌────────────────┐
│ Intermediate   │  ← Промежуточный CA
│      CA        │
└───────┬────────┘
        │ подписал
        ▼
┌────────────────┐
│  google.com    │  ← Сертификат сайта
│  Certificate   │
└────────────────┘
```

---

### Аналогия 4: DNS-резолюция как вопрос "Где живёт Вася?"

```
Вы хотите найти адрес Васи Пупкина из Москвы:

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  ВЫ: "Где живёт Вася Пупкин из Москвы?"                         │
│                                                                 │
│  Информационное бюро (Root DNS):                                │
│  "Я не знаю всех людей. Но Москва — спроси у московского        │
│   справочного бюро."                                            │
│                                                                 │
│  Московское бюро (TLD DNS для .ru):                             │
│  "Пупкины? Есть такая семья. Спроси у управляющего              │
│   их домом — вот его адрес."                                    │
│                                                                 │
│  Управляющий домом (Authoritative DNS):                         │
│  "Вася Пупкин живёт в квартире 42, вот точный адрес:            │
│   ул. Ленина, д.10, кв.42"                                      │
│                                                                 │
│  ВЫ: Теперь могу отправить письмо!                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

В интернете:

www.example.com → ?

      Ваш компьютер
            │
            │ "Где www.example.com?"
            ▼
      Resolver (1.1.1.1)
            │
            │ "Кто отвечает за .com?"
            ▼
      Root Server
            │
            │ "Спроси у a.gtld-servers.net"
            ▼
      .com TLD Server
            │
            │ "За example.com отвечает ns1.example.com"
            ▼
      Authoritative NS (ns1.example.com)
            │
            │ "www.example.com = 93.184.216.34"
            ▼
      Ответ: 93.184.216.34 ✓
```

---

### Аналогия 5: TLS Handshake как секретное рукопожатие

```
Представьте, что вы с другом хотите общаться секретно,
но рядом есть шпионы:

┌─────────────────────────────────────────────────────────────────┐
│                    СЕКРЕТНОЕ РУКОПОЖАТИЕ                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Вы                                              Друг           │
│  │                                                │             │
│  │  1. "Привет! Вот мои любимые шифры"            │             │
│  │  ──────────────────────────────────────────►   │  ClientHello│
│  │     [AES, ChaCha20, ...]                       │             │
│  │                                                │             │
│  │  2. "Привет! Выбираю AES. Вот мой паспорт"     │             │
│  │  ◄──────────────────────────────────────────   │  ServerHello│
│  │     [Сертификат + публичный ключ]              │  + Cert     │
│  │                                                │             │
│  │  3. Проверяете паспорт:                        │             │
│  │     - Имя совпадает? ✓                         │             │
│  │     - Не просрочен? ✓                          │             │
│  │     - Выдан кем-то, кому доверяю? ✓            │             │
│  │                                                │             │
│  │  4. Договариваетесь о секретном слове          │             │
│  │     (Diffie-Hellman key exchange)              │             │
│  │  ─────────── 🔐 ──────────────────►            │  Key        │
│  │  ◄─────────── 🔐 ──────────────────            │  Exchange   │
│  │                                                │             │
│  │  5. Теперь у обоих одинаковый секретный ключ!  │             │
│  │     (Шпионы его не знают!)                     │             │
│  │                                                │             │
│  │  6. Всё общение шифруется этим ключом          │             │
│  │  ═══════════ 🔒 ═══════════════════►           │  Encrypted  │
│  │  ◄═══════════ 🔒 ═══════════════════           │  Data       │
│  │                                                │             │
└─────────────────────────────────────────────────────────────────┘

TLS 1.3 сделал это ещё быстрее:
- TLS 1.2: 2 round-trips (туда-обратно)
- TLS 1.3: 1 round-trip (и даже 0 для повторных соединений!)
```

---

## Часть 2: Почему это сложно — 6 типичных ошибок

### Ошибка 1: Сертификат истёк — сайт недоступен

```
❌ СИМПТОМ:
Браузер показывает: "Your connection is not private"
              или: "NET::ERR_CERT_DATE_INVALID"
Пользователи не могут зайти на сайт!

📋 ПРИЧИНА:
Сертификаты имеют срок действия (обычно 90 дней для Let's Encrypt).
Если забыли обновить — сайт "падает" для всех пользователей.

┌─────────────────────────────────────────────────────────────────┐
│  Сертификат                                                     │
│  ├─ Выдан: 01.01.2025                                           │
│  ├─ Истекает: 01.04.2025                                        │
│  └─ Сегодня: 02.04.2025 ← ИСТЁК!                                │
│                                                                 │
│  Браузер: "Не могу доверять просроченному сертификату!"         │
└─────────────────────────────────────────────────────────────────┘

✅ РЕШЕНИЕ:

1. Автоматическое обновление (Let's Encrypt + certbot):
   # Проверить, работает ли auto-renewal
   sudo certbot renew --dry-run

   # Добавить в cron (если не systemd timer)
   0 0 * * * certbot renew --quiet

2. Мониторинг срока действия:
   # Проверить дату истечения
   echo | openssl s_client -connect example.com:443 2>/dev/null | \
       openssl x509 -noout -dates

3. Алерты за 30/14/7/1 день до истечения:
   - Настроить в Nagios/Prometheus/Datadog
   - Или использовать сервисы вроде SSL Labs
```

---

### Ошибка 2: Имя в сертификате не совпадает с доменом

```
❌ СИМПТОМ:
"The certificate is not valid for the requested domain"
"SSL_ERROR_BAD_CERT_DOMAIN"

📋 ПРИЧИНА:
Сертификат выдан для example.com, а вы обращаетесь к www.example.com
(или наоборот).

┌─────────────────────────────────────────────────────────────────┐
│  Сертификат говорит:                                            │
│  ├─ CN (Common Name): example.com                               │
│  └─ SAN (Subject Alt Names): example.com                        │
│                                                                 │
│  Вы запрашиваете: www.example.com                               │
│                                                                 │
│  Браузер: "www.example.com не указан в сертификате!"            │
└─────────────────────────────────────────────────────────────────┘

✅ РЕШЕНИЕ:

1. Заказать сертификат со всеми нужными именами:
   certbot certonly -d example.com -d www.example.com

2. Или использовать wildcard сертификат:
   certbot certonly -d example.com -d *.example.com --dns-challenge

3. Проверить, какие имена в сертификате:
   echo | openssl s_client -connect example.com:443 2>/dev/null | \
       openssl x509 -noout -text | grep -A1 "Subject Alternative Name"
```

---

### Ошибка 3: DNS изменён, но старый IP в кэше

```
❌ СИМПТОМ:
"Я поменял DNS-запись, но пользователи всё ещё идут на старый сервер!"
Миграция не работает часами или днями.

📋 ПРИЧИНА:
DNS-записи кэшируются на время TTL (Time To Live).
Если TTL = 86400 (24 часа), изменения распространятся только через 24 часа.

┌─────────────────────────────────────────────────────────────────┐
│  Хронология проблемы:                                           │
│                                                                 │
│  День 1, 10:00: TTL = 86400, A = 1.2.3.4 (старый сервер)        │
│  День 1, 11:00: Пользователь А запросил DNS                     │
│                 Кэшировал: example.com = 1.2.3.4 до 10:00 дня 2 │
│  День 1, 12:00: ВЫ меняете A = 5.6.7.8 (новый сервер)           │
│  День 1, 14:00: Пользователь А всё ещё идёт на 1.2.3.4!         │
│  День 2, 10:00: Кэш у пользователя А истёк, теперь видит 5.6.7.8│
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

✅ РЕШЕНИЕ:

1. ЗАРАНЕЕ (за неделю до миграции) снизить TTL:
   ; Было:
   example.com.  86400  IN A  1.2.3.4
   ; Стало:
   example.com.  60     IN A  1.2.3.4

2. Подождать старый TTL (чтобы кэши обновились)

3. Выполнить миграцию:
   example.com.  60     IN A  5.6.7.8

4. После миграции вернуть высокий TTL:
   example.com.  86400  IN A  5.6.7.8
```

---

### Ошибка 4: Нет промежуточного сертификата в цепочке

```
❌ СИМПТОМ:
Работает в Chrome, не работает в curl/wget/Java/Python:
"unable to get local issuer certificate"
"certificate verify failed"

📋 ПРИЧИНА:
Браузеры часто "знают" промежуточные сертификаты и могут сами достроить цепочку.
Другие клиенты — нет. Им нужна полная цепочка от сервера.

┌─────────────────────────────────────────────────────────────────┐
│  Правильная цепочка:        Неправильная (сервер отдаёт):       │
│                                                                 │
│  Root CA (в trust store)    Root CA (в trust store)             │
│      │                          │                               │
│      ▼                          ▼                               │
│  Intermediate CA            ??? ← ГДЕ INTERMEDIATE?             │
│      │                          │                               │
│      ▼                          ▼                               │
│  Your Certificate           Your Certificate                    │
│                                                                 │
│  Chrome: "Я знаю этот        curl: "Не могу проверить цепочку!" │
│           Intermediate!"                                        │
└─────────────────────────────────────────────────────────────────┘

✅ РЕШЕНИЕ:

1. Настроить сервер отдавать fullchain, а не только cert:
   # Nginx:
   ssl_certificate /path/to/fullchain.pem;  # НЕ cert.pem!

   # Apache:
   SSLCertificateFile /path/to/cert.pem
   SSLCertificateChainFile /path/to/chain.pem  # Добавить!

2. Проверить цепочку:
   openssl s_client -connect example.com:443 -servername example.com

   # Должны видеть:
   # Certificate chain
   #  0 s:CN = example.com
   #    i:CN = R3
   #  1 s:CN = R3
   #    i:CN = DST Root CA X3

3. Онлайн проверка: https://www.ssllabs.com/ssltest/
```

---

### Ошибка 5: Забыли CNAME на apex домене

```
❌ СИМПТОМ:
CNAME на example.com не работает!
"CNAME at apex" ошибка.

📋 ПРИЧИНА:
CNAME по стандарту RFC нельзя ставить на "голый" домен (apex),
потому что CNAME исключает другие записи, а у apex есть SOA и NS.

┌─────────────────────────────────────────────────────────────────┐
│  НЕПРАВИЛЬНО:                                                   │
│  example.com     CNAME  myapp.herokuapp.com    ← НЕЛЬЗЯ!        │
│                                                                 │
│  Почему: У example.com уже есть SOA и NS записи.                │
│          CNAME говорит "все записи смотри там", а это           │
│          противоречит наличию SOA/NS здесь.                     │
│                                                                 │
│  ПРАВИЛЬНО:                                                     │
│  example.com     A      93.184.216.34                           │
│  www.example.com CNAME  example.com                             │
│                                                                 │
│  Или используйте ALIAS/ANAME (расширения некоторых DNS):        │
│  example.com     ALIAS  myapp.herokuapp.com    ← Работает!      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

✅ РЕШЕНИЕ:

1. Для apex используйте A или AAAA записи, не CNAME

2. Если хостинг не даёт статический IP:
   - Используйте DNS-провайдера с поддержкой ALIAS/ANAME
     (Cloudflare, Route53, DNSimple)
   - Или настройте редирект с apex на www
```

---

### Ошибка 6: Mixed Content — часть ресурсов по HTTP

```
❌ СИМПТОМ:
Браузер показывает "Not Secure" несмотря на HTTPS
Часть ресурсов не загружается
Консоль: "Mixed Content: ... was loaded over HTTPS, but requested
         an insecure image/script/stylesheet"

📋 ПРИЧИНА:
Страница загружена по HTTPS, но запрашивает ресурсы по HTTP.
Браузер блокирует это для защиты пользователя.

┌─────────────────────────────────────────────────────────────────┐
│  https://example.com/page.html                                  │
│                                                                 │
│  <html>                                                         │
│    <head>                                                       │
│      <link href="https://..." rel="stylesheet">  ✓ OK           │
│    </head>                                                      │
│    <body>                                                       │
│      <img src="http://old-cdn.com/logo.png">     ✗ BLOCKED!     │
│      <script src="http://analytics.com/track.js"> ✗ BLOCKED!    │
│    </body>                                                      │
│  </html>                                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

✅ РЕШЕНИЕ:

1. Все ресурсы — через HTTPS:
   <img src="https://cdn.example.com/logo.png">

2. Или protocol-relative URLs (устарело, но работает):
   <img src="//cdn.example.com/logo.png">

3. Content-Security-Policy для автоматического апгрейда:
   Content-Security-Policy: upgrade-insecure-requests

4. Поиск mixed content в коде:
   grep -r "http://" ./src --include="*.html" --include="*.js"
```

---

## Часть 3: Ментальные модели

### Модель 1: DNS как распределённая телефонная книга

```
┌─────────────────────────────────────────────────────────────────┐
│                  РАСПРЕДЕЛЁННАЯ ТЕЛЕФОННАЯ КНИГА                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Обычная телефонная книга:        DNS:                          │
│  ├─ Одна копия у каждого          ├─ Тысячи серверов по миру    │
│  ├─ Обновляется раз в год         ├─ Обновления мгновенные      │
│  └─ Содержит всех                 └─ Разделена по зонам         │
│                                                                 │
│  Структура DNS = иерархия зон ответственности:                  │
│                                                                 │
│        . (root)                                                 │
│        │                                                        │
│        ├── com ──── google                                      │
│        │            └── www.google.com                          │
│        │            └── mail.google.com                         │
│        │                                                        │
│        ├── org ──── wikipedia                                   │
│        │            └── en.wikipedia.org                        │
│        │                                                        │
│        └── ru ───── yandex                                      │
│                     └── www.yandex.ru                           │
│                                                                 │
│  Каждый уровень отвечает только за свою "книгу":                │
│  • Root знает, где .com, .org, .ru                              │
│  • .com знает, где google, facebook, amazon                     │
│  • google.com знает, где www, mail, drive                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

### Модель 2: TLS как секретный язык для двоих

```
┌─────────────────────────────────────────────────────────────────┐
│                   СЕКРЕТНЫЙ ЯЗЫК ДЛЯ ДВОИХ                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Проблема шпионажа:                                             │
│                                                                 │
│    Вы ───────► Сообщение ───────► Друг                          │
│                    ↑                                            │
│                 Шпион: "Ага, интересно!"                        │
│                                                                 │
│  Решение 1: Симметричное шифрование                             │
│  ─────────────────────────────────                              │
│  Один ключ на двоих, как замок с двумя одинаковыми ключами.     │
│  Проблема: как передать ключ безопасно?                         │
│                                                                 │
│  Решение 2: Асимметричное шифрование (публичный/приватный)      │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│    Друг: "Вот мой ОТКРЫТЫЙ замок 🔓 (публичный ключ).           │
│           Закрой сообщение им. Только я могу открыть            │
│           своим СЕКРЕТНЫМ ключом 🔑 (приватный ключ)."          │
│                                                                 │
│    Вы:  [Сообщение] + 🔓 → [🔒 Зашифровано]                     │
│                                                                 │
│    Шпион: "Вижу 🔒, но без 🔑 не открою..."                     │
│                                                                 │
│    Друг:  [🔒 Зашифровано] + 🔑 → [Сообщение]                   │
│                                                                 │
│  TLS комбинирует оба:                                           │
│  1. Асимметричное — для безопасного обмена ключом               │
│  2. Симметричное — для быстрого шифрования данных               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

### Модель 3: Сертификаты как система нотариусов

```
┌─────────────────────────────────────────────────────────────────┐
│                    СИСТЕМА НОТАРИУСОВ                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Реальный мир:                                                  │
│  ├─ Государство ← Высший авторитет                              │
│  │   └─ Выдаёт лицензии нотариусам                              │
│  ├─ Нотариус ← Доверенный посредник                             │
│  │   └─ Заверяет документы печатью                              │
│  └─ Вы ← Обычный человек                                        │
│      └─ Получаете заверенный документ                           │
│                                                                 │
│  Интернет (PKI):                                                │
│  ├─ Root CA ← Предустановлен в браузере/ОС                      │
│  │   └─ DigiCert, Let's Encrypt, Comodo                         │
│  ├─ Intermediate CA ← Выдаёт сертификаты от имени Root          │
│  │   └─ Позволяет Root хранить ключ в безопасности              │
│  └─ End-Entity Certificate ← Ваш сертификат                     │
│      └─ Подписан Intermediate, который подписан Root            │
│                                                                 │
│  Почему цепочка?                                                │
│  ───────────────                                                │
│  • Root CA слишком ценен, чтобы подписывать напрямую            │
│  • Если Intermediate скомпрометирован — отзываем только его     │
│  • Root остаётся безопасным                                     │
│                                                                 │
│  Аналогия:                                                      │
│  Президент (Root) → Министр (Intermediate) → Чиновник (Your cert)
│  Президент не подписывает каждую справку лично!                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

### Модель 4: TTL как срок годности информации

```
┌─────────────────────────────────────────────────────────────────┐
│                   СРОК ГОДНОСТИ ИНФОРМАЦИИ                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Молоко:           DNS-запись:                                  │
│  ┌──────────────┐  ┌──────────────┐                             │
│  │ Годен до:    │  │ TTL: 3600    │                             │
│  │ 15.01.2025   │  │ (1 час)      │                             │
│  └──────────────┘  └──────────────┘                             │
│                                                                 │
│  После срока:      После TTL:                                   │
│  Выбросить!        Запросить заново!                            │
│                                                                 │
│  Примеры TTL:                                                   │
│  ────────────────────────────────────────────────               │
│  60 сек (1 мин)   — Failover, быстрые переключения              │
│  300 сек (5 мин)  — Динамичные сервисы                          │
│  3600 сек (1 час) — Обычные сайты                               │
│  86400 сек (24 ч) — Статичные ресурсы                           │
│                                                                 │
│  Trade-off:                                                     │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  Низкий TTL              │  Высокий TTL                 │    │
│  │  ├─ Быстрые изменения    │  ├─ Меньше DNS-запросов      │    │
│  │  ├─ Больше DNS-запросов  │  ├─ Быстрее для юзеров       │    │
│  │  └─ Выше latency         │  └─ Медленные изменения      │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

### Модель 5: Выбор между DNS и TLS защитами

```
┌─────────────────────────────────────────────────────────────────┐
│                  СЛОИ ЗАЩИТЫ DNS + TLS                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Без защиты (классический интернет):                            │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │  DNS запрос: "Где google.com?" ──► (открыто, видно всем)    ││
│  │  DNS ответ:  "93.184.216.34"   ◄── (можно подменить!)       ││
│  │  HTTP:       "Пароль: 123"     ──► (открыто, видно всем)    ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  С DNSSEC (подпись ответов):                                    │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │  DNS запрос: "Где google.com?" ──► (открыто, видно)         ││
│  │  DNS ответ:  "93.184.216.34" + подпись  ◄── (нельзя         ││
│  │              (можно проверить подлинность)     подменить!)  ││
│  │  HTTP:       "Пароль: 123"     ──► (всё ещё открыто!)       ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  С DoH/DoT (шифрование запросов):                               │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │  DNS запрос: 🔒 зашифровано    ──► (ISP не видит)           ││
│  │  DNS ответ:  🔒 зашифровано    ◄── (ISP не видит)           ││
│  │  HTTP:       "Пароль: 123"     ──► (всё ещё открыто!)       ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  С HTTPS (TLS для данных):                                      │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │  DNS:   (любой вариант выше)                                ││
│  │  HTTPS: 🔒 "Пароль: 123" 🔒   ──► (никто не видит!)         ││
│  │         + сертификат проверен    (сервер аутентифицирован)  ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  Максимальная защита = DNSSEC + DoH + HTTPS                     │
│  ├─ DNSSEC: ответы DNS подлинные                                │
│  ├─ DoH: запросы DNS скрыты                                     │
│  └─ HTTPS: данные зашифрованы + сервер проверен                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## DNS: Domain Name System

### Почему DNS?

**Проблема**: Компьютеры работают с IP-адресами (93.184.216.34), люди — с именами (example.com).

**До DNS (до 1983)**: Централизованный файл `hosts.txt` на каждой машине. Stanford Research Institute (SRI-NIC) поддерживал мастер-копию. Все скачивали обновления по FTP.

```
# hosts.txt (1970-е)
10.0.0.1    UCLA-NMC
10.1.0.1    SRI-NIC
10.2.0.1    UCSB-MOE
...
```

**Проблема масштабирования**: К 1983 году ARPANET вырос настолько, что централизованный hosts.txt стал bottleneck.

**1983**: Paul Mockapetris создаёт DNS (RFC 882, 883). Ключевые идеи:
- **Иерархическая структура** — зоны ответственности
- **Распределённая база** — нет single point of failure
- **Кэширование** — снижение нагрузки

### DNS Architecture: иерархия

```
                          ┌─────────────────┐
                          │   Root Servers  │  13 logical servers (a-m.root-servers.net)
                          │        .        │  ~1500 physical instances worldwide
                          └────────┬────────┘
                                   │
              ┌────────────────────┼────────────────────┐
              │                    │                    │
       ┌──────┴──────┐      ┌──────┴──────┐      ┌──────┴──────┐
       │    .com     │      │    .org     │      │    .net     │
       │   TLD NS    │      │   TLD NS    │      │   TLD NS    │
       └──────┬──────┘      └─────────────┘      └─────────────┘
              │
       ┌──────┴──────┐
       │ example.com │
       │ Authoritative│
       │     NS      │
       └──────┬──────┘
              │
       ┌──────┴──────────────────────────────────┐
       │                                         │
┌──────┴──────┐                          ┌───────┴───────┐
│  www.       │                          │   api.        │
│example.com  │                          │ example.com   │
└─────────────┘                          └───────────────┘
```

### DNS Resolution: полный путь запроса

```
┌─────────────────────────────────────────────────────────────────────┐
│                        DNS Resolution Process                        │
└─────────────────────────────────────────────────────────────────────┘

User types: www.example.com

    Browser
       │
       │ 1. Проверяет browser DNS cache
       │    Hit? → Возвращает IP
       │    Miss? ↓
       │
    OS Resolver (stub resolver)
       │
       │ 2. Проверяет OS DNS cache (/etc/hosts, systemd-resolved)
       │    Hit? → Возвращает IP
       │    Miss? ↓
       │
    Recursive Resolver (ISP или public: 8.8.8.8, 1.1.1.1)
       │
       │ 3. Проверяет resolver cache
       │    Hit? → Возвращает IP
       │    Miss? ↓
       │
       │ 4. Query Root Server
       │    "Где .com?"
       │    Root: "Спроси a.gtld-servers.net"
       │
       │ 5. Query .com TLD Server
       │    "Где example.com?"
       │    TLD: "Спроси ns1.example.com (93.184.216.34)"
       │
       │ 6. Query Authoritative NS
       │    "Какой IP у www.example.com?"
       │    Auth NS: "A record: 93.184.216.34, TTL: 3600"
       │
       │ 7. Кэширует ответ (TTL секунд)
       │
       │ 8. Возвращает IP клиенту
       ▼
    Browser получает 93.184.216.34
```

### DNS Record Types

| Тип | Назначение | Пример |
|-----|------------|--------|
| **A** | IPv4 адрес | `example.com → 93.184.216.34` |
| **AAAA** | IPv6 адрес | `example.com → 2606:2800:220:1:...` |
| **CNAME** | Алиас на другое имя | `www.example.com → example.com` |
| **MX** | Mail exchanger | `example.com → mail.example.com (pri 10)` |
| **TXT** | Текстовые данные | SPF, DKIM, domain verification |
| **NS** | Authoritative nameservers | `example.com → ns1.example.com` |
| **SOA** | Start of Authority | Primary NS, admin email, serial |
| **SRV** | Service location | `_http._tcp.example.com → ...` |
| **CAA** | Certificate Authority Authorization | Какие CA могут выдавать сертификаты |
| **PTR** | Reverse DNS (IP → name) | `34.216.184.93 → example.com` |

### DNS Message Format

```
DNS Query/Response Format:
┌────────────────────────────────────────────────────────────────┐
│                         Header (12 bytes)                       │
├────────────────────────────────────────────────────────────────┤
│ ID (16 bits)           │ Flags (16 bits)                       │
│ Query/Response, Opcode │ AA, TC, RD, RA, Z, RCODE              │
├────────────────────────────────────────────────────────────────┤
│ QDCOUNT (16)  │ ANCOUNT (16)  │ NSCOUNT (16)  │ ARCOUNT (16)   │
├────────────────────────────────────────────────────────────────┤
│                        Question Section                         │
│  QNAME (variable) │ QTYPE (16) │ QCLASS (16)                   │
├────────────────────────────────────────────────────────────────┤
│                        Answer Section                           │
│  NAME │ TYPE │ CLASS │ TTL (32) │ RDLENGTH │ RDATA             │
├────────────────────────────────────────────────────────────────┤
│                      Authority Section                          │
├────────────────────────────────────────────────────────────────┤
│                      Additional Section                         │
└────────────────────────────────────────────────────────────────┘
```

### DNS Caching и TTL

```
TTL (Time To Live):
├─ Определяет, как долго кэшировать запись
├─ Устанавливается владельцем домена
├─ Trade-off:
│   ├─ Высокий TTL (86400 сек = 24 часа):
│   │   ├─ + Меньше DNS запросов
│   │   ├─ + Быстрее для пользователей
│   │   └─ - Медленное распространение изменений
│   │
│   └─ Низкий TTL (60 сек = 1 мин):
│       ├─ + Быстрое переключение (failover, blue-green)
│       ├─ - Больше DNS запросов
│       └─ - Выше latency при cache miss

Типичные значения:
├─ Статичные сайты: 86400 (24 часа)
├─ Динамичные сервисы: 300-3600 (5 мин - 1 час)
├─ Failover/HA: 60 (1 минута)
└─ Миграция: 60 → переключение → 86400
```

### DNS Security: проблемы и решения

#### Проблема 1: DNS Spoofing / Cache Poisoning

```
Атака:
┌────────────────────────────────────────────────────────────────┐
│ 1. Злоумышленник отправляет поддельные DNS ответы              │
│ 2. Если Query ID угадан, resolver кэширует поддельный IP       │
│ 3. Пользователи направляются на malicious server              │
└────────────────────────────────────────────────────────────────┘

Mitigation:
├─ Рандомизация Source Port (не только Query ID)
├─ DNSSEC — криптографическая подпись записей
└─ DNS over HTTPS/TLS — шифрование запросов
```

#### DNSSEC: подпись записей

```
DNSSEC Chain of Trust:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  Root Zone                                                      │
│  ├─ DNSKEY: public key root zone                                │
│  └─ DS: hash of .com DNSKEY                                     │
│                                                                 │
│  .com Zone                                                      │
│  ├─ DNSKEY: public key .com zone                                │
│  ├─ RRSIG: signature of .com records                            │
│  └─ DS: hash of example.com DNSKEY                              │
│                                                                 │
│  example.com Zone                                               │
│  ├─ DNSKEY: public key example.com                              │
│  ├─ A: 93.184.216.34                                            │
│  └─ RRSIG: signature of A record                                │
│                                                                 │
│  Resolver validates chain: Root → .com → example.com            │
└─────────────────────────────────────────────────────────────────┘
```

#### DNS over HTTPS (DoH) / DNS over TLS (DoT)

```
Traditional DNS:
├─ Порт: 53 (UDP/TCP)
├─ Шифрование: Нет
├─ Проблема: ISP/Network видит все DNS запросы

DoT (DNS over TLS):
├─ Порт: 853 (TCP)
├─ Шифрование: TLS
├─ Проблема: Легко блокировать (отдельный порт)

DoH (DNS over HTTPS):
├─ Порт: 443 (стандартный HTTPS)
├─ Шифрование: TLS
├─ Преимущество: Неотличим от обычного HTTPS трафика
├─ Проблема: Сложнее для корпоративного мониторинга

Providers:
├─ Cloudflare: 1.1.1.1 (https://cloudflare-dns.com/dns-query)
├─ Google: 8.8.8.8 (https://dns.google/dns-query)
├─ Quad9: 9.9.9.9 (https://dns.quad9.net/dns-query)
└─ NextDNS: Custom filtering (https://dns.nextdns.io)
```

### DNS в коде

```kotlin
// Android: DNS resolution
val addresses = InetAddress.getAllByName("example.com")
addresses.forEach { println(it.hostAddress) }

// Custom DNS resolver (OkHttp)
val dns = object : Dns {
    override fun lookup(hostname: String): List<InetAddress> {
        // Custom logic: DoH, caching, logging
        return Dns.SYSTEM.lookup(hostname)
    }
}

val client = OkHttpClient.Builder()
    .dns(dns)
    .build()
```

```bash
# CLI tools
dig example.com                  # Query A record
dig +short example.com           # Just the IP
dig @8.8.8.8 example.com         # Use specific resolver
dig example.com MX               # Query MX records
dig +trace example.com           # Full resolution path
nslookup example.com             # Simple lookup
host example.com                 # Another simple tool
```

---

## TLS: Transport Layer Security

### Историческая справка

```
1994    SSL 1.0 (Netscape) — никогда не выпущен публично (security flaws)
1995    SSL 2.0 — первая публичная версия
1996    SSL 3.0 — значительно улучшен
1999    TLS 1.0 (RFC 2246) — стандартизация SSL 3.0
2006    TLS 1.1 (RFC 4346) — защита от CBC attacks
2008    TLS 1.2 (RFC 5246) — SHA-256, AEAD ciphers
2018    TLS 1.3 (RFC 8446) — радикальное упрощение, 1-RTT
```

**Почему TLS, а не SSL?** Когда IETF стандартизировал протокол, его переименовали из SSL в TLS. Технически SSL 3.0 и TLS 1.0 очень похожи.

### Что защищает TLS?

```
┌─────────────────────────────────────────────────────────────────┐
│                     TLS Protection                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. КОНФИДЕНЦИАЛЬНОСТЬ (Confidentiality)                        │
│     └─ Шифрование данных — никто не может прочитать             │
│                                                                 │
│  2. ЦЕЛОСТНОСТЬ (Integrity)                                     │
│     └─ MAC/AEAD — данные не изменены в пути                     │
│                                                                 │
│  3. АУТЕНТИФИКАЦИЯ (Authentication)                             │
│     └─ Сертификаты — это действительно тот сервер               │
│                                                                 │
│  4. FORWARD SECRECY (опционально в TLS 1.2, обязательно в 1.3)  │
│     └─ Компрометация ключа не раскрывает прошлые сессии         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

Что TLS НЕ скрывает:
├─ IP адреса (source, destination)
├─ Размер данных (можно padding, но это metadata)
├─ Timing (когда и как часто)
├─ SNI (Server Name Indication) — до TLS 1.3 ECH
└─ Факт соединения
```

### TLS 1.2 Handshake

```
┌─────────────────────────────────────────────────────────────────┐
│                      TLS 1.2 Full Handshake                      │
└─────────────────────────────────────────────────────────────────┘

    Client                                              Server
       │                                                   │
       │ ─── ClientHello ─────────────────────────────────►│
       │     • Version: TLS 1.2                            │
       │     • Random (32 bytes)                           │
       │     • Session ID                                  │
       │     • Cipher Suites list                          │
       │     • Extensions (SNI, ALPN, ...)                 │
       │                                                   │
       │ ◄── ServerHello ──────────────────────────────────│
       │     • Version: TLS 1.2                            │
       │     • Random (32 bytes)                           │
       │     • Session ID                                  │
       │     • Selected Cipher Suite                       │
       │                                                   │
       │ ◄── Certificate ──────────────────────────────────│
       │     • Server's X.509 certificate chain            │
       │                                                   │
       │ ◄── ServerKeyExchange (if DHE/ECDHE) ─────────────│
       │     • DH/ECDH parameters                          │
       │     • Signature                                   │
       │                                                   │
       │ ◄── ServerHelloDone ──────────────────────────────│
       │                                                   │
       │ ─── ClientKeyExchange ────────────────────────────►│
       │     • DH/ECDH public value (or encrypted PMS)     │
       │                                                   │
       │ ─── ChangeCipherSpec ─────────────────────────────►│
       │     • "Switching to encrypted mode"               │
       │                                                   │
       │ ─── Finished (encrypted) ─────────────────────────►│
       │     • Verify data: hash of all handshake messages │
       │                                                   │
       │ ◄── ChangeCipherSpec ─────────────────────────────│
       │                                                   │
       │ ◄── Finished (encrypted) ─────────────────────────│
       │                                                   │
    ═══╧═══════════════════════════════════════════════════╧═══
                    Secure channel established
                    (2 RTT for new connection)
```

### TLS 1.3 Handshake: революция

```
┌─────────────────────────────────────────────────────────────────┐
│                      TLS 1.3 Full Handshake                      │
└─────────────────────────────────────────────────────────────────┘

    Client                                              Server
       │                                                   │
       │ ─── ClientHello ─────────────────────────────────►│
       │     • Version: TLS 1.3                            │
       │     • Random (32 bytes)                           │
       │     • Cipher Suites (only AEAD)                   │
       │     • key_share: ECDH public key                  │
       │     • supported_versions: [TLS 1.3]               │
       │                                                   │
       │ ◄── ServerHello ──────────────────────────────────│
       │     • Random (32 bytes)                           │
       │     • Selected Cipher Suite                       │
       │     • key_share: ECDH public key                  │
       │                                                   │
       │ ◄── {EncryptedExtensions} ────────────────────────│  ┐
       │     • ALPN, etc.                                  │  │
       │                                                   │  │
       │ ◄── {Certificate} ────────────────────────────────│  │ Encrypted
       │                                                   │  │ with
       │ ◄── {CertificateVerify} ──────────────────────────│  │ handshake
       │     • Signature over transcript                   │  │ keys
       │                                                   │  │
       │ ◄── {Finished} ───────────────────────────────────│  ┘
       │                                                   │
       │ ─── {Finished} ───────────────────────────────────►│
       │                                                   │
    ═══╧═══════════════════════════════════════════════════╧═══
                    Secure channel established
                    (1 RTT for new connection!)
```

### TLS 1.3: ключевые изменения

| Аспект | TLS 1.2 | TLS 1.3 |
|--------|---------|---------|
| **RTT** | 2 RTT (new) / 1 RTT (resume) | 1 RTT (new) / 0 RTT (resume) |
| **Cipher Suites** | ~37 вариантов | 5 (только AEAD) |
| **Key Exchange** | RSA, DHE, ECDHE | Только (EC)DHE |
| **Forward Secrecy** | Опционально | Обязательно |
| **Handshake Encryption** | Частично | Почти полностью |
| **Renegotiation** | Да | Нет |
| **Compression** | Да (vulnerable) | Нет |

**Удалено в TLS 1.3:**
- RSA key exchange (нет forward secrecy)
- CBC mode ciphers (padding oracle attacks)
- RC4, DES, 3DES
- MD5, SHA-1 for signatures
- Static DH
- Compression (CRIME attack)

### Cipher Suites

```
TLS 1.2 Cipher Suite Example:
TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
 │    │     │        │    │    │
 │    │     │        │    │    └─ PRF hash
 │    │     │        │    └────── AEAD mode
 │    │     │        └─────────── Symmetric cipher
 │    │     └──────────────────── Authentication
 │    └────────────────────────── Key Exchange
 └─────────────────────────────── Protocol

TLS 1.3 Cipher Suite (simplified):
TLS_AES_128_GCM_SHA256
TLS_AES_256_GCM_SHA384
TLS_CHACHA20_POLY1305_SHA256

Key exchange и signature algorithm — отдельные extensions
```

### Certificates: X.509

```
X.509 Certificate Structure:
┌─────────────────────────────────────────────────────────────────┐
│                        Certificate                               │
├─────────────────────────────────────────────────────────────────┤
│ Version: 3 (X.509v3)                                            │
│ Serial Number: 0x0A:01:41:42...                                 │
│ Signature Algorithm: SHA256withRSA                              │
│                                                                 │
│ Issuer: CN=Let's Encrypt Authority X3, O=Let's Encrypt, C=US    │
│                                                                 │
│ Validity:                                                       │
│   Not Before: Jan 1 00:00:00 2024 GMT                           │
│   Not After: Apr 1 00:00:00 2024 GMT                            │
│                                                                 │
│ Subject: CN=example.com                                         │
│                                                                 │
│ Subject Public Key Info:                                        │
│   Algorithm: RSA                                                │
│   Public Key: (2048 bit)                                        │
│                                                                 │
│ Extensions:                                                     │
│   Subject Alternative Name: DNS:example.com, DNS:*.example.com  │
│   Key Usage: Digital Signature, Key Encipherment                │
│   Extended Key Usage: TLS Web Server Authentication             │
│   Basic Constraints: CA:FALSE                                   │
│   Authority Information Access: OCSP, CA Issuers                │
│   Certificate Policies: DV (Domain Validation)                  │
│   SCT (Signed Certificate Timestamp): CT log entries            │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│ Signature: (Issuer's signature over certificate)                │
└─────────────────────────────────────────────────────────────────┘
```

### Certificate Chain of Trust

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│    Root CA (self-signed, in browser/OS trust store)             │
│    ├─ CN=DigiCert Global Root CA                                │
│    └─ Validity: 20+ years                                       │
│                    │                                            │
│                    │ Signs                                      │
│                    ▼                                            │
│    Intermediate CA                                              │
│    ├─ CN=DigiCert TLS RSA SHA256 2020 CA1                       │
│    ├─ Signed by: DigiCert Global Root CA                        │
│    └─ Validity: ~10 years                                       │
│                    │                                            │
│                    │ Signs                                      │
│                    ▼                                            │
│    End-Entity Certificate (your server)                         │
│    ├─ CN=example.com                                            │
│    ├─ Signed by: DigiCert TLS RSA SHA256 2020 CA1               │
│    └─ Validity: 90 days - 1 year                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

Validation Process:
1. Server sends: End-Entity cert + Intermediate cert(s)
2. Client verifies End-Entity signature using Intermediate public key
3. Client verifies Intermediate signature using Root public key
4. Client checks: Root is in trusted store? → VALID
```

### Certificate Validation: что проверяется

```
□ Chain of Trust
  └─ Подписи валидны до trusted root

□ Validity Period
  └─ Not Before < now < Not After

□ Hostname Verification
  └─ SNI matches Subject CN or SAN

□ Revocation Status
  ├─ CRL (Certificate Revocation List) — скачиваемый список
  ├─ OCSP (Online Certificate Status Protocol) — запрос к CA
  └─ OCSP Stapling — сервер предоставляет stapled response

□ Certificate Transparency
  └─ SCT present in certificate or TLS extension

□ Key Usage
  └─ Certificate allows TLS server authentication
```

### Let's Encrypt и ACME

```
ACME Protocol (Automatic Certificate Management Environment):
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  1. Account Registration                                        │
│     Client ─── Register ──────────────────────────► Let's Encrypt│
│                                                                 │
│  2. Order Certificate                                           │
│     Client ─── Order (example.com) ───────────────► Let's Encrypt│
│     Client ◄── Challenges ────────────────────────              │
│                                                                 │
│  3. Complete Challenge (HTTP-01 or DNS-01)                      │
│     HTTP-01: Place file at /.well-known/acme-challenge/TOKEN    │
│     DNS-01: Create TXT record _acme-challenge.example.com       │
│                                                                 │
│  4. Validation                                                  │
│     Let's Encrypt ─── Verify challenge ───► Your server          │
│                                                                 │
│  5. Issue Certificate                                           │
│     Client ─── Finalize ──────────────────────────► Let's Encrypt│
│     Client ◄── Certificate ───────────────────────              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

Certbot example:
$ certbot certonly --webroot -w /var/www/html -d example.com

Auto-renewal:
$ certbot renew --dry-run
```

### TLS в коде

```kotlin
// Kotlin/Android: Custom TLS configuration
val trustManager = object : X509TrustManager {
    override fun checkClientTrusted(chain: Array<X509Certificate>, authType: String) {}
    override fun checkServerTrusted(chain: Array<X509Certificate>, authType: String) {
        // Custom validation logic
    }
    override fun getAcceptedIssuers(): Array<X509Certificate> = arrayOf()
}

val sslContext = SSLContext.getInstance("TLS")
sslContext.init(null, arrayOf(trustManager), SecureRandom())

// OkHttp with custom SSL
val client = OkHttpClient.Builder()
    .sslSocketFactory(sslContext.socketFactory, trustManager)
    .hostnameVerifier { hostname, session ->
        // Custom hostname verification
        hostname == "example.com"
    }
    .build()
```

```java
// Java: Certificate Pinning
CertificatePinner certificatePinner = new CertificatePinner.Builder()
    .add("example.com", "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
    .build();

OkHttpClient client = new OkHttpClient.Builder()
    .certificatePinner(certificatePinner)
    .build();
```

### TLS Best Practices (2024-2025)

```
✅ DO:
├─ Use TLS 1.3 (fallback to TLS 1.2 if needed)
├─ Enable HSTS (HTTP Strict Transport Security)
├─ Use ECDSA certificates (faster than RSA)
├─ Implement certificate pinning for mobile apps
├─ Enable OCSP Stapling
├─ Use modern cipher suites (AEAD only)
├─ Automate certificate renewal (Let's Encrypt + certbot)
└─ Monitor certificate expiration

❌ DON'T:
├─ Use TLS 1.0/1.1 or SSL
├─ Use self-signed certs in production
├─ Disable hostname verification
├─ Use weak cipher suites (RC4, DES, export)
├─ Ignore certificate errors
└─ Store private keys insecurely
```

---

## Связь DNS и TLS

### SNI: Server Name Indication

```
Проблема (до SNI):
┌─────────────────────────────────────────────────────────────────┐
│ Один IP адрес может хостить множество HTTPS сайтов              │
│ Но TLS handshake происходит ДО HTTP request                     │
│ Сервер не знает, какой сертификат показать!                     │
└─────────────────────────────────────────────────────────────────┘

Решение: SNI extension в ClientHello
┌─────────────────────────────────────────────────────────────────┐
│ ClientHello:                                                    │
│   ...                                                           │
│   Extensions:                                                   │
│     server_name: example.com  ◄── Сервер знает, какой cert     │
└─────────────────────────────────────────────────────────────────┘

Проблема SNI: hostname передаётся в plaintext!
├─ ISP/Network видит, какие сайты вы посещаете
└─ Решение: Encrypted Client Hello (ECH) в TLS 1.3
```

### Encrypted Client Hello (ECH)

```
ECH Flow:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  1. DNS Query: example.com                                      │
│     Response includes: HTTPS record with ECH config             │
│                                                                 │
│  2. ClientHello:                                                │
│     Outer SNI: cloudflare-ech.com (public, decoy)               │
│     Inner SNI: example.com (encrypted)                          │
│                                                                 │
│  3. Server decrypts Inner ClientHello                           │
│     Proceeds with actual hostname                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Типичные ошибки

### DNS

```
1. Слишком высокий TTL перед миграцией
   ❌ TTL: 86400 → меняю IP → пользователи видят старый IP 24 часа
   ✅ За неделю до миграции: TTL: 60

2. Неправильный CNAME
   ❌ CNAME example.com → www.example.com (CNAME at apex!)
   ✅ A example.com → IP; CNAME www → example.com

3. Игнорирование DNS propagation
   ❌ Сменил NS → сразу тестирую → "не работает!"
   ✅ Подождать TTL старых записей (до 48 часов для NS)
```

### TLS

```
1. Игнорирование certificate errors в development
   ❌ trustAllCertificates = true (и забыл убрать)
   ✅ Правильный trust store для dev environment

2. Не обновлять сертификаты
   ❌ Сертификат истёк → сайт недоступен
   ✅ Мониторинг + auto-renewal

3. Mixed content
   ❌ HTTPS страница загружает HTTP ресурсы
   ✅ Все ресурсы через HTTPS или protocol-relative URLs
```

---

## Инструменты

### DNS

```bash
# dig — мощный DNS клиент
dig example.com                    # A record
dig +short example.com             # Only IP
dig @8.8.8.8 example.com           # Specific resolver
dig example.com ANY                # All records
dig +trace example.com             # Full resolution path
dig +dnssec example.com            # DNSSEC info

# Other tools
nslookup example.com
host example.com
whois example.com
```

### TLS

```bash
# openssl — Swiss Army knife
openssl s_client -connect example.com:443
openssl s_client -connect example.com:443 -servername example.com
openssl x509 -in cert.pem -text -noout
openssl verify -CAfile chain.pem cert.pem

# testssl.sh — comprehensive TLS testing
./testssl.sh example.com

# SSL Labs (online)
https://www.ssllabs.com/ssltest/
```

---

## DNSSEC: глубокое погружение

### Зачем нужен DNSSEC: проблема доверия в DNS

**DNS изначально не был спроектирован с учётом безопасности.** Когда в 1983 году создавался Domain Name System, интернет был академической сетью из нескольких десятков узлов, где все друг другу доверяли. Никто не предполагал, что через 40 лет миллиарды устройств будут полагаться на эту систему для критически важных операций — от банковских переводов до управления электростанциями.

**Проблема:** когда ваш компьютер спрашивает "какой IP у google.com?", он слепо доверяет ответу. Любой, кто находится между вами и DNS-сервером, может подменить ответ — и вы окажетесь на фальшивом сайте, даже не подозревая об этом.

**Реальный случай — атака Kaminsky (2008):** исследователь Дэн Каминский обнаружил, что можно "отравить" кэш DNS-резолвера, заставив его запомнить поддельный IP для любого домена. Один успешный взлом — и все пользователи этого резолвера перенаправляются на сайт злоумышленника. Эта уязвимость существовала с самого начала DNS, но 25 лет никто её не замечал.

**DNSSEC решает эту проблему через криптографические подписи.** Каждая DNS-запись подписывается приватным ключом владельца домена. Резолвер может проверить подпись публичным ключом и убедиться, что данные:
- **Подлинные** — пришли от настоящего владельца домена
- **Целостные** — не были изменены по пути
- **Актуальные** — подпись не истекла

**Важно понимать:** DNSSEC НЕ шифрует DNS-запросы. Он только гарантирует, что ответ настоящий. Для шифрования нужны DoH/DoT (о них ниже).

### Архитектура ключей: ZSK и KSK

**Почему используются два типа ключей?** Это не усложнение ради усложнения — это результат практического опыта.

Представьте, что вы подписываете все свои документы одной подписью. Если эту подпись украдут, злоумышленник получит полный контроль. Но если у вас есть "главная подпись" (которую вы храните в сейфе) и "рабочая подпись" (которую используете ежедневно) — компрометация рабочей подписи менее катастрофична.

**ZSK (Zone Signing Key)** — это "рабочая подпись". Она используется часто (подписывает все записи в зоне), поэтому теоретически более уязвима. Срок жизни: 30-90 дней. При компрометации — меняем ZSK, и всё продолжает работать.

**KSK (Key Signing Key)** — это "главная подпись". Она подписывает только DNSKEY-записи (включая сам ZSK). Используется редко, хранится более защищённо. Срок жизни: 1-2 года. При компрометации — нужно менять DS-запись у родительского домена, что требует координации.

```
DNSSEC Key Hierarchy:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  KSK (Key Signing Key)                                          │
│  ├─ Подписывает ТОЛЬКО DNSKEY записи                            │
│  ├─ Длинный срок жизни (1-2 года)                               │
│  ├─ Требует обновления DS record у parent                       │
│  ├─ Алгоритм: ECDSAP256SHA256 (рекомендуется 2024+)             │
│  └─ Флаг: 257 (SEP - Secure Entry Point)                        │
│                                                                 │
│  ZSK (Zone Signing Key)                                         │
│  ├─ Подписывает все остальные записи зоны                       │
│  ├─ Короткий срок жизни (30-90 дней)                            │
│  ├─ Ротация НЕ требует изменений у parent                       │
│  ├─ Алгоритм: тот же, что и KSK                                 │
│  └─ Флаг: 256                                                   │
│                                                                 │
│  CSK (Combined Signing Key) — альтернатива                      │
│  ├─ Один ключ для всего (BIND 9 default)                        │
│  ├─ Проще в управлении                                          │
│  └─ Но ротация требует обновления DS                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

Почему два ключа?
├─ Безопасность: ZSK используется чаще → выше риск компрометации
├─ Операционность: ZSK rollover не требует координации с parent
└─ Криптография: можно использовать разную длину ключей
```

### DNSSEC Record Types

| Тип | Назначение | Пример |
|-----|------------|--------|
| **DNSKEY** | Публичный ключ зоны | `256 3 13 base64...` (ZSK) |
| **RRSIG** | Подпись RRset | Подписывает A, MX, NS и др. |
| **DS** | Delegation Signer | Hash KSK для parent zone |
| **NSEC/NSEC3** | Authenticated Denial | Доказательство отсутствия |

### NSEC vs NSEC3: Zone Walking Protection

```
Проблема NSEC:
┌─────────────────────────────────────────────────────────────────┐
│ NSEC раскрывает все имена в зоне (zone enumeration attack)      │
│                                                                 │
│ Query: nonexistent.example.com                                  │
│ NSEC Response: "mail.example.com → www.example.com"             │
│ → Атакующий знает, что между mail и www нет других записей     │
│ → Можно перечислить ВСЮ зону                                   │
└─────────────────────────────────────────────────────────────────┘

Решение NSEC3:
┌─────────────────────────────────────────────────────────────────┐
│ NSEC3 использует хэшированные имена                             │
│                                                                 │
│ NSEC3 Response: "1AVVQN... → 2BDMU7..."                         │
│ → Без brute-force нельзя узнать реальные имена                  │
│                                                                 │
│ Параметры NSEC3:                                                │
│ ├─ Algorithm: 1 (SHA-1)                                         │
│ ├─ Iterations: 0-10 (рекомендуется 0-1 для performance)         │
│ └─ Salt: опционально (добавляет entropy)                        │
└─────────────────────────────────────────────────────────────────┘
```

### Key Rollover: практика

```bash
# BIND 9: автоматический DNSSEC с dnssec-policy
# /etc/named.conf

zone "example.com" {
    type primary;
    file "example.com.zone";
    dnssec-policy default;    # Включает автоматическую ротацию
    inline-signing yes;       # Подпись на лету
};

# Проверка DNSSEC статуса
dig @localhost example.com DNSKEY +dnssec +multi
dig @localhost example.com SOA +dnssec

# Проверка chain of trust онлайн
# https://dnsviz.net/d/example.com/dnssec/
# https://dnssec-analyzer.verisignlabs.com/
```

```
Key Rollover Timeline (Best Practices):
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  ZSK Rollover (Pre-Publish method):                             │
│  ├─ Day 0: Publish new ZSK (но ещё не подписывает)              │
│  ├─ Wait: TTL + propagation (обычно 1-4 дня)                    │
│  ├─ Day 4: Activate new ZSK, start signing                      │
│  ├─ Wait: TTL (для RRSIG propagation)                           │
│  └─ Day 8: Remove old ZSK                                       │
│                                                                 │
│  KSK Rollover (Double-KSK method):                              │
│  ├─ Day 0: Publish new KSK                                      │
│  ├─ Wait: RFC 5011 timing (45 дней) или                         │
│  │        Parent DS propagation (обычно 1 неделя)               │
│  ├─ Day 7+: Submit new DS to parent                             │
│  ├─ Wait: Parent TTL + verification                             │
│  └─ Day 14+: Remove old KSK                                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## DoH/DoT: практическая настройка

### Зачем шифровать DNS: история и контекст

**DNSSEC гарантирует подлинность ответа, но не скрывает сам запрос.** Когда вы спрашиваете DNS "какой IP у wikileaks.org?", этот вопрос виден всем на пути: вашему провайдеру, корпоративному IT-отделу, правительственным системам мониторинга.

**Это не паранойя — это документированная практика:**
- Провайдеры продают данные о DNS-запросах рекламным компаниям
- Корпорации мониторят, какие сайты посещают сотрудники
- Правительства используют DNS для цензуры и слежки
- Злоумышленники в публичных Wi-Fi перехватывают DNS для атак

**DNS over TLS (DoT)** и **DNS over HTTPS (DoH)** решают эту проблему, шифруя DNS-трафик. Но делают это по-разному, и выбор между ними — это компромисс между приватностью и контролем.

**DoT** использует отдельный порт 853. Это позволяет сетевым администраторам видеть, что происходит DNS-запрос (но не видеть его содержимое). Корпоративные firewall могут заблокировать DoT, если это противоречит политике безопасности.

**DoH** использует порт 443 — тот же, что и обычный HTTPS. DNS-запрос выглядит как обычный веб-трафик, и отличить его практически невозможно. Это обеспечивает максимальную приватность, но лишает сетевых администраторов возможности контролировать DNS.

**Критика DoH со стороны корпоративного мира:** IT-безопасники справедливо указывают, что DoH создаёт "слепые пятна" в мониторинге. Malware может использовать DoH для связи с командным сервером, и это останется незамеченным. Централизация DNS у нескольких крупных провайдеров (Cloudflare, Google) тоже вызывает опасения.

**Критика традиционного DNS со стороны privacy-сообщества:** Открытый DNS — это инструмент массовой слежки. Каждый DNS-запрос — это запись о том, какие сайты вы посещаете, когда и как часто.

**Правильный выбор зависит от контекста:**
- Личный компьютер дома → DoH для максимальной приватности
- Корпоративная сеть → DoT или централизованный DoH через корпоративный резолвер
- Публичный Wi-Fi → обязательно DoH или DoT

### Сравнение протоколов

| Аспект | DoT (DNS over TLS) | DoH (DNS over HTTPS) |
|--------|-------------------|---------------------|
| **Порт** | 853 (отдельный) | 443 (стандартный HTTPS) |
| **Блокировка** | Легко заблокировать | Сложно (выглядит как HTTPS) |
| **Latency** | Ниже (прямой TLS) | Выше (HTTP overhead) |
| **Интеграция** | Требует поддержки ОС | Работает в браузерах |
| **Корпоративный мониторинг** | Возможен (отдельный порт) | Затруднён |

### Windows 11/Server 2022+ настройка

```powershell
# Проверка поддержки DoH
Get-DnsClientDohServerAddress

# Добавление DoH сервера (Cloudflare)
Add-DnsClientDohServerAddress -ServerAddress "1.1.1.1" `
    -DohTemplate "https://cloudflare-dns.com/dns-query" `
    -AllowFallbackToUdp $False `
    -AutoUpgrade $True

# Добавление Quad9 с блокировкой malware
Add-DnsClientDohServerAddress -ServerAddress "9.9.9.9" `
    -DohTemplate "https://dns.quad9.net/dns-query" `
    -AllowFallbackToUdp $False `
    -AutoUpgrade $True

# Настройка сетевого адаптера
Set-DnsClientServerAddress -InterfaceIndex 12 -ServerAddresses "1.1.1.1","9.9.9.9"

# Group Policy (Windows 11 24H2+):
# Computer Configuration → Administrative Templates → Network → DNS Client
# → "Configure encrypted name resolution"
```

### Linux: systemd-resolved

```bash
# /etc/systemd/resolved.conf
[Resolve]
DNS=1.1.1.1#cloudflare-dns.com 9.9.9.9#dns.quad9.net
FallbackDNS=8.8.8.8#dns.google
DNSOverTLS=yes    # Включает DoT
#DNSSEC=yes       # Опционально (может сломать некоторые домены)

# Применить
sudo systemctl restart systemd-resolved

# Проверка
resolvectl status
resolvectl query example.com
```

### Linux: cloudflared (DoH proxy)

```bash
# Установка
curl -L https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 \
    -o /usr/local/bin/cloudflared
chmod +x /usr/local/bin/cloudflared

# Запуск как DNS proxy
cloudflared proxy-dns --port 5053 --upstream https://cloudflare-dns.com/dns-query

# Как systemd сервис
cat > /etc/systemd/system/cloudflared-dns.service << 'EOF'
[Unit]
Description=Cloudflare DNS over HTTPS proxy
After=network.target

[Service]
Type=simple
ExecStart=/usr/local/bin/cloudflared proxy-dns --port 53 --upstream https://cloudflare-dns.com/dns-query
Restart=on-failure

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl enable --now cloudflared-dns
```

### Браузеры: настройка DoH

```
Firefox (рекомендуется для privacy):
Settings → Privacy & Security → Enable secure DNS using:
├─ Increased Protection: Предпочитает DoH, fallback на системный DNS
├─ Max Protection: Только DoH, системный DNS игнорируется
└─ Provider: Cloudflare (default) | NextDNS | Custom

Chrome:
Settings → Privacy and security → Security → Use secure DNS
├─ With your current service provider (если ISP поддерживает)
└─ With: Cloudflare (1.1.1.1) | Google (8.8.8.8) | Custom

Safari (macOS/iOS):
Через профиль конфигурации или DNS settings в Network preferences
```

---

## Certificate Transparency: полное понимание

### Почему понадобилась прозрачность сертификатов

**Certificate Transparency (CT) — это ответ на серию катастрофических провалов системы сертификатов.**

До 2011 года мир PKI (Public Key Infrastructure) жил в иллюзии безопасности. Сотни удостоверяющих центров (Certificate Authorities, CA) могли выпускать сертификаты для любого домена, и никто не мог это проконтролировать. Если CA выпустит поддельный сертификат для google.com — как об этом узнать?

**Случай DigiNotar (2011):** Голландский CA был взломан. Злоумышленники выпустили более 500 поддельных сертификатов, включая сертификаты для Google, Yahoo, Skype и даже *.com (любой домен в .com!). Эти сертификаты использовались иранским правительством для слежки за гражданами. Взлом оставался незамеченным **недели**, пока разработчики Chrome случайно не обнаружили аномалию.

**Случай Comodo (2011):** Через скомпрометированного реселлера были выпущены поддельные сертификаты для Gmail, Yahoo Mail, Skype. Опять же — обнаружено случайно.

**Проблема была системной:** CA могли выпускать сертификаты в полной секретности. Не существовало публичного реестра, аудита или способа узнать, какие сертификаты выпущены для вашего домена. Владелец домена узнавал о поддельном сертификате только после атаки — если вообще узнавал.

**Certificate Transparency решает эту проблему радикально:** каждый сертификат должен быть публично записан в append-only лог. Эти логи криптографически защищены от модификации (технология Merkle Tree). Любой может проверить, какие сертификаты выпущены для любого домена.

**Результат:** если CA выпустит сертификат без записи в CT-лог, браузеры его отклонят. Если выпустит с записью — владелец домена может это обнаружить через мониторинг. Тайные сертификаты стали невозможны.

**С апреля 2018 года Chrome требует CT для всех публичных сертификатов.** Сертификат без SCT (Signed Certificate Timestamp) — подтверждения записи в лог — не будет принят браузером.

### Как работает CT

```
Certificate Transparency Ecosystem:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  1. CA получает запрос на сертификат                            │
│                                                                 │
│  2. CA создаёт precertificate                                   │
│     └─ Содержит все данные сертификата                          │
│     └─ Помечен как "poison" extension                           │
│                                                                 │
│  3. CA отправляет precertificate в CT logs                      │
│     └─ Минимум 2 независимых лога (Chrome/Safari requirement)   │
│                                                                 │
│  4. CT log возвращает SCT (Signed Certificate Timestamp)        │
│     └─ Обещание включить в лог в течение MMD (24 часа max)      │
│                                                                 │
│  5. CA выдаёт финальный сертификат с embedded SCTs              │
│     └─ SCT может быть: в сертификате, TLS extension, OCSP       │
│                                                                 │
│  6. Браузер проверяет SCT при TLS handshake                     │
│     └─ Chrome: 2+ SCTs от разных операторов                     │
│     └─ Safari: аналогичные требования                           │
│                                                                 │
│  7. Monitors сканируют CT logs                                  │
│     └─ Обнаруживают mis-issuance                                │
│     └─ Уведомляют владельцев доменов                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Мониторинг через crt.sh

```bash
# Web: https://crt.sh/?q=example.com

# CLI через curl
curl -s "https://crt.sh/?q=%.example.com&output=json" | \
    jq '.[] | {name: .name_value, issuer: .issuer_name, not_before: .not_before}'

# Найти все сертификаты для домена и subdomains
curl -s "https://crt.sh/?q=%.example.com&output=json" | \
    jq -r '.[].name_value' | sort -u

# SQL query (advanced)
# https://crt.sh/?q=%.example.com&exclude=expired
```

### Автоматический мониторинг

```yaml
# Пример: GitHub Actions для мониторинга CT
name: CT Log Monitor
on:
  schedule:
    - cron: '0 */6 * * *'  # Каждые 6 часов

jobs:
  monitor:
    runs-on: ubuntu-latest
    steps:
      - name: Check new certificates
        run: |
          curl -s "https://crt.sh/?q=%.example.com&output=json" | \
            jq '[.[] | select(.not_before > (now - 86400 | strftime("%Y-%m-%dT%H:%M:%S")))]' \
            > new_certs.json

          if [ $(jq length new_certs.json) -gt 0 ]; then
            echo "New certificates found!"
            cat new_certs.json
            # Отправить alert
          fi
```

### Сервисы мониторинга CT

| Сервис | Особенности | Цена |
|--------|-------------|------|
| **Cloudflare CT Monitoring** | Бесплатно для Cloudflare domains | Free |
| **Censys** | Мощный поиск, API | Freemium |
| **Facebook CT Monitor** | Уведомления о новых сертификатах | Free |
| **SSLMate Cert Spotter** | Email alerts, API | Free tier |

---

## OCSP Stapling: настройка

### Проблема отзыва сертификатов

**Что происходит, когда сертификат нужно отозвать?** Приватный ключ украден, сотрудник уволен, домен продан — причин много. Сертификат ещё не истёк, но ему нельзя доверять. Как браузер об этом узнает?

**Первое решение — CRL (Certificate Revocation Lists):** CA публикует список отозванных сертификатов. Браузер скачивает список и проверяет, есть ли там нужный сертификат. Проблема: списки огромные (миллионы записей), скачивать их при каждом соединении — нереально.

**Второе решение — OCSP (Online Certificate Status Protocol):** Браузер спрашивает CA напрямую: "Этот сертификат ещё валиден?" CA отвечает "да" или "нет". Это быстрее, чем скачивать весь CRL, но создаёт новые проблемы:

1. **Приватность:** CA видит, какие сайты вы посещаете. Каждый раз, когда вы открываете сайт с HTTPS, ваш браузер "звонит" в CA и говорит: "Пользователь с IP X.X.X.X сейчас заходит на Y.com"
2. **Производительность:** дополнительный запрос к CA — это дополнительная задержка (обычно 100-300ms)
3. **Надёжность:** если OCSP-сервер CA недоступен, что делать? Большинство браузеров используют "soft fail" — игнорируют ошибку и принимают сертификат. Это фактически обнуляет защиту.

**OCSP Stapling решает все три проблемы.** Сервер сам периодически запрашивает у CA подтверждение валидности своего сертификата и "прикрепляет" (staples) этот ответ к TLS handshake. Браузер получает подтверждение сразу от сервера, без дополнительных запросов.

**Результат:**
- **Приватность:** CA не знает, кто посещает сайт
- **Производительность:** нет дополнительного RTT
- **Надёжность:** сервер кэширует OCSP-ответ и может отдавать его, даже если CA временно недоступен

**Почему не все используют OCSP Stapling?** Нужна правильная настройка сервера. По умолчанию Nginx и Apache не включают stapling — его нужно явно настроить.

### Зачем нужен OCSP Stapling

```
Без OCSP Stapling:
┌────────┐    ┌────────┐    ┌────────┐
│ Client │───►│ Server │    │  OCSP  │
│        │◄───│        │    │Responder│
│        │────────────────►│        │
│        │◄────────────────│        │
└────────┘    └────────┘    └────────┘
  Проблемы:
  ├─ Дополнительный RTT для OCSP check
  ├─ Privacy: OCSP Responder видит какие сайты посещает клиент
  ├─ Reliability: если OCSP недоступен → soft-fail (игнорировать?)
  └─ Latency: особенно плохо на мобильных сетях

С OCSP Stapling:
┌────────┐    ┌────────┐    ┌────────┐
│ Client │───►│ Server │───►│  OCSP  │
│        │◄───│   +    │◄───│Responder│
│        │    │ stapled│    │        │
│        │    │response│    │        │
└────────┘    └────────┘    └────────┘
  Преимущества:
  ├─ Нет дополнительного RTT
  ├─ Privacy: OCSP Responder не знает о клиенте
  └─ Reliability: сервер кэширует OCSP response
```

### Nginx конфигурация

```nginx
server {
    listen 443 ssl http2;
    server_name example.com;

    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;

    # OCSP Stapling
    ssl_stapling on;
    ssl_stapling_verify on;

    # Важно: trusted certificate для проверки OCSP response
    # Для Let's Encrypt это chain (intermediate + root)
    ssl_trusted_certificate /etc/letsencrypt/live/example.com/chain.pem;

    # Resolver для OCSP запросов
    resolver 1.1.1.1 8.8.8.8 valid=300s;
    resolver_timeout 5s;
}
```

### Apache конфигурация

```apache
# В глобальной секции (/etc/apache2/mods-enabled/ssl.conf)
SSLStaplingCache shmcb:/var/run/apache2/ssl_stapling_cache(128000)

# В VirtualHost
<VirtualHost *:443>
    ServerName example.com

    SSLEngine on
    SSLCertificateFile /etc/letsencrypt/live/example.com/cert.pem
    SSLCertificateKeyFile /etc/letsencrypt/live/example.com/privkey.pem
    SSLCertificateChainFile /etc/letsencrypt/live/example.com/chain.pem

    # OCSP Stapling
    SSLUseStapling on
    SSLStaplingResponderTimeout 5
    SSLStaplingReturnResponderErrors off
</VirtualHost>
```

### Проверка OCSP Stapling

```bash
# OpenSSL (с SNI!)
echo | openssl s_client -connect example.com:443 -servername example.com -status 2>/dev/null | \
    grep -A 17 "OCSP Response"

# Ожидаемый вывод:
# OCSP Response Status: successful (0x0)
# ...
# Cert Status: good

# Если "OCSP response: no response sent" → stapling не работает
```

### OCSP Must-Staple: изменения 2025

```
⚠️ ВАЖНО: Let's Encrypt прекращает поддержку OCSP Must-Staple!

Timeline:
├─ Декабрь 2024: Анонс deprecation
├─ Май 7, 2025: Новые сертификаты БЕЗ Must-Staple extension
└─ 2025+: OCSP в целом уходит, CRLite приходит на замену

Что делать:
├─ Не включать Must-Staple для новых сертификатов
├─ При renewal убрать --must-staple флаг из certbot
└─ Следить за развитием CRLite в браузерах
```

---

## CAA Records: контроль над сертификатами

### Зачем нужен контроль над выпуском сертификатов

**Проблема:** любой из сотен удостоверяющих центров может выпустить сертификат для любого домена. Если ваша компания использует DigiCert, это не мешает кому-то запросить сертификат для вашего домена у Let's Encrypt — и получить его.

**Почему это плохо?**
1. **Внутренний контроль:** крупные компании хотят знать, кто и когда запрашивает сертификаты для их доменов
2. **Соответствие политикам:** некоторые индустрии требуют использования определённых CA
3. **Защита от ошибок:** сотрудник может случайно запросить сертификат у "неправильного" CA
4. **Защита от атак:** если злоумышленник получит контроль над DNS (даже временно), он не сможет получить сертификат от неавторизованного CA

**CAA (Certification Authority Authorization)** — это DNS-запись, которая указывает, какие CA имеют право выпускать сертификаты для домена. Это не техническое ограничение (CA физически может выпустить сертификат), а **обязательство:** с 2017 года все публичные CA обязаны проверять CAA перед выпуском сертификата.

**Как это работает на практике:**
1. Вы добавляете CAA-запись в DNS: `example.com. CAA 0 issue "letsencrypt.org"`
2. Когда кто-то запрашивает сертификат для example.com у DigiCert, DigiCert проверяет CAA
3. Видит, что разрешён только letsencrypt.org, и **отказывает** в выпуске

**Важно:** CAA работает только если все CA следуют правилам. Злоумышленник, создавший свой CA, может игнорировать CAA. Поэтому CAA — это защита от легитимных ошибок и compliance-инструмент, но не абсолютная защита.

**CAA + DNSSEC = надёжная комбинация.** Без DNSSEC атакующий может подменить CAA-запись через DNS spoofing. С DNSSEC — подмена невозможна.

### Структура CAA записи

```
CAA Record Format:
[flag] [tag] [value]

Флаги:
├─ 0: Non-critical (CA может игнорировать неизвестные tags)
└─ 128: Critical (CA ДОЛЖЕН понимать tag, иначе отказать)

Tags:
├─ issue: Разрешает выдачу обычных сертификатов
├─ issuewild: Разрешает выдачу wildcard сертификатов
├─ iodef: URL для уведомлений о нарушениях
└─ issuemail: Для S/MIME сертификатов (с Sep 2024)
```

### Практические примеры

```bash
# Только Let's Encrypt может выдавать сертификаты
example.com. CAA 0 issue "letsencrypt.org"

# Let's Encrypt + DigiCert для разных целей
example.com. CAA 0 issue "letsencrypt.org"
example.com. CAA 0 issue "digicert.com"

# Wildcard только от Let's Encrypt
example.com. CAA 0 issuewild "letsencrypt.org"

# Запретить все сертификаты (например, для internal subdomain)
internal.example.com. CAA 0 issue ";"

# Уведомления о нарушениях
example.com. CAA 0 iodef "mailto:security@example.com"
example.com. CAA 0 iodef "https://example.com/caa-report"

# Ограничение метода валидации (advanced)
# Только DNS-01 challenge разрешён
example.com. CAA 0 issue "letsencrypt.org; validationmethods=dns-01"

# Account-level restriction (привязка к конкретному ACME аккаунту)
example.com. CAA 0 issue "letsencrypt.org; accounturi=https://acme-v02.api.letsencrypt.org/acme/acct/123456"
```

### Проверка CAA

```bash
# dig
dig example.com CAA +short
# 0 issue "letsencrypt.org"

# Онлайн проверка
# https://caatest.co.uk/
# https://www.sslshopper.com/caa-record-checker.html
```

### CAA Best Practices

```
✅ Рекомендации:
├─ Всегда устанавливайте CAA для production доменов
├─ Используйте iodef для получения уведомлений
├─ Комбинируйте с DNSSEC для защиты от DNS spoofing
├─ Документируйте разрешённые CA для команды
└─ Перед сменой CA — обновите CAA заранее

❌ Типичные ошибки:
├─ Забыли добавить issuewild → wildcard не выдаётся
├─ Опечатка в имени CA → сертификат отклонён
├─ CAA на subdomain конфликтует с parent
└─ Не обновили CAA перед сменой CA
```

---

## DNS атаки и защита

### Почему DNS — любимая цель атакующих

**DNS — это "телефонная книга интернета", и контроль над ней даёт огромную власть.** Если вы можете изменить ответ DNS для банка, вы можете перенаправить всех клиентов этого банка на фальшивый сайт — и они даже не заметят (URL в адресной строке будет правильным).

**DNS атаки особенно опасны по нескольким причинам:**

1. **Невидимость:** пользователь не видит, какой IP вернул DNS. Он видит только доменное имя.
2. **Масштаб:** взломав один резолвер, вы влияете на тысячи или миллионы пользователей.
3. **Persistence:** отравленный кэш может жить часами или днями.
4. **Upstream effect:** если отравить кэш рекурсивного резолвера, все его клиенты получат поддельные данные.

**Три главных вектора атак на DNS:**
- **Cache Poisoning:** заставить резолвер запомнить неправильный IP для домена
- **DNS Rebinding:** обойти same-origin policy браузера через DNS
- **DNS Amplification:** использовать DNS-серверы для DDoS-атак

Рассмотрим каждый подробнее.

### DNS Rebinding Attack

**DNS Rebinding — это атака, которая обходит защиту браузера через DNS.** Это одна из самых элегантных и опасных атак, потому что она эксплуатирует не баг, а фундаментальное допущение в дизайне веб-безопасности.

**Контекст: Same-Origin Policy.** Браузеры не позволяют JavaScript с одного сайта делать запросы к другому сайту (за редкими исключениями). Это защищает от того, чтобы malicious.com мог читать вашу почту на gmail.com.

**Ключевое допущение:** браузер определяет "происхождение" (origin) по доменному имени. Если JavaScript загружен с evil.com — он может делать запросы к evil.com, но не к google.com.

**Атака DNS Rebinding эксплуатирует это допущение:**

```
DNS Rebinding Attack Flow:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  1. Жертва посещает malicious.com                               │
│     DNS: malicious.com → 1.2.3.4 (attacker's IP), TTL=1s        │
│                                                                 │
│  2. Malicious JavaScript загружается в браузер                  │
│     └─ Скрипт ждёт истечения DNS TTL                            │
│                                                                 │
│  3. DNS rebinding:                                              │
│     DNS: malicious.com → 192.168.1.1 (internal IP!)             │
│     └─ Теперь same-origin policy НЕ блокирует                   │
│                                                                 │
│  4. JavaScript делает запросы к внутренней сети                 │
│     └─ Router admin panel, IoT devices, internal APIs           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

Защита:
├─ DNS-level:
│   ├─ Resolver фильтрует private IP в ответах (RFC 1918)
│   └─ Local DNS server блокирует rebinding
│
├─ Application-level:
│   ├─ Проверка Host header на сервере
│   ├─ HTTPS на всех internal сервисах
│   └─ Authentication даже для local services
│
├─ Browser-level:
│   ├─ DNS pinning (Chrome, Firefox)
│   └─ Private Network Access (в разработке)
│
└─ Network-level:
    ├─ Firewall rules на local network
    └─ Strict CORS policies
```

### DNS Cache Poisoning: современные атаки

```
Классический Cache Poisoning (Kaminsky Attack, 2008):
┌─────────────────────────────────────────────────────────────────┐
│ 1. Атакующий отправляет query для random.example.com            │
│ 2. Одновременно шлёт поддельные responses с угаданным Query ID  │
│ 3. Если угадал → resolver кэширует поддельный NS для example.com│
│ 4. Все последующие queries для *.example.com → к атакующему     │
└─────────────────────────────────────────────────────────────────┘

Mitigation (современный стандарт):
├─ Source Port Randomization (не только Query ID)
├─ 0x20 encoding (рандомизация регистра в запросе)
├─ DNSSEC — криптографическая проверка
├─ DNS Cookies (RFC 7873)
└─ Query Name Minimization (RFC 7816)

Новые атаки (2024):
├─ SAD DNS (Side-channel AttackeD DNS) — обход port randomization
├─ NXNSAttack — amplification через delegation
└─ MCP DNS Rebind — атаки на AI/LLM инфраструктуру
```

### DNS Amplification/DDoS

```bash
# Проверка: ваш DNS не используется для amplification?
dig +short txt open-resolvers.net

# Если ваш resolver публичный:
# 1. Ограничьте recursion только для trusted networks
# 2. Rate limiting (Response Rate Limiting - RRL)
# 3. Мониторинг аномального трафика

# BIND конфигурация для защиты
options {
    recursion yes;
    allow-recursion { trusted-networks; };

    # Response Rate Limiting
    rate-limit {
        responses-per-second 15;
        window 5;
    };
};
```

---

## TLS 1.3 0-RTT: риски и mitigation

### Компромисс между скоростью и безопасностью

**TLS 1.3 — это огромный шаг вперёд в безопасности,** но одна его функция — 0-RTT (Zero Round-Trip Time) — представляет собой осознанный компромисс, который важно понимать.

**Проблема, которую решает 0-RTT:** обычный TLS handshake требует минимум 1-2 RTT (round-trip time). Для пользователя в Москве, который подключается к серверу в США, это 150-300ms только на установку соединения — ещё до передачи первого байта данных.

**Для мобильных пользователей это критично:** на нестабильном 3G RTT может быть 500ms+. Если пользователь часто теряет соединение (входит в метро, переходит между Wi-Fi и LTE), каждое переподключение — это потерянные секунды.

**0-RTT позволяет отправить данные сразу в первом пакете.** Клиент использует ключ от предыдущей сессии, чтобы зашифровать данные и отправить их вместе с ClientHello. Сервер может расшифровать и обработать запрос ещё до завершения handshake.

**Но есть цена:** 0-RTT данные не защищены от replay-атак. Злоумышленник может записать зашифрованный пакет и отправить его серверу повторно. TLS не может это предотвратить на уровне протокола — потому что для replay protection нужен server random, а он появляется только после 0-RTT.

**Практический сценарий атаки:**
1. Пользователь отправляет 0-RTT запрос: POST /transfer?amount=1000&to=alice
2. Атакующий (например, на публичном Wi-Fi) записывает зашифрованный пакет
3. Атакующий отправляет этот пакет серверу 10 раз
4. Если сервер не защищён — деньги переведутся 10 раз

**Почему это не катастрофа:** атака работает только против non-idempotent операций, только если приложение не реализует собственную защиту, и только в узком временном окне. Но это достаточно серьёзно, чтобы требовать внимания.

### Как работает 0-RTT

```
TLS 1.3 0-RTT Resume:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│    Client                                              Server   │
│       │                                                   │     │
│       │ ─── ClientHello + early_data ─────────────────────►     │
│       │     • PSK identity (from previous session)        │     │
│       │     • Application Data (encrypted with PSK)       │     │
│       │                                                   │     │
│       │ ◄── ServerHello + Finished ───────────────────────│     │
│       │                                                   │     │
│    ═══╧═══════════════════════════════════════════════════╧═══  │
│            0-RTT: данные отправлены в первом же пакете!         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

Преимущества:
├─ Минимальная latency для повторных соединений
├─ Отлично для мобильных сетей с высоким RTT
└─ Ускоряет первый HTTP request
```

### Уязвимость к Replay Attack

```
Replay Attack Scenario:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  1. Легитимный пользователь отправляет 0-RTT запрос:            │
│     POST /transfer?amount=1000&to=alice                         │
│                                                                 │
│  2. Атакующий (на пути трафика) записывает encrypted 0-RTT      │
│                                                                 │
│  3. Атакующий повторно отправляет этот 0-RTT пакет серверу      │
│     └─ Если сервер не защищён → транзакция выполнится дважды!   │
│                                                                 │
│  Почему это возможно:                                           │
│  ├─ 0-RTT data не имеет forward secrecy                         │
│  ├─ Нет server random для защиты от replay                      │
│  └─ TLS сам по себе НЕ защищает от replay для 0-RTT             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Защита от 0-RTT Replay

```
Стратегии защиты:

1. Отключить 0-RTT (самый безопасный):
   # Nginx
   ssl_early_data off;

   # Apache (mod_ssl не поддерживает 0-RTT по умолчанию)

2. Только idempotent операции в 0-RTT:
   ├─ GET запросы — безопасно
   ├─ HEAD, OPTIONS — безопасно
   └─ POST/PUT/DELETE — отклонять в early data

3. Application-level replay protection:
   ├─ Strike register (хранить использованные tickets)
   ├─ Unique nonce в каждом запросе
   └─ Ограничение времени действия early data

4. Использовать Early-Data header:
   # Nginx добавляет header для backend
   proxy_set_header Early-Data $ssl_early_data;

   # Backend может отклонить:
   if request.headers.get('Early-Data') == '1':
       if request.method != 'GET':
           return 425 Too Early

5. Cloudflare подход:
   └─ Cf-Replay-Nonce header для уникальной идентификации
```

### Nginx конфигурация для безопасного 0-RTT

```nginx
server {
    listen 443 ssl http2;

    ssl_early_data on;  # Включаем 0-RTT

    # Передаём информацию о early data backend'у
    proxy_set_header Early-Data $ssl_early_data;

    # Для критичных endpoints — отклоняем early data
    location /api/payment {
        if ($ssl_early_data = 1) {
            return 425;  # Too Early
        }
        proxy_pass http://backend;
    }

    # Для GET запросов — разрешаем early data
    location /api/read {
        proxy_pass http://backend;
    }
}
```

---

## Практические инструменты проверки

### Комплексная проверка DNS

```bash
# 1. DNS resolution и timing
dig +stats example.com

# 2. DNSSEC validation
dig +dnssec +multi example.com
delv @8.8.8.8 example.com    # Если есть BIND 9.10+

# 3. Все DNS записи
dig example.com ANY +noall +answer

# 4. Проверка CAA
dig example.com CAA +short

# 5. Проверка через разные resolvers
for ns in 1.1.1.1 8.8.8.8 9.9.9.9; do
    echo "=== $ns ==="
    dig @$ns example.com +short
done
```

### Комплексная проверка TLS

```bash
# 1. Базовая проверка сертификата
echo | openssl s_client -connect example.com:443 -servername example.com 2>/dev/null | \
    openssl x509 -noout -dates -subject -issuer

# 2. Проверка chain
echo | openssl s_client -connect example.com:443 -servername example.com -showcerts 2>/dev/null

# 3. Проверка cipher suites
nmap --script ssl-enum-ciphers -p 443 example.com

# 4. OCSP Stapling
echo | openssl s_client -connect example.com:443 -servername example.com -status 2>/dev/null | \
    grep -A 5 "OCSP Response"

# 5. Certificate Transparency
echo | openssl s_client -connect example.com:443 2>/dev/null | \
    openssl x509 -text | grep -A 3 "CT Precertificate"

# 6. Полный аудит — testssl.sh
git clone https://github.com/drwetter/testssl.sh.git
./testssl.sh/testssl.sh example.com
```

### Онлайн инструменты

| Инструмент | URL | Назначение |
|------------|-----|------------|
| **SSL Labs** | ssllabs.com/ssltest | TLS конфигурация (A+ рейтинг) |
| **DNS Viz** | dnsviz.net | DNSSEC chain visualization |
| **crt.sh** | crt.sh | Certificate Transparency search |
| **Security Headers** | securityheaders.com | HTTP security headers |
| **Hardenize** | hardenize.com | Комплексный security audit |

---

## Источники

| # | Источник | Тип | Вклад |
|---|----------|-----|-------|
| 1 | [Cloudflare DNSSEC](https://www.cloudflare.com/learning/dns/dnssec/how-dnssec-works/) | Docs | ZSK/KSK концепции |
| 2 | [ISC BIND DNSSEC Policy](https://kb.isc.org/docs/dnssec-key-and-signing-policy) | Official | Key management |
| 3 | [Glucn: Mastering Key Management](https://glucn.com/posts/2024-03-05-key-management-in-dnssec) | Blog | Rollover best practices |
| 4 | [Microsoft DoH Client](https://learn.microsoft.com/en-us/windows-server/networking/dns/doh-client-support) | Official | Windows DoH setup |
| 5 | [Cloudflare DoH Docs](https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/) | Official | DoH configuration |
| 6 | [Certificate Transparency](https://certificate.transparency.dev/) | Official | CT ecosystem |
| 7 | [Let's Encrypt CT Logs](https://letsencrypt.org/docs/ct-logs/) | Official | CT requirements |
| 8 | [DigitalOcean OCSP Stapling](https://www.digitalocean.com/community/tutorials/how-to-configure-ocsp-stapling-on-apache-and-nginx) | Tutorial | Nginx/Apache config |
| 9 | [SSLMate OCSP Blog](https://sslmate.com/blog/post/ocsp_stapling_in_apache_and_nginx) | Blog | OCSP troubleshooting |
| 10 | [Let's Encrypt CAA](https://letsencrypt.org/docs/caa/) | Official | CAA records |
| 11 | [RFC 8659](https://www.rfc-editor.org/rfc/rfc8659.html) | RFC | CAA specification |
| 12 | [Palo Alto DNS Rebinding](https://unit42.paloaltonetworks.com/dns-rebinding/) | Security | Attack analysis |
| 13 | [Cloudflare 0-RTT](https://blog.cloudflare.com/introducing-0-rtt/) | Blog | 0-RTT implementation |
| 14 | [TLS 1.3 0-RTT Security](https://github.com/tlswg/tls13-spec/issues/1001) | GitHub | Replay attack discussion |
| 15 | [crt.sh](https://crt.sh/) | Tool | CT monitoring |

---

## Связанные темы

- [[networking-overview]] — карта раздела
- [[network-transport-layer]] — TCP/UDP/QUIC, на которых работает TLS
- [[network-http-evolution]] — HTTPS = HTTP + TLS
- [[web-security-owasp]] — TLS как часть web security
- [[authentication-authorization]] — TLS client certificates

---

**Резюме:** DNS превращает имена в IP-адреса через иерархическую распределённую систему. TLS обеспечивает конфиденциальность, целостность и аутентификацию соединений. TLS 1.3 — современный стандарт с 1-RTT handshake и обязательным forward secrecy. Let's Encrypt демократизировал HTTPS через бесплатные автоматические сертификаты. DoH/DoT защищают DNS-запросы от прослушивания. Для production: всегда HTTPS, автоматическое обновление сертификатов, мониторинг expiration.

---

*Последнее обновление: 2026-01-09 — Добавлены педагогические секции: 5 аналогий (DNS-телефонная книга, TLS-конверт с печатью, сертификат-паспорт, DNS-резолюция, TLS handshake-рукопожатие), 6 типичных ошибок DNS/TLS с диагностикой, 5 ментальных моделей для понимания безопасности интернета*
