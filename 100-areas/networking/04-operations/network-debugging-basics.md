---
title: "Network Debugging Basics"
created: 2025-12-26
modified: 2025-12-26
type: tutorial
status: published
level: junior
tags:
  - topic/networking
  - debugging
  - troubleshooting
  - devtools
  - cli
  - type/tutorial
  - level/beginner
related:
  - "[[network-tools-reference]]"
  - "[[network-tcpdump-wireshark]]"
  - "[[ios-debugging]]"
---

# Network Debugging Basics

> Системный подход к диагностике сетевых проблем для разработчиков

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **Сетевые основы** | Что такое IP, DNS, TCP | [[network-fundamentals-for-developers]] |
| **Командная строка** | Запуск утилит из терминала | Bash basics |
| **Браузер DevTools** | Вкладка Network | F12 в браузере |

### Для кого этот материал

| Уровень | Подходит? | Рекомендация |
|---------|-----------|--------------|
| **Новичок** | ✅ Да | Критически важный навык |
| **Intermediate** | ✅ Да | Системный подход |
| **Advanced** | ⏭️ Перейти к | [[network-troubleshooting-advanced]] |

### Терминология для новичков

> 💡 **Network Debugging** = поиск причины "почему не работает сеть". Системный подход экономит часы бессмысленного гугления.

| Термин | Значение | Аналогия для новичка |
|--------|----------|---------------------|
| **ping** | Проверка "живой ли хост" | **Стук в дверь** — "есть кто дома?" |
| **traceroute** | Маршрут до хоста | **GPS-трек** — через какие города едет посылка |
| **dig** | DNS-запрос | **Позвонить в справочную** — узнать IP |
| **curl** | HTTP-запрос из консоли | **Позвонить в службу поддержки** — что ответит сервер |
| **netstat** | Список открытых соединений | **Список всех звонков** — кто с кем общается |
| **tcpdump** | Захват пакетов | **Прослушка разговоров** — что реально передаётся |
| **nmap** | Сканер портов | **Проверка всех дверей** — какие порты открыты |
| **telnet** | Проверка TCP-порта | **Попробовать позвонить** — порт отвечает? |
| **OSI Model** | 7 уровней сети | **Этажи здания** — проблема на каком этаже? |
| **Timeout** | Время ожидания ответа | **"Не берут трубку"** — сервер не отвечает |

---

## Часть 1: Интуиция без кода

> Прежде чем запускать команды, построим ментальные образы для понимания сетевой диагностики

### Аналогия 1: Layer-by-layer debugging как приём у врача

**Почему врачи не начинают с МРТ:**
```
Пациент: "Доктор, у меня болит голова"

ПЛОХОЙ ВРАЧ:                    ХОРОШИЙ ВРАЧ:
"Давайте сразу МРТ мозга!"      "Давайте по порядку..."
                                 1. Давление? (базовое)
                                 2. Температура?
                                 3. Когда ели/пили?
                                 4. Стресс?
                                 5. И только потом МРТ

Результат:                      Результат:
$2000 и ничего не нашли         "Вы просто обезвожены"
```

**Network debugging работает так же:**
```
┌─────────────────────────────────────────────────────┐
│  "API не отвечает"                                  │
│                                                     │
│  ПЛОХОЙ ПОДХОД:                                     │
│  → Сразу смотрим логи сервера                       │
│  → Дебажим код приложения                           │
│  → Меняем конфигурацию                              │
│  → Час потерян, проблема в VPN                      │
│                                                     │
│  ХОРОШИЙ ПОДХОД (снизу вверх):                      │
│  → ping IP (2 секунды) — работает? ✓               │
│  → telnet на порт (2 секунды) — timeout! ✗         │
│  → Ага, firewall или сервис не запущен             │
│  → Проблема найдена за 30 секунд                   │
└─────────────────────────────────────────────────────┘
```

---

### Аналогия 2: Ping как стук в дверь

**Что делает ping:**
```
Вы ─────── СТУК-СТУК ───────► Дверь (хост)
                                │
                                ▼
                         "Кто там?" (ICMP Echo Reply)
                                │
Вы ◄─────── ОТВЕТ ──────────────┘

Время между стуком и ответом = latency (задержка)
```

**Три результата ping:**
```
┌─────────────────────────────────────────────────────┐
│  РЕЗУЛЬТАТ               │  ЧТО ЗНАЧИТ              │
├─────────────────────────────────────────────────────┤
│  64 bytes from X:        │  Хост жив, отвечает      │
│  time=25ms               │  Задержка 25мс           │
├─────────────────────────────────────────────────────┤
│  Request timeout         │  Нет ответа              │
│                          │  (ICMP блокируется ИЛИ   │
│                          │   хост недоступен)       │
├─────────────────────────────────────────────────────┤
│  Destination unreachable │  Маршрутизатор говорит:  │
│  No route to host        │  "Не знаю как туда       │
│                          │   доставить"             │
└─────────────────────────────────────────────────────┘

ВАЖНО: Многие серверы блокируют ping!
       Нет ответа ping ≠ хост недоступен
       Проверяй telnet на известный порт (80, 443)
```

---

### Аналогия 3: Traceroute как GPS-трекинг посылки

**Когда вы заказываете посылку:**
```
Ваш компьютер                                  Сервер
      │                                           │
      │ → Москва → Франкфурт → Амстердам →       │
      └───────────────────────────────────────────┘

Traceroute показывает ВСЕ остановки посылки (пакета)
```

**Как читать traceroute:**
```
$ traceroute google.com

 1  192.168.1.1     1.2 ms   ← Ваш роутер
 2  10.0.0.1       12.3 ms   ← Провайдер (первый hop)
 3  * * *                    ← Не отвечает (ICMP заблокирован)
 4  72.14.194.226  25.1 ms   ← Магистральный роутер
 5  142.250.66.78  28.4 ms   ← Google edge

┌─────────────────────────────────────────────────────┐
│  ПРАВИЛО ИНТЕРПРЕТАЦИИ:                             │
│                                                     │
│  * * * на промежуточном hop — НОРМАЛЬНО             │
│  (роутер просто не отвечает на ICMP)                │
│                                                     │
│  * * * на ПОСЛЕДНЕМ hop — ПРОБЛЕМА                  │
│  (пакеты не доходят до цели)                        │
│                                                     │
│  Резкий скачок latency на hop N — ПРОБЛЕМА ТАМ      │
│  (перегруженный роутер или плохой канал)            │
└─────────────────────────────────────────────────────┘
```

---

### Аналогия 4: Три типа неудачных звонков

**Connection Refused — "Занято, перезвоните":**
```
┌─────────────────────────────────────────────────────┐
│  Вы: *звоните*                                      │
│  Телефон: БИП-БИП-БИП (мгновенно)                   │
│                                                     │
│  Что произошло:                                     │
│  • Телефон существует и работает                    │
│  • Но АБОНЕНТ не отвечает (сервис не запущен)       │
│  • Или занят (порт закрыт)                          │
│                                                     │
│  Подсказка: МГНОВЕННЫЙ ответ                        │
│  Проблема на: ХОСТЕ (сервис, порт, локальный FW)    │
└─────────────────────────────────────────────────────┘
```

**Timeout — "Гудки идут, никто не берёт":**
```
┌─────────────────────────────────────────────────────┐
│  Вы: *звоните*                                      │
│  Телефон: *тишина... 30 секунд... тишина...*        │
│  Автоответчик: "Абонент недоступен"                 │
│                                                     │
│  Что произошло:                                     │
│  • Звонок ушёл, но НЕТ ОТВЕТА                       │
│  • Может firewall "съел" пакет                      │
│  • Может хост завис                                 │
│  • Может пакеты теряются по пути                    │
│                                                     │
│  Подсказка: ДОЛГОЕ ожидание (15-120 сек)            │
│  Проблема на: ПУТИ (firewall, сеть, DROP policy)    │
└─────────────────────────────────────────────────────┘
```

**No Route — "Номер не существует":**
```
┌─────────────────────────────────────────────────────┐
│  Вы: *звоните*                                      │
│  Оператор: "Набранный номер не существует"          │
│  (мгновенный ответ, но НЕ от абонента)              │
│                                                     │
│  Что произошло:                                     │
│  • Ваш "телефон" не знает как позвонить туда        │
│  • Нет маршрута в routing table                     │
│  • VPN не подключен                                 │
│  • Gateway недоступен                               │
│                                                     │
│  Подсказка: БЫСТРЫЙ ответ от ПОСРЕДНИКА             │
│  Проблема на: ВАШЕЙ СТОРОНЕ (routing, VPN, gateway) │
└─────────────────────────────────────────────────────┘
```

---

### Аналогия 5: Browser DevTools как рентген HTTP

**Что видит пользователь:**
```
"Страница не загружается"
"Ошибка сети"
"Что-то пошло не так"

   😕 Бесполезно для debugging
```

**Что видит разработчик с DevTools:**
```
┌─────────────────────────────────────────────────────┐
│  Network Tab — "рентгеновский снимок" запроса       │
│                                                     │
│  Request:                                           │
│  ┌─────────────────────────────────────────────┐    │
│  │ GET /api/users HTTP/2                       │    │
│  │ Host: api.example.com                       │    │
│  │ Authorization: Bearer eyJ...                │    │
│  └─────────────────────────────────────────────┘    │
│                                                     │
│  Response:                                          │
│  ┌─────────────────────────────────────────────┐    │
│  │ HTTP/2 401 Unauthorized                     │    │
│  │ WWW-Authenticate: Bearer error="invalid..."│    │
│  └─────────────────────────────────────────────┘    │
│                                                     │
│  Timing:                                            │
│  ┌─────────────────────────────────────────────┐    │
│  │ DNS:     0.5ms   ▓                          │    │
│  │ Connect: 25ms    ▓▓▓▓▓                      │    │
│  │ TLS:     50ms    ▓▓▓▓▓▓▓▓▓▓                 │    │
│  │ TTFB:    200ms   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓       │    │
│  │ Download: 5ms    ▓                          │    │
│  └─────────────────────────────────────────────┘    │
│                                                     │
│  Теперь ясно: токен истёк, TTFB высокий (backend)  │
└─────────────────────────────────────────────────────┘
```

---

## Часть 2: Почему это сложно

> 6 типичных ошибок при сетевой диагностике

### Ошибка 1: Прыгать сразу на L7 без проверки L3

**СИМПТОМ:**
```
"API не отвечает"
    │
    ▼
Смотрим логи сервера... пусто
    │
    ▼
Дебажим код приложения... всё ок
    │
    ▼
Перезапускаем контейнеры... не помогает
    │
    ▼
2 часа спустя: "А, у меня VPN отвалился"
```

**ПОЧЕМУ ЭТО НЕПРАВИЛЬНО:**
```
Если L3 не работает (нет маршрута до хоста),
то L7 (HTTP, логи, код) НИКОГДА не покажут проблему.

Вы ищете под фонарём, а ключи лежат в темноте.
```

**РЕШЕНИЕ:**
```bash
# ВСЕГДА начинай с L3
ping 8.8.8.8              # Интернет вообще есть?
ping api.example.com      # Хост доступен?

# Только потом L4
nc -zv api.example.com 443    # Порт открыт?

# И только потом L7
curl -v https://api.example.com/health
```

---

### Ошибка 2: Гуглить ошибку вместо системной диагностики

**СИМПТОМ:**
```
Ошибка: "ECONNREFUSED"
    │
    ▼
Google: "ECONNREFUSED node.js"
    │
    ▼
Stack Overflow: "Try setting timeout to 60000"
    │
    ▼
Не помогло
    │
    ▼
Google: "ECONNREFUSED docker"
    │
    ▼
Stack Overflow: "Rebuild your containers"
    │
    ▼
Час потерян на случайные советы
```

**ПОЧЕМУ ЭТО НЕПРАВИЛЬНО:**
```
ECONNREFUSED — это СИМПТОМ, не диагноз.
Причин может быть десяток:
• Сервис не запущен
• Порт неправильный
• Firewall блокирует
• Сервис слушает на localhost

Stack Overflow не знает ВАШУ ситуацию.
```

**РЕШЕНИЕ:**
```bash
# 1. Где находится сервис?
dig api.example.com +short
# → 10.0.1.5

# 2. Порт открыт?
nc -zv 10.0.1.5 8080
# → Connection refused

# 3. НА СЕРВЕРЕ: сервис слушает?
ss -tuln | grep 8080
# → ПУСТО = сервис не запущен

# 4. Запускаем сервис, проблема решена
# Без единого запроса в Google
```

---

### Ошибка 3: Путать Connection Refused с Timeout

**СИМПТОМ:**
```
"Connection refused"        "Timeout"
        │                        │
        └────────┬───────────────┘
                 │
        "Наверное firewall"
                 │
        Час ищем правила в iptables
                 │
        Проблема была в другом месте
```

**ПОЧЕМУ ЭТО ВАЖНО:**
```
┌─────────────────────────────────────────────────────┐
│                                                     │
│  Connection Refused (мгновенный ответ)              │
│  ═══════════════════════════════════                │
│  • Пакет ДОШЁЛ до хоста                             │
│  • Хост ОТВЕТИЛ "порт закрыт"                       │
│  • Проблема: сервис, локальный firewall REJECT      │
│  • Где искать: НА СЕРВЕРЕ                           │
│                                                     │
├─────────────────────────────────────────────────────┤
│                                                     │
│  Timeout (долгое ожидание)                          │
│  ═════════════════════════                          │
│  • Пакет ушёл в никуда                              │
│  • Ответа НЕТ                                       │
│  • Проблема: firewall DROP, сеть, маршрутизация     │
│  • Где искать: НА ПУТИ (не на сервере!)             │
│                                                     │
└─────────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:**
```
Засекай ВРЕМЯ ответа:

< 100ms + "refused"  → Хост отвечает, ищи на сервере
> 15 sec + "timeout" → Пакеты теряются, ищи в сети/firewall
```

---

### Ошибка 4: Забывать про DNS

**СИМПТОМ:**
```
"Сайт не работает!"
    │
    ▼
curl https://mysite.com
# → Could not resolve host

"Сервер упал? Звоним в поддержку!"
    │
    ▼
Сервер работает отлично...
    │
    ▼
Через час: "DNS запись устарела / NS сервер лежит"
```

**ПОЧЕМУ DNS — ЧАСТАЯ ПРИЧИНА:**
```
DNS — первый шаг ЛЮБОГО сетевого запроса.
Если DNS не работает — ничего не работает.

Типичные проблемы:
• DNS propagation (обновили запись, ещё не разъехалось)
• Кэш локальный (старый IP в кэше)
• NS сервер недоступен
• Typo в домене
```

**РЕШЕНИЕ:**
```bash
# ВСЕГДА проверяй DNS отдельно

# 1. Что говорит DNS?
dig mysite.com +short
# → 93.184.216.34

# 2. Этот IP правильный?
# (сверь с ожидаемым)

# 3. Можно достучаться до IP напрямую?
curl -v http://93.184.216.34 -H "Host: mysite.com"

# 4. Если IP работает, но домен нет → DNS кэш
# macOS: sudo dscacheutil -flushcache
# Linux: sudo systemd-resolve --flush-caches
```

---

### Ошибка 5: Не проверять Security Groups в облаке

**СИМПТОМ:**
```
Развернул сервис в AWS/GCP/Azure
Локально всё работает
Извне — timeout

"Наверное проблема в коде?"
    │
    ▼
3 часа дебага кода
    │
    ▼
Проблема: Security Group не разрешает порт 8080
```

**ПОЧЕМУ ЭТО ПРОПУСКАЮТ:**
```
Security Groups — это "невидимый" firewall:
• Не показывается в iptables на сервере
• Не логируется по умолчанию
• Работает на уровне hypervisor
• Легко забыть при создании инстанса
```

**РЕШЕНИЕ:**
```
┌─────────────────────────────────────────────────────┐
│  ЧЕКЛИСТ для облачных сервисов:                     │
│                                                     │
│  1. Security Group (AWS) / NSG (Azure) /            │
│     Firewall Rules (GCP)                            │
│     → Inbound rule для вашего порта существует?     │
│                                                     │
│  2. Network ACL (AWS)                               │
│     → Есть ещё один уровень! Проверьте и его.       │
│                                                     │
│  3. Subnet routing                                  │
│     → Internet Gateway подключен к subnet?          │
│                                                     │
│  4. Instance firewall (iptables)                    │
│     → Да, он ДОПОЛНИТЕЛЬНО к Security Group         │
└─────────────────────────────────────────────────────┘
```

---

### Ошибка 6: "Ping работает = всё работает"

**СИМПТОМ:**
```
"Сервис недоступен!"

$ ping server.com
# → 64 bytes, time=25ms

"Ping работает, значит сеть в порядке.
 Проблема в приложении!"

    │
    ▼
2 часа дебага приложения
    │
    ▼
Реальная проблема: firewall блокирует порт 8080
(но пропускает ICMP)
```

**ПОЧЕМУ PING НЕДОСТАТОЧЕН:**
```
Ping проверяет ТОЛЬКО:
• ICMP Echo Request/Reply
• Уровень L3 (IP connectivity)

Ping НЕ проверяет:
• TCP порты (сервис запущен?)
• UDP порты
• HTTP/HTTPS (приложение работает?)
• Firewall rules для TCP/UDP
```

**РЕШЕНИЕ:**
```bash
# Ping — это шаг 1, но не единственный

# 1. Ping — базовая связность
ping server.com

# 2. Порт — сервис слушает?
nc -zv server.com 8080

# 3. HTTP — приложение отвечает?
curl -v http://server.com:8080/health

# Все три должны работать!
```

---

## Часть 3: Ментальные модели

### Модель 1: OSI снизу вверх как чеклист

```
┌─────────────────────────────────────────────────────┐
│  ВОПРОС                    │  ИНСТРУМЕНТ │ ПОРЯДОК │
├─────────────────────────────────────────────────────┤
│  Физика работает?          │  ip link    │    1    │
│  (кабель, WiFi, интерфейс) │             │         │
├─────────────────────────────────────────────────────┤
│  IP доступен?              │  ping       │    2    │
│  (маршрут, gateway)        │  mtr        │         │
├─────────────────────────────────────────────────────┤
│  Порт открыт?              │  nc/telnet  │    3    │
│  (firewall, сервис)        │  ss         │         │
├─────────────────────────────────────────────────────┤
│  Приложение отвечает?      │  curl -v    │    4    │
│  (HTTP code, headers)      │  DevTools   │         │
└─────────────────────────────────────────────────────┘

ПРАВИЛО: Если шаг N не работает — шаги N+1 бессмысленны.
         Не проверяй HTTP, пока не убедился что ping проходит.
```

---

### Модель 2: Время ответа как подсказка

```
┌─────────────────────────────────────────────────────┐
│                                                     │
│  МГНОВЕННЫЙ ОТВЕТ (< 100ms)                         │
│  ══════════════════════════                         │
│                                                     │
│  "Connection refused"                               │
│  → Хост жив и отвечает                              │
│  → Проблема ЛОКАЛЬНАЯ (порт, сервис)                │
│                                                     │
│  "No route to host"                                 │
│  → Роутер ответил "не знаю куда"                    │
│  → Проблема в МАРШРУТИЗАЦИИ                         │
│                                                     │
├─────────────────────────────────────────────────────┤
│                                                     │
│  ДОЛГОЕ ОЖИДАНИЕ (15-120 сек)                       │
│  ═══════════════════════════                        │
│                                                     │
│  "Connection timeout"                               │
│  → Пакеты уходят в никуда                           │
│  → Проблема НА ПУТИ (firewall DROP, сеть)           │
│                                                     │
│  TCP делает несколько retransmit, потом сдаётся     │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---

### Модель 3: "Где пакет умер?" — главный вопрос

```
┌─────────────────────────────────────────────────────┐
│                                                     │
│  Клиент ──► [?] ──► [?] ──► [?] ──► Сервер          │
│      │       │       │       │       │              │
│      │       │       │       │       │              │
│      ▼       ▼       ▼       ▼       ▼              │
│   Ваш PC   Router   ISP   Cloud   Backend           │
│                                                     │
│  ЦЕЛЬ: найти, на каком этапе пакет "умирает"        │
│                                                     │
└─────────────────────────────────────────────────────┘

Инструменты поиска:

┌─────────────────────────────────────────────────────┐
│  traceroute / mtr   →   Показывает ВСЕ хопы         │
│                         и где начинаются потери    │
│                                                     │
│  ping промежуточных →   Проверить конкретный hop   │
│  хопов                                              │
│                                                     │
│  Логика:                                            │
│  • Если hop N отвечает, hop N+1 нет → проблема там │
│  • Если все хопы OK, но цель нет → проблема на цели│
└─────────────────────────────────────────────────────┘
```

---

### Модель 4: Изоляция проблемы (клиент vs сеть vs сервер)

```
┌─────────────────────────────────────────────────────┐
│                                                     │
│  "Не работает" — ГДЕ проблема?                      │
│                                                     │
│   [КЛИЕНТ]  ───────  [СЕТЬ]  ───────  [СЕРВЕР]      │
│                                                     │
├─────────────────────────────────────────────────────┤
│                                                     │
│  Проблема на КЛИЕНТЕ?                               │
│  • Другие сайты работают?                           │
│  • С телефона/другого устройства работает?          │
│  • VPN подключен?                                   │
│  • DNS резолвится правильно?                        │
│                                                     │
├─────────────────────────────────────────────────────┤
│                                                     │
│  Проблема в СЕТИ?                                   │
│  • traceroute показывает потери на хопе?            │
│  • Firewall блокирует?                              │
│  • Security Group в облаке?                         │
│                                                     │
├─────────────────────────────────────────────────────┤
│                                                     │
│  Проблема на СЕРВЕРЕ?                               │
│  • Сервис запущен? (ss -tuln)                       │
│  • Логи показывают ошибки?                          │
│  • Ресурсы исчерпаны? (CPU, RAM, disk)              │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---

### Модель 5: Бритва Оккама в debugging

```
┌─────────────────────────────────────────────────────┐
│                                                     │
│  "Самое простое объяснение обычно верное"           │
│                                                     │
│  СТАТИСТИКА ПРОБЛЕМ:                                │
│                                                     │
│  50%  │█████████████████████████│  Сервис не        │
│       │                         │  запущен/крашнулся│
│                                                     │
│  25%  │████████████             │  Firewall/         │
│       │                         │  Security Group    │
│                                                     │
│  15%  │███████                  │  DNS проблемы      │
│       │                         │                    │
│  8%   │████                     │  Сетевые проблемы  │
│       │                         │  (routing, loss)   │
│                                                     │
│  2%   │█                        │  Экзотика          │
│       │                         │  (MTU, TCP tunning)│
│                                                     │
└─────────────────────────────────────────────────────┘

ВЫВОД: Проверь сначала очевидное!
       • Сервис запущен?
       • Порт открыт в firewall?
       • DNS правильный?

       И только потом ищи сложное.
```

---

## Зачем это знать

### Почему сетевая диагностика — критический навык для разработчика

**"Не работает"** — пожалуй, самая бесполезная фраза в IT. Когда пользователь говорит "сайт не открывается", за этим может скрываться десяток совершенно разных проблем: от отключённого Wi-Fi до упавшего сервера на другом континенте. Без системного подхода к диагностике разработчик превращается в гадалку, которая тыкает наугад: "может DNS? может firewall? может сервер умер?".

**Почему программисты плохо диагностируют сетевые проблемы.** Большинство разработчиков учились писать код, а не понимать, как этот код взаимодействует с сетью. Когда `fetch()` возвращает ошибку, типичная реакция — гуглить текст ошибки и копировать решения со Stack Overflow. Иногда это работает, но чаще приводит к часам бессмысленных попыток.

**Системный подход vs случайный тыкинг.** Представьте, что врач при любой жалобе пациента сразу назначал бы операцию. Абсурд? Но именно так многие подходят к сетевым проблемам — сразу лезут в самые сложные настройки, не проверив базовое. Системный подход означает: проверь простое, прежде чем искать сложное. Физический уровень (кабель подключён?) → сетевой уровень (IP доступен?) → транспортный (порт открыт?) → прикладной (HTTP отвечает правильно?).

**Что даёт этот навык на практике:**
- **Скорость решения проблем.** Вместо часа хаотичных попыток — 5-10 минут методичной проверки
- **Уверенность в диагнозе.** Вы точно знаете, где проблема, и можете доказать это коллегам
- **Экономия денег.** Неправильная диагностика часто приводит к ненужным покупкам железа или сервисов
- **Репутация.** Человек, который быстро находит и чинит проблемы — на вес золота в любой команде

**Статистика реальных инцидентов:**
- 30% connection failures — misconfigured firewall rules (забытое правило в Security Group)
- 25% "сервис упал" — DNS propagation (запись ещё не обновилась)
- 65% performance issues — resource exhaustion (память, CPU, сокеты)
- 75% команд улучшают время реакции при централизованном logging

**После изучения этого материала** вы будете подходить к любой сетевой проблеме системно: знать, какой инструмент когда применить, как интерпретировать результаты, и главное — **не гадать**, а **знать** где искать проблему.

---

## The Golden Rule: Layer-by-Layer Approach

### Почему OSI-модель — это не только для экзаменов

Многие разработчики считают OSI-модель академической абстракцией, которую учат на курсах и забывают на следующий день. Но на практике эта модель — идеальный инструмент для **структурированной диагностики** любой сетевой проблемы.

**Принцип "снизу вверх".** Каждый уровень OSI зависит от нижних уровней. Если не работает физический уровень (кабель выдернут), бессмысленно проверять DNS или HTTP. Если не работает сетевой уровень (нет маршрута до хоста), проверка порта ничего не даст. Поэтому опытные инженеры всегда начинают с нижних уровней и поднимаются вверх.

**Как это экономит время.** Представьте: разработчик час дебажит почему API не отвечает, ищет проблемы в коде, проверяет логи сервера... а потом выясняется, что просто VPN отключился. Если бы он начал с проверки `ping`, проблема нашлась бы за 10 секунд. Метод "снизу вверх" заставляет проверять самое простое и быстрое в первую очередь.

**Практическая адаптация OSI для разработчика.** Полная 7-уровневая модель избыточна для большинства задач. На практике достаточно 4 ключевых уровней:

1. **Физический/канальный (L1-L2):** Есть ли вообще соединение? Кабель подключён? Wi-Fi работает? Интерфейс активен?
2. **Сетевой (L3):** Доходят ли пакеты до адресата? Есть ли маршрут? Проходит ли ping?
3. **Транспортный (L4):** Устанавливается ли TCP-соединение? Порт открыт? Firewall не блокирует?
4. **Прикладной (L7):** Приложение отвечает правильно? HTTP-код? Формат ответа?

**Типичная ошибка начинающих.** Сразу прыгать на L7 — проверять HTTP, логи сервера, код приложения. Это всё равно что чинить двигатель машины, когда закончился бензин. Сначала проверь топливо (L1-L3), потом разбирайся с двигателем (L4-L7).

```
Проблема: "Сайт не открывается"

НЕ ДЕЛАЙ: random google search → copy-paste команд → часы потерянного времени
ДЕЛАЙ:    Layer 1 → Layer 2 → Layer 3 → Layer 4 → Layer 7 → точный диагноз за минуты
```

### Чеклист диагностики по уровням OSI

```
┌─────────────────────────────────────────────────────────────────┐
│ LAYER 7: Application                                            │
│ Вопросы: HTTP code? Response body? Headers correct?             │
│ Инструменты: curl -v, Browser DevTools, Postman                 │
├─────────────────────────────────────────────────────────────────┤
│ LAYER 4: Transport                                              │
│ Вопросы: Port open? Connection established? Timeout?            │
│ Инструменты: telnet, nc, ss, netstat                            │
├─────────────────────────────────────────────────────────────────┤
│ LAYER 3: Network                                                │
│ Вопросы: IP reachable? Routing correct? Firewall blocking?      │
│ Инструменты: ping, traceroute, mtr                              │
├─────────────────────────────────────────────────────────────────┤
│ LAYER 2-1: Data Link / Physical                                 │
│ Вопросы: Cable connected? WiFi signal? Interface up?            │
│ Инструменты: ip link, ifconfig, iwconfig                        │
└─────────────────────────────────────────────────────────────────┘

Правило: Начинай снизу (физика), иди вверх (приложение)
```

---

## Три главных сетевых ошибки и что они значат

### Анатомия сетевых ошибок: что происходит внутри

Когда ваше приложение пытается подключиться к серверу, происходит последовательность событий на уровне TCP/IP стека. Понимание этих событий позволяет мгновенно интерпретировать ошибки, потому что **каждый тип ошибки указывает на конкретную точку отказа**.

**Как работает TCP-соединение.** При попытке подключиться ваш компьютер отправляет TCP SYN-пакет на целевой IP:порт. Дальше возможны три сценария:

1. **Хост получил пакет и ответил RST** → Connection Refused
2. **Пакет ушёл в никуда, ответа нет** → Timeout
3. **Маршрутизатор сказал "не знаю куда отправить"** → No Route to Host

**Почему это важно различать.** Каждая из этих ошибок указывает на разный уровень проблемы:
- **Connection Refused** = проблема на хосте назначения (сервис, порт, локальный firewall)
- **Timeout** = проблема на пути (firewall DROP, потеря пакетов, сеть)
- **No Route** = проблема маршрутизации (нет пути, VPN, routing table)

Если вы понимаете эту механику, вы сразу знаете, где искать проблему, вместо того чтобы проверять всё подряд.

### Connection Refused vs Timeout vs No Route to Host

| Ошибка | Время ответа | Что происходит на уровне TCP | Причина |
|--------|--------------|------------------------------|---------|
| **Connection Refused** | Мгновенно (мс) | Хост получил SYN, ответил RST (reset) | Порт закрыт, сервис не запущен, firewall REJECT |
| **Connection Timeout** | Долго (15-30 сек) | SYN отправлен, ACK не получен, повторные попытки | Firewall DROP, пакеты теряются, хост не отвечает |
| **No Route to Host** | Быстро (ICMP ответ) | Маршрутизатор вернул ICMP Destination Unreachable | Нет маршрута в routing table, gateway недоступен |

### Как диагностировать каждую

#### Connection Refused — "я тебя слышу, но не хочу разговаривать"

**Что происходит технически.** Когда вы видите Connection Refused, это **хорошая новость** с точки зрения сетевой связности: пакеты успешно доходят до хоста, хост их получает и отвечает. Проблема локализована на самом сервере.

TCP стек хоста получает ваш SYN-пакет, смотрит в таблицу открытых портов, не находит listener'а на этом порту, и отправляет обратно RST (reset) пакет. Это происходит на уровне ядра операционной системы — никакое приложение даже не узнаёт о попытке подключения.

**Главная подсказка: скорость ответа.** Connection Refused приходит мгновенно (обычно менее 100 мс), потому что хост активно отвечает. Если ответ приходит долго — это не refused, а что-то другое.

```bash
# Хост отвечает, но порт закрыт
$ telnet example.com 8080
Connection refused

# Проверяем: сервис запущен?
$ ss -tuln | grep 8080
# Пусто = порт не слушает

# Проверяем: firewall reject?
$ sudo iptables -L -n | grep 8080
```

**Типичные причины и как их исправить:**
- **Сервис не запущен** — проверьте `systemctl status myservice` или `docker ps`
- **Сервис крашнулся** — смотрите логи `journalctl -u myservice` или `docker logs`
- **Сервис слушает на другом порту** — проверьте конфигурацию, часто путают 80/8080, 443/8443
- **Сервис слушает только на localhost** — типичная проблема Docker: контейнер биндится на 127.0.0.1 внутри, недоступен извне
- **Firewall с REJECT policy** — в отличие от DROP, REJECT отправляет RST

#### Connection Timeout — "я кричу в пустоту и никто не отвечает"

**Что происходит технически.** Timeout — это отсутствие любого ответа. Ваш компьютер отправляет SYN-пакет и... ничего. Тишина. TCP стек ждёт, потом отправляет SYN повторно (retransmit), ждёт ещё, снова отправляет... После нескольких попыток (обычно 3-6, зависит от настроек OS) — сдаётся и возвращает ошибку timeout.

**Почему firewall делает DROP вместо REJECT.** Это намеренная практика безопасности, называемая "stealth mode". Если firewall отвечает REJECT, атакующий точно знает, что хост существует и слушает на этом IP. С DROP атакующий не может отличить заблокированный порт от несуществующего хоста — это усложняет сканирование.

**Проблема для разработчика.** DROP хорош для безопасности, но ужасен для диагностики. Вы не можете отличить "firewall блокирует" от "пакеты теряются в сети" от "сервер завис". Поэтому timeout — самый сложный случай для диагностики.

**Важно: время ожидания.** Timeout занимает 15-120 секунд в зависимости от настроек TCP стека. Это время на несколько попыток retransmit с экспоненциальным backoff. Если вы видите мгновенный "timeout" — это что-то другое (возможно, ошибка резолвинга DNS).

```bash
# Нет ответа — firewall молча дропает
$ telnet example.com 8080
# ... ждём 30+ секунд ...
Connection timed out

# Проверяем: сеть до хоста работает?
$ ping example.com

# Проверяем: другие порты работают?
$ telnet example.com 80
```

**Типичные причины и как их проверить:**
- **Firewall с DROP policy** — попробуйте другой порт (80, 443), который точно открыт. Если они работают — проблема в правилах для вашего порта
- **Security Group в AWS/GCP/Azure** — первое место где смотреть в облаке. Inbound rules должны явно разрешать ваш порт
- **Network ACL** — в AWS есть ещё один уровень — NACL на уровне subnet. Часто забывают про outbound rules
- **Сервер завис (kernel panic, OOM)** — если все порты timeout, включая SSH — сервер не отвечает вообще. Нужен out-of-band доступ (console в облаке)

#### No Route to Host — "я не знаю как туда попасть"

**Что происходит технически.** Эта ошибка возникает на уровне IP-маршрутизации, до того как TCP вообще начал работать. Когда ваш компьютер хочет отправить пакет, он смотрит в таблицу маршрутизации (routing table) и ищет: "куда отправить пакет для IP X.X.X.X?". Если подходящего маршрута нет — ошибка No Route.

**Два сценария возникновения:**
1. **Локально:** Ваш компьютер сам не знает маршрут. Нет default gateway, или целевая сеть не прописана.
2. **На промежуточном роутере:** Какой-то маршрутизатор на пути отправляет ICMP Destination Unreachable обратно вам.

**Типичный случай с VPN.** Вы подключились к корпоративному VPN, который создал маршруты к внутренним сетям (10.0.0.0/8). Отключились от VPN — маршруты пропали. Теперь при попытке достучаться до 10.1.2.3 — No Route to Host, потому что ваш компьютер не знает, как попасть в сеть 10.0.0.0/8.

**Разница от Timeout.** No Route возвращается быстро (ICMP-ответ), а Timeout — долго (ждём несуществующего ответа). Если вы получили ошибку мгновенно и это не Connection Refused — скорее всего No Route.

```bash
# Routing problem — пакеты не доходят
$ ping 192.168.100.1
No route to host

# Проверяем routing table
$ ip route
$ route -n

# Проверяем default gateway
$ ip route | grep default
```

**Типичные причины и как их исправить:**
- **VPN не подключен** — `ip route` покажет, что нет маршрута к целевой сети. Подключите VPN
- **Gateway недоступен** — проверьте `ping $(ip route | grep default | awk '{print $3}')`. Если default gateway не отвечает — проблема с локальной сетью
- **Неправильная статическая маршрутизация** — кто-то руками добавил маршрут, который больше не работает
- **Network partition** — редко, но бывает: часть сети недоступна из-за сбоя оборудования

---

## Инструменты по уровням

### Философия выбора инструмента

Каждый диагностический инструмент отвечает на конкретный вопрос. Ошибка новичка — запускать все инструменты подряд и надеяться, что какой-то покажет проблему. Правильный подход — сформулировать вопрос и выбрать инструмент, который на него отвечает.

| Вопрос | Инструмент | Что получим |
|--------|------------|-------------|
| Хост вообще доступен? | ping | Да/нет + latency |
| Где теряются пакеты по пути? | mtr/traceroute | Карта пути + потери на каждом hop |
| Порт открыт? | nc/telnet | Да/нет + тип ошибки |
| Что слушает на сервере? | ss/netstat | Список портов + процессы |
| Какой IP у домена? | dig/nslookup | DNS-ответ + цепочка резолвинга |
| Как проходит HTTP-запрос? | curl -v | Headers + timing + ошибки |

**Правило минимальной инвазивности.** Начинайте с самых простых и быстрых инструментов. Ping занимает секунду, curl -v — пару секунд. Не запускайте tcpdump или Wireshark, пока не исключили простые причины — это как использовать микроскоп, чтобы найти слона в комнате.

### Layer 3: Проверка сетевой связности

#### ping — первый инструмент в любой диагностике

**Когда использовать.** Ping — это ваш первый вопрос: "Хост вообще существует и отвечает?". Если ping не проходит — нет смысла проверять порты, HTTP, SSL. Сначала разберитесь со связностью на уровне IP.

**Что ping делает технически.** Отправляет ICMP Echo Request пакеты и ждёт ICMP Echo Reply. ICMP — это служебный протокол IP-уровня, работает независимо от TCP/UDP. Поэтому ping показывает чистую сетевую связность без влияния приложений.

**Важное ограничение.** Многие серверы и firewall'ы блокируют ICMP. Это значит: отсутствие ответа ping ≠ недоступность хоста. Если ping не проходит, но telnet на порт 80 работает — хост доступен, просто ICMP заблокирован.

#### ping — базовая проверка
```bash
# Хост доступен?
ping -c 4 google.com

# Ping конкретного IP (обойти DNS)
ping -c 4 8.8.8.8

# Если ping работает на IP, но не на domain → проблема DNS
```

> **Важно:** Многие серверы блокируют ICMP. Отсутствие ping ≠ недоступность хоста.

#### traceroute / mtr — когда нужно понять где именно проблема

**Когда использовать.** Ping показывает, что хост недоступен или теряет пакеты. Но где именно? На вашем роутере? У провайдера? На другом конце света? Traceroute показывает весь путь пакета от вас до цели.

**Как это работает.** Умный трюк с TTL (Time To Live). Каждый IP-пакет имеет TTL — счётчик, который уменьшается на 1 на каждом роутере. Когда TTL доходит до 0, роутер отправляет ICMP Time Exceeded обратно отправителю.

Traceroute отправляет пакеты с TTL=1 (первый роутер ответит), затем TTL=2 (второй роутер), TTL=3, и так далее. Получаем карту всех роутеров на пути.

**MTR лучше traceroute.** Классический traceroute — это одномоментный снимок. MTR (My Traceroute) запускает traceroute непрерывно и собирает статистику: средняя latency, packet loss на каждом hop. Это критически важно для диагностики intermittent проблем — одиночный traceroute может их не показать.

#### traceroute / mtr — путь пакета
```bash
# Где теряются пакеты?
traceroute google.com

# MTR = traceroute + ping (лучше!)
mtr google.com

# На Windows
tracert google.com
# Или WinMTR (GUI)
```

**Как читать MTR:**

```
                             Packets               Pings
 Host                      Loss%   Snt   Last   Avg  Best  Wrst
 1. router.local            0.0%    10    1.2   1.4   0.9   2.1
 2. isp-gateway.net         0.0%    10   12.3  11.8  10.2  15.4
 3. ???                    100.0%   10    0.0   0.0   0.0   0.0  ← Потери?
 4. target.server.com       0.0%    10   45.2  44.8  42.1  52.3
```

**Правило интерпретации:**
> Packet loss на промежуточном hop БЕЗ потерь на последующих — это нормально (ICMP rate limiting). Проблема только если loss продолжается до конечной точки.

### Layer 4: Проверка портов и соединений

**Что проверяем на транспортном уровне.** Layer 3 (ping, traceroute) показал, что хост доступен. Но это не значит, что сервис работает. На Layer 4 мы проверяем: можно ли установить TCP-соединение на нужный порт?

**Почему порт может быть закрыт при работающей сети:**
- Сервис не запущен (crashed, не стартовал)
- Сервис слушает на другом порту (8080 вместо 80)
- Сервис слушает только на localhost (127.0.0.1)
- Firewall на хосте блокирует входящие соединения
- Security Group в облаке не разрешает порт

#### telnet / nc — порт открыт?

**Когда использовать.** Это ваш главный инструмент для проверки: "можно ли установить TCP-соединение на этот порт?". В отличие от ping, telnet/nc проверяют конкретный порт и используют TCP, а не ICMP.

**Разница между telnet и nc.** Исторически telnet создавался для интерактивных терминальных сессий, nc (netcat) — как универсальный сетевой инструмент. Для диагностики оба работают одинаково, но nc более гибкий (может сканировать диапазоны портов, работать с UDP).

**Что означают результаты:**
- `Connected` — TCP handshake успешен, порт слушает
- `Connection refused` — хост ответил RST, порт закрыт
- `Connection timed out` — нет ответа, firewall DROP или хост недоступен
```bash
# Проверка TCP порта
telnet example.com 443
# или
nc -zv example.com 443

# Сканирование диапазона портов
nc -zv example.com 80-90
```

#### ss / netstat — что слушает локально?

**Когда использовать.** Вы на сервере и хотите понять: какие порты открыты? Какие процессы их слушают? Это серверная сторона диагностики — вместо "могу ли я подключиться" вы спрашиваете "что готово принимать соединения".

**Почему ss вместо netstat.** netstat — устаревший инструмент, официально deprecated в современных Linux. ss (socket statistics) быстрее (особенно на серверах с тысячами соединений), показывает больше информации, и активно развивается. Если netstat ещё работает на вашей системе — он читает /proc/net/* файлы. ss использует netlink API напрямую, что эффективнее.

**Типичные вопросы, на которые отвечает ss:**
- Сервис слушает на правильном порту?
- Сервис биндится на 0.0.0.0 (все интерфейсы) или только 127.0.0.1?
- Кто занял порт 8080, когда я пытаюсь запустить свой сервис?
- Сколько установленных соединений к моему сервису?

```bash
# Все слушающие порты (современный способ)
ss -tuln

# С процессами (нужен sudo)
sudo ss -tulnp

# Старый способ (netstat deprecated, но работает)
netstat -tuln

# Найти кто занял порт 8080
ss -tulnp | grep 8080
# или
lsof -i :8080
```

**Расшифровка колонок ss:**
```
State      Recv-Q Send-Q  Local Address:Port   Peer Address:Port
LISTEN     0      128     0.0.0.0:22           0.0.0.0:*
ESTAB      0      0       192.168.1.5:22       192.168.1.10:54321
```

- **Recv-Q/Send-Q = 0** — всё ок
- **Recv-Q > 0** — данные ждут чтения (application не справляется)
- **Send-Q > 0** — данные ждут отправки (сеть или receiver медленные)

### Layer 7: HTTP диагностика

**Когда мы доходим до Layer 7.** Если ping работает (L3 OK), telnet на порт подключается (L4 OK) — переходим к прикладному уровню. Здесь мы проверяем: правильно ли отвечает само приложение? HTTP-код? Headers? Тело ответа?

**Почему curl, а не браузер.** Браузер — отличный инструмент для пользователя, но плохой для диагностики. Он скрывает детали, делает автоматические редиректы, кэширует ответы, обрабатывает ошибки молча. curl показывает raw HTTP: что именно отправлено, что получено, сколько времени заняло каждый этап.

**Что можно увидеть с curl -v:**
- DNS lookup (какой IP получен)
- TCP connection (куда подключились)
- TLS handshake (какой сертификат, версия TLS)
- Отправленные headers (что отправил клиент)
- Полученные headers (что вернул сервер)
- Коды ответа и тело

#### curl -v — ваш главный HTTP-отладчик
```bash
# Полная информация о запросе
curl -v https://api.example.com/health

# Что показывает:
# * — информация от curl (connection, TLS)
# > — отправленные headers
# < — полученные headers
```

**Пример вывода:**
```
* Trying 93.184.216.34:443...
* Connected to example.com (93.184.216.34) port 443
* TLS 1.3 connection established...
> GET /api/health HTTP/2
> Host: example.com
> User-Agent: curl/7.88.1
>
< HTTP/2 200
< content-type: application/json
< date: Thu, 26 Dec 2025 10:00:00 GMT
```

#### Полезные curl опции
```bash
# Только headers (без body)
curl -I https://example.com

# Измерить время ответа
curl -o /dev/null -s -w "Time: %{time_total}s\n" https://example.com

# Подробный timing breakdown
curl -o /dev/null -s -w "
DNS:        %{time_namelookup}s
Connect:    %{time_connect}s
TLS:        %{time_appconnect}s
TTFB:       %{time_starttransfer}s
Total:      %{time_total}s
" https://example.com

# Игнорировать SSL ошибки (только для debug!)
curl -k https://self-signed.example.com

# POST с JSON
curl -X POST -H "Content-Type: application/json" \
  -d '{"key":"value"}' \
  https://api.example.com/endpoint
```

#### Browser DevTools Network Tab

**Waterfall Chart — что означают цвета:**

```
┌─────────────────────────────────────────────────────────────┐
│ [===ЗЕЛЁНЫЙ===][======СИНИЙ======]                         │
│      TTFB           Download                                │
│                                                             │
│ Зелёный доминирует → сервер медленный (backend bottleneck) │
│ Синий доминирует → большой файл или медленная сеть         │
└─────────────────────────────────────────────────────────────┘
```

**Timing Breakdown в DevTools:**
| Фаза | Что значит |
|------|------------|
| Queueing | Запрос ждёт в очереди браузера |
| Stalled | Браузер занят другими делами |
| DNS Lookup | Резолвинг домена |
| Initial Connection | TCP handshake |
| SSL | TLS handshake |
| TTFB | Time To First Byte (ждём ответа сервера) |
| Content Download | Скачивание body |

**Pro Tips:**
- **TTFB = 0ms** → ресурс из кэша (проверь Size column)
- **Staircase pattern** → dependency chain (один запрос ждёт другой)
- **Parallel bars** → HTTP/2 multiplexing работает

### DNS диагностика

**Почему DNS — критическая точка отказа.** Каждый раз, когда вы вводите доменное имя, происходит DNS-запрос. Если DNS не работает или отвечает неправильно — ничего работать не будет, хотя технически сеть в порядке.

**Типичные DNS-проблемы:**
- **Propagation delay** — вы обновили DNS-запись, но изменения ещё не дошли до всех DNS-серверов (занимает до 48 часов)
- **Кэширование** — ваш компьютер или resolver закэшировал старый IP, игнорируя обновления
- **Неправильные NS-серверы** — домен указывает на неработающие name servers
- **DNSSEC-ошибки** — signature validation failed, запись отклоняется

**Почему dig, а не nslookup.** nslookup — старый инструмент, который до сих пор работает и есть на Windows. dig (Domain Information Groper) — стандарт в Unix-мире: показывает больше информации, поддерживает все типы запросов, имеет режим trace для отладки всей цепочки резолвинга.

**Важный трюк для диагностики.** Если сайт не открывается — сделайте `dig +short domain.com` и проверьте: это вообще правильный IP? Затем `ping` этот IP напрямую. Если ping работает, но сайт нет — проблема на уровне HTTP, не DNS.

#### dig — ваш главный инструмент DNS-диагностики
```bash
# Базовый запрос
dig example.com

# Только IP (короткий ответ)
dig +short example.com

# Проверить конкретный DNS сервер
dig @8.8.8.8 example.com

# Проследить всю цепочку резолвинга
dig +trace example.com

# Проверить конкретный тип записи
dig example.com MX      # Mail servers
dig example.com AAAA    # IPv6
dig example.com TXT     # SPF, DKIM etc.
dig example.com NS      # Name servers
```

#### nslookup — альтернатива (есть на Windows)
```bash
# Базовый запрос
nslookup example.com

# Через конкретный DNS сервер
nslookup example.com 8.8.8.8

# Проверить MX записи
nslookup -type=MX example.com
```

**Типичные DNS проблемы:**

| Симптом | Вероятная причина |
|---------|-------------------|
| `dig` работает, браузер нет | DNS cache браузера/OS |
| Разные IP с разных DNS серверов | Propagation не завершена |
| SERVFAIL | Проблема с authoritative NS |
| NXDOMAIN | Домен не существует |
| Очень долгий lookup | DNS сервер недоступен/медленный |

```bash
# Очистить DNS cache
# macOS
sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder

# Linux (systemd-resolved)
sudo systemd-resolve --flush-caches

# Windows
ipconfig /flushdns
```

---

## HTTP Status Codes: Что делать

### Философия HTTP-кодов

HTTP-коды ответа — это не просто числа, а стандартизированный язык коммуникации между клиентом и сервером. Понимание этого языка позволяет мгновенно локализовать проблему.

**Первая цифра определяет категорию:**
- **1xx** — Informational (редко встречается, обычно скрыто)
- **2xx** — Success (всё хорошо)
- **3xx** — Redirection (иди сюда вместо этого)
- **4xx** — Client Error (проблема на твоей стороне)
- **5xx** — Server Error (проблема на стороне сервера)

**Ключевой вопрос: это моя проблема или сервера?** 4xx означает: "сервер понял твой запрос, но отказывается его выполнять из-за ошибки в запросе". 5xx означает: "сервер получил запрос, но не смог его обработать из-за внутренней ошибки".

На практике граница размыта: иногда сервер возвращает 500 из-за плохих данных от клиента. Но как первое приближение это разделение полезно.

### 4xx — Client Errors (твоя проблема)

| Code | Название | Что проверить |
|------|----------|---------------|
| 400 | Bad Request | Формат запроса, JSON syntax |
| 401 | Unauthorized | Auth header, токен expired? |
| 403 | Forbidden | Права доступа, API key правильный? |
| 404 | Not Found | URL правильный? Ресурс существует? |
| 405 | Method Not Allowed | GET vs POST? Проверь endpoint |
| 429 | Too Many Requests | Rate limit, добавь retry с backoff |

### 5xx — Server Errors (не твоя проблема... обычно)

| Code | Название | Что значит | Что делать |
|------|----------|------------|------------|
| 500 | Internal Server Error | Сервер сломался | Смотри server logs |
| 502 | Bad Gateway | Upstream не отвечает | Proxy/LB не может достучаться до backend |
| 503 | Service Unavailable | Сервис перегружен | Retry позже, проверь health |
| 504 | Gateway Timeout | Upstream timeout | Backend слишком долго отвечает |

**502 vs 503 vs 504:**
```
Client → [Load Balancer] → Backend

502 Bad Gateway:
- Backend вернул invalid response
- Backend crashed mid-request
- Проверь: backend running? health checks passing?

503 Service Unavailable:
- Backend явно говорит "я занят"
- Maintenance mode
- Circuit breaker open
- Проверь: capacity? health? retry-after header?

504 Gateway Timeout:
- Backend не ответил в отведённое время
- Проверь: backend slow? database locked? network issues?
```

---

## Firewall Debugging

### Понимание многослойной защиты

**Почему firewall — частая причина проблем.** В современной инфраструктуре пакет проходит через несколько уровней фильтрации, и каждый может его заблокировать:

1. **Локальный firewall на клиенте** (редко, но бывает)
2. **Сетевой firewall на периметре** (корпоративный, NAT gateway)
3. **Cloud Security Groups** (AWS SG, Azure NSG, GCP Firewall Rules)
4. **Network ACLs** (в AWS — отдельно от Security Groups)
5. **Локальный firewall на сервере** (iptables, nftables, UFW, firewalld)

**Типичная история.** Разработчик развернул сервис, локально всё работает, а извне — timeout. Потратил час на debugging кода, а проблема — забытое правило в Security Group. Потому что Security Groups не на виду, а iptables на сервере настроен правильно.

**Порядок проверки.** Начинайте с сервера (ss -tuln — порт слушает?), затем локальный firewall (iptables), затем облачные правила (Security Groups). Если вы проверяете снаружи — сначала убедитесь, что изнутри сервера всё работает.

### Проверить что блокирует

```bash
# UFW (Ubuntu)
sudo ufw status verbose

# firewalld (RHEL/CentOS)
sudo firewall-cmd --list-all

# iptables (raw)
sudo iptables -L -n -v

# nftables (modern)
sudo nft list ruleset
```

### Проверить открытые порты извне

```bash
# С другой машины
nmap -p 22,80,443 target-server.com

# Проверить конкретный порт
nc -zv target-server.com 8080
```

### Временно открыть порт для теста

```bash
# UFW
sudo ufw allow 8080/tcp
# После теста
sudo ufw delete allow 8080/tcp

# firewalld
sudo firewall-cmd --add-port=8080/tcp
# Перманентно
sudo firewall-cmd --add-port=8080/tcp --permanent
```

> **Cloud:** Не забывай про Security Groups (AWS), Network Security Groups (Azure), Firewall Rules (GCP) — они отдельно от OS firewall!

---

## Чеклист: "Сервис недоступен"

### Как пользоваться этим чеклистом

Этот чеклист — ваша шпаргалка для систематической диагностики. Каждый пункт — это вопрос с конкретным инструментом для ответа. Если ответ положительный — переходите к следующему. Если отрицательный — вы нашли проблему.

**Важно: порядок имеет значение.** Проверять HTTP бессмысленно, если ping не проходит. Смотреть в Security Groups бесполезно, если сервис не слушает на порту. Двигайтесь последовательно от низов к верхам.

**Время на каждый шаг.** Большинство проверок занимают секунды. Если вы потратили больше минуты на один шаг — либо вы нашли проблему и нужно её исследовать глубже, либо пора перейти к следующему.

```
□ 1. Ping IP адрес (не домен)
     → Не пингуется? → Network/Routing проблема
     → Пингуется? → Продолжай

□ 2. Проверь DNS
     dig domain.com
     → NXDOMAIN? → DNS не настроен
     → IP неправильный? → DNS propagation

□ 3. Telnet/nc на порт
     nc -zv host port
     → Connection refused? → Сервис не запущен
     → Timeout? → Firewall блокирует

□ 4. Проверь локально на сервере
     ss -tuln | grep PORT
     → Не слушает? → Запусти сервис
     → Слушает на 127.0.0.1? → Bind на 0.0.0.0

□ 5. Проверь firewall
     sudo iptables -L -n | grep PORT
     → DROP/REJECT? → Открой порт

□ 6. Проверь cloud security groups
     AWS Console / GCP Console / Azure Portal
     → Inbound rule exists?

□ 7. HTTP level
     curl -v https://domain.com
     → 4xx? → Client problem (auth, URL)
     → 5xx? → Server problem (logs)
```

---

## Практические сценарии

### Зачем нужны готовые сценарии

Сценарии ниже — это не просто примеры команд, а **паттерны мышления**. Когда вы сталкиваетесь с проблемой типа "API не отвечает", ваш мозг должен автоматически запустить цепочку: DNS → ping → telnet → curl. Со временем это становится рефлексом.

**Как использовать сценарии:**
1. Найдите сценарий, похожий на вашу ситуацию
2. Выполняйте команды последовательно
3. На каждом шаге интерпретируйте результат
4. Первый неожиданный результат — это подсказка, где искать проблему

**Важно: адаптируйте под свою ситуацию.** Эти сценарии — отправная точка. В реальности ваши IP-адреса, порты и домены будут другими. Понимайте логику, а не копируйте команды вслепую.

### Сценарий 1: API не отвечает

**Симптомы:** Приложение показывает ошибку сети, curl возвращает ошибку, браузер говорит "сайт недоступен".

**Логика диагностики:** Идём снизу вверх — от сетевой связности к прикладному уровню.

```bash
# 1. Проверить DNS
dig api.example.com +short
# → 93.184.216.34

# 2. Проверить connectivity
ping 93.184.216.34
# → работает

# 3. Проверить порт
nc -zv 93.184.216.34 443
# → Connection refused ❌

# Вывод: Сервис не слушает на 443
# Действие: Проверить статус сервиса на сервере
```

### Сценарий 2: Сайт медленный

**Симптомы:** Страница грузится долго, но в итоге загружается. Или первый запрос медленный, а повторные быстрые.

**Логика диагностики:** "Медленно" — понятие расплывчатое. Нужно измерить и понять, где именно время тратится: DNS? TCP connect? TLS handshake? Ответ сервера? Скачивание контента?

**Ключевой инструмент:** `curl` с опцией timing breakdown показывает время каждого этапа. Это мгновенно сужает область поиска.

```bash
# 1. Измерить где задержка
curl -o /dev/null -s -w "DNS: %{time_namelookup}s\nConnect: %{time_connect}s\nTTFB: %{time_starttransfer}s\nTotal: %{time_total}s\n" https://slow-site.com

# Результат:
# DNS: 0.5s      ← DNS медленный!
# Connect: 0.02s
# TTFB: 0.1s
# Total: 0.65s

# Действие: Сменить DNS сервер или добавить в /etc/hosts
```

### Сценарий 3: Intermittent failures

**Симптомы:** "Иногда работает, иногда нет". Самый сложный случай для диагностики, потому что проблема не воспроизводится стабильно.

**Почему это сложно.** Одномоментные инструменты (ping, traceroute) могут показать "всё ок", пока проблема не проявится. Нужны инструменты, которые работают продолжительное время и собирают статистику.

**Типичные причины intermittent проблем:**
- **Packet loss на одном из hop'ов** — перегруженный роутер иногда теряет пакеты
- **DNS с несколькими записями** — часть серверов работает, часть нет
- **Load balancer с unhealthy backend** — некоторые запросы попадают на сломанный сервер
- **Network congestion** — в часы пик сеть перегружена

**Ключевой инструмент:** MTR с большим количеством пакетов. Запустите `mtr -c 100` и дайте ему поработать несколько минут — соберётся статистика по packet loss и latency на каждом hop.

```bash
# 1. MTR для проверки качества соединения
mtr -c 100 api.example.com

# Смотрим на:
# - Packet loss (не должен быть >1%)
# - High latency spikes
# - Inconsistent routes

# 2. Если MTR показывает потери на одном hop
# → Проверить что это не ICMP rate limiting
# → Loss должна продолжаться до конца trace
```

---

## Quick Reference Card

### Зачем нужна шпаргалка

**Эту страницу стоит распечатать** (или добавить в закладки). В момент инцидента вы будете нервничать, и вспоминать синтаксис команд сложно. Шпаргалка позволяет действовать быстро и не думать о деталях.

**Когда использовать шпаргалку vs когда думать.** Шпаргалка — для стандартных проверок. Но если стандартные проверки не дали результата, нужно думать: что уникального в вашей ситуации? Какие инструменты могут помочь? Шпаргалка — это ускоритель, не замена понимания.

### Команды одной строкой

```bash
# Что слушает на порту?
lsof -i :8080

# Кто подключен к моему серверу?
ss -tn state established

# DNS lookup через Google DNS
dig @8.8.8.8 example.com +short

# Полный HTTP timing
curl -w "@-" -o /dev/null -s "https://example.com" <<'EOF'
    time_namelookup:  %{time_namelookup}s\n
       time_connect:  %{time_connect}s\n
    time_appconnect:  %{time_appconnect}s\n
   time_pretransfer:  %{time_pretransfer}s\n
      time_redirect:  %{time_redirect}s\n
 time_starttransfer:  %{time_starttransfer}s\n
                    ----------\n
         time_total:  %{time_total}s\n
EOF

# Проверить TLS certificate
echo | openssl s_client -connect example.com:443 2>/dev/null | openssl x509 -text -noout
```

### Таблица инструментов

| Задача | Инструмент | Пример |
|--------|------------|--------|
| Host reachable? | ping | `ping -c 4 host` |
| Path to host? | mtr | `mtr host` |
| Port open? | nc | `nc -zv host port` |
| What's listening? | ss | `ss -tuln` |
| DNS lookup | dig | `dig domain +short` |
| HTTP request | curl | `curl -v url` |
| Packet capture | tcpdump | `sudo tcpdump -i any port 80` |

---

## Ссылки и источники

### Официальная документация
- [Chrome DevTools Network Reference](https://developer.chrome.com/docs/devtools/network/reference)
- [curl verbose documentation](https://everything.curl.dev/usingcurl/verbose)
- [dig +trace tutorial (IBM)](https://www.ibm.com/think/tutorials/using-dig-trace)

### Практические руководства
- [MTR guide (AWS)](https://repost.aws/articles/ARYuHnu150R9ahMl-2hNNEVw/diagnosing-packet-loss-and-latency-with-mtr)
- [Interpreting traceroute (APNIC)](https://blog.apnic.net/2022/03/28/how-to-properly-interpret-a-traceroute-or-mtr/)
- [netstat/ss guide (Pluralsight)](https://www.pluralsight.com/resources/blog/cloud/netstat-network-analysis-and-troubleshooting-explained)

### Community
- [SSH connection errors (AWS)](https://repost.aws/knowledge-center/ec2-linux-resolve-ssh-connection-errors)
- [Network debugging (Debuglab)](https://debuglab.net/2025/10/27/a-developers-guide-to-network-debugging-from-browser-to-backend/)

---

## Связанные материалы

### В этом разделе
→ [[networking-overview]] — общая картина сетевых технологий
→ [[network-fundamentals-for-developers]] — базовые концепции для новичков
→ [[network-tools-reference]] — детальный справочник инструментов
→ [[network-tcpdump-wireshark]] — глубокий packet analysis
→ [[network-troubleshooting-advanced]] — сложные кейсы диагностики

### Смежные темы
→ [[observability]] — мониторинг и алертинг
→ [[docker-for-developers]] — debugging в контейнерах

---

## Связь с другими темами

**[[network-tools-reference]]** — Справочник сетевых инструментов является прямым продолжением темы отладки: если debugging basics учит системному подходу к диагностике, то tools reference предоставляет детальное описание каждого инструмента с флагами и примерами. Знание методологии отладки без владения конкретными инструментами малоэффективно, и наоборот — инструменты без методологии превращаются в хаотичный перебор. Рекомендуется сначала освоить системный подход из этой заметки, затем углубиться в справочник инструментов.

**[[network-tcpdump-wireshark]]** — Packet analysis с помощью tcpdump и Wireshark — это следующий уровень сетевой диагностики после базовых инструментов вроде ping, traceroute и curl. Когда стандартные методы не помогают локализовать проблему, захват и анализ пакетов позволяет увидеть реальное поведение сети на уровне TCP-сегментов и HTTP-заголовков. Понимание основ debugging необходимо для корректной интерпретации результатов packet analysis. Изучайте последовательно: сначала основы, затем packet analysis.

**[[ios-debugging]]** — Отладка сетевых проблем в iOS-приложениях требует знания как общих сетевых принципов, так и специфики платформы: URLSession, Network.framework, Charles Proxy. Системный подход к сетевой диагностике из этой заметки напрямую применим к мобильной разработке, где сетевые проблемы усложняются нестабильным WiFi, переключением сетей и ограничениями фоновой работы. Рекомендуется освоить общие принципы отладки перед погружением в платформенную специфику.

---

## Источники и дальнейшее чтение

- **Sanders (2017).** *Practical Packet Analysis with Wireshark.* — практическое руководство по анализу сетевого трафика, идеально дополняющее системный подход к отладке конкретными навыками работы с пакетами.
- **Kurose, Ross (2021).** *Computer Networking: A Top-Down Approach.* — фундаментальный учебник, дающий теоретическую базу для понимания каждого уровня сетевого стека, что критично для послойной диагностики проблем.
- **Hunt (2002).** *TCP/IP Network Administration.* — практическое руководство по администрированию TCP/IP-сетей с множеством примеров диагностики и решения типичных проблем.

---

*Последнее обновление: 2026-01-09 — Добавлены педагогические секции: 5 аналогий (layer-by-layer как врач, ping как стук в дверь, traceroute как GPS, три типа неудачных звонков, DevTools как рентген), 6 типичных ошибок диагностики с решениями (прыгать на L7, гуглить вместо диагностики, путать refused/timeout, забывать DNS, Security Groups, "ping=всё работает"), 5 ментальных моделей (OSI чеклист, время ответа как подсказка, "где пакет умер", изоляция проблемы, бритва Оккама)*
