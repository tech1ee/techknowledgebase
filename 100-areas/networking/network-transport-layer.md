---
title: "Транспортный уровень: TCP, UDP, QUIC"
date_created: 2025-01-15
date_modified: 2025-01-15
tags:
  - topic/networking
  - networking/transport
  - networking/protocols
  - networking/tcp
  - networking/udp
  - networking/quic
  - type/concept
  - level/intermediate
related:
  - "[[networking-overview]]"
  - "[[network-ip-routing]]"
  - "[[network-http-evolution]]"
  - "[[os-processes-threads]]"
  - "[[os-synchronization]]"
  - "[[kotlin-coroutines]]"
status: published
---

# Транспортный уровень: TCP, UDP, QUIC

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **IP-адресация** | Транспортный уровень работает поверх IP | [[network-ip-routing]] |
| **Сетевые основы** | Понимание URL, DNS, HTTP | [[network-fundamentals-for-developers]] |
| **Биты и байты** | Header-структуры в бинарном формате | Computer Science basics |

### Для кого этот материал

| Уровень | Подходит? | Рекомендация |
|---------|-----------|--------------|
| **Новичок** | ⚠️ С подготовкой | Сначала изучи основы |
| **Intermediate** | ✅ Да | Основная аудитория |
| **Advanced** | ✅ Да | Фокус на QUIC и tuning |

### Терминология для новичков

> 💡 **Транспортный уровень** = "служба доставки" для приложений. Отвечает за то, чтобы данные дошли целиком, в правильном порядке, нужному приложению.

| Термин | Значение | Аналогия для новичка |
|--------|----------|---------------------|
| **TCP** | Transmission Control Protocol — надёжная доставка | **Заказное письмо** — расписка о получении |
| **UDP** | User Datagram Protocol — быстрая доставка без гарантий | **Открытка** — быстро, но без подтверждения |
| **QUIC** | Quick UDP Internet Connections — современный протокол | **Экспресс-доставка нового поколения** — быстро И надёжно |
| **Port** | Номер приложения на хосте (0-65535) | **Номер квартиры** — в какую дверь стучать |
| **Segment** | Единица данных TCP | **Страница письма** — часть большого сообщения |
| **Datagram** | Единица данных UDP | **SMS** — короткое самостоятельное сообщение |
| **Handshake** | Установка соединения (SYN-ACK) | **Рукопожатие** — договорились о разговоре |
| **ACK** | Acknowledgement — подтверждение | **"Получил!"** — ответ что дошло |
| **Retransmission** | Повторная отправка потерянных данных | **Переотправка письма** — не дошло, шлём снова |
| **Flow Control** | Контроль скорости отправки | **"Помедленнее, не успеваю записывать"** |
| **Congestion Control** | Контроль загруженности сети | **Регулировщик на перекрёстке** — не создавать пробки |
| **Window Size** | Сколько данных можно отправить без ACK | **Размер порции** — сколько съешь за раз |

---

## Часть 1: Интуиция без кода

> 💡 **Цель раздела**: Понять транспортный уровень через 5 аналогий из реальной жизни, прежде чем погружаться в технические детали.

### Аналогия 1: TCP как заказное письмо с уведомлением

```
Обычное письмо (UDP):                    Заказное письмо (TCP):
┌─────────────────────┐                  ┌─────────────────────┐
│                     │                  │                     │
│  Бросил в ящик      │                  │  1. Отдал на почту  │
│  и забыл            │                  │  2. Получил трек    │
│                     │                  │  3. Отследил путь   │
│  Дошло? Кто знает!  │                  │  4. Получил подпись │
│                     │                  │                     │
└─────────────────────┘                  └─────────────────────┘

     "Fire and forget"                    "Гарантия доставки"
```

**Суть аналогии:**
- **TCP** = заказное письмо: вы получаете квитанцию (ACK), можете отследить, а если не дошло — почта перешлёт
- **UDP** = обычное письмо: бросили в ящик, дальше как повезёт
- **Порт** = номер квартиры: адрес дома (IP) недостаточен, нужно знать конкретную дверь

**Когда что выбрать:**
- TCP: когда каждый байт важен (файлы, веб-страницы, API)
- UDP: когда скорость важнее точности (видеозвонок — лучше пропустить кадр, чем задержать)

---

### Аналогия 2: Порты как двери в многоквартирном доме

```
IP-адрес = адрес здания        Порт = номер квартиры
   192.168.1.100                    :80, :443, :22

┌─────────────────────────────────────────────────────────┐
│                    Здание (Host)                        │
│         IP: 192.168.1.100                               │
│                                                         │
│  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐           │
│  │ :22 │  │ :80 │  │:443 │  │:3306│  │:5432│           │
│  │ SSH │  │HTTP │  │HTTPS│  │MySQL│  │Pgsql│           │
│  └──┬──┘  └──┬──┘  └──┬──┘  └──┬──┘  └──┬──┘           │
│     │       │        │        │        │               │
└─────┼───────┼────────┼────────┼────────┼───────────────┘
      │       │        │        │        │
      ▼       ▼        ▼        ▼        ▼
   Процесс Процесс  Процесс  Процесс  Процесс
    sshd   nginx     nginx    mysqld   postgres

Один хост — много сервисов, каждый слушает свой порт
```

**Почему это важно:**
- Без портов все пакеты шли бы в одну "дверь" — хаос
- Порты от 0 до 1023 — "привилегированные" (только root может слушать)
- Порты 1024-65535 — свободные для приложений

**Эфемерные (ephemeral) порты:**
```
Клиент открывает соединение:
┌──────────────┐                    ┌──────────────┐
│   Browser    │                    │  Web Server  │
│              │                    │              │
│  src: 52431 ─┼───────────────────►│   dst: 443   │
│  (случайный) │                    │ (фиксирован) │
└──────────────┘                    └──────────────┘

52431 — эфемерный порт, назначенный ОС для этого соединения
443 — well-known порт HTTPS
```

---

### Аналогия 3: Трёхстороннее рукопожатие как знакомство

```
Представьте знакомство на вечеринке:

Вася                                           Петя
  │                                              │
  │  "Привет, я Вася, хочу поговорить"           │
  │  ────────────────────────────────────────►   │  SYN
  │                                              │
  │  "Привет Вася! Я Петя, давай"                │
  │  ◄────────────────────────────────────────   │  SYN-ACK
  │                                              │
  │  "Отлично, Петя, начинаем!"                  │
  │  ────────────────────────────────────────►   │  ACK
  │                                              │
  │         [Теперь оба готовы говорить]         │
  │                                              │

ПОЧЕМУ ТРИ, А НЕ ДВА?

Два шага:
  Вася: "Привет!"
  Петя: "Привет!"
  → Вася не знает, получил ли Петя его приветствие

Три шага:
  Вася: "Привет!" (я готов)
  Петя: "Привет! Слышу тебя" (я тоже готов)
  Вася: "Отлично, слышу тебя" (подтверждаю)
  → Оба уверены, что канал работает в обе стороны
```

**Важный момент — sequence numbers:**
```
Зачем случайные начальные номера?

Плохо (предсказуемо):
  Вася: seq=0    →  Хакер может угадать
  Петя: seq=0       и подделать пакеты

Хорошо (случайно):
  Вася: seq=2847361092    →  Угадать невозможно
  Петя: seq=1938472655
```

---

### Аналогия 4: Window как размер "трубы" для данных

```
Flow Control: "Не заливай меня данными!"

Без окна:                           С окном:
┌─────────┐    ▓▓▓▓▓▓▓▓▓▓         ┌─────────┐    ▓▓▓
│ Sender  │    ▓▓▓▓▓▓▓▓▓▓         │ Sender  │    ▓▓▓
│         │──► ▓▓▓▓▓▓▓▓▓▓ ──X     │         │──► ▓▓▓ ──►┌─────────┐
└─────────┘    ПЕРЕПОЛНЕНИЕ!      └─────────┘         │Receiver │
                                                       │ Window  │
                                   "У меня место       │  =3KB   │
                                    только на 3KB"     └─────────┘

Sliding Window — скользящее окно:

Отправитель видит:
┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
│ 1  │ 2  │ 3  │ 4  │ 5  │ 6  │ 7  │ 8  │ 9  │ 10 │
└────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘
  ▲         ▲                   ▲
  │         │                   │
  Подтверж. │                   │
             Отправлено,        Можно отправить
             ждём ACK           (окно = 4)

После получения ACK для 1-2:
┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
│ 1  │ 2  │ 3  │ 4  │ 5  │ 6  │ 7  │ 8  │ 9  │ 10 │
└────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘
              ▲                       ▲
              │                       │
              Окно "сдвинулось" вправо
```

**Congestion Control — другая проблема:**
```
Flow Control:      "Получатель не успевает"
Congestion Control: "Сеть перегружена"

         Отправитель                    Получатель
              │                              │
              │     ┌──── Сеть ────┐         │
              │     │   Роутеры    │         │
              │─────┤   ПРОБКА!    ├─────────│
              │     │   ▓▓▓▓▓▓▓    │         │
              │     └──────────────┘         │

Если все будут слать на максимуме → коллапс сети
TCP вежливо "притормаживает" при потерях
```

---

### Аналогия 5: QUIC как несколько независимых труб

```
Проблема TCP + HTTP/2 (одна труба):

┌─────────────────────────────────────────────────────┐
│  TCP Connection (одна труба для всего)              │
│  ═══════════════════════════════════════════════    │
│                                                     │
│  Stream 1: [HTML]─────►                             │
│  Stream 2: [CSS]──────►  ← Пакет потерян            │
│  Stream 3: [JS]───────►                             │
│  Stream 4: [Image]────►                             │
│                                                     │
│  💥 CSS потерялся → ВСЁ СТОИТ (Head-of-Line Block) │
│     Даже готовые HTML, JS, Image ждут!              │
└─────────────────────────────────────────────────────┘

QUIC (независимые трубы):

┌─────────────────────────────────────────────────────┐
│  QUIC Connection (несколько независимых потоков)    │
│                                                     │
│  Stream 1: ════[HTML]════════► ✓ Доставлено        │
│  Stream 2: ════[CSS]═══X═════► ⏳ Ретрансмит       │
│  Stream 3: ════[JS]══════════► ✓ Доставлено        │
│  Stream 4: ════[Image]═══════► ✓ Доставлено        │
│                                                     │
│  CSS потерялся → только CSS ждёт пересылки         │
│  Остальные потоки работают независимо!              │
└─────────────────────────────────────────────────────┘
```

**QUIC vs TCP — скорость соединения:**
```
TCP + TLS 1.2 (классика):         QUIC (современность):

Round 1: SYN ──────────────►      Round 1: Initial + данные ──►
         ◄────────── SYN-ACK               ◄────────── Response
Round 2: ACK ──────────────►
         ClientHello ──────►
         ◄──────── ServerHello
Round 3: Finished ─────────►
         ◄────────── Finished
Round 4: HTTP Request ─────►

Итого: 3-4 RTT                    Итого: 1 RTT (или 0 для повторных!)

При RTT = 100ms:
TCP+TLS: 300-400ms до данных
QUIC: 100ms (или 0ms!)
```

---

## Часть 2: Почему это сложно — 6 типичных ошибок

### Ошибка 1: Предполагать, что `read()` вернёт всё

```
❌ СИМПТОМ:
Данные "обрезаются" или приходят частями

Код:
  byte[] buffer = new byte[1024];
  inputStream.read(buffer);  // Ожидал 1024 байта
  // Получил... 127 байт. Где остальное?!

📋 ДИАГНОСТИКА:
TCP — потоковый протокол. read() возвращает "сколько есть сейчас",
а не "сколько отправили". Сегментация и буферизация — норма.

✅ РЕШЕНИЕ:
// Читать в цикле до конца
ByteArrayOutputStream result = new ByteArrayOutputStream();
byte[] buffer = new byte[1024];
int bytesRead;
while ((bytesRead = inputStream.read(buffer)) != -1) {
    result.write(buffer, 0, bytesRead);
}

// Или использовать readFully() / readNBytes()
byte[] data = inputStream.readNBytes(expectedLength);
```

---

### Ошибка 2: Connection refused vs Connection timeout

```
❌ СИМПТОМ 1: "Connection refused" (мгновенно)
📋 ПРИЧИНА: Порт закрыт, никто не слушает
            Хост получил пакет и сказал "нет такой двери"

✅ РЕШЕНИЕ:
- Проверь, запущен ли сервис
- Проверь правильность порта
- netstat -tlnp | grep PORT

───────────────────────────────────────────────────

❌ СИМПТОМ 2: "Connection timed out" (долго, потом ошибка)
📋 ПРИЧИНА: Пакеты не доходят вообще (firewall, нет маршрута)
            Хост не отвечает ни "да", ни "нет"

✅ РЕШЕНИЕ:
- Проверь firewall: iptables -L, ufw status
- Проверь маршрут: traceroute HOST
- Проверь доступность: ping HOST

ВИЗУАЛЬНО:

Connection refused:            Connection timeout:
┌────────┐     ┌────────┐     ┌────────┐     ╳ Firewall
│ Client │────►│ Server │     │ Client │────►╳
│        │◄────│  RST   │     │        │     ╳ (тишина)
└────────┘     └────────┘     └────────┘
  Быстро!                       Долго ждём...
```

---

### Ошибка 3: Накопление TIME_WAIT — "порты кончились"

```
❌ СИМПТОМ:
"Cannot assign requested address"
"Too many open files"
Тысячи соединений в состоянии TIME_WAIT

$ netstat -an | grep TIME_WAIT | wc -l
28547  ← Проблема!

📋 ПРИЧИНА:
TCP ждёт 2*MSL (60-120 сек) после закрытия соединения,
чтобы "опоздавшие" пакеты не попали в новое соединение
на тех же портах.

При высокой нагрузке (тысячи запросов/сек) —
эфемерные порты заканчиваются.

┌──────────────────────────────────────────────────┐
│         Жизнь TCP-соединения                     │
│                                                  │
│  ESTABLISHED ──► FIN_WAIT ──► TIME_WAIT ──► CLOSED
│                                    │             │
│                                    └─ 60-120 сек │
└──────────────────────────────────────────────────┘

✅ РЕШЕНИЯ:

1. Connection pooling (переиспользуй соединения):
   HttpClient client = HttpClient.newBuilder()
       .connectTimeout(Duration.ofSeconds(10))
       .build();  // Один клиент на всё приложение

2. HTTP Keep-Alive (не закрывай после каждого запроса):
   Connection: keep-alive

3. SO_REUSEADDR (осторожно!):
   socket.setReuseAddress(true);

4. Настройка ядра (Linux):
   sysctl -w net.ipv4.tcp_tw_reuse=1
```

---

### Ошибка 4: Nagle's algorithm мешает real-time

```
❌ СИМПТОМ:
Интерактивное приложение "тормозит" на 40-200ms
Маленькие пакеты отправляются с задержкой
Игра/чат "лагает" без видимой причины

📋 ПРИЧИНА:
Nagle's algorithm буферизует мелкие пакеты для эффективности.
Хорошо для bulk transfer, плохо для интерактивности.

Nagle включён (по умолчанию):
┌──────────────────────────────────────────────┐
│ App: send("H")                               │
│      send("e")    → Nagle: "Подожду ещё..."  │
│      send("l")                               │
│      send("l")                               │
│      send("o")                               │
│                   → Nagle: "Ок, отправляю"   │
│ Network: [Hello]  (одним пакетом, но с задержкой)
└──────────────────────────────────────────────┘

✅ РЕШЕНИЕ:

// Отключить Nagle для интерактивных приложений
socket.setTcpNoDelay(true);

// Теперь каждый send() отправляется сразу
// Больше пакетов, но меньше latency

КОГДА ОТКЛЮЧАТЬ:
✓ Игры, чаты, терминалы
✓ Интерактивные протоколы
✓ Когда latency важнее throughput

КОГДА ОСТАВИТЬ:
✓ Передача файлов
✓ Bulk data transfer
✓ Когда throughput важнее latency
```

---

### Ошибка 5: Нет таймаутов — вечное ожидание

```
❌ СИМПТОМ:
Программа "зависает" при сетевых операциях
Потоки блокируются навсегда
Приложение "не отвечает" при проблемах с сетью

📋 ПРИЧИНА:
По умолчанию сокеты ждут бесконечно.
Если сервер не отвечает — вы просто ждёте.

// Плохо:
Socket socket = new Socket();
socket.connect(address);  // Может висеть вечно
socket.getInputStream().read();  // Может висеть вечно

✅ РЕШЕНИЕ:

// Connect timeout — сколько ждать соединения
socket.connect(address, 5000);  // 5 секунд

// Read timeout — сколько ждать данных
socket.setSoTimeout(30000);  // 30 секунд

// Для HTTP клиентов:
HttpClient client = HttpClient.newBuilder()
    .connectTimeout(Duration.ofSeconds(5))
    .build();

OkHttpClient client = new OkHttpClient.Builder()
    .connectTimeout(10, TimeUnit.SECONDS)
    .readTimeout(30, TimeUnit.SECONDS)
    .writeTimeout(30, TimeUnit.SECONDS)
    .build();

ПРАВИЛО: Всегда задавай таймауты!
- Connect: 5-10 секунд
- Read: 30-60 секунд (зависит от операции)
- Idle: для Keep-Alive соединений
```

---

### Ошибка 6: Закрытие без graceful shutdown

```
❌ СИМПТОМ:
Данные "теряются" при закрытии соединения
RST вместо FIN в логах
Сервер не получает последние данные от клиента

📋 ПРИЧИНА:
close() может отправить RST вместо FIN,
если в буфере есть непрочитанные данные.

Грубое закрытие (RST):
Client: "Пока!" *хлопает дверью*
Server: "Подожди, я не договорил..." *ошибка*

Вежливое закрытие (FIN):
Client: "Я закончил отправлять"
Server: "Понял, вот мои последние данные... Я тоже закончил"
Client: "Принял, до свидания"

✅ РЕШЕНИЕ:

// Полный graceful shutdown
socket.shutdownOutput();  // Отправить FIN, но читать можно

// Дочитать оставшиеся данные от сервера
while (inputStream.read(buffer) != -1) {
    // обработка
}

socket.close();  // Теперь безопасно закрыть

// Или использовать try-with-resources правильно:
try (Socket socket = new Socket(host, port);
     var out = socket.getOutputStream();
     var in = socket.getInputStream()) {

    out.write(request);
    out.flush();

    socket.shutdownOutput();  // Сигнал "я закончил писать"

    // Читаем ответ до конца
    byte[] response = in.readAllBytes();
}
```

---

## Часть 3: Ментальные модели

### Модель 1: Транспорт как почтовая служба

```
┌─────────────────────────────────────────────────────────┐
│                    ПОЧТОВАЯ АНАЛОГИЯ                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  IP-уровень = Почтовая служба                           │
│  ├─ Доставляет между городами (хостами)                │
│  ├─ Не гарантирует доставку                            │
│  └─ Не знает, кому именно в городе                     │
│                                                         │
│  TCP = Заказное письмо с уведомлением                   │
│  ├─ Квитанция о отправке (SYN-ACK)                     │
│  ├─ Уведомление о вручении (ACK)                       │
│  ├─ Перенаправление при ошибке (retransmit)            │
│  └─ Номер квартиры (port)                              │
│                                                         │
│  UDP = Листовка в почтовый ящик                         │
│  ├─ Быстро и дёшево                                    │
│  ├─ Без гарантий (может выкинут)                       │
│  └─ Подходит для массовой рассылки (broadcast)         │
│                                                         │
│  QUIC = Премиум курьер с мобильным приложением          │
│  ├─ Мгновенное подтверждение (0-RTT)                   │
│  ├─ Отслеживание в реальном времени                    │
│  ├─ Не теряет посылку при смене адреса (migration)     │
│  └─ Несколько независимых доставок одновременно        │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

### Модель 2: TCP как телефонный разговор

```
TCP = Телефонный звонок:

1. УСТАНОВКА (Handshake):
   📞 Набираешь номер         → SYN
   📞 Слышишь гудки, ответ   → SYN-ACK
   📞 "Алло, это Вася?"      → ACK

2. РАЗГОВОР (Data Transfer):
   📞 Говоришь, слушаешь     → Данные туда-сюда
   📞 "Повтори, не расслышал" → Retransmission
   📞 "Помедленнее, записываю" → Flow Control

3. ЗАВЕРШЕНИЕ (Termination):
   📞 "Ну всё, пока"         → FIN
   📞 "Пока-пока"            → ACK + FIN
   📞 *вешаешь трубку*       → ACK

UDP = Рация / Громкоговоритель:

📻 Нажал кнопку — говоришь  → Отправил датаграм
📻 Отпустил — слушаешь      → Может кто ответит
📻 Нет соединения           → Просто broadcast
📻 Кто услышал — услышал    → Нет гарантий
```

---

### Модель 3: Состояния TCP как конечный автомат

```
Представь TCP как персонажа в игре с состояниями:

┌──────────────────────────────────────────────────────────┐
│                    TCP STATE MACHINE                      │
│                         RPG-style                         │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  [CLOSED] 💤 "Сплю, никого не жду"                       │
│      │                                                   │
│      │ listen()                                          │
│      ▼                                                   │
│  [LISTEN] 👂 "Жду гостей"  ←── Сервер                    │
│      │                                                   │
│      │ получил SYN                                       │
│      ▼                                                   │
│  [SYN_RCVD] 🤝 "Здороваюсь"                              │
│      │                                                   │
│      │ получил ACK                                       │
│      ▼                                                   │
│  [ESTABLISHED] 💬 "Общаемся!" ←── Основное состояние     │
│      │                                                   │
│      │ получил FIN или close()                           │
│      ▼                                                   │
│  [FIN_WAIT / CLOSE_WAIT] 👋 "Прощаемся"                  │
│      │                                                   │
│      │ финальные ACK                                     │
│      ▼                                                   │
│  [TIME_WAIT] ⏰ "Жду на всякий случай" (2 минуты)        │
│      │                                                   │
│      │ timeout                                           │
│      ▼                                                   │
│  [CLOSED] 💤 "Снова сплю"                                │
│                                                          │
└──────────────────────────────────────────────────────────┘

Проблемные состояния для диагностики:
• SYN_SENT висит долго → сервер не отвечает / firewall
• SYN_RCVD много штук → возможно SYN flood атака
• CLOSE_WAIT много → приложение не закрывает сокеты
• TIME_WAIT много → высокая нагрузка, нормально (или нужен pooling)
```

---

### Модель 4: Congestion Control как вежливый водитель

```
Представь сеть как дорогу, а TCP как вежливого водителя:

SLOW START — выезд на трассу:
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  Скорость: 10 → 20 → 40 → 80 → 160 км/ч                 │
│            ↑    ↑    ↑    ↑    ↑                        │
│        Разгоняюсь экспоненциально, пока дорога свободна │
│                                                         │
└─────────────────────────────────────────────────────────┘

CONGESTION AVOIDANCE — крейсерская скорость:
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  Скорость: 160 → 161 → 162 → 163 км/ч                   │
│                ↑     ↑     ↑                            │
│            Добавляю по чуть-чуть, слежу за дорогой      │
│                                                         │
└─────────────────────────────────────────────────────────┘

ПОТЕРЯ ПАКЕТА — авария впереди!

Timeout (серьёзная авария):
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  💥 Совсем плохо → Еду 10 км/ч (cwnd = 1)              │
│                    Начинаю разгон сначала               │
│                                                         │
└─────────────────────────────────────────────────────────┘

3 Duplicate ACKs (небольшая пробка):
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  ⚠️ Пробка → Сбрасываю до половины скорости             │
│              (cwnd = cwnd/2)                            │
│              Быстро восстанавливаюсь                    │
│                                                         │
└─────────────────────────────────────────────────────────┘

BBR — умный водитель с навигатором:
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  🧭 Измеряю пропускную способность дороги               │
│  📊 Измеряю время в пути (RTT)                          │
│  🎯 Еду с оптимальной скоростью, не создавая пробок     │
│                                                         │
│  Не жду аварии, чтобы узнать о проблеме!                │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

### Модель 5: Выбор протокола как выбор транспорта

```
┌─────────────────────────────────────────────────────────────┐
│            ТРАНСПОРТНАЯ АНАЛОГИЯ                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Что везёшь?              Какой транспорт?                  │
│  ─────────────────────────────────────────                  │
│                                                             │
│  📄 Важные документы      →  TCP (заказная почта)           │
│     (файлы, API)             Гарантия доставки важнее       │
│                                                             │
│  📺 Видеозвонок           →  UDP + свой контроль            │
│     (потеря кадра ОК)        Скорость важнее полноты        │
│                                                             │
│  🎮 Онлайн игра           →  UDP                            │
│     (старые данные бесполезны) Latency критична             │
│                                                             │
│  🌐 Веб-страница          →  QUIC (HTTP/3)                  │
│     (много ресурсов)         Параллелизм + скорость         │
│                                                             │
│  📱 Мобильное приложение  →  QUIC                           │
│     (WiFi → LTE переходы)    Connection migration           │
│                                                             │
│  🔧 Internal microservices →  gRPC (HTTP/2 или QUIC)        │
│     (высокий throughput)     Эффективность + streaming      │
│                                                             │
└─────────────────────────────────────────────────────────────┘

DECISION FLOWCHART:

     Данные критичны?
           │
     ┌─────┴─────┐
     Да         Нет
     │           │
     │      Latency критична?
     │           │
     │     ┌─────┴─────┐
     │     Да         Нет
     │     │           │
     │     UDP         TCP
     │  (игры, VoIP)  (bulk transfer)
     │
  Много параллельных запросов?
           │
     ┌─────┴─────┐
     Да         Нет
     │           │
   QUIC        TCP
(HTTP/3, mobile) (простые API)
```

---

## Зачем нужен транспортный уровень?

IP-уровень доставляет пакеты между хостами. Но этого недостаточно:

```
Проблемы, которые IP НЕ решает:
├─ Какому приложению предназначен пакет? (Web server? SSH? Database?)
├─ Что делать, если пакет потерялся?
├─ Что делать, если пакеты пришли не в том порядке?
├─ Что делать, если получатель не успевает обрабатывать?
└─ Как передать больше данных, чем влезает в один пакет?
```

**Транспортный уровень** решает эти проблемы, предоставляя:
- **Мультиплексирование** — порты позволяют множеству приложений использовать сеть одновременно
- **Надёжность** (опционально) — гарантия доставки и порядка
- **Flow control** — защита получателя от перегрузки
- **Congestion control** — защита сети от перегрузки

---

## TCP: Transmission Control Protocol

### Историческая справка

**1974** — Vint Cerf и Bob Kahn публикуют "A Protocol for Packet Network Intercommunication", описывающий TCP.

**1981** — RFC 793 формализует TCP. С тех пор протокол практически не менялся в своей основе, только добавлялись расширения.

**Почему TCP доминирует?** Он решил ключевую проблему: как надёжно передавать данные поверх ненадёжной сети. До TCP каждое приложение реализовывало свою логику retransmission.

### TCP Header: структура

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |           |U|A|P|R|S|F|                               |
| Offset| Reserved  |R|C|S|S|Y|I|            Window             |
|       |           |G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**Ключевые поля:**

| Поле | Размер | Назначение |
|------|--------|------------|
| **Source/Dest Port** | 16 бит каждый | Идентификация приложений (0-65535) |
| **Sequence Number** | 32 бита | Позиция первого байта данных в потоке |
| **Acknowledgment Number** | 32 бита | Следующий ожидаемый байт |
| **Flags** | 6 бит | SYN, ACK, FIN, RST, PSH, URG |
| **Window** | 16 бит | Flow control — сколько байт готов принять |
| **Checksum** | 16 бит | Проверка целостности |

### TCP Connection Establishment: Three-Way Handshake

```
    Client                                      Server
       │                                           │
       │  1. SYN (seq=x)                           │
       │  ─────────────────────────────────────►   │
       │  "Хочу установить соединение"             │
       │                                           │
       │  2. SYN-ACK (seq=y, ack=x+1)              │
       │  ◄─────────────────────────────────────   │
       │  "Ок, давай. Вот мой seq"                 │
       │                                           │
       │  3. ACK (seq=x+1, ack=y+1)                │
       │  ─────────────────────────────────────►   │
       │  "Принял, начинаем"                       │
       │                                           │
    ───┴───────────────────────────────────────────┴───
              Соединение установлено (1.5 RTT)
```

**Почему три пакета, а не два?**

Каждая сторона должна:
1. Сообщить свой начальный sequence number
2. Подтвердить получение sequence number другой стороны

Два пакета не позволяют серверу убедиться, что клиент получил его SYN.

**Initial Sequence Number (ISN)**: выбирается случайно для защиты от sequence prediction attacks.

### TCP Connection Termination: Four-Way Handshake

```
    Client                                      Server
       │                                           │
       │  1. FIN (seq=x)                           │
       │  ─────────────────────────────────────►   │
       │  "Я закончил отправлять"                  │
       │                                           │
       │  2. ACK (ack=x+1)                         │
       │  ◄─────────────────────────────────────   │
       │  "Понял"                                  │
       │                                           │
       │      (сервер может ещё отправлять)        │
       │                                           │
       │  3. FIN (seq=y)                           │
       │  ◄─────────────────────────────────────   │
       │  "Я тоже закончил"                        │
       │                                           │
       │  4. ACK (ack=y+1)                         │
       │  ─────────────────────────────────────►   │
       │  "Понял, закрываем"                       │
       │                                           │
    ───┴───────────────────────────────────────────┴───
            TIME_WAIT (2*MSL, обычно 60 сек)
```

**TIME_WAIT**: клиент ждёт 2*MSL (Maximum Segment Lifetime, обычно 30 сек) перед полным закрытием. Это гарантирует, что поздние пакеты от предыдущего соединения не попадут в новое соединение на тех же портах.

### TCP States: диаграмма состояний

```
                              ┌───────────────┐
                              │    CLOSED     │
                              └───────┬───────┘
                   ┌────────────────┬─┴─┬────────────────┐
            passive open     active open  │          simultaneous
                   │               │      │              open
                   ▼               ▼      │               │
           ┌───────────────┐ ┌───────────────┐           │
           │    LISTEN     │ │   SYN_SENT    │◄──────────┘
           └───────┬───────┘ └───────┬───────┘
                   │ rcv SYN        │ rcv SYN+ACK
                   │ send SYN+ACK   │ send ACK
                   ▼                ▼
           ┌───────────────┐ ┌───────────────┐
           │   SYN_RCVD    │ │ ESTABLISHED   │
           └───────┬───────┘ └───────┬───────┘
                   │ rcv ACK        │
                   └────────┬───────┘
                            │
                            ▼
                    ┌───────────────┐
                    │  ESTABLISHED  │ ◄── Данные передаются здесь
                    └───────┬───────┘
             ┌──────────────┴──────────────┐
      close/send FIN               rcv FIN/send ACK
             │                             │
             ▼                             ▼
     ┌───────────────┐             ┌───────────────┐
     │   FIN_WAIT_1  │             │  CLOSE_WAIT   │
     └───────┬───────┘             └───────┬───────┘
             │ rcv ACK                     │ close/send FIN
             ▼                             ▼
     ┌───────────────┐             ┌───────────────┐
     │   FIN_WAIT_2  │             │   LAST_ACK    │
     └───────┬───────┘             └───────┬───────┘
             │ rcv FIN/send ACK            │ rcv ACK
             ▼                             ▼
     ┌───────────────┐             ┌───────────────┐
     │   TIME_WAIT   │             │    CLOSED     │
     └───────┬───────┘             └───────────────┘
             │ 2MSL timeout
             ▼
     ┌───────────────┐
     │    CLOSED     │
     └───────────────┘
```

### Flow Control: Window Size

**Проблема**: получатель может не успевать обрабатывать данные. Если отправитель будет слать без ограничений, буферы переполнятся, пакеты будут отброшены.

**Решение**: **Sliding Window** — получатель сообщает, сколько байт он готов принять.

```
Sender's view:
┌───────────────────────────────────────────────────────────┐
│ Sent &  │    Sent but     │    Can send    │   Cannot    │
│  ACKed  │   not ACKed     │   (window)     │    send     │
└─────────┴─────────────────┴────────────────┴─────────────┘
          ▲                 ▲                ▲
          │                 │                │
       SND.UNA           SND.NXT         SND.UNA + SND.WND

Receiver advertises: "Window = 16384 bytes"
Sender can have up to 16384 unacknowledged bytes in flight
```

**Window Scaling** (RFC 7323): 16-битное поле Window ограничивает окно до 64KB. Для высокоскоростных сетей этого мало. Window Scaling option позволяет масштабировать до 1GB.

### Congestion Control: защита сети

**Проблема**: даже если получатель готов принимать данные, сеть может быть перегружена. Если все будут слать на максимуме, маршрутизаторы начнут отбрасывать пакеты.

**Congestion Window (cwnd)**: отправитель поддерживает собственное окно, ограничивающее количество данных in flight.

```
Effective window = min(rwnd, cwnd)
где rwnd — receiver window (flow control)
    cwnd — congestion window (congestion control)
```

#### Алгоритмы Congestion Control

**Slow Start** (начальная фаза):
```
cwnd = 1 MSS (Maximum Segment Size)
При каждом ACK: cwnd += 1 MSS
Результат: экспоненциальный рост (1 → 2 → 4 → 8 → ...)
Продолжается до: ssthresh (slow start threshold) или потери
```

**Congestion Avoidance** (после ssthresh):
```
При каждом RTT: cwnd += 1 MSS
Результат: линейный рост
Продолжается до: потери пакета
```

**Fast Retransmit & Fast Recovery**:
```
При получении 3 duplicate ACKs:
├─ Не ждать timeout
├─ Сразу retransmit потерянный сегмент
├─ ssthresh = cwnd / 2
└─ cwnd = ssthresh + 3 MSS (Fast Recovery)
```

```
       cwnd
        ▲
        │            ┌── Потеря (timeout)
        │            │   ssthresh = cwnd/2
        │      ●─────●   cwnd = 1
        │     /│     │
        │    / │     │
        │   /  │     │
        │  ●   │     │
        │ /│   │     │      ┌── 3 dup ACKs
        │/ │   │     │      │   ssthresh = cwnd/2
        ●  │   │     ●──────●   cwnd = ssthresh
        │  │   │    /│      │
        │  │   │   / │      │
   ─────┴──┴───┴──/──┴──────┴────────► время
           │     /   │
           │    /    │
           └───/─────┘
        Slow Start  Congestion Avoidance
```

#### Современные алгоритмы

| Алгоритм | Год | Особенности |
|----------|-----|-------------|
| **Reno** | 1990 | Классический, basis for others |
| **CUBIC** | 2008 | Linux default, быстрое восстановление |
| **BBR** | 2016 | Google, модель на основе bandwidth и RTT |
| **BBRv2** | 2022 | Улучшенная fairness с другими алгоритмами |

**BBR (Bottleneck Bandwidth and RTT)**: вместо реакции на потери, BBR строит модель сети и старается работать на оптимальной точке.

```
Традиционные алгоритмы:
"Потеря пакета = сеть перегружена" → уменьшить cwnd

BBR:
"Измеряю bandwidth и RTT" → поддерживаю оптимальный rate
```

### TCP Options: расширения

| Option | Назначение |
|--------|------------|
| **MSS** | Maximum Segment Size, сообщается при handshake |
| **Window Scale** | Масштабирование окна до 1GB |
| **SACK** | Selective ACK — подтверждение отдельных сегментов |
| **Timestamps** | RTT измерение, защита от wraparound |
| **TCP Fast Open** | Данные в SYN пакете (0-RTT для повторных соединений) |

### TCP в коде: сокеты

```java
// Server (Java)
ServerSocket serverSocket = new ServerSocket(8080);
Socket clientSocket = serverSocket.accept();  // Blocking, ждёт соединения

InputStream in = clientSocket.getInputStream();
OutputStream out = clientSocket.getOutputStream();

// Read/Write — TCP гарантирует порядок и доставку
byte[] buffer = new byte[1024];
int bytesRead = in.read(buffer);  // Может вернуть меньше, чем буфер!

out.write("Response".getBytes());
out.flush();

clientSocket.close();  // FIN
serverSocket.close();
```

```kotlin
// Kotlin with Coroutines
suspend fun handleConnection(socket: Socket) = withContext(Dispatchers.IO) {
    socket.use { sock ->
        val reader = sock.getInputStream().bufferedReader()
        val writer = sock.getOutputStream().bufferedWriter()

        val request = reader.readLine()
        writer.write("HTTP/1.1 200 OK\r\n\r\nHello")
        writer.flush()
    }
}
```

---

## UDP: User Datagram Protocol

### Зачем нужен UDP, если есть TCP?

**TCP** добавляет overhead:
- Handshake (1.5 RTT до первых данных)
- Head-of-line blocking (потеря одного пакета блокирует весь поток)
- Congestion control может быть слишком консервативным

**UDP** — "голый" транспорт:
- Нет соединения — отправляй сразу
- Нет гарантий — потеряли и потеряли
- Нет порядка — обрабатывай как придёт
- Минимальный header (8 байт vs 20+ у TCP)

### UDP Header

```
 0      7 8     15 16    23 24    31
+--------+--------+--------+--------+
|   Source Port   |   Dest Port     |
+--------+--------+--------+--------+
|     Length      |    Checksum     |
+--------+--------+--------+--------+
|              data                 |
+-----------------------------------+
```

**Всего 8 байт header** против минимум 20 у TCP.

### Когда использовать UDP?

```
Используй UDP когда:
├─ Потеря пакета лучше, чем задержка
│  └─ Видео/аудио стриминг: лучше пропустить кадр, чем задержать
│
├─ Приложение само управляет надёжностью
│  └─ QUIC, игры с client-side prediction
│
├─ Broadcast/Multicast
│  └─ TCP не поддерживает multicast
│
├─ Простые запрос-ответ протоколы
│  └─ DNS: один пакет запроса, один пакет ответа
│
└─ High-frequency data с допустимой потерей
   └─ Telemetry, metrics
```

### UDP в реальных протоколах

| Протокол | Почему UDP |
|----------|------------|
| **DNS** | Простой запрос-ответ, TCP fallback для больших ответов |
| **DHCP** | Broadcast, клиент ещё не имеет IP |
| **QUIC** | Собственная надёжность, избегает TCP HOL blocking |
| **RTP** | Real-time audio/video, потеря лучше задержки |
| **Gaming** | Low latency критичен, outdated data бесполезны |

### UDP в коде

```java
// UDP Server
DatagramSocket socket = new DatagramSocket(9999);
byte[] buffer = new byte[1024];
DatagramPacket packet = new DatagramPacket(buffer, buffer.length);

socket.receive(packet);  // Получаем один датаграм
String message = new String(packet.getData(), 0, packet.getLength());

// Отправляем ответ
byte[] response = "ACK".getBytes();
DatagramPacket responsePacket = new DatagramPacket(
    response, response.length,
    packet.getAddress(), packet.getPort()
);
socket.send(responsePacket);
```

---

## QUIC: следующая эволюция

### Историческая справка

**2012** — Google начинает эксперименты с QUIC (Quick UDP Internet Connections).

**2016** — QUIC используется для ~7% интернет-трафика (в основном Google services).

**2021** — RFC 9000 стандартизирует QUIC.

**2022** — RFC 9114 определяет HTTP/3 поверх QUIC.

**2024** — ~30% top websites поддерживают HTTP/3/QUIC.

### Почему QUIC?

**Проблема TCP #1: Head-of-Line Blocking**

```
HTTP/2 over TCP:
┌─────────────────────────────────────────────────────────────┐
│  Stream 1: [A][B][C]     Stream 2: [X][Y][Z]                │
│                │                        │                   │
│                ▼                        ▼                   │
│            TCP: [A][X][B][Y][C][Z] (multiplexed)            │
│                     ▲                                       │
│                     │ Пакет [X] потерян                     │
│                     │                                       │
│            TCP ждёт retransmission [X]                      │
│            Пакеты [B],[Y],[C],[Z] заблокированы!            │
└─────────────────────────────────────────────────────────────┘

QUIC:
┌─────────────────────────────────────────────────────────────┐
│  Stream 1: [A][B][C]     Stream 2: [X][Y][Z]                │
│                │                        │                   │
│                ▼                        ▼                   │
│  QUIC streams независимы друг от друга                      │
│                     ▲                                       │
│                     │ Пакет [X] потерян                     │
│                     │                                       │
│  Stream 2 ждёт retransmission [X]                           │
│  Stream 1 продолжает работать! [B],[C] доставлены           │
└─────────────────────────────────────────────────────────────┘
```

**Проблема TCP #2: Connection Establishment Latency**

```
TCP + TLS 1.2:
┌────────────────────────────────────────────────────────────┐
│                                                            │
│   Client              Network              Server          │
│      │                                        │            │
│      │─── SYN ───────────────────────────────►│  1 RTT     │
│      │◄── SYN-ACK ────────────────────────────│            │
│      │─── ACK ───────────────────────────────►│            │
│      │                                        │            │
│      │─── ClientHello ───────────────────────►│  2 RTT     │
│      │◄── ServerHello, Certificate ──────────│            │
│      │─── Key Exchange ──────────────────────►│            │
│      │◄── Finished ──────────────────────────│            │
│      │                                        │            │
│      │─── HTTP Request ──────────────────────►│  Данные    │
│                                                            │
│   Итого: 3 RTT до первых данных                            │
└────────────────────────────────────────────────────────────┘

QUIC:
┌────────────────────────────────────────────────────────────┐
│                                                            │
│   Client              Network              Server          │
│      │                                        │            │
│      │─── Initial (Crypto + HTTP Request) ───►│  1 RTT     │
│      │◄── Initial (Crypto) + Response ───────│            │
│      │                                        │            │
│   Итого: 1 RTT (или 0-RTT для повторных соединений!)       │
└────────────────────────────────────────────────────────────┘
```

**Проблема TCP #3: Connection Migration**

```
TCP: соединение = (src IP, src port, dst IP, dst port)

Смена IP (например, WiFi → Cellular):
├─ TCP соединение разрывается
├─ Новый handshake
├─ TLS renegotiation
└─ Всё состояние потеряно

QUIC: соединение = Connection ID

Смена IP:
├─ Connection ID остаётся прежним
├─ Соединение продолжается
└─ Прозрачно для приложения
```

### QUIC Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     Application (HTTP/3)                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────────────────────────────────────────────────┐   │
│  │                    QUIC Layer                        │   │
│  │  ┌────────────┐ ┌────────────┐ ┌────────────┐       │   │
│  │  │  Stream 1  │ │  Stream 2  │ │  Stream N  │       │   │
│  │  └────────────┘ └────────────┘ └────────────┘       │   │
│  │                                                      │   │
│  │  ┌──────────────────────────────────────────────┐   │   │
│  │  │           Connection Management               │   │   │
│  │  │  • Connection ID                              │   │   │
│  │  │  • Connection Migration                       │   │   │
│  │  │  • Version Negotiation                        │   │   │
│  │  └──────────────────────────────────────────────┘   │   │
│  │                                                      │   │
│  │  ┌──────────────────────────────────────────────┐   │   │
│  │  │           Loss Detection & Recovery           │   │   │
│  │  │  • Per-stream retransmission                  │   │   │
│  │  │  • ACK-based (не NACK)                        │   │   │
│  │  └──────────────────────────────────────────────┘   │   │
│  │                                                      │   │
│  │  ┌──────────────────────────────────────────────┐   │   │
│  │  │           Congestion Control                  │   │   │
│  │  │  • Pluggable (Cubic, BBR, ...)               │   │   │
│  │  └──────────────────────────────────────────────┘   │   │
│  │                                                      │   │
│  │  ┌──────────────────────────────────────────────┐   │   │
│  │  │           TLS 1.3 (integrated)                │   │   │
│  │  │  • Encryption from packet 1                   │   │   │
│  │  │  • 0-RTT resumption                           │   │   │
│  │  └──────────────────────────────────────────────┘   │   │
│  └──────────────────────────────────────────────────────┘   │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                          UDP                                │
├─────────────────────────────────────────────────────────────┤
│                          IP                                 │
└─────────────────────────────────────────────────────────────┘
```

### QUIC Packet Structure

```
QUIC Long Header (used during handshake):
┌────────────────────────────────────────────────────────────┐
│ Header Form (1) │ Fixed Bit (1) │ Type (2) │ Reserved (2) │
├────────────────────────────────────────────────────────────┤
│                    Version (32 bits)                       │
├────────────────────────────────────────────────────────────┤
│ DCID Len (8) │     Destination Connection ID (0-160)       │
├────────────────────────────────────────────────────────────┤
│ SCID Len (8) │       Source Connection ID (0-160)          │
├────────────────────────────────────────────────────────────┤
│                   Type-Specific Fields                     │
├────────────────────────────────────────────────────────────┤
│                   Encrypted Payload                        │
└────────────────────────────────────────────────────────────┘

QUIC Short Header (after handshake):
┌────────────────────────────────────────────────────────────┐
│ Header Form (0) │ Fixed Bit (1) │ Spin (1) │ Reserved (2) │
│                 │               │          │ Key Phase    │
├────────────────────────────────────────────────────────────┤
│              Destination Connection ID                     │
├────────────────────────────────────────────────────────────┤
│               Packet Number (8-32 bits)                    │
├────────────────────────────────────────────────────────────┤
│                   Encrypted Payload                        │
└────────────────────────────────────────────────────────────┘
```

**Connection ID** — ключевое отличие от TCP. Позволяет:
- Connection migration при смене IP
- Load balancing без sticky sessions
- NAT rebinding не разрывает соединение

### QUIC 0-RTT: как это работает

```
Первое соединение (1-RTT):
┌────────────────────────────────────────────────────────────┐
│ Client                                            Server   │
│    │                                                  │    │
│    │─── Initial[CRYPTO(ClientHello)] ────────────────►│    │
│    │◄── Initial[CRYPTO(ServerHello)] ─────────────────│    │
│    │◄── Handshake[CRYPTO(Certificate, Finished)] ─────│    │
│    │─── Handshake[CRYPTO(Finished)] + 1-RTT[Data] ───►│    │
│    │                                                  │    │
│    │  Сохраняем: Session Ticket, Transport Parameters │    │
└────────────────────────────────────────────────────────────┘

Повторное соединение (0-RTT):
┌────────────────────────────────────────────────────────────┐
│ Client                                            Server   │
│    │                                                  │    │
│    │─── Initial[CRYPTO] + 0-RTT[Data] ───────────────►│    │
│    │◄── Response ─────────────────────────────────────│    │
│    │                                                  │    │
│    │  Данные отправлены в первом же пакете!           │    │
└────────────────────────────────────────────────────────────┘
```

**0-RTT Risk**: Replay attacks. Сервер должен помнить принятые 0-RTT пакеты или использовать идемпотентные операции.

### QUIC vs TCP: сравнение

| Характеристика | TCP | QUIC |
|----------------|-----|------|
| **Transport** | Kernel (TCP/IP stack) | Userspace (UDP) |
| **Encryption** | Отдельно (TLS) | Интегрировано (TLS 1.3) |
| **Handshake** | 1-3 RTT (TCP + TLS) | 1 RTT (0-RTT для повторных) |
| **HOL Blocking** | Весь поток | Только affected stream |
| **Connection ID** | 4-tuple (IP:port) | Connection ID |
| **Migration** | Нет | Да |
| **Congestion Control** | Kernel (обычно CUBIC) | Pluggable (BBR, CUBIC) |
| **Evolution** | Медленная (kernel updates) | Быстрая (userspace) |

### QUIC Implementations

| Реализация | Язык | Используется |
|------------|------|--------------|
| **quiche** | Rust | Cloudflare, curl |
| **mvfst** | C++ | Meta/Facebook |
| **ngtcp2** | C | nginx, curl |
| **quic-go** | Go | Caddy, Traefik |
| **quinn** | Rust | General purpose |
| **msquic** | C | Microsoft, Windows |

---

## Сравнение протоколов: когда что использовать

### Decision Tree

```
Нужна сеть?
    │
    ├─ Да
    │   │
    │   ├─ Real-time с допустимой потерей?
    │   │   │
    │   │   ├─ Да → UDP (RTP, gaming)
    │   │   │
    │   │   └─ Нет
    │   │       │
    │   │       ├─ HTTP-based API?
    │   │       │   │
    │   │       │   ├─ Да
    │   │       │   │   │
    │   │       │   │   ├─ Mobile/unreliable network?
    │   │       │   │   │   │
    │   │       │   │   │   ├─ Да → HTTP/3 (QUIC)
    │   │       │   │   │   │
    │   │       │   │   │   └─ Нет → HTTP/2 (TCP)
    │   │       │   │   │
    │   │       │   │   └─ Legacy compatibility? → HTTP/1.1
    │   │       │   │
    │   │       │   └─ Нет
    │   │       │       │
    │   │       │       ├─ High-throughput internal? → gRPC (HTTP/2)
    │   │       │       │
    │   │       │       └─ Simple TCP → TCP sockets
    │   │       │
    │   │       └─ Собственный протокол
    │   │           │
    │   │           ├─ Надёжность нужна? → TCP или QUIC
    │   │           │
    │   │           └─ Сам управляю? → UDP + свой reliability
    │   │
    │   └─ Нет → IPC (Unix sockets, shared memory)
    │
    └─ Нет → Локальные вычисления
```

### Benchmark: Latency Comparison

```
Типичные latency (same datacenter):

TCP Handshake:           ~0.5ms (1 RTT)
TCP + TLS 1.2:           ~1.5ms (3 RTT)
TCP + TLS 1.3:           ~1.0ms (2 RTT)
QUIC (new connection):   ~0.5ms (1 RTT)
QUIC (0-RTT resumption): ~0.0ms (0 RTT)
UDP:                     ~0.0ms (no handshake)
```

---

## Связь с ОС и приложениями

### Сокеты и ОС ([[os-processes-threads]])

```
Приложение
    │
    │ socket(), bind(), listen(), accept(), read(), write()
    ▼
┌───────────────────────────────────────────────────────────┐
│                     User Space                            │
├───────────────────────────────────────────────────────────┤
│                     System Calls                          │
├───────────────────────────────────────────────────────────┤
│                     Kernel Space                          │
│  ┌─────────────────────────────────────────────────────┐  │
│  │                   Socket Layer                      │  │
│  │  • File descriptors                                 │  │
│  │  • Socket buffers (sk_buff)                         │  │
│  ├─────────────────────────────────────────────────────┤  │
│  │                   TCP/UDP Layer                     │  │
│  │  • Connection state machine                         │  │
│  │  • Congestion control                               │  │
│  ├─────────────────────────────────────────────────────┤  │
│  │                   IP Layer                          │  │
│  │  • Routing table                                    │  │
│  │  • Fragmentation                                    │  │
│  ├─────────────────────────────────────────────────────┤  │
│  │                   Network Driver                    │  │
│  │  • NIC interaction                                  │  │
│  │  • DMA                                              │  │
│  └─────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────┘
```

### Epoll и высоконагруженные серверы

```c
// Традиционный подход: 1 thread per connection
// Проблема: 10K connections = 10K threads = плохо

// Современный подход: epoll + event loop
int epoll_fd = epoll_create1(0);
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &event);

while (true) {
    int n = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
    for (int i = 0; i < n; i++) {
        if (events[i].data.fd == listen_fd) {
            // New connection
            int client_fd = accept(listen_fd, ...);
            epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &ev);
        } else {
            // Data ready
            handle_client(events[i].data.fd);
        }
    }
}
```

Связь с [[kotlin-coroutines]]: Kotlin Dispatchers.IO использует thread pool для blocking I/O, но suspend функции позволяют эффективно мультиплексировать корутины.

---

## Типичные ошибки

### 1. Игнорирование частичных read()

```java
// ❌ НЕПРАВИЛЬНО: предполагаем, что read() вернёт всё
byte[] buffer = new byte[1024];
inputStream.read(buffer);  // Может вернуть 1 байт!
String message = new String(buffer);

// ✅ ПРАВИЛЬНО: читаем до конца
ByteArrayOutputStream result = new ByteArrayOutputStream();
byte[] buffer = new byte[1024];
int length;
while ((length = inputStream.read(buffer)) != -1) {
    result.write(buffer, 0, length);
}
```

### 2. Не закрывать соединения

```java
// ❌ НЕПРАВИЛЬНО: утечка ресурсов
Socket socket = new Socket("host", 80);
// ... использование
// Забыли закрыть!

// ✅ ПРАВИЛЬНО: try-with-resources
try (Socket socket = new Socket("host", 80)) {
    // ... использование
}  // Автоматически закроется
```

### 3. TCP_NODELAY для интерактивных приложений

```java
// По умолчанию: Nagle's algorithm включён
// Маленькие пакеты буферизуются для эффективности
// Плохо для real-time!

// ✅ Для интерактивных приложений:
socket.setTcpNoDelay(true);
```

### 4. Неправильные таймауты

```java
// ❌ НЕПРАВИЛЬНО: бесконечное ожидание
socket.connect(address);  // Может висеть вечно

// ✅ ПРАВИЛЬНО: таймауты
socket.connect(address, 5000);  // Connect timeout: 5 секунд
socket.setSoTimeout(30000);     // Read timeout: 30 секунд
```

---

## Ресурсы

### RFC
- **RFC 793** — TCP
- **RFC 768** — UDP
- **RFC 9000** — QUIC
- **RFC 9001** — Using TLS to Secure QUIC
- **RFC 9002** — QUIC Loss Detection and Congestion Control

### Инструменты
- **Wireshark** — анализ пакетов, поддерживает QUIC
- **tcpdump** — командная строка capture
- **ss** / **netstat** — состояние сокетов
- **qlog** — логирование QUIC соединений

---

## Связанные темы

- [[networking-overview]] — карта раздела
- [[network-ip-routing]] — IP-уровень, на котором работает транспорт
- [[network-http-evolution]] — HTTP/3 использует QUIC
- [[network-dns-tls]] — TLS интегрирован в QUIC
- [[os-processes-threads]] — сокеты как file descriptors
- [[os-io-devices]] — как данные попадают в сеть

---

**Резюме:** TCP, UDP, QUIC — три столпа транспортного уровня. TCP даёт надёжность ценой latency. UDP даёт скорость без гарантий. QUIC объединяет лучшее: надёжность TCP, низкую latency (0-RTT), отсутствие HOL blocking, встроенное шифрование. Для новых проектов с HTTP — выбирай HTTP/3 (QUIC). Для legacy или специфичных требований — TCP. Для real-time с допустимой потерей — UDP.

---

*Последнее обновление: 2026-01-09 — Добавлены педагогические секции: 5 аналогий (TCP-заказное письмо, порты-квартиры, handshake-знакомство, window-труба, QUIC-независимые потоки), 6 типичных ошибок транспортного уровня с диагностикой, 5 ментальных моделей для понимания TCP/UDP/QUIC*
