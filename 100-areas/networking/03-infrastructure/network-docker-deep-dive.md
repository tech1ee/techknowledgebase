---
title: "Docker Networking Deep Dive"
created: 2025-01-15
modified: 2025-01-15
tags:
  - topic/networking
  - topic/docker
  - containers
  - linux
  - topic/devops
  - type/deep-dive
  - level/advanced
related:
  - [network-kubernetes-deep-dive]]
  - "[[network-ip-routing]]"
  - "[[network-transport-layer]"
prerequisites:
  - "[[network-ip-routing]]"
  - "[[network-transport-layer]]"
  - "[[docker-for-developers]]"
status: published
---

# Docker Networking Deep Dive

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **Linux basics** | Docker построен на Linux namespaces | Linux fundamentals |
| **IP-адресация** | Понимание подсетей, NAT | [[network-ip-routing]] |
| **Docker basics** | Что такое контейнер, образ | Docker getting started |

### Для кого этот материал

| Уровень | Подходит? | Рекомендация |
|---------|-----------|--------------|
| **Новичок** | ⚠️ С подготовкой | Сначала Docker basics |
| **Intermediate** | ✅ Да | Основная аудитория |
| **Advanced** | ✅ Да | Custom networks, overlay |

### Терминология для новичков

> 💡 **Docker Networking** = как контейнеры "видят" друг друга и внешний мир. Контейнер изолирован, но ему нужна сеть.

| Термин | Значение | Аналогия для новичка |
|--------|----------|---------------------|
| **Network Namespace** | Изолированный сетевой стек | **Своя квартира** — свои розетки, свой Wi-Fi |
| **Bridge** | Виртуальный коммутатор | **Общий коридор** — соединяет квартиры |
| **veth pair** | Виртуальный кабель между namespaces | **Труба между квартирами** |
| **docker0** | Дефолтный bridge | **Стандартный коридор** — для всех контейнеров |
| **Host network** | Контейнер использует сеть хоста | **Жить с хозяином** — общая сеть |
| **Overlay** | Сеть между несколькими хостами | **Межгородская связь** |
| **Port mapping** | -p 8080:80 — проброс порта | **Переадресация звонка** — звонят на 8080, попадают на 80 |
| **ICC** | Inter-Container Communication | **Разговор между соседями** |
| **iptables** | Firewall правила Linux | **Охранник здания** — что пропускать |
| **IPAM** | IP Address Management | **Администратор адресов** — кому какой IP |

---

## Часть 1: Интуиция без кода — Как думать о Docker networking

> **Цель:** Понять, как контейнеры общаются друг с другом и с внешним миром, через метафоры из реальной жизни. Docker networking — не магия, а комбинация понятных Linux-примитивов.

### Аналогия 1: Контейнеры как квартиры в жилом комплексе

```
ЖИЛОЙ КОМПЛЕКС = DOCKER HOST:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐              │
│  │  Квартира 1 │  │  Квартира 2 │  │  Квартира 3 │              │
│  │  (Container)│  │  (Container)│  │  (Container)│              │
│  │             │  │             │  │             │              │
│  │  Своя сеть  │  │  Своя сеть  │  │  Своя сеть  │              │
│  │  Свой IP    │  │  Свой IP    │  │  Свой IP    │              │
│  │  Свой порт  │  │  Свой порт  │  │  Свой порт  │              │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘              │
│         │                │                │                     │
│         └────────────────┼────────────────┘                     │
│                          │                                      │
│               ┌──────────┴──────────┐                           │
│               │   Общий коридор     │                           │
│               │   (Bridge docker0)  │                           │
│               └──────────┬──────────┘                           │
│                          │                                      │
│               ┌──────────┴──────────┐                           │
│               │      Ресепшен       │                           │
│               │   (NAT + iptables)  │                           │
│               │   Переадресация     │                           │
│               └──────────┬──────────┘                           │
│                          │                                      │
│                     ┌────┴────┐                                  │
│                     │ Улица   │ (Внешняя сеть)                   │
│                     └─────────┘                                  │
│                                                                 │
│  КВАРТИРА = NETWORK NAMESPACE                                   │
│  • Своя электропроводка (сетевой стек)                         │
│  • Свой домофон (IP-адрес)                                      │
│  • Свой почтовый ящик (порты)                                   │
│                                                                 │
│  КОРИДОР = BRIDGE                                               │
│  • Соединяет квартиры                                           │
│  • Жители могут общаться                                        │
│  • Изолирован от улицы                                          │
│                                                                 │
│  РЕСЕПШЕН = NAT/iptables                                        │
│  • "Звонок для квартиры 3" → переадресовывает                   │
│  • -p 8080:80 = "Звонки на 8080 передавать в кв. 3 на 80"       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Почему это важно:** Контейнер изолирован как квартира — у него своя сеть, свои порты, свой IP. Чтобы квартиры общались, нужен коридор (bridge). Чтобы гости с улицы попали в квартиру, нужен ресепшен (NAT).

### Аналогия 2: Veth pair как телефонная трубка

```
VETH PAIR = ТЕЛЕФОННАЯ ТРУБКА С ДВУМЯ КОНЦАМИ:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   Контейнер                            Хост                     │
│   (Квартира)                           (Коридор)                │
│                                                                 │
│   ┌─────────────┐                  ┌─────────────┐              │
│   │             │                  │             │              │
│   │   eth0      │ ═══════════════  │   veth123   │              │
│   │   (трубка)  │   телефонный    │   (трубка)  │              │
│   │             │      провод      │             │              │
│   └─────────────┘                  └──────┬──────┘              │
│                                           │                     │
│                                    ┌──────┴──────┐              │
│                                    │   docker0   │              │
│                                    │  (коммутатор)│              │
│                                    └─────────────┘              │
│                                                                 │
│  КАК ЭТО РАБОТАЕТ:                                              │
│                                                                 │
│  1. Docker создаёт пару виртуальных интерфейсов                 │
│  2. Один конец (eth0) помещается В контейнер                    │
│  3. Другой конец (vethXXX) остаётся НА хосте                    │
│  4. Хостовый конец подключается к bridge                        │
│                                                                 │
│  Пакет, отправленный в eth0 контейнера,                         │
│  мгновенно появляется на vethXXX хоста — и наоборот.            │
│                                                                 │
│  КАК УВИДЕТЬ:                                                   │
│  $ docker exec container cat /sys/class/net/eth0/iflink         │
│  42  # ← номер интерфейса на хосте                              │
│                                                                 │
│  $ ip link | grep "42:"                                         │
│  42: veth12ab34@if41: ...  # ← это другой конец пары            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Почему это важно:** Veth pair — это "волшебный кабель", соединяющий изолированные миры. Без понимания этого невозможно отлаживать проблемы связности между контейнерами.

### Аналогия 3: Типы сетей как типы зданий

```
ТИП DOCKER СЕТИ = ТИП ЗДАНИЯ:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  🏢 BRIDGE = ЖИЛОЙ КОМПЛЕКС                                     │
│  ─────────────────────────────────────────────────────────────  │
│  • Каждая квартира изолирована                                  │
│  • Общий коридор для соседей                                    │
│  • Ресепшен для гостей (NAT)                                    │
│  • Подходит для: большинства приложений                         │
│                                                                 │
│  🏠 HOST = ЖИТЬ С ХОЗЯИНОМ                                      │
│  ─────────────────────────────────────────────────────────────  │
│  • Нет своей квартиры — делишь дом с хозяином                   │
│  • Прямой доступ ко всем комнатам (портам)                      │
│  • Нет изоляции — конфликты за розетки                          │
│  • Подходит для: latency-critical (load balancers)              │
│                                                                 │
│  🚫 NONE = БУНКЕР                                               │
│  ─────────────────────────────────────────────────────────────  │
│  • Полная изоляция — ни окон, ни дверей                         │
│  • Только loopback (сам с собой)                                │
│  • Подходит для: batch jobs, security-critical                  │
│                                                                 │
│  🌐 OVERLAY = ТЕЛЕПОРТ МЕЖДУ ГОРОДАМИ                           │
│  ─────────────────────────────────────────────────────────────  │
│  • Квартиры в разных зданиях (хостах)                           │
│  • Соединены туннелем (VXLAN)                                   │
│  • "Соседи" на разных континентах                               │
│  • Подходит для: Swarm, распределённые системы                  │
│                                                                 │
│  📡 MACVLAN = ОТДЕЛЬНЫЙ ДОМ В ПОСЁЛКЕ                           │
│  ─────────────────────────────────────────────────────────────  │
│  • Свой адрес на улице (MAC в LAN)                              │
│  • Виден как физическое устройство                              │
│  • Не может общаться с "управляющей компанией" (хостом)         │
│  • Подходит для: legacy apps, прямой LAN доступ                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Почему это важно:** Выбор неправильного типа сети — частая причина проблем. Bridge для development, host для performance, overlay для multi-host, macvlan для legacy.

### Аналогия 4: Port mapping как переадресация звонков

```
PORT MAPPING = ПЕРЕАДРЕСАЦИЯ В КОЛЛ-ЦЕНТРЕ:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   ВНЕШНИЙ МИР                              КОНТЕЙНЕР            │
│                                                                 │
│   "Позвоните на 8080"                      nginx на :80         │
│          │                                       ▲              │
│          ▼                                       │              │
│   ┌─────────────────────────────────────────────────────┐       │
│   │                     DOCKER HOST                      │       │
│   │                                                     │       │
│   │   iptables NAT PREROUTING:                          │       │
│   │   "Если dst port = 8080 → переписать на 172.17.0.2:80"     │
│   │                                                     │       │
│   │   docker run -p 8080:80 nginx                       │       │
│   │              ─────┬─────                            │       │
│   │                   │                                 │       │
│   │        Host:8080 → Container:80                     │       │
│   │                                                     │       │
│   └─────────────────────────────────────────────────────┘       │
│                                                                 │
│  ВАРИАНТЫ MAPPING:                                              │
│                                                                 │
│  -p 8080:80             → 0.0.0.0:8080 → container:80           │
│  ⚠️ Доступен всем! Даже из интернета!                           │
│                                                                 │
│  -p 127.0.0.1:8080:80   → только localhost:8080                 │
│  ✅ Безопасно — только с этой машины                            │
│                                                                 │
│  -p 192.168.1.5:8080:80 → только с этого IP                     │
│  ✅ Контроль — доступ из конкретной сети                        │
│                                                                 │
│  -P (uppercase)         → случайный порт на хосте               │
│  Удобно для разработки, неудобно для production                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Почему это важно:** `-p 80:80` делает порт доступным ВСЕМУ миру, а не только localhost. Это частая причина security-инцидентов. Всегда указывайте IP при необходимости.

### Аналогия 5: Docker Compose сеть как офисное здание с этажами

```
DOCKER COMPOSE = ОФИСНОЕ ЗДАНИЕ:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   docker-compose.yml создаёт здание с этажами:                  │
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  FRONTEND NETWORK (7 этаж)                              │   │
│   │  ┌─────────┐        ┌─────────┐                         │   │
│   │  │  nginx  │◄──────►│   web   │   Видят друг друга      │   │
│   │  └─────────┘        └────┬────┘                         │   │
│   └──────────────────────────│──────────────────────────────┘   │
│                              │ web в обеих сетях                │
│   ┌──────────────────────────│──────────────────────────────┐   │
│   │  BACKEND NETWORK (подвал)│                              │   │
│   │                     ┌────┴────┐        ┌─────────┐      │   │
│   │                     │   web   │◄──────►│  mysql  │      │   │
│   │                     └─────────┘        └─────────┘      │   │
│   │   internal: true — нет выхода в интернет!               │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│   РЕЗУЛЬТАТ:                                                    │
│   • nginx видит web ✓                                           │
│   • web видит nginx и mysql ✓                                   │
│   • nginx НЕ видит mysql ✗ (разные этажи)                       │
│   • mysql НЕ видит интернет ✗ (internal)                        │
│                                                                 │
│   DNS ВНУТРИ СЕТИ:                                              │
│   web$ ping mysql     # работает! DNS = имя сервиса             │
│   web$ ping nginx     # работает!                               │
│   mysql$ ping nginx   # НЕ работает — разные сети               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Почему это важно:** Docker Compose автоматически создаёт изолированные сети. Понимание этого позволяет строить безопасную архитектуру: база данных не видит интернет, frontend не видит базу напрямую.

---

## Часть 2: Почему это сложно — Типичные ошибки в Docker networking

> **Цель:** Научиться распознавать и избегать ловушек, в которые попадают даже опытные разработчики. Сетевые проблемы в Docker — одни из самых сложных для отладки.

### Ошибка 1: Ожидание DNS в default bridge

**СИМПТОМ:**
```bash
$ docker run -d --name db postgres
$ docker run -it --name app alpine ping db
ping: bad address 'db'

"DNS не работает в Docker! Баг!"
```

**РЕШЕНИЕ:**
```bash
# Default bridge НЕ ИМЕЕТ DNS service discovery!
# Это by design — legacy behavior

# Правильно: создать user-defined bridge
$ docker network create myapp
$ docker run -d --name db --network myapp postgres
$ docker run -it --name app --network myapp alpine ping db
PING db (172.20.0.2): 56 data bytes
64 bytes from 172.20.0.2: seq=0 ttl=64 time=0.089 ms
# Работает! ✓
```

**Правило:** Никогда не используйте default bridge для production. Всегда создавайте user-defined network.

### Ошибка 2: Published port доступен из интернета

**СИМПТОМ:**
```bash
$ docker run -d -p 3306:3306 mysql
# "MySQL запущен, всё безопасно"

# Через час:
$ docker logs mysql
# [Warning] Access denied for user 'root'@'203.0.113.42'
# Кто-то из интернета ломится в базу!
```

**РЕШЕНИЕ:**
```bash
# -p 3306:3306 слушает на 0.0.0.0 — весь мир!

# Правильно: bind к localhost
$ docker run -d -p 127.0.0.1:3306:3306 mysql

# Или использовать internal network
$ docker network create --internal dbnet
$ docker run -d --network dbnet mysql
# Теперь MySQL недоступен снаружи вообще
```

**Правило:** Всегда указывайте IP в `-p` для sensitive сервисов. `127.0.0.1:PORT:PORT` — ваш друг.

### Ошибка 3: UFW не защищает Docker порты

**СИМПТОМ:**
```bash
$ sudo ufw enable
$ sudo ufw default deny incoming
$ sudo ufw status
Status: active
Default: deny (incoming)

$ docker run -d -p 80:80 nginx
# "UFW включен, порт защищён"

$ curl http://server-ip:80
# Nginx отвечает! UFW не помог!
```

**РЕШЕНИЕ:**
```bash
# Docker добавляет правила в iptables nat table
# UFW работает в filter table — они не пересекаются!

# Вариант 1: Использовать DOCKER-USER chain
$ sudo iptables -I DOCKER-USER -i eth0 ! -s 10.0.0.0/8 -j DROP

# Вариант 2: Отключить iptables management в Docker
# /etc/docker/daemon.json
{
  "iptables": false
}
# ⚠️ Теперь NAT не работает автоматически!

# Вариант 3: Использовать ufw-docker plugin
$ sudo wget -O /usr/local/bin/ufw-docker \
    https://github.com/chaifeng/ufw-docker/raw/master/ufw-docker
$ sudo ufw-docker allow nginx 80/tcp
```

**Правило:** UFW + Docker = ложное чувство безопасности. Всегда проверяйте `iptables -L -n -v` и используйте DOCKER-USER chain.

### Ошибка 4: Хардкодинг IP контейнера

**СИМПТОМ:**
```python
# config.py
DATABASE_URL = "postgresql://172.17.0.5:5432/mydb"

# После docker restart:
$ docker start db
# Контейнер получил новый IP: 172.17.0.8
# Приложение: "Connection refused"
```

**РЕШЕНИЕ:**
```python
# НИКОГДА не хардкодьте IP контейнеров!

# Правильно: использовать DNS имена
DATABASE_URL = "postgresql://db:5432/mydb"
# "db" = имя контейнера или сервиса в Compose

# Ещё лучше: environment variables
DATABASE_URL = os.getenv("DATABASE_URL")
```

```yaml
# docker-compose.yml
services:
  app:
    environment:
      - DATABASE_URL=postgresql://db:5432/mydb
  db:
    image: postgres
```

**Правило:** IP контейнера эфемерен. Используйте DNS имена (имя сервиса) — они стабильны.

### Ошибка 5: Масштабирование с фиксированным портом

**СИМПТОМ:**
```yaml
# docker-compose.yml
services:
  web:
    image: nginx
    ports:
      - "80:80"
    deploy:
      replicas: 3

$ docker compose up -d --scale web=3
# Error: port 80 is already in use
# Все 3 реплики пытаются занять один порт!
```

**РЕШЕНИЕ:**
```yaml
# Вариант 1: Диапазон портов
services:
  web:
    ports:
      - "80-82:80"  # web_1:80, web_2:81, web_3:82

# Вариант 2: Load balancer перед репликами
services:
  nginx:
    image: nginx
    ports:
      - "80:80"
    # nginx.conf: upstream web { server web:8080; }

  web:
    image: myapp
    expose:
      - "8080"  # expose, не ports!
    deploy:
      replicas: 3

# Вариант 3: Docker Swarm Routing Mesh
$ docker service create --replicas 3 --publish 80:80 nginx
# Swarm сам раскидает трафик
```

**Правило:** При масштабировании сервиса порты конфликтуют. Используйте load balancer или Swarm Routing Mesh.

### Ошибка 6: Macvlan контейнер не видит хост

**СИМПТОМ:**
```bash
$ docker network create -d macvlan \
    --subnet=192.168.1.0/24 \
    --gateway=192.168.1.1 \
    -o parent=eth0 mymacvlan

$ docker run --network mymacvlan --ip 192.168.1.100 alpine
$ ping 192.168.1.1    # gateway — работает ✓
$ ping 192.168.1.50   # хост — НЕ работает ✗

"Баг в macvlan!"
```

**РЕШЕНИЕ:**
```bash
# Это НЕ баг — ограничение Linux kernel!
# Трафик между macvlan и parent interface заблокирован.

# Решение: создать macvlan subinterface на хосте
$ ip link add macvlan0 link eth0 type macvlan mode bridge
$ ip addr add 192.168.1.200/32 dev macvlan0
$ ip link set macvlan0 up
$ ip route add 192.168.1.100/32 dev macvlan0

# Теперь хост может общаться с контейнером через 192.168.1.200
```

**Правило:** Macvlan изолирует контейнер от хоста. Если нужна связь — создайте дополнительный интерфейс на хосте.

---

## Часть 3: Ментальные модели для Docker networking

> **Цель:** Сформировать устойчивые паттерны мышления, которые помогут быстро диагностировать проблемы и выбирать правильные решения.

### Модель 1: "Матрёшка изоляции"

```
УРОВНИ ИЗОЛЯЦИИ КАК МАТРЁШКА:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   ВНЕШНИЙ МИР                                                   │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  HOST (физический/виртуальный сервер)                   │   │
│   │  ┌─────────────────────────────────────────────────┐    │   │
│   │  │  DOCKER NETWORK (bridge/overlay)                │    │   │
│   │  │  ┌─────────────────────────────────────────┐    │    │   │
│   │  │  │  NETWORK NAMESPACE (контейнер)          │    │    │   │
│   │  │  │  ┌─────────────────────────────────┐    │    │    │   │
│   │  │  │  │  ПРОЦЕСС (приложение)           │    │    │    │   │
│   │  │  │  │                                 │    │    │    │   │
│   │  │  │  │  bind 0.0.0.0:80                │    │    │    │   │
│   │  │  │  └─────────────────────────────────┘    │    │    │   │
│   │  │  └─────────────────────────────────────────┘    │    │   │
│   │  └─────────────────────────────────────────────────┘    │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ЧТОБЫ ЗАПРОС ДОШЁЛ ДО ПРИЛОЖЕНИЯ, НУЖНО:                       │
│                                                                 │
│  1. Пройти firewall хоста (iptables/ufw)                        │
│  2. Пройти Docker network (NAT/routing)                         │
│  3. Войти в namespace контейнера (veth pair)                    │
│  4. Дойти до процесса (bind address/port)                       │
│                                                                 │
│  ОТЛАДКА = найти на каком уровне блокировка                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Применение:** При проблемах со связностью идите снаружи внутрь: сначала проверьте host firewall, потом Docker network, потом namespace, потом процесс.

### Модель 2: "Дерево выбора сетевого драйвера"

```
КАКОЙ ДРАЙВЕР ВЫБРАТЬ?
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│              Несколько хостов?                                  │
│                    │                                            │
│         ┌────YES───┴───NO────┐                                  │
│         ▼                    ▼                                  │
│     OVERLAY            Нужна изоляция?                          │
│                              │                                  │
│                    ┌───YES───┴───NO────┐                        │
│                    ▼                   ▼                        │
│              BRIDGE            Нужен прямой LAN?                │
│        (user-defined)                  │                        │
│                              ┌───YES───┴───NO────┐              │
│                              ▼                   ▼              │
│                         MACVLAN             HOST                │
│                                    (latency-critical)           │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  СЦЕНАРИЙ              ДРАЙВЕР        ПРИЧИНА                   │
│  ─────────────────────────────────────────────────────────────  │
│  Development           bridge         Изоляция, DNS, просто     │
│  Production            bridge         + internal для DB         │
│  Load Balancer         host           Минимум latency           │
│  Swarm/K8s             overlay        Multi-host                │
│  Legacy VoIP app       macvlan        Нужен "физический" IP     │
│  Batch job без сети    none           Полная изоляция           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Применение:** Начните с вопроса "несколько хостов?" — это сразу определяет overlay vs остальные. Потом изоляция vs performance.

### Модель 3: "Пакет как турист с визой"

```
ПУТЬ ПАКЕТА = ТУРИСТ ПРОХОДИТ КОНТРОЛЬ:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   ВХОДЯЩИЙ ПАКЕТ (запрос к -p 8080:80):                         │
│                                                                 │
│   ┌──────────────┐                                              │
│   │ Пакет с dst  │                                              │
│   │ host:8080    │                                              │
│   └──────┬───────┘                                              │
│          ▼                                                      │
│   ┌──────────────────────────────────────┐                      │
│   │ 1. PREROUTING (nat table)            │                      │
│   │    "Куда вы направляетесь?"          │                      │
│   │    DNAT: 8080 → 172.17.0.2:80        │                      │
│   │    (Переписываем destination)        │                      │
│   └──────────────┬───────────────────────┘                      │
│                  ▼                                              │
│   ┌──────────────────────────────────────┐                      │
│   │ 2. FORWARD (filter table)            │                      │
│   │    "Есть ли у вас разрешение?"       │                      │
│   │    DOCKER-USER → DOCKER chain        │                      │
│   │    (Проверка правил firewall)        │                      │
│   └──────────────┬───────────────────────┘                      │
│                  ▼                                              │
│   ┌──────────────────────────────────────┐                      │
│   │ 3. docker0 bridge                    │                      │
│   │    "Передаём в нужную квартиру"      │                      │
│   │    (Маршрутизация по MAC)            │                      │
│   └──────────────┬───────────────────────┘                      │
│                  ▼                                              │
│   ┌──────────────────────────────────────┐                      │
│   │ 4. veth pair → контейнер             │                      │
│   │    "Добро пожаловать!"               │                      │
│   │    Пакет доставлен процессу          │                      │
│   └──────────────────────────────────────┘                      │
│                                                                 │
│   ИСХОДЯЩИЙ ПАКЕТ (ответ контейнера):                           │
│                                                                 │
│   eth0 контейнера → veth → docker0 → POSTROUTING (SNAT/MASQ)    │
│   (src: 172.17.0.2 → src: host_ip)                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Применение:** Если пакет не доходит — он застрял на одном из "контролей". Проверяйте каждый: PREROUTING (dnat), FORWARD (firewall), bridge (routing), veth (namespace).

### Модель 4: "DNS как телефонная книга"

```
DNS В DOCKER = ИЕРАРХИЯ СПРАВОЧНИКОВ:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   КОНТЕЙНЕР СПРАШИВАЕТ: "Какой IP у mysql?"                     │
│          │                                                      │
│          ▼                                                      │
│   ┌──────────────────────────────────────────────────────┐      │
│   │ 1. EMBEDDED DNS (127.0.0.11)                         │      │
│   │    Docker's internal DNS server                       │      │
│   │                                                      │      │
│   │    Знает:                                            │      │
│   │    • Имена контейнеров в той же сети                 │      │
│   │    • Алиасы (--network-alias)                        │      │
│   │    • Имена сервисов в Compose                        │      │
│   │                                                      │      │
│   │    mysql → 172.20.0.5 ✓                              │      │
│   └──────────────────────────────────────────────────────┘      │
│                                                                 │
│   ЕСЛИ НЕ НАЙДЕНО (external domain):                            │
│          │                                                      │
│          ▼                                                      │
│   ┌──────────────────────────────────────────────────────┐      │
│   │ 2. HOST DNS (/etc/resolv.conf хоста)                 │      │
│   │    Или --dns при запуске контейнера                  │      │
│   │                                                      │      │
│   │    google.com → 142.250.x.x ✓                        │      │
│   └──────────────────────────────────────────────────────┘      │
│                                                                 │
│   ВАЖНО:                                                        │
│   • Default bridge НЕ использует embedded DNS!                  │
│   • Только user-defined networks получают DNS discovery         │
│   • /etc/resolv.conf в контейнере: nameserver 127.0.0.11        │
│                                                                 │
│   ОТЛАДКА DNS:                                                  │
│   $ docker exec container cat /etc/resolv.conf                  │
│   $ docker exec container nslookup mysql                        │
│   $ docker exec container dig mysql                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Применение:** Если DNS не работает — проверьте: 1) user-defined network? 2) /etc/resolv.conf показывает 127.0.0.11? 3) контейнеры в одной сети?

### Модель 5: "Три уровня troubleshooting"

```
ОТЛАДКА DOCKER NETWORKING — ТРИ УРОВНЯ:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  УРОВЕНЬ 1: DOCKER CLI (начать здесь)                           │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  docker network ls              # Какие сети есть?              │
│  docker network inspect mynet   # Кто в сети? Какие IP?         │
│  docker inspect container       # Сети контейнера               │
│  docker port container          # Port mapping                  │
│  docker logs container          # Ошибки приложения             │
│                                                                 │
│  УРОВЕНЬ 2: NETSHOOT (если CLI не помог)                        │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  # Запуск в namespace проблемного контейнера                    │
│  docker run -it --network container:problem nicolaka/netshoot   │
│                                                                 │
│  # Внутри netshoot:                                             │
│  ip addr                        # Интерфейсы и IP               │
│  ip route                       # Маршруты                      │
│  ss -tulnp                      # Слушающие порты               │
│  nslookup mysql                 # DNS                           │
│  ping other_container           # Connectivity                  │
│  curl http://api:8080           # HTTP                          │
│  tcpdump -i any port 80         # Packet capture                │
│                                                                 │
│  УРОВЕНЬ 3: HOST LEVEL (если проблема в хосте)                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  bridge link show               # veth подключены к bridge?     │
│  ip netns list                  # Namespaces                    │
│  iptables -t nat -L -n          # NAT правила                   │
│  iptables -t filter -L DOCKER-USER  # Firewall                  │
│  tcpdump -i docker0             # Трафик на bridge              │
│  tcpdump -i vethXXX             # Трафик конкретного контейнера │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Применение:** Идите по уровням: сначала простые docker commands, потом netshoot внутри контейнера, только потом спускайтесь на host level для iptables/bridge/veth.

---

## Почему это важно

Docker изолирует приложения, но изоляция без понимания сети приводит к **"работает локально, не работает в production"**. Сетевые проблемы — одни из самых сложных для диагностики в контейнерах.

### Типичные проблемы

| Проблема | Причина | Результат |
|----------|---------|-----------|
| Контейнеры не видят друг друга | Разные сети | Service discovery не работает |
| Порт уже занят | Конфликт маппинга | Контейнер не стартует |
| Медленная сеть | NAT overhead | Latency в 2-3x выше |
| Firewall блокирует | Docker + iptables конфликт | Сервис недоступен извне |

### Зачем разбираться глубже

- **Отладка:** Понимание того, как трафик идёт через veth → bridge → iptables
- **Безопасность:** Изоляция сетей, контроль ICC
- **Performance:** Выбор правильного драйвера (host vs bridge)
- **Масштабирование:** Overlay для multi-host, swarm

---

## Linux Networking Primitives

### Зачем понимать низкий уровень

**Docker — это не магия, а комбинация Linux технологий.** Когда что-то ломается, вы не можете сказать "это Docker". Нужно понимать, какой именно примитив сломался:
- Контейнер не видит сеть? → Network namespace
- Контейнеры не могут общаться? → Bridge или veth
- Порт недоступен снаружи? → iptables NAT

**Аналогия:** Представьте Docker как конструктор LEGO. Если знаете детали (namespaces, veth, bridge) — можете собрать что угодно и починить любую проблему. Если только кнопки в UI — застрянете при первой нестандартной ситуации.

Docker networking построен на примитивах Linux ядра. Понимание этих основ — ключ к отладке.

### Network Namespaces

**Network namespace** — изолированный экземпляр сетевого стека:
- Свои сетевые интерфейсы
- Своя таблица маршрутизации
- Свои iptables правила

```bash
# Создать namespace
ip netns add red
ip netns add blue

# Выполнить команду в namespace
ip netns exec red ip addr

# Список namespaces
ip netns list
```

**Каждый Docker контейнер = отдельный network namespace.**

### Veth Pairs (Virtual Ethernet)

**Veth pair** — виртуальный сетевой кабель с двумя концами:

```
┌──────────────────┐         ┌──────────────────┐
│   Namespace A    │         │   Namespace B    │
│                  │         │                  │
│    ┌──────┐      │ veth    │      ┌──────┐   │
│    │veth0 │◄────────────────────►│veth1 │   │
│    └──────┘      │  pair   │      └──────┘   │
└──────────────────┘         └──────────────────┘
```

Пакет, отправленный в один конец, мгновенно появляется на другом.

```bash
# Создать veth pair
ip link add veth0 type veth peer name veth1

# Переместить один конец в namespace
ip link set veth1 netns red

# Назначить IP
ip addr add 10.0.0.1/24 dev veth0
ip netns exec red ip addr add 10.0.0.2/24 dev veth1

# Поднять интерфейсы
ip link set veth0 up
ip netns exec red ip link set veth1 up
```

### Linux Bridge

Для соединения **более двух** namespaces нужен **bridge** — виртуальный сетевой свитч:

```
┌─────────────────────────────────────────────┐
│                   Host                       │
│                                             │
│    ┌─────────┐     ┌─────────┐              │
│    │Container│     │Container│              │
│    │   A     │     │   B     │              │
│    └────┬────┘     └────┬────┘              │
│         │veth          │veth                │
│         │              │                    │
│    ┌────┴──────────────┴────┐               │
│    │       docker0          │               │
│    │     (Linux Bridge)     │               │
│    └───────────┬────────────┘               │
│                │                            │
│         ┌──────┴──────┐                     │
│         │   eth0      │                     │
│         └─────────────┘                     │
└─────────────────────────────────────────────┘
```

```bash
# Просмотр bridge и подключённых интерфейсов
bridge link show
brctl show  # deprecated, но иногда удобнее
```

---

## Docker Network Drivers

### Почему много драйверов

**Нет универсального решения для networking.** Разные сценарии требуют разных trade-offs:
- **Безопасность vs Performance:** Изоляция требует NAT, NAT добавляет latency
- **Single host vs Multi-host:** Локальный bridge не работает между серверами
- **Простота vs Контроль:** Default bridge прост, но ограничен

**Правило выбора:**
1. **Development/Testing:** bridge (default) — работает из коробки
2. **Production single host:** user-defined bridge — DNS discovery, изоляция
3. **Latency-critical:** host — нет сетевого overhead
4. **Распределённые системы:** overlay — контейнеры на разных хостах
5. **Legacy интеграция:** macvlan — когда нужен "физический" IP в LAN

### Обзор драйверов

| Driver | Изоляция | Performance | Use Case |
|--------|----------|-------------|----------|
| **bridge** | Высокая | Средняя (NAT) | По умолчанию, single host |
| **host** | Нет | Максимальная | Latency-critical apps |
| **none** | Полная | N/A | Security, custom networking |
| **overlay** | Высокая | Средняя | Multi-host, Swarm |
| **macvlan** | Высокая | Высокая | Legacy apps, прямой LAN доступ |
| **ipvlan** | Высокая | Высокая | Как macvlan, но без MAC |

### Bridge Network (Default)

```bash
# Просмотр сетей
docker network ls

# Инспекция default bridge
docker network inspect bridge
```

**Default bridge (docker0):**
- Автоматически создаётся
- Нет DNS service discovery!
- Контейнеры общаются по IP

**User-defined bridge:**
- DNS service discovery работает
- Изоляция от других сетей
- Рекомендуется всегда использовать

```bash
# Создать пользовательскую сеть
docker network create mynet

# Запустить контейнер в сети
docker run -d --name web --network mynet nginx

# Контейнеры в mynet могут обращаться по имени
docker run --network mynet alpine ping web
```

### Host Network

**Контейнер использует сетевой стек хоста напрямую.**

```bash
docker run --network host nginx
# Nginx слушает на host:80 без port mapping
```

**Преимущества:**
- Нет NAT overhead
- Минимальная latency
- Доступ ко всем портам хоста

**Недостатки:**
- Нет изоляции
- Конфликты портов
- Только Linux (не работает на Mac/Windows)

**Use case:** Load balancers (HAProxy, Nginx), latency-sensitive apps

### Overlay Network

Соединяет контейнеры **на разных хостах**:

```
┌─────────────────┐         ┌─────────────────┐
│     Host A      │ VXLAN   │     Host B      │
│                 │ tunnel  │                 │
│  ┌───────────┐  │         │  ┌───────────┐  │
│  │Container 1│◄────────────►│Container 2│  │
│  └───────────┘  │ Overlay │  └───────────┘  │
│                 │ Network │                 │
└─────────────────┘         └─────────────────┘
```

```bash
# Для overlay нужен Swarm mode
docker swarm init

# Создать overlay сеть
docker network create -d overlay myoverlay

# Контейнеры на разных нодах могут общаться
```

### Macvlan Network

**Каждый контейнер получает свой MAC-адрес** и появляется как физическое устройство в LAN.

```bash
docker network create -d macvlan \
    --subnet=192.168.1.0/24 \
    --gateway=192.168.1.1 \
    -o parent=eth0 \
    mymacvlan

docker run --network mymacvlan \
    --ip=192.168.1.100 \
    nginx
```

**Важно:**
- Требует promiscuous mode на родительском интерфейсе
- Контейнер НЕ может общаться с хостом напрямую (ограничение ядра)
- Для общения с хостом нужен отдельный bridge

---

## Docker Compose Networking

### Автоматическая сеть

Docker Compose создаёт сеть `<project>_default`:

```yaml
# docker-compose.yml
services:
  web:
    image: nginx
    ports:
      - "80:80"

  api:
    image: myapi
    depends_on:
      - db

  db:
    image: postgres
```

Все сервисы автоматически:
- В одной сети `myproject_default`
- Доступны по имени сервиса (web, api, db)
- DNS разрешает имена

### Кастомные сети

```yaml
services:
  web:
    image: nginx
    networks:
      - frontend

  api:
    image: myapi
    networks:
      - frontend
      - backend

  db:
    image: postgres
    networks:
      - backend

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
    internal: true  # Нет доступа к интернету
```

**Изоляция:** db доступен только из api, web не может достучаться до db.

### DNS и Service Discovery

```yaml
services:
  api:
    image: myapi
    networks:
      default:
        aliases:
          - api.internal
          - backend-api
```

```bash
# Внутри контейнера
nslookup api        # Работает
nslookup api.internal  # Тоже работает (alias)

# DNS сервер Docker
cat /etc/resolv.conf
# nameserver 127.0.0.11  # Embedded DNS
```

### Scaling и DNS Round-Robin

```bash
docker compose up -d --scale api=3

# nslookup вернёт 3 IP
docker compose exec web nslookup api
# Server:    127.0.0.11
# Address 1: 172.18.0.2 api_1
# Address 2: 172.18.0.3 api_2
# Address 3: 172.18.0.4 api_3
```

Docker выполняет **DNS round-robin** между репликами.

---

## Docker и Firewall (iptables/nftables)

### Как Docker управляет iptables

Docker автоматически создаёт iptables правила:

```bash
# Просмотр Docker-правил
iptables -t nat -L -n -v | grep DOCKER
iptables -t filter -L -n -v | grep DOCKER
```

**Ключевые chains:**
- `DOCKER` — NAT для port mapping
- `DOCKER-USER` — ваши кастомные правила
- `DOCKER-ISOLATION-*` — изоляция между сетями

### Port Mapping внутри

```
External Request: host:8080
        ↓
    PREROUTING (nat table)
        ↓ DNAT → 172.17.0.2:80
    FORWARD chain
        ↓
    Container: 172.17.0.2:80
```

### Добавление своих правил

> **Важно:** Не добавляй правила в `DOCKER` chain — Docker перезапишет!

```bash
# Правильно: используй DOCKER-USER
iptables -I DOCKER-USER -s 10.0.0.0/8 -j DROP  # Блокировать внутреннюю сеть

# Для match по оригинальному порту используй conntrack
iptables -I DOCKER-USER -m conntrack \
    --ctorigdstport 8080 -j ACCEPT
```

### Docker с nftables (Docker 29.0+)

```json
// /etc/docker/daemon.json
{
  "firewall-backend": "nftables"
}
```

```bash
# Просмотр nftables правил Docker
nft list table ip docker-bridges
```

**Статус:** Экспериментальный (2024). Для production пока рекомендуется iptables.

### UFW и Docker — конфликт!

> Docker обходит UFW, так как работает в nat table.

**Решения:**
1. Отключить iptables в Docker + host networking
2. Использовать `DOCKER-USER` chain
3. UFW + ufw-docker plugin

---

## Troubleshooting

### Базовые команды

```bash
# Список сетей
docker network ls

# Детали сети
docker network inspect mynet

# Какие сети у контейнера
docker inspect --format='{{json .NetworkSettings.Networks}}' container_name

# IP контейнера
docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' container_name
```

### Netshoot — Swiss Army Knife

```bash
# Запустить в network namespace проблемного контейнера
docker run -it --network container:problem_container \
    nicolaka/netshoot

# Внутри доступны: tcpdump, nmap, netstat, dig, curl, iperf...
```

### Типичные проблемы

#### Контейнеры не видят друг друга

```bash
# 1. Проверить сети
docker network inspect mynet
# Оба контейнера в списке?

# 2. Проверить DNS
docker exec container1 nslookup container2

# 3. Проверить connectivity
docker exec container1 ping container2
```

#### Порт недоступен снаружи

```bash
# 1. Порт слушает?
docker exec container ss -tlnp | grep :80

# 2. Port mapping правильный?
docker port container

# 3. iptables правила
iptables -t nat -L DOCKER -n -v

# 4. Firewall на хосте
firewall-cmd --list-all  # или ufw status
```

#### DNS не работает

```bash
# Проверить resolv.conf в контейнере
docker exec container cat /etc/resolv.conf
# Должен быть 127.0.0.11

# Проверить embedded DNS
docker exec container nslookup google.com
docker exec container nslookup other_container_name
```

### Tcpdump в контейнере

```bash
# Через netshoot
docker run --rm -it --network container:target nicolaka/netshoot \
    tcpdump -i any -n port 80

# Или на хосте (смотрим veth)
# Найти veth контейнера
docker exec container cat /sys/class/net/eth0/iflink
# На хосте найти по этому номеру
ip link | grep <number>:
# Sniff
tcpdump -i veth... -n
```

---

## Security Best Practices

### Network Isolation

```bash
# Отключить ICC (Inter-Container Communication) глобально
dockerd --icc=false

# Или создать изолированную сеть
docker network create --internal myinternal
# Контейнеры в internal сети не имеют доступа к интернету
```

### Не использовать default bridge

```bash
# Плохо
docker run nginx

# Хорошо
docker network create myapp
docker run --network myapp nginx
```

### Ограничить capabilities

```bash
docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE nginx
```

### Rootless Docker

```bash
# Установить rootless mode
dockerd-rootless-setuptool.sh install

# Запуск от обычного пользователя
# Даже если контейнер взломан, нет root на хосте
```

### Secrets — не в ENV

```yaml
# Плохо
services:
  db:
    environment:
      - POSTGRES_PASSWORD=secret123

# Хорошо (Docker Swarm)
services:
  db:
    secrets:
      - db_password

secrets:
  db_password:
    file: ./secret.txt
```

### Мониторинг сети

- **Falco** — runtime security monitoring
- **Cilium** — eBPF-based networking + security
- **Tetragon** — eBPF observability

---

## Performance Considerations

### Bridge vs Host Latency

| Scenario | Bridge | Host |
|----------|--------|------|
| HTTP request (same host) | ~50μs overhead | ~5μs |
| High throughput (iperf3) | 10-20% slower | Native |

**Вывод:** Для latency-critical приложений используй `--network host`.

### Overlay Network Overhead

Overlay добавляет:
- VXLAN encapsulation
- Encryption (если включено)
- ~10-15% throughput penalty

**Оптимизация:**
```bash
# MTU для VXLAN
docker network create -d overlay \
    --opt com.docker.network.driver.mtu=1450 \
    myoverlay
```

### DNS Caching

Docker embedded DNS не кэширует долго. Для высоконагруженных систем:

```yaml
services:
  dnsmasq:
    image: jpillora/dnsmasq
    restart: always
    cap_add:
      - NET_ADMIN

  app:
    dns: dnsmasq
```

---

## Подводные камни

### 1. Default bridge не имеет DNS

**Ошибка:** Запуск без `--network`, ожидание DNS discovery.

```bash
# Не работает
docker run alpine ping mycontainer

# Работает
docker network create mynet
docker run --network mynet alpine ping mycontainer
```

### 2. Published port = доступен всем

```bash
docker run -p 80:80 nginx  # Слушает на 0.0.0.0!
```

**Решение:**
```bash
docker run -p 127.0.0.1:80:80 nginx  # Только localhost
```

### 3. UFW не защищает Docker порты

Docker добавляет правила в nat table, UFW проверяет filter table.

**Решение:** Используй `DOCKER-USER` chain или внешний firewall.

### 4. Container IP меняется при рестарте

**Ошибка:** Хардкодинг IP контейнера.

```python
# Плохо
DB_HOST = "172.17.0.5"

# Хорошо
DB_HOST = "db"  # Используй DNS имя сервиса
```

### 5. Macvlan: контейнер не видит хост

Это ограничение Linux kernel.

**Решение:** Создай дополнительный bridge для host-container traffic.

### 6. Port conflict при scale

```yaml
services:
  web:
    ports:
      - "80:80"
    deploy:
      replicas: 3  # Конфликт! Все пытаются занять 80
```

**Решение:** Используй ranges или load balancer:
```yaml
ports:
  - "80-82:80"  # Для 3 реплик
```

### 7. DNS TTL и container restarts

При рестарте контейнер получает новый IP. Другие контейнеры могут кэшировать старый IP.

**Решение:** Короткий DNS TTL или service mesh.

---

## Чек-лист

### Перед production

- [ ] Используется user-defined network (не default bridge)
- [ ] Sensitive ports bound to localhost
- [ ] Internal networks для backend сервисов
- [ ] ICC отключён или ограничен
- [ ] DOCKER-USER правила настроены
- [ ] Secrets не в environment variables
- [ ] Rootless mode или minimal capabilities

### При troubleshooting

- [ ] `docker network inspect` — контейнеры в одной сети?
- [ ] `docker exec ... nslookup` — DNS работает?
- [ ] `docker port` — mapping корректный?
- [ ] `iptables -L -n` — правила не блокируют?
- [ ] `netshoot` для глубокого анализа

---

## Связанные материалы

- [[network-kubernetes-deep-dive]] — K8s networking, CNI plugins
- [[network-security-fundamentals]] — Firewall, Zero Trust
- [[network-troubleshooting-advanced]] — Tcpdump, диагностика
- [[network-tools-reference]] — CLI инструменты
- [[os-networking]] — Linux networking stack

---

## Источники

| # | Источник | Тип | Ключевой вклад |
|---|----------|-----|----------------|
| 1 | [Docker Network Drivers](https://docs.docker.com/engine/network/drivers/) | Docs | Official drivers reference |
| 2 | [Docker with nftables](https://docs.docker.com/engine/network/firewall-nftables/) | Docs | nftables integration |
| 3 | [Docker Compose Networking](https://docs.docker.com/compose/how-tos/networking/) | Docs | Compose networks |
| 4 | [OWASP Docker Security](https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html) | Cheatsheet | Security best practices |
| 5 | [Netshoot](https://github.com/nicolaka/netshoot) | GitHub | Troubleshooting container |
| 6 | [Network Namespaces Explained](https://medium.com/@amazingandyyy/introduction-to-network-namespaces-and-virtual-ethernet-veth-devices-304e0c02d084) | Blog | Linux primitives |
| 7 | [Container Networking Deep Dive](https://dev.to/polarbit/how-docker-container-networking-works-mimic-it-using-linux-network-namespaces-9mj) | Blog | veth, bridge internals |
| 8 | [Docker Bridge vs Macvlan](https://kenbinlab.com/docker-networking-tutorial-bridge-none-host-ipvlan-macvlan-overlay/) | Tutorial | Driver comparison |
| 9 | [Spacelift Docker Networking](https://spacelift.io/blog/docker-networking) | Blog | Practical examples |
| 10 | [Docker Security Best Practices](https://betterstack.com/community/guides/scaling-docker/docker-security-best-practices/) | Guide | 2024 security |
| 11 | [nftables with Docker](https://dzx.fr/blog/nftables-docker-drop-policy/) | Blog | Firewall integration |
| 12 | [Lumigo Docker Debugging](https://lumigo.io/container-monitoring/docker-debugging-common-scenarios-and-7-practical-tips/) | Blog | Troubleshooting tips |
| 13 | [VMware Container Networking](https://blogs.vmware.com/tanzu/blog-a-container-is-a-linux-namespace-and-networking-basics/) | Blog | Namespace fundamentals |
| 14 | [Docker DNS Service Discovery](https://www.compilenrun.com/docs/devops/docker/docker-networking/docker-dns/) | Docs | Embedded DNS |
| 15 | [Cisco Docker Security](https://blogs.cisco.com/security/strengthening-docker-security-best-practices-for-resilient-containers) | Blog | Enterprise security |

---

## Связь с другими темами

**[[network-kubernetes-deep-dive]]** — Kubernetes networking строится поверх концепций Docker networking, но добавляет абстракции более высокого уровня: Services, Ingress, Network Policies и CNI-плагины. Понимание Docker-примитивов (network namespaces, veth pairs, bridges) является обязательным для диагностики сетевых проблем в Kubernetes, поскольку каждый Pod по сути работает в Docker-like сетевом пространстве. Рекомендуется сначала глубоко понять Docker networking, затем переходить к Kubernetes.

**[[network-ip-routing]]** — Docker networking использует IP-маршрутизацию на уровне хоста: bridge-сети создают виртуальные подсети с собственными CIDR, NAT обеспечивает выход контейнеров в интернет, а iptables/nftables правила управляют маршрутизацией между сетями. Без понимания IP-адресации, subnetting и NAT невозможно диагностировать проблемы с connectivity контейнеров или проектировать сложные multi-host сетевые топологии.

**[[network-transport-layer]]** — TCP/UDP-соединения между контейнерами проходят через виртуальные сетевые интерфейсы, и понимание транспортного уровня необходимо для диагностики проблем с port mapping, connection timeouts и DNS-резолюцией. Docker-прокси по умолчанию работает в userspace, что влияет на производительность TCP-соединений, а знание TCP-handshake помогает отличить сетевые проблемы от проблем приложения при отладке контейнеров.

---

## Источники и дальнейшее чтение

- **Tanenbaum, Wetherall (2011).** *Computer Networks.* — фундаментальное описание сетевых принципов, включая виртуальные сети и изоляцию, что даёт теоретическую базу для понимания container networking.
- **Kurose, Ross (2021).** *Computer Networking: A Top-Down Approach.* — современный учебник с покрытием NAT, DHCP и DNS — всех протоколов, которые Docker использует для создания изолированных сетевых сред.
- **Peterson, Davie (2011).** *Computer Networks: A Systems Approach.* — системный взгляд на сетевую архитектуру, включая виртуализацию и software-defined networking, которые лежат в основе контейнерных сетей.

---

*Последнее обновление: 2026-01-09 — Добавлены педагогические секции: 5 аналогий (контейнеры как квартиры в жилом комплексе, veth pair как телефонная трубка, типы сетей как типы зданий, port mapping как переадресация звонков, Docker Compose как офисное здание с этажами), 6 типичных ошибок с СИМПТОМ/РЕШЕНИЕ (DNS в default bridge, published port доступен из интернета, UFW не защищает Docker порты, хардкодинг IP контейнера, масштабирование с фиксированным портом, macvlan контейнер не видит хост), 5 ментальных моделей (матрёшка изоляции, дерево выбора сетевого драйвера, пакет как турист с визой, DNS как телефонная книга, три уровня troubleshooting)*
