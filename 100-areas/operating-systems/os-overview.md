---
title: "Операционные системы: карта раздела"
created: 2025-12-02
modified: 2025-12-02
type: overview
status: published
area: operating-systems
confidence: high
tags:
  - topic/os
  - fundamentals
  - systems-programming
  - type/moc
  - level/beginner
related:
  - "[[os-processes-threads]]"
  - "[[os-memory-management]]"
  - "[[os-scheduling]]"
  - "[[os-synchronization]]"
  - "[[os-file-systems]]"
  - "[[os-io-devices]]"
  - "[[os-virtualization]]"
---

# Операционные системы: карта раздела

Операционная система — слой абстракции между железом и приложениями. Она решает три фундаментальные задачи: управление ресурсами (CPU, память, диск), изоляция процессов друг от друга, и предоставление удобного API для программ. Без ОС каждая программа должна была бы напрямую работать с железом — писать драйверы для каждого устройства, вручную распределять память, следить за тем, чтобы не затереть данные другой программы.

---

## TL;DR

> **Что:** ОС — это "менеджер ресторана", который распределяет столики (CPU), еду (память) и официантов (I/O) между гостями (программами).
>
> **Зачем разработчику:** Понимание ОС объясняет, почему программа тормозит (context switch, thrashing), почему многопоточность сложна (race conditions), и почему Docker быстрее VM (shared kernel).
>
> **Три кита ОС:** Виртуализация (иллюзия множества CPU/памяти), Concurrency (координация потоков), Persistence (хранение данных).
>
> **Ключевое число:** Context switch занимает 1-3 µs напрямую, но с cache miss — до 10-30 µs. При 1000 потоках это становится проблемой.

---

## Часть 1: Интуиция без кода

### Аналогия 1: ОС — "менеджер ресторана"

Представьте ресторан с одним поваром (CPU), ограниченным количеством столиков (RAM) и кухонными запасами (диск).

```
               РЕСТОРАН (Компьютер)
┌─────────────────────────────────────────────────────┐
│                                                     │
│   Гости (Программы):                               │
│   ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐              │
│   │ 🧑 │  │ 👩 │  │ 🧔 │  │ 👴 │  ...          │
│   │Word │  │Chrome│ │Spotify│ │Game │              │
│   └─────┘  └─────┘  └─────┘  └─────┘              │
│       │        │        │        │                 │
│       ▼        ▼        ▼        ▼                 │
│   ┌─────────────────────────────────────┐         │
│   │        МЕНЕДЖЕР (ОС)                │         │
│   │  • Кто сядет за столик? (RAM)       │         │
│   │  • Кто следующий к повару? (CPU)    │         │
│   │  • Кто подождёт в очереди?          │         │
│   └─────────────────────────────────────┘         │
│                    │                               │
│       ┌────────────┼────────────┐                 │
│       ▼            ▼            ▼                 │
│   ┌───────┐   ┌───────┐   ┌───────┐              │
│   │Столики│   │  Повар │   │Склад  │              │
│   │ (RAM) │   │ (CPU)  │   │(Диск) │              │
│   └───────┘   └───────┘   └───────┘              │
│                                                     │
└─────────────────────────────────────────────────────┘

Без менеджера:
• Гости дерутся за столики
• Повар не знает, чей заказ готовить
• Хаос и никто не ест

С менеджером (ОС):
• Справедливое распределение столиков
• Очерёдность заказов
• Все получают еду (хоть и с ожиданием)
```

---

### Аналогия 2: Ядро как "машинное отделение корабля"

```
           ПАССАЖИРСКИЙ КОРАБЛЬ
┌────────────────────────────────────────┐
│         ПАЛУБА (User Space)            │
│  ┌────┐ ┌────┐ ┌────┐ ┌────┐          │
│  │ 🧑 │ │ 👩 │ │ 🧔 │ │ 👴 │          │
│  │pass│ │pass│ │pass│ │pass│          │
│  └────┘ └────┘ └────┘ └────┘          │
│                                        │
│  Пассажиры могут:                      │
│  ✓ Гулять по палубе                    │
│  ✓ Заказывать еду                      │
│  ✗ НЕ могут в машинное отделение      │
├────────────────────────────────────────┤
│    🚪 ДВЕРЬ С ОХРАНОЙ (Syscall)       │
│    Пассажир: "Мне нужно в порт X!"    │
│    Охранник передаёт капитану          │
├────────────────────────────────────────┤
│      МАШИННОЕ ОТДЕЛЕНИЕ (Kernel)       │
│  ┌────────────────────────────────┐   │
│  │  👨‍✈️ Капитан (Scheduler)         │   │
│  │  ⚙️ Двигатели (CPU)              │   │
│  │  🧭 Навигация (Memory)           │   │
│  │  📻 Радио (I/O Devices)          │   │
│  └────────────────────────────────┘   │
│                                        │
│  Только персонал корабля:              │
│  ✓ Управляет двигателем               │
│  ✓ Меняет курс                        │
│  ✓ Работает с оборудованием           │
└────────────────────────────────────────┘

Почему пассажиры не могут в машинное?
→ Безопасность: один ошибётся — потонут ВСЕ
→ ОС защищает систему от багов в программах
```

---

### Аналогия 3: Syscall — "заказ в ресторане"

```
Вы хотите прочитать файл. Но файл на диске, а диск — "в машинном отделении".

ВАШ КОД (User Space)          ЯДРО (Kernel Space)
─────────────────────         ──────────────────────

val file = File("/data.txt")
    │
    │ "Официант! Мне файл!"
    │
    ▼
┌───────────────────┐
│   read() syscall  │─────────► Ядро получает запрос
└───────────────────┘          │
    │                          │ Проверяет права
    │ (ждёт...)                │ Находит файл на диске
    │                          │ Копирует данные
    │                          │
    ◄──────────────────────────┘
    │
    ▼
println(file.readText())  // Данные у вас!

СТОИМОСТЬ: ~100-200 наносекунд на каждый syscall
           Быстро? Да. Но если миллионы вызовов — заметно!
```

---

### Аналогия 4: Context Switch — "переключение разговоров"

Вы на вечеринке и говорите с тремя людьми по очереди:

```
Разговор с Аней про работу...
    → ПЕРЕКЛЮЧЕНИЕ →
Разговор с Борей про футбол...
    → ПЕРЕКЛЮЧЕНИЕ →
Разговор с Васей про отпуск...
    → ПЕРЕКЛЮЧЕНИЕ →
Снова с Аней...

При каждом переключении вы:
1. Запоминаете, где остановились с предыдущим (save state)
2. Вспоминаете контекст нового разговора (load state)
3. Тратите время на "а о чём мы говорили?"

CPU делает то же самое с процессами!

┌─────────────────────────────────────────────────────┐
│              CONTEXT SWITCH                         │
├─────────────────────────────────────────────────────┤
│                                                     │
│  Процесс A работает     Процесс B ждёт             │
│  ┌─────────────┐        ┌─────────────┐            │
│  │ Регистры    │        │ Сохранённое │            │
│  │ PC, SP...   │        │ состояние   │            │
│  │ Кэш горячий │        │ в памяти    │            │
│  └─────────────┘        └─────────────┘            │
│         │                      │                   │
│         │    ПЕРЕКЛЮЧЕНИЕ      │                   │
│         │    (1-30 µs)         │                   │
│         ▼                      ▼                   │
│  ┌─────────────┐        ┌─────────────┐            │
│  │ Сохранено   │        │ Регистры    │            │
│  │ в память    │        │ загружены   │            │
│  │             │        │ Кэш ХОЛОДНЫЙ│ ← Проблема!│
│  └─────────────┘        └─────────────┘            │
│                                                     │
│  "Холодный кэш" = данные B не в кэше CPU           │
│  = первые операции медленные (cache miss)          │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---

### Аналогия 5: Виртуальная память — "этажи в торговом центре"

```
Каждый магазин (процесс) думает, что у него ВЕСЬ этаж:

МАГАЗИН A видит:               МАГАЗИН B видит:
┌─────────────────┐            ┌─────────────────┐
│ Адрес 0x0000    │            │ Адрес 0x0000    │
│ Мой вход        │            │ Мой вход        │
├─────────────────┤            ├─────────────────┤
│ Адрес 0x1000    │            │ Адрес 0x1000    │
│ Мои полки       │            │ Мои полки       │
├─────────────────┤            ├─────────────────┤
│ Адрес 0x2000    │            │ Адрес 0x2000    │
│ Мой склад       │            │ Мой склад       │
└─────────────────┘            └─────────────────┘

РЕАЛЬНОСТЬ (физическая память):
┌─────────────────────────────────────────────────┐
│ 0x0000-0x0FFF: Вход магазина A                  │
│ 0x1000-0x1FFF: Полки магазина B  ← перемешано!  │
│ 0x2000-0x2FFF: Склад магазина A                 │
│ 0x3000-0x3FFF: Вход магазина B                  │
│ ...                                             │
│ SWAP (диск): Полки магазина A (не поместились)  │
└─────────────────────────────────────────────────┘

Менеджер ТЦ (ОС) ведёт "таблицу трансляции" (Page Table):
  Магазин A, адрес 0x1000 → физический 0x2000
  Магазин B, адрес 0x1000 → физический 0x1000

Магазины изолированы! A не может попасть в B.
```

---

## Часть 2: Почему операционные системы — это сложно

### Ошибка 1: Путаница Process vs Thread

**СИМПТОМ:** "Зачем мне потоки, если есть процессы?" или наоборот

```
Process (Процесс):                Thread (Поток):
• Своё адресное пространство      • ОБЩЕЕ адресное пространство
• Изоляция от других процессов    • Разделяет память с другими потоками
• fork() создаёт КОПИЮ            • pthread_create() добавляет поток
• Тяжёлый (~100-300µs создать)    • Лёгкий (~30-50µs создать)

┌─────────────────────┐           ┌─────────────────────┐
│    ПРОЦЕСС A        │           │    ПРОЦЕСС B        │
│  ┌───┐ ┌───┐ ┌───┐  │           │  ┌───┐              │
│  │T1 │ │T2 │ │T3 │  │           │  │T1 │ (один поток) │
│  └───┘ └───┘ └───┘  │           │  └───┘              │
│  [  ОБЩАЯ ПАМЯТЬ  ] │           │  [ СВОЯ ПАМЯТЬ  ]   │
│  heap, код, данные  │           │                     │
└─────────────────────┘           └─────────────────────┘
        │                                  │
        │          ИЗОЛИРОВАНЫ             │
        └──────────────────────────────────┘
```

**КОГДА ЧТО ИСПОЛЬЗОВАТЬ:**
- **Процессы**: безопасность важнее (Chrome: каждая вкладка = процесс)
- **Потоки**: производительность важнее (веб-сервер: потоки на запросы)

---

### Ошибка 2: Недооценка overhead Context Switch

**СИМПТОМ:** "У меня 10000 потоков, всё должно быть параллельно!"

```kotlin
// ❌ ПЛОХО: 10000 потоков для 10000 задач
val threads = (1..10000).map {
    thread { doWork(it) }
}

// При 8 ядрах CPU:
// • 10000 потоков конкурируют за 8 ядер
// • Context switch каждые 1-10ms
// • 10000 / 8 ≈ 1250 переключений на ядро в секунду
// • Overhead: ~30µs × 1250 = ~37ms ПОТЕРЯННОГО времени на ядро!

// ✅ ЛУЧШЕ: Thread pool размером с число ядер
val executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors())
(1..10000).forEach { executor.submit { doWork(it) } }
```

---

### Ошибка 3: Непонимание виртуальной памяти и Page Fault

**СИМПТОМ:** "У меня 16GB RAM, почему программа тормозит?"

```
Сценарий: Программа выделила 20GB, но у вас 16GB RAM

┌────────────────────────────────────────────────────────┐
│ Виртуальная память программы: 20GB                     │
│                                                        │
│  [████████████████████████████████████████]            │
│   ↑          ↑           ↑           ↑                 │
│  Страница   Страница    Страница   Страница            │
│  в RAM      на ДИСКЕ    в RAM      на ДИСКЕ            │
│                                                        │
│ При доступе к странице на диске:                       │
│ 1. CPU: "Хочу данные по адресу X"                      │
│ 2. MMU: "Этой страницы нет в RAM!" → PAGE FAULT        │
│ 3. OS: Загружает с диска (10ms для HDD!)               │
│ 4. CPU: Ждёт...                                        │
│                                                        │
│ 10ms = 10,000,000 наносекунд                           │
│ Для сравнения: доступ к RAM = 100ns                    │
│ Разница: 100,000x медленнее!                           │
└────────────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:** Мониторить page faults: `vmstat`, `perf stat`

---

### Ошибка 4: Игнорирование Syscall Overhead

**СИМПТОМ:** Код работает медленнее, чем ожидалось

```kotlin
// ❌ ПЛОХО: syscall на каждый байт
val file = FileInputStream("large.bin")
while (true) {
    val byte = file.read()  // SYSCALL! 100-200ns каждый раз
    if (byte == -1) break
    process(byte)
}
// 1GB файл = 1 миллиард syscalls = ~100-200 СЕКУНД overhead!

// ✅ ЛУЧШЕ: буферизованное чтение
val file = BufferedInputStream(FileInputStream("large.bin"), 64 * 1024)
val buffer = ByteArray(64 * 1024)
while (true) {
    val bytesRead = file.read(buffer)  // Один syscall на 64KB
    if (bytesRead == -1) break
    processBuffer(buffer, bytesRead)
}
// 1GB файл = ~16000 syscalls = ~1.6-3.2ms overhead
```

---

### Ошибка 5: Неправильный выбор модели concurrency

**СИМПТОМ:** Thread-per-request падает под нагрузкой

```
10000 одновременных HTTP запросов:

MODEL 1: Thread-per-request (PostgreSQL style)
┌──────────────────────────────────────────┐
│ 10000 потоков                            │
│ • 10000 × 1MB stack = 10GB памяти!       │
│ • Context switch overhead               │
│ • Работает для сотен, не тысяч          │
└──────────────────────────────────────────┘

MODEL 2: Event Loop + небольшой thread pool (Node.js, Ktor)
┌──────────────────────────────────────────┐
│ 8 потоков (по числу ядер)                │
│ • Event loop обрабатывает I/O события    │
│ • Потоки НЕ блокируются на I/O           │
│ • 10000 запросов на 8 потоках            │
│ • Минимум context switches               │
└──────────────────────────────────────────┘

MODEL 3: Coroutines / Virtual Threads (Kotlin, Java 21+)
┌──────────────────────────────────────────┐
│ Миллион корутин на нескольких OS потоках │
│ • Переключение в userspace (~20ns)       │
│ • OS не знает про корутины               │
│ • Лучшее из обоих миров                  │
└──────────────────────────────────────────┘
```

---

### Ошибка 6: Забывают про Kernel Mode Overhead

**СИМПТОМ:** Системные вызовы дорогие после Spectre/Meltdown

```
До 2018 (Spectre/Meltdown):
  User → Kernel: ~100ns
  Kernel → User: ~100ns

После 2018 (с KPTI патчами):
  User → Kernel: ~300-500ns  ← 3-5x медленнее!
  Kernel → User: ~300-500ns

ПОЧЕМУ? Kernel Page Table Isolation:
• Раньше: kernel и user разделяли таблицу страниц
• Теперь: при syscall переключается ВСЯ таблица страниц
• Защита от атак, но стоит производительности

РЕШЕНИЕ: Минимизировать syscalls
• Батчинг операций (io_uring в Linux)
• Memory-mapped files вместо read/write
• Userspace networking (DPDK)
```

---

## Часть 3: Ментальные модели операционных систем

### Модель 1: ОС как "слоёный пирог"

```
┌─────────────────────────────────────────────────────┐
│                   ПРИЛОЖЕНИЯ                        │
│            (Chrome, VS Code, игры)                  │
├─────────────────────────────────────────────────────┤
│                 СИСТЕМНЫЕ БИБЛИОТЕКИ                │
│              (libc, glibc, Win32 API)               │
│            Обёртки над syscalls                     │
├─────────────────────────────────────────────────────┤
│                    СИСТЕМНЫЕ ВЫЗОВЫ                 │
│         (read, write, fork, exec, mmap)             │
│         ═══════════════════════════════             │
│         ↑ ГРАНИЦА USER/KERNEL ↑                    │
├─────────────────────────────────────────────────────┤
│                     ЯДРО ОС                         │
│  ┌────────────┬────────────┬────────────┬────────┐ │
│  │ Процессы   │ Память     │ Файловые   │ Сеть   │ │
│  │ Потоки     │ Виртуальная│ системы    │ TCP/IP │ │
│  │ Scheduler  │ Paging     │ VFS, ext4  │        │ │
│  └────────────┴────────────┴────────────┴────────┘ │
├─────────────────────────────────────────────────────┤
│                     ДРАЙВЕРЫ                        │
│          (видеокарта, диск, сеть, USB)              │
├─────────────────────────────────────────────────────┤
│                    ЖЕЛЕЗО                           │
│              (CPU, RAM, SSD, NIC)                   │
└─────────────────────────────────────────────────────┘

Каждый слой знает только о соседних!
• Приложение не знает, какой диск (SSD/HDD)
• Ядро не знает, что делает приложение
```

---

### Модель 2: Time-sharing как "вращающийся стол"

```
Представьте круглый стол, который вращается:

        CPU (повар обслуживает того, кто перед ним)
                    │
                    ▼
            ┌───────────────┐
            │    Сейчас:    │
            │   Процесс A   │
            └───────────────┘
                    │
    ┌───────────────┼───────────────┐
    │               │               │
┌───────┐      ┌───────┐       ┌───────┐
│   B   │      │   A   │       │   C   │
│ ждёт  │      │работа │       │ ждёт  │
└───────┘      └───────┘       └───────┘
    ↑                               │
    └───────────────────────────────┘
              Вращение (scheduler)

Каждые 10ms (time slice) стол поворачивается:
A → B → C → A → B → C → ...

Иллюзия: каждый процесс "думает", что CPU только его!
Реальность: CPU разделён между всеми
```

---

### Модель 3: Защитные кольца (Rings)

```
            ┌───────────────────────────────────┐
            │         RING 3 (User Mode)        │
            │   Приложения, библиотеки          │
            │   МИНИМУМ привилегий              │
            │                                   │
            │    ┌───────────────────────┐      │
            │    │    RING 2, 1          │      │
            │    │  (редко используются)  │      │
            │    │                       │      │
            │    │   ┌───────────────┐   │      │
            │    │   │   RING 0      │   │      │
            │    │   │   KERNEL      │   │      │
            │    │   │ ВСЕ права     │   │      │
            │    │   └───────────────┘   │      │
            │    └───────────────────────┘      │
            └───────────────────────────────────┘

Ring 0 (Kernel):
• Доступ к ЛЮБОЙ памяти
• Управление CPU (halt, interrupts)
• Прямой доступ к устройствам

Ring 3 (User):
• Только своя виртуальная память
• Никакого прямого доступа к железу
• Любое нарушение → trap → kernel решает что делать

Переход Ring 3 → Ring 0: только через syscall (контролируемая точка входа)
```

---

### Модель 4: "Всё — файл" (Unix philosophy)

```
В Unix/Linux почти всё представлено как файл:

┌──────────────────────────────────────────────────────┐
│                   ВСЁ - ФАЙЛ                         │
├──────────────────────────────────────────────────────┤
│                                                      │
│  /home/user/doc.txt    → обычный файл               │
│  /dev/sda              → жёсткий диск               │
│  /dev/null             → "чёрная дыра"              │
│  /dev/random           → генератор случайных чисел  │
│  /proc/1234/status     → информация о процессе      │
│  /sys/class/net/eth0   → сетевой интерфейс          │
│  /dev/tty              → терминал                   │
│                                                      │
│  Общий API: open(), read(), write(), close()        │
│                                                      │
│  Хотите прочитать температуру CPU?                  │
│  cat /sys/class/thermal/thermal_zone0/temp          │
│                                                      │
│  Хотите посмотреть память процесса?                 │
│  cat /proc/1234/maps                                │
│                                                      │
└──────────────────────────────────────────────────────┘

ПРЕИМУЩЕСТВО: Унифицированный интерфейс
• Не нужны разные API для разных устройств
• Команды работают с чем угодно: cat, grep, awk
• Простота и composability
```

---

### Модель 5: Таблица выбора — что когда использовать

```
┌─────────────────────────────────────────────────────────────┐
│              ВЫБОР МОДЕЛИ CONCURRENCY                        │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ЗАДАЧА                         │  РЕШЕНИЕ                  │
│  ─────────────────────────────  │  ─────────────────────── │
│  CPU-bound (вычисления)         │  Потоков = числу ядер    │
│  I/O-bound (сеть, диск)         │  Async / Event Loop      │
│  Изоляция важна (безопасность)  │  Процессы                │
│  Shared state между задачами    │  Потоки + синхронизация  │
│  Много лёгких задач             │  Корутины / Green Threads│
│  Realtime требования            │  RTOS, pinned threads    │
│                                                              │
├─────────────────────────────────────────────────────────────┤
│              ВЫБОР: PROCESS vs THREAD vs COROUTINE          │
├─────────────────────────────────────────────────────────────┤
│                    │ Process     │ Thread      │ Coroutine │
│ ───────────────────┼─────────────┼─────────────┼───────────│
│ Изоляция памяти    │ ДА          │ НЕТ         │ НЕТ       │
│ Создание           │ 100-300µs   │ 30-50µs     │ <1µs      │
│ Context switch     │ 10-30µs     │ 1-10µs      │ ~20ns     │
│ Память на единицу  │ MB          │ MB (stack)  │ KB        │
│ Масштабируемость   │ Сотни       │ Тысячи      │ Миллионы  │
│ Сложность          │ Низкая      │ Средняя     │ Средняя   │
│ Пример             │ PostgreSQL  │ MySQL       │ Go, Kotlin│
└─────────────────────────────────────────────────────────────┘
```

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| Базовое программирование | Понимание переменных, функций, памяти — основа для понимания как ОС управляет ресурсами | Любой курс по программированию (Python, Java, C) |
| Основы архитектуры компьютера | Знание что такое CPU, RAM, диск — для понимания что именно ОС абстрагирует | [Crash Course Computer Science](https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo) |
| Командная строка Linux/macOS | Практическое применение концепций ОС, работа с процессами и файлами | [Linux Journey](https://linuxjourney.com/) — бесплатный интерактивный курс |
| Основы языка C (желательно) | Системное программирование, понимание указателей и памяти | [Learn C](https://www.learn-c.org/) — онлайн практика |

**Время на подготовку:** ~2-4 недели при изучении с нуля, 0 если уже программируете

---

## Зачем разработчику понимать ОС

Даже если вы пишете на Java или Python, ваш код в итоге выполняется на ОС. Понимание того, как работает ОС, объясняет поведение ваших программ:

**Почему программа тормозит?** Возможно, ОС вытеснила ваш процесс, потому что другой процесс имеет более высокий приоритет. Или программа ждёт I/O, и CPU простаивает. Или происходит thrashing — системе не хватает памяти и она постоянно swap'ит страницы на диск.

**Почему многопоточность сложна?** Потому что ОС может прервать ваш поток в любой момент и переключиться на другой. Два потока могут одновременно модифицировать одну переменную, и результат непредсказуем. Понимание scheduling и synchronization объясняет, почему race conditions возникают и как их предотвращать.

**Почему контейнеры быстрее VM?** Потому что контейнеры используют механизмы изоляции ОС (namespaces, cgroups), а не эмулируют целую машину. Понимание виртуализации объясняет tradeoffs между Docker и VM.

---

## Структура раздела

```
┌─────────────────────────────────────────────────────────────────┐
│                    ОПЕРАЦИОННЫЕ СИСТЕМЫ                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │ Процессы и      │  │ Управление      │  │ Планирование    │ │
│  │ потоки          │  │ памятью         │  │ процессов       │ │
│  │                 │  │                 │  │                 │ │
│  │ Что такое       │  │ Виртуальная     │  │ Как ОС решает   │ │
│  │ процесс?        │  │ память, paging, │  │ кому дать CPU?  │ │
│  │ Чем отличается  │  │ page faults,    │  │ FIFO, Round     │ │
│  │ от потока?      │  │ swapping        │  │ Robin, CFS      │ │
│  └────────┬────────┘  └────────┬────────┘  └────────┬────────┘ │
│           │                    │                    │          │
│           ▼                    ▼                    ▼          │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │                   СИНХРОНИЗАЦИЯ                              ││
│  │  Mutex, Semaphore, Deadlock, Race Conditions                ││
│  │  Как процессы/потоки координируют доступ к ресурсам         ││
│  └─────────────────────────────────────────────────────────────┘│
│           │                    │                    │          │
│           ▼                    ▼                    ▼          │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │ Файловые        │  │ Ввод/Вывод      │  │ Виртуализация   │ │
│  │ системы         │  │                 │  │                 │ │
│  │                 │  │ Как ОС работает │  │ VM vs           │ │
│  │ Как данные      │  │ с устройствами? │  │ Containers      │ │
│  │ хранятся на     │  │ Interrupts,     │  │ Hypervisors,    │ │
│  │ диске?          │  │ DMA, буферы     │  │ namespaces      │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Материалы раздела

### Фундамент (читать в этом порядке)

| Материал | Что узнаете | Связан с |
|----------|-------------|----------|
| [[os-processes-threads]] | Процесс vs поток, fork/exec, жизненный цикл | JVM threads, Kotlin coroutines |
| [[os-memory-management]] | Виртуальная память, paging, page faults | JVM heap, GC tuning |
| [[os-scheduling]] | Как ОС распределяет CPU между процессами | Thread pools, async programming |

### Координация и ресурсы

| Материал | Что узнаете | Связан с |
|----------|-------------|----------|
| [[os-synchronization]] | Mutex, semaphore, deadlock, race conditions | JVM synchronized, locks |
| [[os-file-systems]] | Как данные хранятся на диске, inodes, journaling | Database storage, I/O optimization |
| [[os-io-devices]] | Interrupts, DMA, buffering, polling vs interrupts | Network programming, async I/O |

### Современные технологии

| Материал | Что узнаете | Связан с |
|----------|-------------|----------|
| [[os-virtualization]] | VM vs containers, hypervisors, namespaces | Docker, Kubernetes |

---

## Ключевые концепции раздела

### Абстракции ОС

ОС предоставляет абстракции, скрывающие сложность железа:

| Реальность (железо) | Абстракция ОС | Что это даёт |
|---------------------|---------------|--------------|
| Один CPU с прерываниями | Множество процессов | Иллюзия параллельного выполнения |
| Физическая RAM + диск | Виртуальная память | Каждый процесс "думает", что у него вся память |
| Секторы на диске | Файлы и директории | Удобная иерархическая структура |
| Порты, IRQ, DMA | Файловые дескрипторы | Унифицированный API (всё — файл) |

### Ядро (Kernel)

Kernel — привилегированная часть ОС, работающая в защищённом режиме CPU. Только kernel может:
- Напрямую работать с железом
- Переключать процессы
- Управлять памятью
- Обрабатывать прерывания

Пользовательские программы запрашивают услуги kernel через **системные вызовы** (syscalls). Syscall — это контролируемый переход из user mode в kernel mode.

```
User Space (ring 3)           Kernel Space (ring 0)
┌─────────────────┐           ┌─────────────────┐
│ Ваша программа  │           │ Ядро Linux      │
│                 │  syscall  │                 │
│ open("/file")   │──────────▶│ VFS, драйверы   │
│                 │           │ планировщик     │
│ read(fd, buf)   │◀──────────│ память          │
│                 │  return   │                 │
└─────────────────┘           └─────────────────┘
```

### Режимы работы процессора

Современные CPU имеют уровни привилегий (rings на x86):
- **Ring 0 (kernel mode)**: Полный доступ ко всему железу
- **Ring 3 (user mode)**: Ограниченный доступ, защита памяти

Попытка выполнить привилегированную инструкцию в user mode вызывает исключение (trap), и управление передаётся kernel. Это защищает систему от ошибок и вредоносных программ.

---

## Числа, которые нужно знать

Эти числа помогают принимать архитектурные решения:

| Операция | Примерное время | Источник |
|----------|-----------------|----------|
| Context switch (прямые затраты) | 1-3 µs | Eli Bendersky benchmarks |
| Context switch (с cache miss) | 10-30 µs | Stack Overflow, Linux benchmarks |
| fork() с COW | ~100-300 µs | Linux kernel benchmarks |
| fork() + exec() простой программы | ~1-5 ms | Зависит от программы |
| Создание потока | ~30-50 µs | pthread_create benchmarks |
| Syscall overhead | ~100-200 ns | Linux kernel measurements |
| Page fault (memory) | ~1 µs | Зависит от TLB |
| Page fault (disk) | ~10 ms | SSD: 0.1ms, HDD: 10ms |

**Почему это важно:** Context switch за 3µs кажется быстрым, но если у вас 1000 потоков, активно конкурирующих за CPU, overhead становится значительным. Это одна из причин, почему async I/O и event loops (Node.js, Kotlin coroutines) могут быть эффективнее thread-per-request модели.

---

## Связь с другими разделами

```
┌─────────────────────────────────────────────────────────────────┐
│                    КАК ВСЁ СВЯЗАНО                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  JVM                          OS                                │
│  ───                          ──                                │
│  JVM threads          ←───→   OS threads (1:1 в HotSpot)        │
│  JVM heap             ←───→   Virtual memory pages              │
│  GC паузы             ←───→   Stop-the-world = все threads      │
│  synchronized         ←───→   OS mutex / futex                  │
│                                                                 │
│  Kotlin                       OS                                │
│  ──────                       ──                                │
│  Coroutines           ←───→   Много coroutines на 1 thread      │
│  Dispatchers          ←───→   Thread pools, scheduling          │
│  suspend functions    ←───→   Non-blocking I/O                  │
│                                                                 │
│  DevOps                       OS                                │
│  ──────                       ──                                │
│  Docker containers    ←───→   Namespaces + cgroups              │
│  Kubernetes           ←───→   Container orchestration           │
│  VM (EC2, GCE)        ←───→   Hypervisor virtualization         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Путь обучения

```
УРОВЕНЬ 1: Основы (понимаю что происходит)
└── [[os-processes-threads]] → [[os-memory-management]] → [[os-scheduling]]

УРОВЕНЬ 2: Углублённое понимание (могу диагностировать проблемы)
└── [[os-synchronization]] → [[os-file-systems]] → [[os-io-devices]]

УРОВЕНЬ 3: Продвинутый (понимаю внутреннее устройство)
└── [[os-virtualization]] → низкоуровневая отладка

РЕКОМЕНДУЕМЫЙ ПОРЯДОК:
1. Processes & Threads (3-5 дней)    ← Фундамент многопоточности
2. Memory Management (3-5 дней)      ← Heap, stack, виртуальная память
3. Scheduling (2-3 дня)              ← Как CPU распределяет время
4. Synchronization (3-5 дней)        ← Locks, deadlocks, race conditions
5. File Systems (2-3 дня)            ← Как данные хранятся
6. I/O Devices (2-3 дня)             ← Blocking vs async
7. Virtualization (2-3 дня)          ← VM vs containers
```

---

## С чего начать

**Если вы бэкенд-разработчик:** Начните с [[os-processes-threads]] — это объяснит, как работают потоки в вашем приложении. Затем [[os-memory-management]] — поймёте, почему приложение может начать тормозить при нехватке памяти.

**Если вы работаете с многопоточностью:** Читайте [[os-synchronization]] — это фундамент для понимания locks, deadlocks, race conditions на уровне ОС, что объясняет поведение synchronized и Lock в Java.

**Если вы DevOps/SRE:** [[os-virtualization]] объяснит разницу между VM и контейнерами на уровне механизмов ОС. [[os-io-devices]] поможет понять I/O bottlenecks.

---

## Кто использует и реальные примеры

### Почему компании заботятся о понимании ОС

| Компания/Проект | Что делают | Какие концепции ОС критичны |
|-----------------|------------|----------------------------|
| **Netflix** | Streaming миллионам пользователей | Async I/O, memory management, kernel bypass для сети (DPDK) |
| **Google Chrome** | Каждая вкладка = отдельный процесс | Process isolation (безопасность), IPC между процессами |
| **Docker** | Контейнеризация приложений | Namespaces, cgroups, copy-on-write файловые системы |
| **PostgreSQL** | Process-per-connection модель | fork(), shared memory, semaphores для координации |
| **MySQL** | Thread-per-connection модель | Threads, mutexes, thread pools |
| **Node.js** | Single-threaded event loop | Non-blocking I/O, epoll/kqueue, минимизация context switches |
| **Android** | Убивает фоновые приложения при нехватке памяти | Low Memory Killer, process priorities, memory pressure |

### Context Switch в реальности

**Проблема Meta (ноябрь 2024):** Инженеры Meta обнаружили, что на их веб-серверах ~17% CPU времени тратится на `switch_mm_irqs_off` — функцию переключения контекста. Патчи для Linux kernel снизили время Hackbench теста с 4.5s до 4.2s.

**Почему это важно для вас:**
- При проектировании high-load системы: thread-per-request vs async I/O — разница в тысячах context switches
- При выборе базы данных: PostgreSQL (processes) vs MySQL (threads) — разные overhead и изоляция
- При настройке thread pools: слишком много потоков = overhead на переключение

### Типы ОС и где они используются

| Тип ОС | Примеры | Где применяется |
|--------|---------|-----------------|
| Desktop/Server | Linux, Windows, macOS | Серверы, рабочие станции, облака |
| Mobile | Android, iOS | Смартфоны, планшеты |
| Embedded | FreeRTOS, VxWorks, Zephyr | IoT устройства, автомобили, роботы |
| Real-time (RTOS) | QNX, RTLinux | Медицинское оборудование, авиация, промышленность |

---

## Рекомендуемые источники

### Книги (в порядке рекомендации)

| Книга | Уровень | Почему стоит читать | Бесплатно? |
|-------|---------|---------------------|------------|
| **[Operating Systems: Three Easy Pieces](https://pages.cs.wisc.edu/~remzi/OSTEP/)** (OSTEP) | Beginner-Intermediate | Лучшая книга для начала. Легко читается, хорошо структурирована. Три темы: virtualization, concurrency, persistence | Да, онлайн |
| **Modern Operating Systems** (Tanenbaum) | Intermediate | Классический учебник, автор — создатель MINIX. Глубже чем OSTEP | Нет |
| **Operating System Concepts** ("Dinosaur Book") | Academic | Стандартный университетский учебник, много деталей | Нет |
| **Linux Kernel Development** (Robert Love) | Advanced | Практическая реализация в Linux, для тех кто хочет понять ядро | Нет |

### Онлайн-курсы

| Курс | Платформа | Особенности |
|------|-----------|-------------|
| [MIT 6.S081: Operating System Engineering](https://pdos.csail.mit.edu/6.1810/2025/) | MIT OpenCourseWare | Hands-on с xv6, лучший для практики. RISC-V архитектура |
| [Operating Systems and You: Becoming a Power User](https://www.coursera.org/learn/os-power-user) | Coursera (Google) | Практический курс для начинающих, бесплатный аудит |
| [Neso Academy: Operating Systems](https://www.youtube.com/playlist?list=PLBlnK6fEyqRiVhbXDGLXDk_OQAeuVcp2O) | YouTube | 1.6M+ подписчиков, отличные объяснения на английском |

### Практические ресурсы

| Ресурс | Что это | Для кого |
|--------|---------|----------|
| [xv6](https://github.com/mit-pdos/xv6-riscv) | Учебная ОС от MIT, ~10K строк кода | Тех, кто хочет читать реальный код ОС |
| [Linux Journey](https://linuxjourney.com/) | Интерактивный курс по Linux | Новичков в командной строке |
| [Red Hat Interactive Labs](https://www.redhat.com/en/interactive-labs) | Hands-on лабы в браузере | Практики с Linux без установки |
| [Write Your Own OS](https://www.udemy.com/course/writing-your-own-operating-system-from-scratch/) | Udemy курс — написать ОС с нуля | Тех, кто хочет понять на уровне кода |

### YouTube каналы

- **[Neso Academy](https://www.youtube.com/@nesaboratory)** — теория ОС, 1.6M подписчиков
- **[Low Byte Productions](https://www.youtube.com/@LowByteProductions)** — Source Dive по xv6, разбор кода
- **[NetworkChuck](https://www.youtube.com/@NetworkChuck)** — Linux, DevOps, практика

---

## Терминология для новичков

| Термин | Что это | Аналогия из жизни |
|--------|---------|-------------------|
| **Kernel (Ядро)** | Привилегированная часть ОС с полным доступом к железу | Капитан корабля — единственный, кто может управлять штурвалом и двигателями |
| **User space** | Непривилегированный режим, где работают обычные программы | Пассажиры корабля — могут ходить по палубе, но не в машинное отделение |
| **Syscall** | Запрос от программы к ядру ("сделай что-то с железом") | Звонок официанту — вы не идёте на кухню сами, а просите принести еду |
| **Context switch** | Переключение CPU с одной задачи на другую | Переключение внимания между разговорами на вечеринке — нужно "вспомнить", о чём говорили |
| **Virtual memory** | Иллюзия, что у каждой программы вся память — её личная | Каждый арендатор в ТЦ думает, что весь этаж — его, хотя это общее пространство |
| **Page** | Блок памяти (обычно 4KB), которым ОС оперирует | Страница в книге — ОС работает не с буквами, а со страницами целиком |
| **Page fault** | Программа обратилась к данным, которых нет в RAM | Библиотекарь идёт в хранилище за книгой, которой нет на полке |
| **Scheduler** | Компонент ОС, решающий кому дать CPU | Диспетчер такси — решает какая машина поедет к какому клиенту |
| **Interrupt (Прерывание)** | Сигнал от устройства: "у меня есть данные!" | Звонок телефона — прерывает текущую работу, чтобы обработать входящий вызов |
| **DMA** | Передача данных напрямую в память без участия CPU | Курьер доставляет посылку в ваш почтовый ящик, пока вы работаете — не нужно отвлекаться |
| **IPC** | Способы общения между процессами | Записки между учениками — процессы изолированы, но могут обмениваться сообщениями |
| **VFS** | Единый интерфейс для всех файловых систем | Универсальный пульт управления — работает с любым TV, независимо от производителя |
| **Futex** | Быстрая блокировка в Linux (работает в user space, пока нет конфликта) | Турникет — обычно проходишь сразу, и только при конфликте зовут охранника (ядро) |

---

---

## Проверь себя

<details>
<summary>1. Зачем нужны два режима процессора (kernel mode и user mode)?</summary>

**Ответ:** Защита системы от ошибок и вредоносных программ. Пользовательский код не может напрямую работать с железом — только через syscalls. Если программа попытается выполнить привилегированную инструкцию в user mode, CPU сгенерирует исключение и передаст управление ядру. Это предотвращает ситуации, когда баг в одной программе ломает всю систему.

</details>

<details>
<summary>2. Почему context switch за 3µs может стать проблемой?</summary>

**Ответ:** Потому что overhead накапливается. Если у вас 1000 потоков, активно конкурирующих за CPU, система будет тратить значительное время только на переключение между ними. Плюс indirect costs: cache misses после переключения (данные предыдущего потока выталкиваются из кэша). Это одна из причин популярности async/await и event loops — они позволяют обрабатывать тысячи соединений меньшим числом потоков.

</details>

<details>
<summary>3. Что общего между Docker контейнером и JVM heap?</summary>

**Ответ:** Оба используют абстракции ОС. JVM heap — это виртуальная память, которую ОС отображает на физические страницы (pages). Docker контейнер использует namespaces и cgroups ОС для изоляции. Понимание уровня ОС объясняет ограничения: почему JVM может получить OutOfMemoryError при наличии свободной RAM (лимиты cgroups в контейнере), почему контейнеры легче VM (shared kernel).

</details>

---

## Связи с другими разделами базы знаний

**JVM/Java:**
- [[jvm-concurrency-overview]] — JVM threads = OS threads (1:1 mapping в HotSpot), понимание ОС объясняет поведение многопоточности
- [[jvm-memory-model]] — JMM абстрагирует детали виртуальной памяти ОС, но GC работает поверх тех же page faults
- [[java-modern-features]] — Virtual Threads (Loom) — попытка уйти от overhead OS threads, но под капотом всё равно ОС

**Kotlin:**
- [[kotlin-coroutines]] — корутины НЕ равны OS threads: много корутин на одном потоке, scheduler в userspace
- [[kotlin-flow]] — реактивные потоки построены на non-blocking I/O, который использует механизмы ОС (epoll, kqueue)

**Android:**
- [[android-process-memory]] — Android агрессивно убивает процессы при нехватке памяти (LMK), понимание ОС объясняет lifecycle
- [[android-threading]] — Main thread + Workers = scheduler ОС решает кому дать CPU

**DevOps:**
- [[os-virtualization]] → [[docker-kubernetes]] — контейнеры используют namespaces/cgroups, без понимания ОС трудно дебажить проблемы изоляции

---

*Проверено: 2026-01-03 | На основе OSTEP, Tanenbaum, MIT 6.S081, Linux Kernel benchmarks*

---

*Обновлено: 2026-01-09 — добавлены педагогические секции (интуиция ресторан/корабль/виртуальная память, 6 типичных ошибок process vs thread/context switch/page fault, 5 ментальных моделей layered architecture/time-sharing/rings)*
