---
title: "Файловые системы: как данные хранятся на диске"
created: 2025-12-02
modified: 2025-12-02
type: deep-dive
status: published
area: operating-systems
confidence: high
tags:
  - topic/os
  - filesystem
  - storage
  - io
  - type/deep-dive
  - level/intermediate
related:
  - "[[os-overview]]"
  - "[[os-io-devices]]"
  - "[[database-design-optimization]]"
---

# Файловые системы: как данные хранятся на диске

Файловая система — абстракция, превращающая блоки на диске в иерархию файлов и директорий. Она отвечает за организацию данных (где физически лежит файл), метаданные (имя, права, время модификации), и надёжность (что делать при сбое питания). Понимание файловых систем объясняет почему `fsync()` важен для баз данных, почему удаление большого файла может быть мгновенным, и как работает journaling.

---

## TL;DR

> **Что:** Файловая система = "библиотечный каталог" для диска. Превращает хаос блоков в файлы и папки.
>
> **Inode:** Каждый файл имеет inode — "паспорт" с метаданными (размер, права, указатели на блоки). Имя файла НЕ в inode, а в директории.
>
> **Journaling:** Перед изменением записываем намерение в journal. Если crash — можно восстановиться за секунды (vs часы fsck).
>
> **Page Cache:** Диск медленный → ОС кэширует данные в RAM. write() → cache → return, fsync() → диск.
>
> **fsync() важен:** Без него данные могут потеряться при crash. Базы данных обязательно используют fsync.
>
> **VFS:** Единый API для всех ФС (ext4, XFS, NFS) — приложения не зависят от конкретной ФС.

---

## Часть 1: Интуиция без кода

### 📚 Аналогия 1: Библиотека (файловая система)

**Файловая система — это библиотечный каталог**, превращающий хаос полок с книгами в организованную систему.

```
Физический диск (полки с книгами):
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
│ A │ B │ C │ D │ E │ F │ G │ H │ I │ J │ ← Блоки данных (4KB каждый)
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘

Файловая система (библиотечный каталог):
┌─────────────────────────────────────────────────────────────┐
│  Superblock: "В нашей библиотеке 1000 книг, 500 полок"      │
├─────────────────────────────────────────────────────────────┤
│  Inode #1: размер=3 блока, блоки=[A, C, F]                  │ → файл 1
│  Inode #2: размер=2 блока, блоки=[B, E]                     │ → файл 2
│  Inode #3: размер=4 блока, блоки=[D, G, H, I]               │ → файл 3
├─────────────────────────────────────────────────────────────┤
│  Директория /home:                                          │
│    "report.txt"  → inode #1                                 │
│    "photo.jpg"   → inode #2                                 │
│    "video.mp4"   → inode #3                                 │
└─────────────────────────────────────────────────────────────┘
```

**Ключевой инсайт:** Имя файла НЕ в inode! Директория — это просто таблица "имя → inode".

### 🪪 Аналогия 2: Паспорт файла (Inode)

**Inode — это паспорт файла**, содержащий всё о файле, кроме имени:

```
┌─────────────────────────────────────────────────────────────┐
│                    ПАСПОРТ (INODE #42)                       │
├─────────────────────────────────────────────────────────────┤
│  Тип: обычный файл                                          │
│  Размер: 12,345 байт                                        │
│  Владелец: user (uid=1000)                                  │
│  Группа: staff (gid=50)                                     │
│  Права: rwxr-xr-x (755)                                     │
│                                                             │
│  Создан: 2024-01-15 10:30:00                                │
│  Изменён: 2024-06-20 14:15:30                               │
│  Последний доступ: 2024-06-21 09:00:00                      │
│                                                             │
│  Блоки данных: [100, 101, 102, 505, 506]                    │
│                                                             │
│  Количество hardlinks: 2                                    │
│  (два имени указывают на этот inode)                        │
└─────────────────────────────────────────────────────────────┘

НЕТ ИМЕНИ В INODE! Имя хранится в директории.
```

**Почему это важно:**
1. `mv file1 file2` — мгновенно (меняется только запись в директории)
2. Можно иметь несколько имён для одного файла (hardlinks)
3. `ls -l` показывает данные из inode, а имя — из директории

### 📝 Аналогия 3: Черновик заказа (Journal)

**Journaling — это черновик**, куда записывают намерение перед действием:

```
Без journaling (crash = катастрофа):

Операция: создать файл
1. Обновить bitmap ✓
2. Записать inode  ← CRASH здесь!
3. Обновить директорию

Результат: bitmap говорит "блок занят", но файла нет!
fsck должен проверить ВСЕ блоки = часы на большом диске

─────────────────────────────────────────────────────────────

С journaling (crash = восстановление за секунды):

1. Записать в journal: "Собираюсь: bitmap+inode+dir"
2. Обновить bitmap ✓
3. Записать inode ← CRASH здесь!
4. Обновить директорию
5. Удалить запись из journal

При восстановлении:
- Читаем journal: "Операция не завершена"
- Откатываем или повторяем
- Готово за секунды!
```

**Режимы journaling:**
| Режим | Что журналируется | Скорость | Надёжность |
|-------|------------------|----------|------------|
| **metadata** (default ext4) | Только метаданные | Быстро | Файлы OK, данные могут быть мусором |
| **data=ordered** | Данные записываются ДО метаданных | Средне | Файлы целые, без мусора |
| **data=journal** | Всё: данные + метаданные | Медленно | Максимальная |

### 📋 Аналогия 4: Книга на столе vs в хранилище (Page Cache)

**Page Cache — это стол читателя**: книги из хранилища (диска) лежат на столе (RAM) для быстрого доступа.

```
RAM в 100,000 раз быстрее диска!

Без page cache:
read() → диск → 10ms → данные
write() → диск → 10ms → OK

С page cache:
read() → RAM (cache hit) → 100ns → данные
write() → RAM → 100ns → OK (диск потом)

┌─────────────────────────────────────────────────────────────┐
│                         RAM                                  │
│  ┌─────────────────────────────────────────────────────┐    │
│  │              PAGE CACHE (~50% свободной RAM)         │    │
│  │                                                      │    │
│  │  file.txt:  [page 0] [page 1] [page 2]              │    │
│  │  data.db:   [page 0] [page 1] ... [page 1000]       │    │
│  │  log.txt:   [page 0] ← dirty, ещё не на диске       │    │
│  │                                                      │    │
│  └─────────────────────────────────────────────────────┘    │
│                          ↑↓ sync                             │
├─────────────────────────────────────────────────────────────┤
│                         ДИСК                                 │
│                  (медленное хранилище)                       │
└─────────────────────────────────────────────────────────────┘

write() возвращается СРАЗУ (данные в cache)
fsync() гарантирует запись на диск
```

**Опасность:** Без fsync() данные могут потеряться при crash!

### 🔗 Аналогия 5: Два имени одной книги (Hardlink vs Symlink)

```
HARDLINK: два названия в каталоге → один inode

Директория /home/alice:
  "my_report.txt" → inode #42

Директория /home/bob:
  "shared_doc.txt" → inode #42  ← ТОТ ЖЕ inode!

- Удаление одного имени не удаляет файл
- Файл удаляется когда link count = 0
- Нельзя hardlink на другой раздел
- Нельзя hardlink на директорию

─────────────────────────────────────────────────────────────

SYMLINK: записка "файл там-то"

/home/alice/shortcut → "/home/bob/original.txt"

Symlink — это отдельный файл (свой inode),
содержащий ПУТЬ к другому файлу.

- Можно на другой раздел
- Можно на директорию
- Может быть "битым" (если original удалён)

┌──────────────────────────────────────────────────────────┐
│ $ ls -la /home/alice/                                     │
│                                                          │
│ -rw-r--r-- 2 alice staff  1234 my_report.txt            │
│            ^ link count = 2 (hardlink)                   │
│                                                          │
│ lrwxrwxrwx 1 alice staff    20 shortcut -> /home/bob/..  │
│ ^                               ^ содержимое = путь      │
│ l = symlink                                              │
└──────────────────────────────────────────────────────────┘
```

### 🔢 Численная интуиция

| Операция | HDD | SSD | Page Cache |
|----------|-----|-----|------------|
| Random read | 10 ms | 0.1 ms | 0.0001 ms |
| Sequential read | 100 MB/s | 500 MB/s | 10,000 MB/s |
| fsync() | 5-10 ms | 0.1-1 ms | N/A |

**Пример: база данных с fsync()**
```
Без fsync() (опасно!):
- INSERT → cache → 0.001 ms → "OK"
- CRASH → данные потеряны!

С fsync() на каждую транзакцию (надёжно, но медленно):
- INSERT → cache → fsync() → 10 ms → "OK"
- Max throughput на HDD: ~100 transactions/sec

С group commit (компромисс):
- Собираем 100 INSERTs → один fsync() → 10 ms
- Throughput: ~10,000 transactions/sec
```

**Почему ext4 default = metadata journaling:**
```
data=journal:  Всё через journal = 2x записи = медленно
data=ordered:  Данные до метаданных = безопасно, 1x записи
data=writeback: Без гарантий порядка = быстро, но данные могут быть мусором
```

---

## Часть 2: Почему это сложно

### ❌ Ошибка 1: "write() = данные на диске"

**СИМПТОМ:** Данные потеряны после crash, хотя write() вернул успех.

**ПОЧЕМУ ВОЗНИКАЕТ:** write() возвращается после записи в page cache, не на диск.

**ДЕМОНСТРАЦИЯ:**
```c
// ❌ Опасно: данные могут потеряться
int fd = open("important.txt", O_WRONLY | O_CREAT, 0644);
write(fd, data, size);  // → page cache (RAM)
close(fd);              // Данные всё ещё в RAM!
// CRASH → данные потеряны

// ✅ Безопасно: данные на диске
int fd = open("important.txt", O_WRONLY | O_CREAT, 0644);
write(fd, data, size);
fsync(fd);              // → диск (гарантированно)
close(fd);
```

**ПРАВИЛО:** Для критичных данных (БД, транзакции) ВСЕГДА используй fsync().

---

### ❌ Ошибка 2: "Удаление файла мгновенно освобождает место"

**СИМПТОМ:** `rm big_file.txt`, но `df` показывает то же свободное место.

**ПОЧЕМУ ВОЗНИКАЕТ:** Файл удаляется только когда:
1. Все hardlinks удалены (link count = 0)
2. Все процессы закрыли файл (open count = 0)

**ПРИМЕР:**
```bash
# Процесс A открывает файл
tail -f /var/log/huge.log &  # PID 1234, держит файл открытым

# Процесс B удаляет файл
rm /var/log/huge.log  # Удаляет имя, но НЕ данные!

# Проверяем
ls /var/log/huge.log  # "No such file"
df -h                 # Место НЕ освободилось!

# Находим "удалённый" файл
lsof | grep deleted
# tail 1234 ... /var/log/huge.log (deleted)

# Решение: убить процесс
kill 1234
df -h                 # Теперь место освободилось!
```

---

### ❌ Ошибка 3: "mv мгновенен, cp — нет"

**СИМПТОМ:** `mv` между разделами неожиданно долгий.

**ПОЧЕМУ ВОЗНИКАЕТ:** `mv` в пределах раздела = изменение записи в директории (мгновенно). `mv` между разделами = copy + delete.

```bash
# Мгновенно (тот же раздел)
mv /home/file.txt /home/backup/file.txt
# Просто меняется запись в директории

# Долго (разные разделы)
mv /home/file.txt /mnt/usb/file.txt
# 1. Копирование всех данных
# 2. Удаление оригинала
# Эквивалентно: cp + rm
```

**РЕШЕНИЕ:** Для атомарного перемещения — используй тот же раздел.

---

### ❌ Ошибка 4: "Больше inodes = лучше"

**СИМПТОМ:** "No space left on device", хотя `df` показывает свободное место.

**ПОЧЕМУ ВОЗНИКАЕТ:** Закончились inodes, не место.

```bash
$ df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1       100G   50G   50G  50% /

$ df -i
Filesystem      Inodes  IUsed   IFree IUse% Mounted on
/dev/sda1       6.5M    6.5M       0  100% /  ← Все inodes заняты!

# Много мелких файлов исчерпали inodes
# Например: миллион 1-байтовых файлов
```

**РЕШЕНИЕ:**
- Для много мелких файлов: выбирай ФС с большим числом inodes
- XFS, Btrfs создают inodes динамически
- Или используй базу данных вместо миллиона файлов

---

### ❌ Ошибка 5: "fsync(file) достаточно для надёжности"

**СИМПТОМ:** После crash файл пустой или отсутствует, хотя fsync() вызывали.

**ПОЧЕМУ ВОЗНИКАЕТ:** fsync() гарантирует данные файла, но НЕ запись в директорию!

```c
// ❌ Может потерять файл при crash
int fd = open("data/file.txt", O_CREAT | O_WRONLY, 0644);
write(fd, data, size);
fsync(fd);   // Данные файла на диске
close(fd);
// Но запись "file.txt" в директории "data/" может быть в cache!

// ✅ Полностью надёжно
int fd = open("data/file.txt", O_CREAT | O_WRONLY, 0644);
write(fd, data, size);
fsync(fd);   // Данные файла

int dir_fd = open("data/", O_RDONLY);
fsync(dir_fd);  // Запись в директорию тоже на диске!
close(dir_fd);
close(fd);
```

---

### ❌ Ошибка 6: Использование O_DIRECT без понимания

**СИМПТОМ:** "O_DIRECT быстрее" — но производительность хуже.

**ПОЧЕМУ ВОЗНИКАЕТ:** O_DIRECT обходит page cache, что убирает двойное копирование, НО:
- Требует выровненные буферы (alignment)
- Нет prefetch и read-ahead
- Каждый read() = реальный I/O

```c
// O_DIRECT требует выравнивание!
void* buf;
posix_memalign(&buf, 4096, size);  // Выравнивание на 4KB

int fd = open("file", O_RDONLY | O_DIRECT);
read(fd, buf, size);  // Прямо с диска, без cache
```

**КОГДА ИСПОЛЬЗОВАТЬ O_DIRECT:**
- База данных с собственным кэшем (PostgreSQL, MySQL)
- Избежать "двойного кэширования"

**КОГДА НЕ ИСПОЛЬЗОВАТЬ:**
- Обычные приложения (page cache эффективнее)
- Случайный доступ к мелким файлам

---

## Часть 3: Ментальные модели

### 🧠 Модель 1: "Путь от имени файла к данным"

```
open("/home/user/file.txt", O_RDONLY)

1. Найти inode корня "/"
   └── Superblock указывает: root inode = 2

2. Найти "home" в директории "/"
   └── Читаем блоки inode 2
   └── Находим запись: "home" → inode 100

3. Найти "user" в директории "home"
   └── Читаем блоки inode 100
   └── Находим: "user" → inode 150

4. Найти "file.txt" в директории "user"
   └── Читаем блоки inode 150
   └── Находим: "file.txt" → inode 200

5. Вернуть file descriptor, связанный с inode 200

read() использует указатели на блоки из inode 200
```

### 🧠 Модель 2: "Жизненный цикл записи"

```
write(fd, data, 1000)

┌─────────────────────────────────────────────────────────────┐
│ 1. Копируем данные в page cache                             │
│    user buffer → kernel page cache                          │
│    Страница помечается как "dirty"                          │
└───────────────────────────┬─────────────────────────────────┘
                            │ write() returns (async!)
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. Dirty pages в page cache                                 │
│    Ожидают записи на диск                                   │
│    Kernel периодически (30 сек) сбрасывает dirty pages     │
└───────────────────────────┬─────────────────────────────────┘
                            │ fsync() или dirty page writeback
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. Запись в journal (если journaling)                       │
│    "Собираюсь записать блок X с данными Y"                  │
└───────────────────────────┬─────────────────────────────────┘
                            │ journal commit
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. Запись данных на диск                                    │
│    Page → disk block                                        │
│    Page помечается как "clean"                              │
└───────────────────────────┬─────────────────────────────────┘
                            │ checkpoint
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. Очистка journal                                          │
│    Удаляем запись о завершённой операции                    │
└─────────────────────────────────────────────────────────────┘
```

### 🧠 Модель 3: "Сравнение файловых систем"

```
┌────────────────────────────────────────────────────────────────────────┐
│                      СРАВНЕНИЕ ФАЙЛОВЫХ СИСТЕМ                          │
├──────────────┬──────────────┬──────────────┬──────────────┬─────────────┤
│ Критерий     │ ext4         │ XFS          │ Btrfs        │ ZFS         │
├──────────────┼──────────────┼──────────────┼──────────────┼─────────────┤
│ Max file     │ 16 TB        │ 8 EB         │ 16 EB        │ 16 EB       │
│ Max FS       │ 1 EB         │ 8 EB         │ 16 EB        │ 256 ZB      │
├──────────────┼──────────────┼──────────────┼──────────────┼─────────────┤
│ Journaling   │ Да           │ Да           │ CoW          │ CoW         │
│ Snapshots    │ Нет          │ Нет          │ Да           │ Да          │
│ Checksums    │ Метаданные   │ Нет          │ Все данные   │ Все данные  │
│ RAID встроен │ Нет          │ Нет          │ Да           │ Да          │
├──────────────┼──────────────┼──────────────┼──────────────┼─────────────┤
│ Применение   │ General      │ Большие      │ Advanced     │ Enterprise  │
│              │ purpose      │ файлы, БД    │ desktop      │ storage     │
└──────────────┴──────────────┴──────────────┴──────────────┴─────────────┘
```

### 🧠 Модель 4: "VFS как адаптер"

```
┌─────────────────────────────────────────────────────────────┐
│                    ПРИЛОЖЕНИЕ                                │
│         open(), read(), write(), close()                     │
└───────────────────────────┬─────────────────────────────────┘
                            │ Единый API
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                         VFS                                  │
│              (Virtual File System)                           │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ struct inode, struct dentry, struct file            │   │
│  │ Общие структуры для всех файловых систем            │   │
│  └─────────────────────────────────────────────────────┘   │
└───────────────────────────┬─────────────────────────────────┘
         ┌──────────────────┼──────────────────┐
         │                  │                  │
         ↓                  ↓                  ↓
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   ext4_ops  │    │   xfs_ops   │    │   nfs_ops   │
│ ext4_read() │    │ xfs_read()  │    │ nfs_read()  │
│ ext4_write()│    │ xfs_write() │    │ nfs_write() │
└──────┬──────┘    └──────┬──────┘    └──────┬──────┘
       │                  │                  │
       ↓                  ↓                  ↓
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ Локальный   │    │ Локальный   │    │ Сетевой     │
│ диск (ext4) │    │ диск (XFS)  │    │ сервер      │
└─────────────┘    └─────────────┘    └─────────────┘
```

### 🧠 Модель 5: "Дерево решений: fsync или нет?"

```
Нужна ли durability (данные должны пережить crash)?
│
├── НЕТ (временные файлы, кэш)
│   └── Не вызывай fsync() → максимальная скорость
│
└── ДА (транзакции, пользовательские данные)
    │
    ├── Можно потерять последние N секунд?
    │   ├── ДА → sync каждые N секунд (fsyncd, pdflush)
    │   └── НЕТ → fsync() после каждой записи
    │
    └── Нужна атомарность (всё или ничего)?
        │
        ├── ДА → write temp file + fsync + rename
        │       (rename атомарен в POSIX)
        │
        └── НЕТ → просто fsync() достаточно

Паттерн "безопасная запись":
1. write("file.tmp", data)
2. fsync("file.tmp")
3. fsync(parent_dir)         # Важно!
4. rename("file.tmp", "file") # Атомарно!
5. fsync(parent_dir)         # Гарантирует rename
```

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| [[os-overview]] | Базовые концепции ОС, syscalls (open, read, write) | Предыдущий материал раздела |
| [[os-io-devices]] | Как ОС взаимодействует с дисками (блочные устройства, DMA) | Предыдущий материал (рекомендуется) |
| Блочные устройства | Понимание что диск работает блоками по 512B/4KB | [Linux Journey: Block Devices](https://linuxjourney.com/) |
| Основы командной строки | Практика с mount, df, stat | [Linux Journey](https://linuxjourney.com/) |

**Время на подготовку:** ~2-3 дня если знаете предыдущие темы

---

## Терминология для новичков

| Термин | Что это | Аналогия из жизни |
|--------|---------|-------------------|
| **Блок (Block)** | Минимальная единица чтения/записи (обычно 4KB) | Страница книги: ОС не читает буквы, только целые страницы |
| **Inode** | "Паспорт" файла: размер, права, указатели на блоки. Имя НЕ здесь! | Карточка в библиотечном каталоге: вся информация о книге, кроме названия |
| **Superblock** | Метаданные всей файловой системы (размер, кол-во inodes) | Обложка библиотечного каталога: сколько книг, сколько полок |
| **Journal** | Лог "что собираемся сделать" для recovery | Черновик заказа: если упадём — знаем что делали |
| **Extent** | Непрерывная последовательность блоков | Полка с серией книг подряд (vs разбросанные по библиотеке) |
| **Фрагментация** | Блоки файла разбросаны по диску | Главы книги на разных этажах — долго собирать |
| **VFS** | Единый API для разных ФС (ext4, XFS, NFS) | Универсальный пульт для всех телевизоров |
| **Page Cache** | Кэш файловых данных в RAM (быстрее диска в 100,000x) | Книги на столе читателя vs в хранилище |
| **fsync()** | Принудительная запись кэша на диск | "Сохранить" в документе — данные точно на диске |
| **Hardlink** | Второе имя для того же inode | Два названия одной книги в каталоге |
| **Symlink** | Ссылка на путь (может быть битой) | Записка "книга в комнате 5" (комната может быть пустой) |
| **Copy-on-Write** | Копирование только при изменении | Фотокопия делается только когда кто-то хочет исправить оригинал |

---

## Структура диска

### Физический уровень

```
HDD:                              SSD:
┌─────────────────────────┐      ┌─────────────────────────┐
│ Секторы по 512 байт     │      │ Pages по 4-16 KB        │
│ на вращающихся пластинах│      │ в NAND flash чипах      │
│                         │      │                         │
│ Seek time: 5-10ms       │      │ Latency: 0.05-0.1ms     │
│ Sequential: 100-200 MB/s│      │ Sequential: 500+ MB/s   │
└─────────────────────────┘      └─────────────────────────┘
```

### Логический уровень

```
┌─────────────────────────────────────────────────────────────────┐
│                          ДИСК                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────┬──────────────┬────────────────────────────────┐  │
│  │ Boot     │ Superblock   │ Блоки данных и метаданных      │  │
│  │ Sector   │              │                                │  │
│  │          │ - размер FS  │ ┌────────┬────────┬──────────┐ │  │
│  │          │ - кол-во     │ │ Inodes │ Bitmaps│ Data     │ │  │
│  │          │   inodes     │ │        │        │ Blocks   │ │  │
│  │          │ - свободное  │ │        │        │          │ │  │
│  │          │   место      │ └────────┴────────┴──────────┘ │  │
│  └──────────┴──────────────┴────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Inode: сердце файловой системы

### Что такое inode

Inode (index node) — структура данных, хранящая всю информацию о файле **кроме имени**:

```c
// Упрощённая структура inode
struct inode {
    uint32_t mode;           // Тип файла + права (rwxr-xr-x)
    uint32_t uid;            // Владелец
    uint32_t gid;            // Группа
    uint64_t size;           // Размер в байтах
    time_t atime;            // Access time
    time_t mtime;            // Modification time
    time_t ctime;            // Change time (метаданные)
    uint32_t link_count;     // Количество hard links
    uint32_t blocks[15];     // Указатели на блоки данных
    // [0-11]: прямые указатели
    // [12]: indirect (указатель на блок указателей)
    // [13]: double indirect
    // [14]: triple indirect
};
```

### Почему имя не в inode?

Один файл может иметь несколько имён (hard links). Имена хранятся в директориях — специальных файлах, которые содержат mapping "имя → номер inode".

```
Директория /home/user:
┌──────────────────────────────────────┐
│ Name           │ Inode Number        │
├──────────────────────────────────────┤
│ .              │ 1001                │  (сама директория)
│ ..             │ 1000                │  (родительская)
│ document.txt   │ 2345                │
│ photo.jpg      │ 2346                │
│ link_to_doc    │ 2345                │  (hard link на тот же inode!)
└──────────────────────────────────────┘
```

### Указатели на блоки данных

Для маленьких файлов достаточно 12 прямых указателей (12 × 4KB = 48KB).

Для больших файлов — indirect pointers:

```
Размер блока: 4KB
Размер указателя: 4 байта
Указателей в блоке: 4KB / 4 = 1024

Прямые указатели (12):
  12 × 4KB = 48 KB

Single indirect:
  1024 × 4KB = 4 MB

Double indirect:
  1024 × 1024 × 4KB = 4 GB

Triple indirect:
  1024 × 1024 × 1024 × 4KB = 4 TB

┌────────────────────────────────────────────────────────────────┐
│                        INODE                                    │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  Direct [0-11] ──────────▶ Data Block                          │
│                                                                │
│  Indirect [12] ──────────▶ ┌──────────┐                        │
│                            │ ptr → DB │                        │
│                            │ ptr → DB │                        │
│                            │ ...      │                        │
│                            └──────────┘                        │
│                                                                │
│  Double Indirect [13] ───▶ ┌──────────┐    ┌──────────┐       │
│                            │ ptr ──────────▶│ ptr → DB │       │
│                            │ ptr ─────┐    │ ...      │       │
│                            └──────────┘    └──────────┘       │
│                                    │       ┌──────────┐       │
│                                    └──────▶│ ptr → DB │       │
│                                            │ ...      │       │
│                                            └──────────┘       │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## Операции с файлами

### Чтение файла

```
read("/home/user/document.txt", buffer, 100):

1. Найти inode корневой директории (/)
   - Номер inode "/" известен (обычно 2)

2. Прочитать директорию /, найти "home"
   - Получить номер inode "home"

3. Прочитать директорию /home, найти "user"
   - Получить номер inode "user"

4. Прочитать директорию /home/user, найти "document.txt"
   - Получить номер inode = 2345

5. Прочитать inode 2345
   - Получить указатели на блоки данных

6. Прочитать нужные блоки данных
   - Вернуть содержимое

Каждый шаг = чтение с диска (без кэша)
Path traversal дорогой!
```

### Запись файла

```
write(fd, data, 100):

1. Найти inode файла (по file descriptor)

2. Найти блок для записи
   - Если файл не имеет места → выделить новый блок
   - Обновить bitmap свободных блоков

3. Записать данные в блок

4. Обновить inode
   - size
   - mtime
   - указатели (если новый блок)

5. Данные в page cache (не на диске!)
   - write() возвращается
   - Позже: writeback на диск
```

### Удаление файла

```
unlink("/home/user/document.txt"):

1. Найти inode директории /home/user

2. Удалить запись "document.txt" из директории

3. Уменьшить link_count в inode файла

4. Если link_count == 0 и файл не открыт:
   - Освободить блоки данных (пометить в bitmap как свободные)
   - Освободить inode

Почему "удаление" мгновенно:
- Данные НЕ стираются
- Только метаданные обновляются
- Блоки помечаются как свободные
```

---

## Journaling: защита от сбоев

### Проблема без journaling

Запись файла — несколько операций:
1. Записать данные в блок
2. Обновить inode
3. Обновить bitmap

Если питание отключится между шагами — файловая система повреждена.

```
Сценарий повреждения:

1. Записали данные в новый блок ✓
2. Обновили inode, добавили указатель на блок ✓
3. [СБОЙ ПИТАНИЯ]
4. Bitmap не обновлён — блок считается свободным!

После перезагрузки:
- Файл указывает на блок X
- Bitmap говорит блок X свободен
- Создаётся новый файл → получает блок X → данные перезаписаны!
```

### Решение: Journal

Перед изменением файловой системы записываем намерение в journal:

```
┌─────────────────────────────────────────────────────────────────┐
│                    JOURNALING WRITE                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Записать в journal:                                         │
│     "Собираюсь: обновить inode X, bitmap Y, блок Z"             │
│                                                                 │
│  2. Выполнить операции на файловой системе                      │
│                                                                 │
│  3. Пометить транзакцию в journal как завершённую               │
│                                                                 │
│  При recovery после сбоя:                                       │
│  - Незавершённые транзакции → отменить (rollback)               │
│  - Завершённые транзакции → проверить, доделать (redo)          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Типы journaling

**Data journaling (полный):** Журналируются и метаданные, и данные. Надёжно, но медленно — данные пишутся дважды.

**Metadata journaling (ordered):** Журналируются только метаданные. Данные пишутся до метаданных. ext4 default.

**Writeback:** Журналируются только метаданные. Порядок записи данных не гарантирован. Быстро, но данные могут быть повреждены.

---

## Основные файловые системы

### ext4 (Linux default)

```
Характеристики:
- Максимальный размер файла: 16 TB
- Максимальный размер FS: 1 EB
- Extents вместо block mapping (меньше фрагментация)
- Delayed allocation (лучше производительность)
- Metadata journaling

Команды:
mkfs.ext4 /dev/sda1
tune2fs -l /dev/sda1    # Информация о FS
```

### XFS (enterprise, large files)

```
Характеристики:
- Оптимизирован для больших файлов
- Отличная параллельная запись
- Allocation groups (параллелизм)
- Online defragmentation

Используется: Red Hat Enterprise, high-performance storage
```

### Btrfs (modern, copy-on-write)

```
Характеристики:
- Copy-on-Write (COW)
- Snapshots (мгновенные снимки)
- Встроенная компрессия
- Checksums для данных (обнаружение повреждений)
- RAID на уровне FS

Используется: SUSE, Facebook (для некоторых workloads)
```

### ZFS (enterprise, data integrity)

```
Характеристики:
- Checksums везде (end-to-end integrity)
- Copy-on-Write
- Snapshots и clones
- Встроенный RAID-Z
- Дедупликация
- Требует много RAM

Используется: FreeBSD, enterprise storage, NAS
```

---

## Page Cache

### Зачем кэшировать

Диск медленный (даже SSD). Ядро кэширует прочитанные данные в RAM:

```
Без кэша:                  С кэшем:
read() → disk (10ms)       read() → RAM (100ns) = 100,000x быстрее!

┌─────────────────────────────────────────────────────────────────┐
│                         PAGE CACHE                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Application                                                    │
│      │                                                          │
│      ▼ read(fd, buf, 4096)                                      │
│  ┌───────────┐                                                  │
│  │ VFS Layer │                                                  │
│  └─────┬─────┘                                                  │
│        │                                                        │
│        ▼                                                        │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │                      PAGE CACHE                            │ │
│  │  ┌─────────────────────────────────────────────────────┐  │ │
│  │  │ file X, page 0 │ file X, page 1 │ file Y, page 0 │  │  │ │
│  │  └─────────────────────────────────────────────────────┘  │ │
│  │                                                            │ │
│  │  Cache Hit? ──Yes──▶ Return from RAM                       │ │
│  │      │                                                     │ │
│  │      No                                                    │ │
│  │      │                                                     │ │
│  │      ▼                                                     │ │
│  │  Read from disk, add to cache, return                      │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Write-back vs Write-through

**Write-back (Linux default):**
1. write() записывает в page cache
2. Страница помечается "dirty"
3. write() возвращается (быстро!)
4. Позже: background writeback на диск

**Write-through:**
1. write() записывает в cache И на диск
2. write() возвращается только после записи на диск
3. Медленно, но данные гарантированно на диске

### fsync() и fdatasync()

```c
// fsync — принудительная запись на диск
int fd = open("important.dat", O_WRONLY);
write(fd, data, size);

fsync(fd);  // Ждём, пока данные на диске
// Теперь данные гарантированно сохранены

// fdatasync — только данные, не метаданные
fdatasync(fd);  // Быстрее fsync, но mtime может не обновиться
```

**Почему это важно для баз данных:**
```
Без fsync:
1. Database записывает транзакцию
2. write() возвращается
3. Database говорит "committed"
4. [СБОЙ ПИТАНИЯ]
5. Данные в page cache потеряны!

С fsync:
1. Database записывает транзакцию
2. fsync() ждёт записи на диск
3. Database говорит "committed"
4. [СБОЙ ПИТАНИЯ]
5. Данные на диске, транзакция восстановлена
```

---

## VFS: Virtual File System

VFS — слой абстракции, позволяющий работать с разными файловыми системами через единый API:

```
┌─────────────────────────────────────────────────────────────────┐
│                    APPLICATION                                   │
│                    open(), read(), write()                       │
└─────────────────────────────────────────┬───────────────────────┘
                                          │
                                          ▼
┌─────────────────────────────────────────────────────────────────┐
│                          VFS LAYER                               │
│                                                                 │
│  struct inode, struct dentry, struct file                       │
│  Общий интерфейс для всех файловых систем                       │
└─────────────────────────────────────────┬───────────────────────┘
                                          │
          ┌───────────────────────────────┼───────────────────────┐
          │                               │                       │
          ▼                               ▼                       ▼
┌─────────────────┐           ┌─────────────────┐     ┌─────────────────┐
│      ext4       │           │      XFS        │     │      NFS        │
│                 │           │                 │     │   (network)     │
└─────────────────┘           └─────────────────┘     └─────────────────┘
```

Благодаря VFS:
- `ls` работает одинаково на ext4, XFS, NFS
- Приложения не зависят от конкретной файловой системы
- Можно монтировать разные FS в одно дерево

---

## Подводные камни файловых систем

### 1. fsync() не гарантирует durability

```c
write(fd, data, size);  // Данные в page cache
fsync(fd);              // Данные на диске... или нет?
```

**Проблема:** Некоторые диски врут о fsync (write-back cache без battery). Данные в кэше контроллера, не на пластинах.

**Решение:** Для критичных данных — диски с battery-backed cache или отключение write cache.

### 2. rename() атомарность — только в пределах одной ФС

```bash
mv /home/user/file /tmp/file  # Может быть НЕ атомарно!
# /home и /tmp могут быть на разных ФС
```

**Атомарный rename:** Только если source и destination на одной файловой системе.

### 3. Ext4 delayed allocation и потеря данных

```c
fd = open("file", O_CREAT);
write(fd, data, size);
// Crash here!
// Данные могут быть потеряны — delayed allocation
```

**Проблема:** ext4 откладывает выделение блоков. При crash данные в памяти теряются.

**Решение:** fsync() после критичных записей, или O_SYNC флаг.

### 4. Hardlinks и inode confusion

```bash
ln file1 file2          # Тот же inode
echo "new" > file1      # file2 тоже изменился!
rm file1                # file2 всё ещё существует
```

**Ловушка:** Hardlinks разделяют inode. Изменение одного — изменение всех.

### 5. Журнал защищает метаданные, не данные

**ext4 default (ordered):** Журналирует метаданные, данные пишет перед метаданными.
**ext4 data=journal:** Журналирует и данные — медленнее, но безопаснее.

При crash без data=journal: метаданные консистентны, но данные файла могут быть мусором.

---

## Практические команды

```bash
# Информация о файловой системе
df -h                     # Использование дискового пространства
df -i                     # Использование inodes
stat file.txt             # Информация о файле (включая inode)
ls -i                     # Показать номера inodes

# Операции с файловыми системами
mount                     # Показать смонтированные FS
mount /dev/sda1 /mnt      # Смонтировать
umount /mnt               # Отмонтировать

# Журнал и recovery
journalctl -k | grep ext4 # Сообщения ядра о ext4
fsck /dev/sda1            # Проверка файловой системы

# Page cache
free -h                   # buff/cache показывает размер page cache
sync                      # Записать dirty pages на диск
echo 3 > /proc/sys/vm/drop_caches  # Очистить cache (для тестов)

# Мониторинг I/O
iostat -x 1               # Статистика I/O
iotop                     # I/O по процессам
```

---

## Проверь себя

<details>
<summary>1. Что такое inode и какую информацию он хранит?</summary>

**Ответ:** Inode — структура данных, описывающая файл (но не имя!). Содержит: права доступа, владельца, размер, timestamps (atime, mtime, ctime), указатели на блоки данных, счётчик hardlinks. Имя файла хранится в directory entry, которая связывает имя с номером inode.

</details>

<details>
<summary>2. Почему журналирование ускоряет recovery после crash?</summary>

**Ответ:** Без журнала при crash нужен полный fsck — проверка всей файловой системы. На больших дисках это часы. С журналом — только replay незавершённых транзакций из журнала. Секунды вместо часов. Журнал хранит "что собирались сделать", если crash — повторяем или откатываем.

</details>

<details>
<summary>3. В чём разница между hardlink и symlink?</summary>

**Ответ:**
- **Hardlink:** Новое имя для того же inode. Нельзя на директории. Нельзя между ФС. rm удаляет только имя, inode живёт пока есть хоть один hardlink.
- **Symlink:** Отдельный файл со ссылкой (путь). Может на директории. Может между ФС. Может быть битым (target удалён).

</details>

<details>
<summary>4. Почему write() возвращается быстро, хотя диск медленный?</summary>

**Ответ:** Page cache. Данные пишутся в RAM (page cache), write() возвращается. Ядро позже (асинхронно) записывает на диск (writeback). Это делает write быстрым, но данные могут потеряться при crash до writeback. Для гарантии записи — fsync() или O_SYNC.

</details>

---

## Связи

**Фундамент:**
- [[os-overview]] — syscalls (open, read, write), VFS абстракция
- [[os-io-devices]] — как работают блочные устройства, interrupts, DMA

**Углубление:**
- [[os-memory-management]] — page cache использует виртуальную память, mmap() связывает файлы и память

**Применение:**
- Базы данных используют direct I/O (O_DIRECT) чтобы обойти page cache и управлять буферизацией самостоятельно
- [[os-virtualization]] — контейнеры могут использовать overlay filesystems (aufs, overlayfs)

---

## Рекомендуемые источники

### Книги и курсы
- [OSTEP: File Systems chapters](https://pages.cs.wisc.edu/~remzi/OSTEP/file-intro.pdf) — бесплатная книга, главы 36-43
- [MIT 6.S081: File System lab](https://pdos.csail.mit.edu/6.1810/2025/) — практическая работа с ФС в xv6

### Официальная документация
- [ext4 Documentation](https://www.kernel.org/doc/html/latest/admin-guide/ext4.html) — документация Linux kernel
- [XFS Documentation](https://xfs.wiki.kernel.org/) — официальная wiki XFS

### Статьи и туториалы
- [GeeksforGeeks: File Systems](https://www.geeksforgeeks.org/operating-systems/file-systems-in-operating-system/) — базовое объяснение
- [LWN: Ext4 design](https://lwn.net/Articles/283128/) — глубокий анализ ext4
- [Understanding fsync](https://blog.httrack.com/blog/2013/11/15/everything-you-always-wanted-to-know-about-fsync/) — почему fsync важен

---

*Обновлено: 2026-01-09 — добавлены педагогические секции (5 аналогий: библиотека, паспорт/inode, черновик/journal, page cache, hardlink vs symlink; 6 типичных ошибок; 5 ментальных моделей: путь к данным, жизненный цикл записи, сравнение ФС, VFS адаптер, дерево решений fsync)*
