---
title: "Виртуальная машина: что это и зачем"
created: 2025-12-18
modified: 2026-02-11
type: concept
status: published
confidence: high
tags:
  - topic/jvm
  - virtual-machine
  - fundamentals
  - type/concept
  - level/beginner
prerequisites:
  - "[[os-processes-threads]]"
  - "[[compilation-pipeline]]"
related:
  - "[[jvm-basics-history]]"
  - "[[os-virtualization-containers]]"
---

# Виртуальная машина: что это и зачем

> **TL;DR:** Виртуальная машина --- программа, которая создаёт абстрактный компьютер (или процессор) внутри реального. Системные VM (VMware, VirtualBox) эмулируют целый компьютер с ОС. Процессные VM (JVM, CLR, V8) выполняют байткод одного приложения. JVM --- стековая процессная VM, выбравшая компактность байткода и кроссплатформенность ценой дополнительного слоя абстракции.

---

## Пререквизиты

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| Процессы и потоки | Понимать, что такое процесс и как ОС изолирует программы | [[os-processes-threads]] |
| Компиляция и интерпретация | Разница между машинным кодом, байткодом и исходным кодом | [[compilation-pipeline]] |

---

## Зачем это знать

Каждый раз, когда вы запускаете `java -jar app.jar` или `node server.js`, вы запускаете виртуальную машину. Не понимая, *что* это такое и *почему* она устроена именно так, вы не сможете объяснить:

- Почему Java-приложение стартует медленно, но потом ускоряется (JIT-warmup).
- Почему Docker --- это *не* виртуальная машина, хотя его часто так называют.
- Почему один и тот же .jar работает на Windows, Linux и macOS без перекомпиляции.
- Почему GC-паузы существуют и когда они допустимы.
- Почему Kotlin, Scala и Clojure работают на одной платформе.

Понимание концепции виртуальной машины --- фундамент, на котором строится всё остальное знание о JVM.

---

## Терминология

| Термин | Значение | Аналогия из жизни |
|--------|----------|-------------------|
| **Виртуальная машина** | Программа, эмулирующая компьютер или процессор | Переводчик-синхронист на международной конференции: создаёт иллюзию, что все говорят на одном языке |
| **Host** | Реальная система, на которой работает VM | Здание, в котором проходит конференция |
| **Guest** | Система или программа внутри VM | Участник конференции, который говорит на своём языке |
| **Байткод** | Код для виртуального процессора, не для реального | Стенограмма доклада на эсперанто --- понятна любому переводчику |
| **JIT** | Just-In-Time --- компиляция байткода в машинный код на лету | Синхронный переводчик, который после 10 повторений одной фразы запоминает её и переводит мгновенно |
| **AOT** | Ahead-Of-Time --- компиляция до запуска | Письменный перевод книги: долго, но результат готов сразу |
| **Гипервизор** | Программа, управляющая системными VM | Администратор здания, который распределяет залы между мероприятиями |
| **Sandbox** | Изолированная среда выполнения с ограниченными правами | Детская площадка с забором: ребёнок играет свободно, но не выходит за пределы |

---

## Что такое виртуальная машина: фундамент

Процессор понимает только свой машинный код. ARM-процессор в телефоне не выполнит код для x86. Процессор Apple M-серии не запустит бинарник, собранный для Intel без слоя трансляции. Это фундаментальная проблема: программа привязана к конкретной архитектуре.

Виртуальная машина решает эту проблему, добавляя *слой абстракции*. Вместо прямого общения программы с железом между ними появляется посредник --- VM, --- который "переводит" инструкции с одного "языка" на другой.

> **Аналогия из жизни:** Представьте международную конференцию с участниками из 50 стран. Без переводчиков каждый докладчик должен знать языки всех слушателей --- невозможно. С переводчиками (VM) докладчик говорит на своём языке, а переводчик адаптирует для каждого слушателя. Результат: написал доклад (программу) один раз --- он понятен (выполняется) везде, где есть переводчик.

Важно понимать: виртуальная машина --- это не один конкретный продукт, а *концепция*. Так же как "автомобиль" --- это и грузовик, и гоночный болид, "виртуальная машина" --- это и VMware (эмулирует целый компьютер), и JVM (выполняет байткод приложения). Эти два вида решают совершенно разные задачи, хотя называются одним термином.

Этот принцип породил два принципиально разных типа виртуальных машин, которые решают разные задачи.

---

## Два типа виртуальных машин

```
┌──────────────────────────────────────────────────────────────────┐
│                    ВИРТУАЛЬНЫЕ МАШИНЫ                              │
├──────────────────────────────┬───────────────────────────────────┤
│       System VM               │        Process VM                 │
│  (эмулирует целый компьютер)  │  (эмулирует процессор             │
│                               │   для одного приложения)          │
├──────────────────────────────┼───────────────────────────────────┤
│  VMware, VirtualBox,          │  JVM, CLR (.NET),                 │
│  Hyper-V, KVM, QEMU          │  V8 (JavaScript), BEAM (Erlang)   │
├──────────────────────────────┼───────────────────────────────────┤
│  Запускает полную ОС внутри  │  Запускает одну программу          │
│  Изоляция на уровне ОС       │  Изоляция на уровне процесса      │
│  Тяжёлые (GB памяти)         │  Лёгкие (MB памяти)               │
├──────────────────────────────┼───────────────────────────────────┤
│  Зачем: серверная             │  Зачем: кроссплатформенность,     │
│  консолидация, тестирование,  │  управление памятью,              │
│  безопасная изоляция          │  оптимизация в runtime            │
└──────────────────────────────┴───────────────────────────────────┘
```

Диаграмма показывает два мира виртуализации. Слева --- полная эмуляция компьютера (запуск ОС внутри ОС). Справа --- эмуляция только процессора для одного приложения (JVM, CLR). Для разработчика на JVM ключевая колонка --- правая: Process VM.

### System VM: эмулируем целый компьютер

System VM (системная виртуальная машина) создаёт полную копию компьютера в программе: процессор, оперативную память, жёсткий диск, сетевую карту. Внутри этого виртуального компьютера можно установить любую операционную систему --- она "думает", что работает на реальном железе.

Управляет системными VM специальная программа --- **гипервизор** (hypervisor). Существует два типа гипервизоров. Type 1 (bare-metal) работает прямо на железе, без промежуточной ОС: VMware ESXi, Microsoft Hyper-V, KVM. Он эффективнее, потому что нет лишнего слоя. Type 2 (hosted) работает как обычная программа внутри ОС: VirtualBox, VMware Workstation, Parallels. Он проще в использовании, но добавляет overhead.

**Как работает:**
1. Гипервизор захватывает аппаратные ресурсы (CPU, RAM, диск)
2. Создаёт виртуальное железо для каждой VM
3. Гостевая ОС работает с виртуальным железом, не подозревая о реальном

**Примеры использования:**
- Один физический сервер = 10 виртуальных серверов (экономия на железе --- это основа облачных вычислений)
- Тестирование: запустить Windows на Mac без перезагрузки
- Безопасность: подозрительный файл запускаем в изолированной VM (sandbox)

**Ключевая проблема:** системные VM тяжёлые. Каждая VM содержит полную копию ОС, загружается минуту, требует гигабайты памяти. Именно поэтому появились контейнеры (Docker) --- они дают изоляцию без дублирования ОС. Но контейнеры --- *не* виртуальные машины (подробнее в секции "Распространённые заблуждения").

---

### Process VM: эмулируем процессор для одной программы

Process VM (процессная виртуальная машина) --- совсем другой зверь. Она не создаёт виртуальный компьютер. Вместо этого она создаёт виртуальный *процессор*, который выполняет байткод одного приложения. Не нужна отдельная ОС --- VM работает как обычный процесс внутри существующей ОС.

JVM --- именно такая машина. Когда вы запускаете `java MyApp`, операционная система создаёт процесс, внутри которого работает JVM. JVM загружает байткод (.class файлы), интерпретирует его или компилирует в машинный код (JIT), управляет памятью (GC) и обеспечивает безопасность (верификация байткода).

> **Аналогия из жизни:** System VM --- это аренда целого офиса в бизнес-центре: свои стены, своя мебель, свой ресепшн. Process VM --- это коворкинг: вам дают стол, Wi-Fi и кофе-машину, а стены и ресепшн общие. Коворкинг дешевле и быстрее (не нужно делать ремонт), но вы делите ресурсы с другими.

**Как работает Process VM (на примере JVM):**
1. Компилятор (javac) превращает Java-код в байткод (.class файлы)
2. JVM загружает байткод через Class Loader
3. Верификатор проверяет байткод на корректность (защита от злонамеренного кода)
4. Interpreter выполняет байткод построчно --- медленно, но сразу
5. JIT-компилятор наблюдает за исполнением и компилирует "горячие" методы в машинный код --- быстро, но с задержкой (warmup)

Мы поняли разницу между системными и процессными VM. Теперь разберём ещё одно фундаментальное различие --- как организовано выполнение инструкций внутри виртуальной машины.

---

## Стековая vs регистровая архитектура

Любая виртуальная машина должна где-то хранить промежуточные результаты вычислений. Существует два подхода: стековый и регистровый.

### Стековая машина

В стековой архитектуре все операнды помещаются на *стек* (структура данных "последний вошёл --- первый вышел"). Инструкция не указывает, *откуда* брать данные --- она всегда берёт с вершины стека.

Покажем, как стековая машина вычисляет выражение `3 + 5`:

```
iconst_3    // Положить 3 на стек        Стек: [3]
iconst_5    // Положить 5 на стек        Стек: [3, 5]
iadd        // Снять два числа,          Стек: [8]
            // сложить, положить результат
```

Это всего 3 инструкции, каждая занимает 1 байт. Инструкция `iadd` не содержит адресов операндов --- они *подразумеваются* (верхние два элемента стека). Именно поэтому стековый байткод компактен.

### Регистровая машина

В регистровой архитектуре операнды хранятся в именованных *регистрах*. Инструкция явно указывает, из каких регистров брать данные и куда записывать результат.

```
load r1, 3       // Загрузить 3 в регистр r1
load r2, 5       // Загрузить 5 в регистр r2
add  r3, r1, r2  // r3 = r1 + r2
```

Инструкция `add r3, r1, r2` содержит три адреса --- она длиннее стековой `iadd`, но за одну инструкцию делает больше полезной работы.

### Почему JVM --- стековая?

JVM выбрала стековую архитектуру в 1991--1995 годах, и причины были прагматичными.

**Компактность байткода** --- главная причина. В эпоху модемов на 14.4 Kbps и Java Applets, загружаемых из интернета, каждый лишний байт --- задержка. Стековый байткод на 25--30% компактнее регистрового.

**Простота портирования.** Написать интерпретатор стековой машины можно за несколько сотен строк кода. Регистровая машина требует аллокатора регистров --- значительно более сложного компонента. В 1995 году Sun хотела, чтобы JVM быстро появилась на всех платформах.

**Независимость от количества регистров.** Реальные процессоры имеют разное число регистров: x86 --- 16, ARM --- 31, SPARC --- 128 (windowed). Привязка байткода к конкретному числу регистров убила бы кроссплатформенность.

| Критерий | Стековая (JVM) | Регистровая (Dalvik/ART) |
|----------|:-------------:|:-----------------------:|
| Размер инструкции | 1--3 байта | 2--6 байт |
| Размер байткода | Компактный | На 25--30% больше |
| Скорость интерпретации | Медленнее (больше обращений к памяти) | Быстрее (меньше инструкций) |
| Сложность реализации | Простой интерпретатор | Нужен аллокатор регистров |
| JIT-компиляция | JIT нивелирует разницу | JIT нивелирует разницу |

> **Ключевой инсайт:** Различие между стековой и регистровой архитектурой критично только для *интерпретатора*. Когда JIT-компилятор транслирует байткод в нативный машинный код, он всё равно использует регистры реального процессора. Поэтому после warmup разница исчезает.

Интересный факт: Google для Android сначала использовал Dalvik VM с *регистровым* байткодом. Причина --- на мобильных устройствах важнее скорость интерпретации (меньше батарея тратится), чем размер байткода (приложение уже загружено). Позже Dalvik заменили на ART, который использует AOT-компиляцию и JIT-гибрид.

---

## Почему байткод, а не сразу машинный код?

Это один из самых частых вопросов: зачем нужен промежуточный шаг? Почему не компилировать Java сразу в x86 или ARM, как C++?

```
БЕЗ VM (C/C++):                          С VM (Java/Kotlin):

program.c → x86_linux.bin                 Program.java → bytecode.class
          → x86_windows.exe                              ↓
          → arm_linux.bin                 JVM (любая платформа) выполняет
          → arm_macos.bin
                                          4 платформы = 4 реализации JVM,
4 платформы = 4 бинарника               но ОДИН байткод
```

### Причина 1: кроссплатформенность (portability)

Компиляция C++ программы под 4 платформы требует 4 разных сборки, 4 тестовых окружения, 4 CI/CD pipeline. С байткодом --- одна сборка, один набор тестов, один артефакт (.jar). JVM на каждой платформе берёт на себя трансляцию в нативный код.

### Причина 2: оптимизация в runtime (profile-guided optimization)

AOT-компилятор (C++) оптимизирует код на основе *статического* анализа: он не знает, какие ветки if/else будут чаще выполняться, какие методы будут горячими. JIT-компилятор JVM наблюдает за *реальным* поведением программы и оптимизирует то, что действительно важно.

Пример: если метод `processOrder()` вызывается 10 000 раз в секунду, а `processRefund()` --- 2 раза в час, JIT агрессивно оптимизирует первый (инлайнинг, разворачивание циклов, escape analysis) и не тратит ресурсы на второй.

### Причина 3: безопасность (security sandbox)

Байткод можно *верифицировать* перед выполнением. JVM проверяет, что байткод не нарушает систему типов, не выходит за границы массивов (stack/buffer overflow), не обращается к чужой памяти. Это было критично для Java Applets (код из интернета) и остаётся важным для серверных приложений.

### Причина 4: многоязыковая платформа

Байткод --- это "контракт" между языком и VM. Любой язык, который может генерировать валидный байткод, получает бесплатно: GC, JIT, библиотеки, tooling. Kotlin, Scala, Clojure --- все компилируются в тот же байткод, что и Java. Разработчику на Kotlin доступны все Java-библиотеки --- миллиарды строк кода.

> **Аналогия из жизни:** Байткод --- как стандартный контейнер для морских перевозок. До контейнеров каждый груз упаковывался по-своему, и в каждом порту нужны были разные краны. Контейнер стандартизировал формат: неважно, что внутри (Java, Kotlin, Scala) --- контейнер (байткод) одинаковый, и любой порт (JVM на любой ОС) может его обработать одним и тем же краном (JIT-компилятором).

Мы разобрали, почему байткод --- ключевое архитектурное решение. Теперь посмотрим, откуда вообще пришла идея виртуальной машины.

---

## Исторический контекст: VM существовали задолго до JVM

### P-code (1970-е): первый байткод

Идея промежуточного кода значительно старше Java. В 1970-х Никлаус Вирт (Niklaus Wirth) разработал **P-code machine** для языка Pascal. P-code (pseudo-code) --- компактный набор инструкций для виртуального процессора. Компилятор Pascal генерировал P-code, а интерпретатор на каждой платформе выполнял его.

Цель была той же, что у JVM: портативность. Университеты могли написать компилятор Pascal один раз, а студенты запускали его на любом доступном компьютере (PDP-11, VAX, IBM PC). P-code machine --- прямой предок всех процессных VM. Интересно, что UCSD Pascal с P-code был настолько популярен в 1970--80-х, что Apple II поставлялся с UCSD Pascal как одной из опций загрузки. Идея "байткод + виртуальная машина" доказала жизнеспособность за 20 лет до Java.

### Smalltalk VM (1980-е): первый GC и объекты

Smalltalk, созданный в Xerox PARC в 1970--1980-х годах, был первым широко известным языком с виртуальной машиной *и* автоматическим сборщиком мусора. Smalltalk VM ввела концепции, которые стали стандартом: динамическая диспетчеризация методов (virtual dispatch), garbage collection, объект как фундаментальная единица вычислений.

Smalltalk был медленным по меркам того времени --- интерпретация объектного кода в 10--100 раз медленнее C. Но он доказал, что абстракция VM + GC жизнеспособна для широкого класса задач. Множество паттернов проектирования (MVC, Observer, Strategy) впервые появились именно в экосистеме Smalltalk, а затем перекочевали в Java.

### Self VM (1990-е): рождение JIT-компиляции

**Self** --- экспериментальный объектно-ориентированный язык, созданный в Sun Microsystems Дэвидом Ангаром (David Ungar) и Рэнди Смитом (Randall Smith). Self VM ввела **adaptive optimization** --- технику, при которой VM наблюдает за работающей программой и оптимизирует только горячие пути.

Ключевые инновации Self VM:
- **Inline caching** --- запоминание результата поиска метода для ускорения virtual dispatch
- **Polymorphic inline caching** --- обработка случаев, когда один callsite вызывает разные реализации метода
- **Deoptimization** --- возможность "откатить" агрессивную оптимизацию, если предположения оказались неверными

В 1999 году Sun купила компанию Longview Technologies, которая коммерциализировала технологии Self VM. Результат --- **HotSpot JVM**, которая использует те же принципы adaptive optimization. Self VM --- непосредственный предок HotSpot.

> **Линия наследования:**
> P-code (1970s) → Smalltalk VM (1980s) → Self VM (1990s) → **HotSpot JVM (1999)**

---

## Сравнение JVM с другими процессными VM

Существует несколько крупных процессных виртуальных машин, каждая из которых сделала свои архитектурные выборы. Сравнение помогает понять, что решения JVM --- не единственно возможные, а результат конкретных компромиссов.

### JVM vs CLR (.NET)

CLR (Common Language Runtime) --- виртуальная машина Microsoft, запускающая C#, F#, VB.NET. Архитектурно CLR и JVM похожи: обе используют байткод (CIL у CLR, bytecode у JVM), обе имеют JIT-компилятор и GC.

Ключевое различие --- подход к типам. JVM использует **type erasure** для generics: `List<String>` и `List<Integer>` в runtime неразличимы (оба --- просто `List`). CLR использует **reified generics**: информация о типах сохраняется в runtime, и `List<string>` действительно отличается от `List<int>`. Reified generics мощнее (можно создать `new T()`, проверить тип через reflection), но сложнее в реализации.

Другое важное отличие --- **value types**. CLR поддерживает структуры (struct), которые размещаются на стеке, а не в heap. Это уменьшает нагрузку на GC. JVM исторически не имела value types, но Project Valhalla (в разработке) добавит их как "primitive classes".

CLR изначально был привязан к Windows, но с .NET Core (2016) стал кроссплатформенным. JVM была кроссплатформенной с первого дня --- это фундаментальное преимущество её 30-летней экосистемы.

### JVM vs V8 (JavaScript)

V8 --- движок Google для выполнения JavaScript. В отличие от JVM, V8 работает с *динамически типизированным* языком, что кардинально меняет архитектуру.

JVM знает типы переменных на этапе компиляции байткода (javac проверяет типы). V8 не знает типы заранее --- переменная может быть числом, строкой или объектом. Поэтому V8 использует **hidden classes** (скрытые классы) --- runtime-структуры, которые описывают "форму" объектов. Когда V8 замечает, что объекты создаются с одинаковым набором полей, он создаёт hidden class и оптимизирует доступ к полям.

V8 не использует интерпретатор в классическом смысле. С 2017 года V8 содержит **Ignition** (байткод-интерпретатор) и **TurboFan** (оптимизирующий JIT-компилятор). Это похоже на tiered compilation HotSpot (C1 + C2), но адаптировано для динамических типов.

Главное преимущество V8 --- **скорость старта**. JavaScript-приложения часто короткоживущие (загрузка веб-страницы), и V8 оптимизирован для быстрого старта. JVM оптимизирована для **пиковой производительности** долгоживущих серверных приложений --- warmup окупается за часы и дни работы.

### JVM vs BEAM (Erlang/Elixir)

BEAM --- виртуальная машина для Erlang и Elixir. Её архитектура радикально отличается от JVM.

BEAM спроектирована вокруг идеи **лёгких процессов** (lightweight processes). Один экземпляр BEAM может запустить миллионы процессов, каждый с собственным стеком, heap и GC. Процессы не разделяют память --- общение только через сообщения (message passing). Если процесс падает, остальные продолжают работать (принцип "let it crash").

JVM исторически основывалась на **разделяемой памяти** (shared memory): потоки имеют общий heap, синхронизация через lock/synchronized. Это эффективнее для CPU-bound задач, но создаёт сложности с конкурентностью (deadlocks, race conditions). Virtual Threads в Java 21 частично приближают JVM к модели BEAM, но без изоляции памяти.

BEAM проигрывает JVM в *чистой вычислительной скорости* (Erlang медленнее Java на CPU-bound задачах в 3-10 раз), но выигрывает в *отказоустойчивости* и *масштабировании IO-bound систем*. WhatsApp обслуживал 2 миллиарда пользователей на BEAM. Netflix и LinkedIn обслуживают сопоставимую нагрузку на JVM --- но с другими архитектурными паттернами.

| Критерий | JVM | CLR | V8 | BEAM |
|----------|:---:|:---:|:--:|:----:|
| Типизация | Статическая | Статическая | Динамическая | Динамическая |
| Generics | Type erasure | Reified | Нет (шаблоны через прототипы) | Нет (динамические типы) |
| GC | Per-process, один heap | Per-process, один heap | Per-isolate | Per-process (лёгкий) |
| Concurrency | Shared memory + locks/virtual threads | Shared memory + async/await | Single-threaded + event loop | Message passing, миллионы процессов |
| Оптимальна для | Long-running серверы, enterprise | Windows-экосистема, gamedev (Unity) | Браузеры, short-lived серверы | Telecom, real-time messaging |

---

## Подводные камни: когда VM --- не лучший выбор

### Ограниченные ресурсы

Микроконтроллеры с 32 KB памяти не запустят JVM. Embedded-системы часто на C/C++ или Rust, где нет overhead виртуальной машины. Даже "облегчённые" JVM вроде J2ME требовали минимум несколько мегабайт.

### Максимальная производительность

Игровые движки, операционные системы, драйверы устройств --- всё это требует прямого доступа к железу. JVM добавляет слой абстракции, который для этих задач неприемлем. JIT хорош для серверов, но GC-паузы недопустимы в игре на 60 FPS.

### Предсказуемое время отклика (hard real-time)

GC-паузы, даже минимальные (ZGC: <10 мс), несовместимы с hard real-time системами (управление ракетой, ABS в автомобиле). Для таких систем используют C, Ada или специализированные real-time JVM (Jamaica VM, AICAS JamaicaVM).

### Cold start для serverless

JVM оптимизирована для long-running процессов: warmup окупается часами работы. Для AWS Lambda, где функция живёт секунды, warmup --- проблема. GraalVM Native Image решает это: AOT-компиляция в нативный бинарник, старт за миллисекунды, но без runtime-оптимизаций JIT.

---

## Распространённые заблуждения

| Заблуждение | Реальность | Причина ошибки |
|-------------|-----------|----------------|
| "VM = медленно" | JIT-компиляция делает JVM **конкурентной с native** для long-running приложений. Profile-guided optimization может превзойти AOT | Первые JVM (1996) были чисто интерпретируемыми --- в 10-50 раз медленнее C. Стереотип 30-летней давности |
| "Docker = VM" | Docker --- **контейнеризация**, не виртуализация. Контейнеры используют тот же kernel хоста. VM имеет собственный kernel | Оба обеспечивают изоляцию, но механизм принципиально разный: VM через гипервизор, Docker через cgroups/namespaces |
| "JVM = System VM" | JVM --- **Process VM** (application-level). Она не эмулирует компьютер, а выполняет байткод внутри обычного процесса ОС | Слово "виртуальная машина" вводит в заблуждение: подразумевается VM как VMware |
| "VM всегда безопаснее native" | VM *добавляет* слой безопасности (верификация, sandbox), но **escape-уязвимости** существуют. Defense in depth необходим | Sandbox JVM защищает от многих атак, но не является непробиваемым |
| "Native всегда быстрее VM" | JIT может оптимизировать лучше AOT благодаря **runtime profiling**: инлайнинг виртуальных методов, спекулятивные оптимизации | Интуиция подсказывает, что "ближе к железу = быстрее", но это не учитывает адаптивную оптимизацию |
| "Все VM работают одинаково" | JVM, CLR, V8, BEAM --- **принципиально разные** архитектуры с разными компромиссами (стековая vs регистровая, shared memory vs message passing) | Общий термин "виртуальная машина" скрывает архитектурные различия |

---

## CS-фундамент

| CS-концепция | Применение в Virtual Machine |
|--------------|------------------------------|
| **Abstraction Layer** | VM абстрагирует hardware/OS. "Write once, run anywhere" |
| **Interpretation vs Compilation** | Interpreter (простой, медленный) vs JIT (быстрый, после warmup). JVM использует обе стратегии |
| **Managed Runtime** | GC, type safety, bounds checking. Безопаснее чем native |
| **Bytecode** | Intermediate representation: портативный + верифицируемый + оптимизируемый |
| **Sandboxing** | Изоляция недоверенного кода через верификацию байткода и ограничение доступа к ресурсам |

---

## Источники и дальнейшее чтение

Smith, J. & Nair, R. (2005). *Virtual Machines: Versatile Platforms for Systems and Processes.* --- Каноническая академическая книга о виртуальных машинах обоих типов (system и process). Подробно разбирает архитектурные решения, классификацию VM и историю. Лучший источник для глубокого понимания концепции.

Lindholm, T. et al. (2014). *The Java Virtual Machine Specification, Java SE 8 Edition.* --- Официальная спецификация JVM: определяет набор инструкций байткода, формат class-файла, верификацию и модель памяти. Не учебник, но единственный авторитетный источник для точных деталей.

Craig, I. (2006). *Virtual Machines.* --- Систематическое сравнение виртуальных машин разных типов: от P-code до JVM и CLR. Хорошо раскрывает исторический контекст и эволюцию идей. Дополняет Smith & Nair более детальным разбором отдельных VM.

Venners, B. (2000). *Inside the Java Virtual Machine.* --- Одна из первых книг, объясняющих внутренности JVM доступным языком. Фундаментальные концепции (class loading, execution engine, стековая архитектура) актуальны до сих пор.

---

## Связь с другими темами

**[[jvm-basics-history]]** --- история JVM даёт необходимый контекст для понимания, *почему* виртуальная машина устроена именно так. Концепция VM --- абстракция; история объясняет, какие конкретные проблемы (фрагментация платформ, безопасность applets, медленные модемы) привели к конкретным решениям (байткод, стековая архитектура, sandbox). Рекомендуется читать параллельно с текущей статьёй или сразу после неё.

**[[os-virtualization-containers]]** --- системная виртуализация и контейнеризация --- другая ветвь "дерева виртуализации". Если Process VM (JVM) виртуализирует процессор для одного приложения, то System VM (VMware, KVM) виртуализирует весь компьютер, а контейнеры (Docker) занимают промежуточную позицию --- изоляция на уровне ОС без полной виртуализации hardware. Понимание всех трёх уровней --- от Process VM до System VM до контейнеров --- формирует целостную картину абстракций в современных системах.

---

*Проверено: 2026-02-11 | Источники: Smith & Nair (2005) Virtual Machines, Lindholm et al. JVM Specification, Craig (2006) Virtual Machines*
