---
title: "JVM: обзор и точка входа"
created: 2025-11-25
modified: 2026-02-11
tags:
  - topic/jvm
  - overview
  - type/moc
  - level/beginner
type: moc
status: published
area: programming
confidence: high
prerequisites:
  - "[[os-memory-management]]"
  - "[[compilation-pipeline]]"
related:
  - "[[jvm-memory-model]]"
  - "[[jvm-class-loader-deep-dive]]"
  - "[[jvm-jit-compiler]]"
  - "[[jvm-gc-tuning]]"
---

# JVM: обзор и точка входа

> **TL;DR:** JVM --- виртуальная машина, выполняющая Java bytecode на любой ОС. "Write Once, Run Anywhere" = один .class файл работает везде. JIT-компиляция делает код быстрым (иногда быстрее C++), GC автоматически управляет памятью. Netflix, LinkedIn, Amazon --- 80% enterprise работает на JVM. Эта статья --- полная история JVM: от проекта Green в 1991 году до Virtual Threads в Java 21.

---

## Пререквизиты

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| Основы программирования | Понимать переменные, функции, классы | Любой курс по Java/Kotlin |
| Компиляция vs интерпретация | Понять разницу bytecode vs native | [[compilation-pipeline]] |
| Процессы и память | Heap, Stack, как программа использует RAM | [[os-memory-management]] |

---

## Зачем это знать

JVM --- не просто "штука, которая запускает Java". Это продукт тридцати лет инженерных решений, каждое из которых отвечало на конкретную проблему своего времени. Понимание истории JVM позволяет ответить на вопросы, которые постоянно возникают на практике: почему GC-паузы неизбежны, почему JIT требует прогрева, зачем нужен байткод вместо прямой компиляции, почему backward compatibility --- и благословение, и проклятие платформы.

Без исторического контекста разработчик воспринимает JVM как чёрный ящик с набором магических флагов. С историческим контекстом --- как систему компромиссов, где каждый компонент появился по конкретной причине. Когда вы понимаете, *почему* HotSpot использует tiered compilation, вы можете обоснованно выбирать между `-XX:TieredStopAtLevel=1` для быстрого старта и полной оптимизацией для long-running сервисов.

---

## Терминология

| Термин | Что это | Аналогия из жизни |
|--------|---------|-------------------|
| **Байткод** | Промежуточный код между исходником и машинным кодом | Эсперанто --- универсальный язык, который переводчик (JVM) понимает везде |
| **JIT** | Just-In-Time --- компиляция байткода в машинный код на лету | Синхронный переводчик на конференции: сначала слушает фразу, потом мгновенно переводит |
| **GC** | Garbage Collection --- автоматическая очистка памяти | Уборщик в ресторане: сам замечает пустые тарелки и уносит, не нужно звать |
| **HotSpot** | Основная реализация JVM от Oracle | Конкретная модель двигателя (как V8 в автомобиле): JVM --- это спецификация, HotSpot --- реализация |
| **OpenJDK** | Open-source реализация Java Platform | Чертёж двигателя в открытом доступе: любой может собрать свою версию |
| **Warmup** | Период прогрева JIT-компилятора | Разогрев спортсмена перед соревнованием: первые минуты медленные, потом на пике формы |
| **Heap** | Область памяти для объектов | Большой склад, где хранятся все данные программы |
| **Stack** | Область памяти для вызовов методов | Стопка тарелок --- последняя положенная снимается первой (LIFO) |
| **WORA** | Write Once, Run Anywhere --- принцип кроссплатформенности | Универсальный рецепт блюда: написан один раз, работает на любой кухне мира |

---

## Историческая справка: от тостеров до облаков

### Green Project (1991--1994): всё началось не с компьютеров

В декабре 1990 года Патрик Нотон (Patrick Naughton), инженер Sun Microsystems, написал письмо руководству с угрозой уволиться. Его раздражало, что Sun игнорирует рынок бытовой электроники. Вместо увольнения ему предложили возглавить секретный проект --- Green Project.

Команда из 13 человек --- Джеймс Гослинг (James Gosling), Майк Шеридан (Mike Sheridan) и Нотон в ядре --- получила задание: создать технологию для smart-устройств. Телевизоры, тостеры, пульты управления --- у каждого свой процессор, своя архитектура. Компилировать код под каждое устройство отдельно? Кошмар для разработчика и для бизнеса.

Гослинг начал с модификации C++, но быстро понял: C++ слишком сложен для встроенных систем. Ручное управление памятью --- источник критических ошибок, а на тостере нет отладчика. Нужен новый язык с автоматическим управлением памятью.

> **Ключевое решение:** Гослинг создал язык Oak (названный в честь дуба за окном его кабинета). Главная идея --- *платформенная независимость*. Код компилируется не в машинный код конкретного процессора, а в промежуточный формат (байткод), который выполняет виртуальная машина.

Аналогия из жизни: представьте международную конференцию. Вместо того чтобы каждый докладчик учил язык каждого слушателя, все используют один общий язык (эсперанто). А в каждом зале сидит переводчик, который переводит эсперанто на местный язык. Байткод --- это эсперанто. JVM --- переводчик. Местный язык --- машинный код конкретного процессора.

Первый продукт --- *7 (Star Seven) --- интерактивный пульт управления домашней электроникой. Технически блестящий, коммерчески провальный: рынок smart-устройств в 1993 году ещё не созрел.

---

### Oak становится Java (1995): поворот к интернету

К 1994 году рынок бытовой электроники не взлетел, но произошло нечто более важное --- взрыв популярности World Wide Web. Команда Green увидела возможность: веб-страницы статичны, а Oak мог бы сделать их интерактивными. Язык переименовали в Java (Oak оказался занятым торговым знаком), и 23 мая 1995 года Sun Microsystems представила Java 1.0 миру.

Ключевой момент: Java появилась с браузерным плагином --- Java Applets. Код загружался с сервера и выполнялся прямо в браузере. Это было революционно: интерактивные анимации, калькуляторы, даже игры --- всё внутри веб-страницы.

Но была и серьёзная проблема: безопасность. Код скачивается из интернета и выполняется на компьютере пользователя --- рецепт катастрофы без защиты. Решение: **Security Manager** и **sandbox** --- JVM ограничивала, к каким ресурсам программа может обращаться. Недоверенный код не мог читать файлы, открывать сетевые соединения или запускать процессы. Это одно из первых решений по безопасности исполняемого кода из сети, задолго до современных Content Security Policy.

> **Почему "Write Once, Run Anywhere" стал лозунгом эпохи.** В середине 90-х рынок был фрагментирован: Windows 95, Mac OS, десятки вариантов Unix, OS/2. Разработчикам приходилось портировать код под каждую платформу. WORA обещал конец этому хаосу: скомпилируй Java-код один раз, и он работает везде, где есть JVM.

```
1995: Ландшафт ОС

┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐
│Windows 95│  │  Mac OS  │  │  Solaris │  │   Linux  │
│  x86     │  │ PowerPC  │  │  SPARC   │  │   x86    │
└────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘
     │             │             │             │
     └─────────────┴──────┬──────┴─────────────┘
                          │
                    ┌─────┴─────┐
                    │    JVM    │
                    │ (байткод) │
                    └─────┬─────┘
                          │
                    ┌─────┴─────┐
                    │ .class    │
                    │  файлы    │
                    └───────────┘
                   Один раз скомпилировал —
                   работает на всех ОС
```

Диаграмма показывает суть WORA: вместо четырёх разных бинарников для четырёх платформ создаётся один набор .class файлов. Каждая ОС имеет свою реализацию JVM, которая "переводит" байткод в инструкции нужного процессора.

---

### Java 2 и HotSpot (1999--2004): скорость и зрелость

Первые версии JVM были медленными --- чистая интерпретация байткода не могла конкурировать с C++. Критики смеялись: "Java is slow". И они были правы --- для 1996 года.

В 1999 году Sun приобрела компанию Longview Technologies, которая разработала виртуальную машину Self. Эта VM использовала революционную идею: **adaptive optimization**. Вместо того чтобы оптимизировать весь код заранее (как делает компилятор C++), VM наблюдает за работающей программой и оптимизирует только те части, которые действительно выполняются часто.

Эта технология стала основой **HotSpot** --- JVM, которая до сих пор является стандартной реализацией.

> **Аналогия из жизни:** Представьте, что вы оптимизируете маршрут доставки пиццы. Статический подход (AOT-компиляция): заранее рассчитать оптимальный маршрут для всех возможных адресов. Это дорого и часто неточно --- вы не знаете пробок. Адаптивный подход (JIT-компиляция): первую неделю водитель ездит по навигатору (интерпретатор), а потом запоминает самые частые маршруты и срезает путь (JIT). Через месяц он доставляет быстрее, чем по любому заранее рассчитанному маршруту, потому что знает реальную обстановку.

HotSpot ввёл **tiered compilation**: два компилятора работают вместе. C1 (client compiler) быстро компилирует с базовыми оптимизациями --- для быстрого старта. C2 (server compiler) агрессивно оптимизирует горячие методы --- для максимальной скорости после прогрева. JVM автоматически выбирает, какой компилятор использовать для каждого метода.

**Java 2 (1998--2004)** принесла зрелость платформе:
- **J2SE 1.2 (1998)** --- Collections Framework, Swing GUI
- **J2SE 1.3 (2000)** --- HotSpot как JVM по умолчанию
- **J2SE 1.4 (2002)** --- NIO (неблокирующий ввод-вывод), assert
- **J2SE 5.0 (2004)** --- Generics, Autoboxing, Enum, Annotations

Java 5 заслуживает отдельного внимания. Добавление **generics** --- пожалуй, самое спорное решение в истории Java. Чтобы сохранить backward compatibility с миллионами строк существующего кода, Sun выбрала **type erasure**: компилятор проверяет типы, а затем *стирает* их из байткода. `List<String>` и `List<Integer>` в runtime --- одинаковые `List`. Это позволило старому коду работать без изменений, но создало проблемы, которые Java-разработчики расхлёбывают до сих пор (невозможность проверить generic-тип в runtime, невозможность создать `new T()`).

---

### Java 6--8 (2006--2014): открытый код и функциональная революция

В 2006 году Sun Microsystems приняла решение, изменившее всю экосистему: **Java стала open source**. Проект OpenJDK дал сообществу доступ к исходному коду JVM. Это решение было не альтруистическим --- Sun терял долю рынка, и открытие кода было способом привлечь контрибьюторов и ускорить развитие.

В 2010 году Oracle купила Sun Microsystems. Сообщество напряглось: Oracle известна агрессивной лицензионной политикой. Опасения частично оправдались (Oracle vs Google по поводу Java API в Android), но OpenJDK остался открытым. Сегодня Oracle --- один из многих контрибьюторов: Amazon, Red Hat, SAP, Azul вносят изменения наравне.

**Java 8 (2014)** --- самый важный релиз после Java 5:
- **Lambda expressions** --- функциональное программирование пришло в Java
- **Stream API** --- декларативная обработка коллекций
- **Optional** --- явная работа с null (хотя не так элегантно, как в Kotlin)
- **Date/Time API (java.time)** --- замена ужасного java.util.Date

Почему lambda были так важны? До Java 8 для простого колбэка нужен был анонимный класс --- 5-7 строк boilerplate. С lambda --- одна строка. Это не просто синтаксический сахар: lambda сделали функциональный стиль практичным, что привело к Stream API и принципиально другому способу обработки данных.

| До Java 8 | После Java 8 |
|-----------|-------------|
| Анонимные классы для колбэков | Lambda выражения |
| Императивные циклы for | Stream API (map/filter/reduce) |
| null-проверки if/else | Optional (частично) |
| java.util.Date (мутабельный) | java.time (иммутабельный) |

Мы разобрали, как Java обрела зрелость и функциональные возможности. Но к этому моменту накопилась проблема: релизы выходили редко (между Java 6 и Java 7 --- пять лет), фичи задерживались годами. Нужен был новый подход к развитию платформы.

---

### Java 9--17 (2017--2021): модули, быстрые релизы и новая эпоха

В 2017 году Oracle объявила переход на **6-месячный цикл релизов**. Вместо "большого релиза раз в 3 года" --- небольшой релиз каждые полгода. Каждый третий год --- LTS (Long-Term Support) версия для enterprise.

**Java 9 (2017)** принесла **JPMS (Java Platform Module System)** --- систему модулей. Это было самое масштабное архитектурное изменение со времён Java 1.0. JDK разбили на ~70 модулей, и теперь можно собирать runtime только из нужных модулей (вместо 300MB monolithic JDK). Однако модули сломали обратную совместимость для некоторого кода, что вызвало волну критики.

**Java 11 (2018, LTS)** --- первый LTS-релиз нового цикла:
- Удалены Java EE и CORBA модули (перенесены в Jakarta EE)
- `var` для локальных переменных в lambda
- HTTP Client (замена устаревшему HttpURLConnection)
- Бесплатные обновления Oracle JDK только через OpenJDK

**Java 17 (2021, LTS)** --- текущий стандарт для enterprise:
- **Sealed classes** --- ограничение иерархии наследования
- **Pattern matching для instanceof** --- проверка типа и приведение в одном выражении
- **Records** --- неизменяемые data-классы (аналог Kotlin data class)
- **ZGC и Shenandoah** --- сборщики мусора с паузами менее 10 мс

---

### Java 21 (2023, LTS): виртуальные потоки и будущее

**Java 21** --- возможно, самый значимый релиз со времён Java 8:

**Virtual Threads (Project Loom)** --- виртуальные потоки, революция в конкурентности. До Java 21 каждый поток Java = поток ОС. Создание потока ОС --- тяжёлая операция (1 MB стека, переключение контекста через kernel). Это ограничивало серверы: 10 000 одновременных соединений = 10 000 потоков = 10 GB памяти только на стеки.

Virtual Threads --- лёгкие потоки, управляемые JVM. Один поток ОС может обслуживать тысячи виртуальных потоков. Netflix после миграции на Virtual Threads сообщил о снижении ошибок с 2000/сек до 100/сек на некоторых сервисах.

**Pattern matching для switch** --- мощный инструмент декомпозиции данных:

Покажем, как выглядит pattern matching в Java 21 --- код, который раньше требовал цепочки if-instanceof:

```java
// Java 21: Pattern matching + sealed interface
sealed interface Shape permits Circle, Rectangle {}
record Circle(double radius) implements Shape {}
record Rectangle(double w, double h) implements Shape {}

double area(Shape s) {
    return switch (s) {                      // Exhaustive: все подтипы покрыты
        case Circle c    -> Math.PI * c.radius() * c.radius();
        case Rectangle r -> r.w() * r.h();   // Нет default — компилятор знает все варианты
    };
}
```

Этот код демонстрирует три фичи Java 21 одновременно: sealed interface ограничивает набор подтипов, records создают неизменяемые объекты, а pattern matching в switch разбирает их без явного приведения типов. Компилятор гарантирует, что все варианты обработаны.

---

## Ключевые design decisions: почему JVM устроена именно так

### Почему стековая машина, а не регистровая?

Большинство реальных процессоров --- регистровые: у них фиксированный набор быстрых ячеек памяти (регистров), и инструкции работают с ними напрямую. JVM --- **стековая машина**: все операции происходят через стек операндов. Чтобы сложить два числа, сначала кладём оба на стек, затем выполняем `iadd`, который снимает два числа и кладёт результат.

Почему выбрали стековую модель?

1. **Компактность байткода.** Стековые инструкции не указывают регистры-источники и регистры-назначения --- всё неявно берётся со стека. Инструкция `iadd` занимает 1 байт. Регистровый аналог (`add r1, r2, r3`) занял бы 3-4 байта. В 1995 году байткод загружался по модему на 14.4 Kbps --- каждый байт на счету.

2. **Простота реализации.** Написать интерпретатор стековой машины проще: не нужно думать о регистровом аллокаторе. Это важно для портирования JVM на новые платформы.

3. **Независимость от архитектуры.** У x86 --- 16 регистров, у ARM --- 31, у SPARC --- 128 (windowed). Если байткод привязан к количеству регистров, он теряет портативность.

Платой за компактность стала производительность интерпретации: стековая машина делает больше операций с памятью. Но JIT-компилятор нивелирует это --- он всё равно транслирует байткод в регистровый машинный код.

### Почему Garbage Collection, а не ручное управление памятью?

Green Project изначально нацеливался на встроенные устройства, где ошибки памяти критичны (перезагрузить тостер --- ладно, а медицинское оборудование?). Гослинг наблюдал, что в C/C++ проектах *до 40% времени отладки* уходит на ошибки памяти: use-after-free, double free, утечки.

GC --- компромисс: программист теряет детальный контроль над моментом освобождения памяти, но взамен получает гарантию отсутствия целых классов ошибок. Этот компромисс оказался выигрышным для 95% задач. Для оставшихся 5% (игровые движки, ОС, real-time) существуют C++, Rust и другие языки без GC.

### Почему backward compatibility --- святое?

Java с первых версий придерживалась правила: **код, скомпилированный для Java 1.0, должен работать на Java 21**. Это жёсткое ограничение, которое замедляет развитие языка (нельзя исправить старые ошибки дизайна), но обеспечивает доверие enterprise: компания может обновить JDK без переписывания миллионов строк кода.

Сравните с Python 2 → Python 3: миграция заняла 15 лет и расколола сообщество. Java выбрала другой путь --- добавлять, не ломая. Цена --- исторический багаж: java.util.Date, raw types, checked exceptions.

---

## Архитектура JVM

```
┌─────────────────────────────────────────┐
│              .java файлы                │
│                   │                     │
│                   ▼ javac               │
│              .class файлы               │
│              (байткод)                  │
└─────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────┐
│               JVM                        │
│  ┌──────────────────────────────────┐   │
│  │  Class Loader                     │   │
│  │  (загрузка .class)                │   │
│  └──────────────────────────────────┘   │
│                  ▼                       │
│  ┌──────────────────────────────────┐   │
│  │  Runtime Data Areas               │   │
│  │  (Heap, Stack, Metaspace)         │   │
│  └──────────────────────────────────┘   │
│                  ▼                       │
│  ┌──────────────────────────────────┐   │
│  │  Execution Engine                 │   │
│  │  (Interpreter + JIT Compiler)     │   │
│  └──────────────────────────────────┘   │
│                  ▼                       │
│  ┌──────────────────────────────────┐   │
│  │  Native Interface (JNI)           │   │
│  └──────────────────────────────────┘   │
└─────────────────────────────────────────┘
```

### Компоненты JVM

**javac** --- компилятор Java. Превращает `.java` файлы в `.class` файлы с байткодом. Байткод --- промежуточный код, одинаковый для всех платформ. Важно: javac --- *не* часть JVM. Это отдельный инструмент. JVM работает только с байткодом, ей безразлично, на каком языке он был написан.

**Class Loader** --- находит и загружает `.class` файлы в память JVM. Загрузка ленивая: класс загружается только при первом использовании. Иерархия: Bootstrap (core Java) → Platform (расширения) → Application (ваш код). Class Loader --- одна из самых недооценённых частей JVM: именно он обеспечивает изоляцию между модулями, позволяет перезагружать классы без перезапуска (hot reload) и лежит в основе сервлет-контейнеров и OSGi. Подробнее: [[jvm-class-loader-deep-dive]]

**Runtime Data Areas** --- память JVM:
- **Heap** --- общая память для всех объектов, управляется GC
- **Stack** --- память потока для локальных переменных и вызовов методов
- **Metaspace** --- метаданные классов (вне heap, растёт автоматически, заменила PermGen в Java 8)
- Подробнее: [[jvm-memory-model]]

**Execution Engine** --- выполняет байткод:
- **Interpreter** --- выполняет байткод построчно, медленно, но сразу работает
- **JIT Compiler** --- компилирует "горячие" методы в native код после warmup, быстро
- JVM комбинирует оба: сначала Interpreter, потом JIT для часто вызываемых методов
- Подробнее: [[jvm-jit-compiler]]

**JNI (Java Native Interface)** --- механизм вызова native кода (C/C++) из Java. Используется для доступа к системным функциям ОС, интеграции с legacy-библиотеками на C, высокопроизводительных вычислений. Осторожно: теряется кроссплатформенность, возможны memory leaks, потому что native код не управляется GC.

Мы разобрали из чего состоит JVM и почему она устроена именно так. Теперь посмотрим, какие ключевые версии отмечают её эволюцию.

---

## Ключевые версии: хронология

| Версия | Год | Ключевые фичи | Почему это важно |
|--------|-----|---------------|------------------|
| Java 1.0 | 1996 | Applets, AWT, базовый JVM | Первый релиз, WORA |
| Java 1.2 | 1998 | Collections, Swing, JIT | Зрелая стандартная библиотека |
| Java 5 | 2004 | Generics, Annotations, Enum | Система типов стала выразительной |
| Java 6 | 2006 | OpenJDK, улучшения JIT | Начало open-source эры |
| Java 8 (LTS) | 2014 | Lambdas, Streams, Optional | Функциональное программирование |
| Java 9 | 2017 | Modules (JPMS), JShell | Модульная архитектура |
| Java 11 (LTS) | 2018 | HttpClient, var | Первый LTS нового цикла |
| Java 17 (LTS) | 2021 | Sealed classes, Records | Современный enterprise-стандарт |
| Java 21 (LTS) | 2023 | Virtual Threads, Pattern matching | Революция в конкурентности |

---

## Карта топиков

### Память и GC
- [[jvm-memory-model]] --- Heap, Stack, где живут объекты
- [[jvm-gc-tuning]] --- выбор и настройка сборщика мусора

### Загрузка и выполнение
- [[jvm-class-loader-deep-dive]] --- как загружаются классы
- [[jvm-jit-compiler]] --- компиляция байткода в native код

### Многопоточность
- [[jvm-concurrency-overview]] --- карта многопоточности
- [[jvm-synchronization]] --- synchronized, volatile, atomic
- [[jvm-concurrent-collections]] --- ConcurrentHashMap, BlockingQueue
- [[jvm-executors-futures]] --- пулы потоков, CompletableFuture

### Диагностика и профилирование
- [[jvm-production-debugging]] --- thread dumps, heap dumps, JFR
- [[jvm-profiling]] --- async-profiler, flame graphs
- [[jvm-benchmarking-jmh]] --- правильные бенчмарки

### Продвинутые топики
- [[jvm-reflection-api]] --- доступ к классам через reflection
- [[jvm-bytecode-manipulation]] --- ASM, Javassist
- [[jvm-module-system]] --- JPMS (Java 9+)

---

## JVM Languages

JVM запускает не только Java. Это важно понимать: JVM --- спецификация виртуальной машины, а не "движок Java". Любой язык, компилирующийся в валидный байткод, может работать на JVM.

| Язык | Особенность | Почему выбирают |
|------|-------------|-----------------|
| **Kotlin** | Современный синтаксис, null-safety | Android (Google рекомендует), серверные приложения |
| **Scala** | Мощная система типов, ФП | Big Data (Spark), высоконагруженные системы (Akka) |
| **Clojure** | Lisp на JVM, иммутабельность | Конкурентное программирование, финтех |
| **Groovy** | Динамический, скрипты | Gradle, Jenkins pipeline, DSL |

Подробнее: [[kotlin-basics]], [[jvm-languages-ecosystem]]

---

## Quick Start: JVM флаги

Покажем основные JVM-флаги, которые используются в production:

```bash
# Heap size: начальный и максимальный
java -Xms512m -Xmx2g MyApp

# GC выбор
java -XX:+UseG1GC MyApp        # G1 (default с Java 9)
java -XX:+UseZGC MyApp         # ZGC (low latency, Java 15+)

# Диагностика
java -XX:+HeapDumpOnOutOfMemoryError MyApp
java -Xlog:gc*:file=gc.log MyApp

# Отладка
java -verbose:class MyApp      # Загрузка классов
java -XX:+PrintCompilation MyApp  # JIT компиляция
```

Флаг `-Xmx2g` --- самый частый: он ограничивает размер heap. Без него JVM может занять всю доступную RAM. Флаги `-XX:+UseZGC` и `-XX:+UseG1GC` выбирают стратегию сборки мусора --- это критично для latency. Подробнее о настройке GC: [[jvm-gc-tuning]].

---

## Кто использует и реальные примеры

| Компания | Как используют JVM | Результаты |
|----------|-------------------|------------|
| **Netflix** | Перешли с G1 на ZGC в 2024, >50% сервисов на JDK 21 | Ошибки с 2000/сек до 100/сек, batch-задачи на 6-8% быстрее |
| **LinkedIn** | Kafka, Samza --- весь real-time processing на JVM | Миллиарды сообщений в день |
| **Amazon** | Corretto --- собственная сборка OpenJDK | Используется во всех AWS сервисах |
| **Uber** | JVM для микросервисов и ML pipeline | Тысячи JVM-сервисов |
| **Twitter/X** | Scala на JVM для всей backend-инфраструктуры | Обработка сотен тысяч твитов в секунду |

### Почему enterprise выбирает JVM

1. **Стабильность** --- backward compatibility, код 20-летней давности работает
2. **Производительность** --- JIT делает код конкурентным с C++
3. **Экосистема** --- Spring, Hibernate, миллионы библиотек
4. **Tooling** --- IntelliJ IDEA, VisualVM, async-profiler, JFR
5. **Talent pool** --- легко найти разработчиков

---

## Распространённые заблуждения

| Заблуждение | Реальность | Почему люди так думают |
|-------------|-----------|----------------------|
| "Java медленная" | JIT-компиляция делает Java конкурентной с C++ для long-running серверов. Netflix, LinkedIn, Goldman Sachs используют Java для latency-critical систем | Первые JVM (1996) были чисто интерпретируемыми. Стереотип 30-летней давности |
| "JVM = Java" | JVM выполняет байткод. Kotlin, Scala, Clojure, Groovy --- все работают на JVM. Байткод не содержит информации о языке-источнике | Java была первым языком для JVM, отсюда путаница в названиях |
| "JVM = Oracle = платно" | OpenJDK полностью бесплатен. Amazon Corretto, Eclipse Temurin, Azul Zulu --- production-ready бесплатные дистрибутивы | Oracle действительно меняла лицензионную политику, но open-source альтернативы полноценны |
| "Старый код работает везде без изменений" | Backward compatibility сохраняется для *стандартных API*. Но deprecated API удаляются (SecurityManager в Java 24), internal API закрываются (модули Java 9) | "Backward compatibility" не означает "замороженность" |
| "HotSpot --- единственная JVM" | OpenJ9 (IBM), GraalVM, Azul Zing --- альтернативные реализации с разными trade-offs (startup time, memory footprint, peak performance) | HotSpot используется в 90%+ случаев, остальные нишевые |

---

## CS-фундамент

| CS-концепция | Применение в JVM |
|--------------|------------------|
| **Platform Independence** | Байткод абстрагирует hardware. WORA --- фундаментальный принцип JVM |
| **Managed Memory** | GC эволюция: Serial → Parallel → G1 → ZGC. Автоматическое управление памятью |
| **JIT Compilation** | Interpreter → C1 → C2 → Tiered. Profile-guided optimization в runtime |
| **Backward Compatibility** | 30 лет код работает. Редкие breaking changes (модули Java 9, удаление SecurityManager) |
| **Open Source Development** | OpenJDK: Oracle + community (Amazon, Red Hat, SAP, Azul). Прозрачная разработка |

---

## Источники и дальнейшее чтение

Lindholm, T. et al. (2014). *The Java Virtual Machine Specification, Java SE 8 Edition.* --- Официальная спецификация JVM. Определяет байткод, class-файл формат, верификацию и модель памяти. Не учебник, но единственный авторитетный источник для точных деталей.

Gosling, J. et al. (2023). *The Java Language Specification, Java SE 21 Edition.* --- Спецификация языка Java. Дополняет JVM Spec: что компилятор должен генерировать и какие гарантии даёт язык. Необходима при написании компиляторов и инструментов анализа.

Venners, B. (2000). *Inside the Java Virtual Machine.* --- Одна из первых книг, объясняющих внутренности JVM на доступном уровне. Несмотря на возраст, фундаментальные концепции (class loading, execution engine, memory model) актуальны. Хороша как введение перед чтением спецификации.

Oaks, S. (2020). *Java Performance: In-Depth Advice for Tuning and Programming Java 8, 11, and Beyond.* --- Практическое руководство по производительности JVM: GC, JIT, мониторинг. Покрывает и HotSpot, и GraalVM.

### Курсы и ресурсы
- [JVM Specification](https://docs.oracle.com/javase/specs/jvms/se21/html/) --- официальная спецификация
- [OpenJDK](https://openjdk.org/) --- исходный код JVM
- [Inside Java Podcast](https://inside.java/podcast/) --- от разработчиков JVM

### Инструменты для изучения
- [JITWatch](https://github.com/AdoptOpenJDK/jitwatch) --- визуализация JIT-компиляции
- [VisualVM](https://visualvm.github.io/) --- мониторинг JVM
- [async-profiler](https://github.com/async-profiler/async-profiler) --- профилирование

---

## Связь с другими темами

**[[jvm-memory-model]]** --- модель памяти JVM определяет, где живут объекты, как устроен heap и stack, и как GC управляет жизненным циклом объектов. Понимание истории JVM помогает осознать, почему модель памяти эволюционировала: PermGen (Java 1--7) заменён на Metaspace (Java 8) именно потому, что фиксированный размер PermGen вызывал OutOfMemoryError при загрузке большого числа классов. Рекомендуется читать после текущей статьи.

**[[jvm-class-loader-deep-dive]]** --- система загрузки классов является одним из архитектурных решений, заложенных ещё в Green Project. Иерархия загрузчиков (Bootstrap → Platform → Application) обеспечивает изоляцию и безопасность --- те самые принципы, ради которых Гослинг отказался от C++. Class Loader глубоко связан с модульной системой Java 9 (JPMS), которая добавила новый слой контроля над видимостью классов.

**[[jvm-jit-compiler]]** --- JIT-компиляция напрямую выросла из HotSpot VM, историю которой мы разобрали в секции про 1999 год. Без понимания, как JVM наблюдает за горячими методами (profiling), невозможно правильно интерпретировать результаты бенчмарков и диагностировать проблемы warmup. Это естественное продолжение текущей статьи.

**[[jvm-gc-tuning]]** --- сборка мусора --- одно из ключевых design decisions JVM, принятое в 1991 году. За 30 лет GC прошёл путь от однопоточного Serial через многопоточный Parallel и region-based G1 до concurrent ZGC с паузами менее миллисекунды. Понимание этой эволюции помогает выбрать правильный GC для конкретного приложения. Читайте после [[jvm-memory-model]].

---

*Проверено: 2026-02-11 | Источники: Lindholm et al. JVM Specification, Venners (2000) Inside the JVM, Netflix Tech Blog, Oracle docs*
