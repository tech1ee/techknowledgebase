---
title: "Caching: быстро, но сложно"
created: 2025-11-24
modified: 2026-01-02
type: concept
status: published
confidence: high
sources_verified: true
tags:
  - topic/architecture
  - architecture/caching
  - architecture/performance
  - tools/redis
  - type/concept
  - level/intermediate
related:
  - "[[microservices-vs-monolith]]"
  - "[[api-design]]"
  - "[[observability]]"
  - "[[network-http-evolution]]"
  - "[[jvm-memory-model]]"
---

# Caching: быстро, но сложно

> 150ms из БД → 2ms из кэша. При 95% hit rate нагрузка на БД падает в 20 раз. Edge HTML caching снижает нагрузку на origin на 60-90%. Инвалидация кэша — одна из двух сложных проблем в CS.

---

## Что нужно знать перед изучением

Прежде чем изучать кэширование, убедитесь, что понимаете:

- **Базы данных** — что такое запрос, почему они медленнее памяти
- **HTTP** — как работают заголовки запросов и ответов → [[network-http-evolution]]
- **Память vs Диск** — RAM работает в 100-1000 раз быстрее HDD/SSD
- **Распределённые системы** (для advanced) — как несколько серверов работают вместе

---

## Главная аналогия: Кухня vs Магазин

Представьте, что вам нужен стакан воды:

```
БЕЗ КЭША (каждый раз идём в магазин):
┌─────────────────────────────────────────────────────────────────┐
│ Хочу воды → Одеваюсь → Еду в магазин → Покупаю → Еду домой     │
│                                                                 │
│ Время: 30 минут                                                 │
│ Каждый раз заново!                                              │
└─────────────────────────────────────────────────────────────────┘

С КЭШЕМ (бутылка воды на столе):
┌─────────────────────────────────────────────────────────────────┐
│ Хочу воды → Беру бутылку со стола                               │
│                                                                 │
│ Время: 5 секунд                                                 │
│                                                                 │
│ Раз в неделю: еду в магазин и покупаю запас бутылок             │
└─────────────────────────────────────────────────────────────────┘
```

**Кэш = хранение часто нужных вещей поближе к себе.**

Это работает потому, что:
1. **80% времени** нам нужны одни и те же данные (80/20 правило)
2. **Память** (RAM) в 100-1000 раз быстрее диска/сети
3. **Повторные вычисления** — пустая трата ресурсов

---

## Почему это важно (Проблема латентности)

### Разница в скорости операций

| Операция | Время | Аналогия |
|----------|-------|----------|
| L1 Cache (CPU) | 0.5 нс | Моргнуть |
| RAM | 100 нс | Вдохнуть |
| SSD | 100,000 нс (0.1 мс) | Встать со стула |
| **Redis GET** | **0.1-2 мс** | **Дойти до кухни** |
| HDD | 10,000,000 нс (10 мс) | Выйти из дома |
| **Database query** | **10-150 мс** | **Сходить в магазин** |
| External API | 50-500 мс | Съездить в другой город |
| Cold compute | 100-1000 мс | Слетать в другую страну |

**Вывод:** Разница между Redis (2 мс) и БД (150 мс) — это как разница между "дойти до кухни" и "съездить в магазин".

### Реальный пример: Без кэша

```
Сценарий: Интернет-магазин, 1000 пользователей в секунду
просматривают каталог товаров

Каждый запрос:
User → API → Service → Database Query → 150ms
                              ↑
                        Каждый раз заново!

Что происходит:
• 1000 запросов к БД каждую секунду
• БД начинает "захлёбываться"
• Очередь запросов растёт
• Latency: 150ms → 500ms → 2000ms → TIMEOUT
• Пользователи уходят
• Бизнес теряет деньги

┌─────────────────────────────────────────────────────────────────┐
│  Load: 1000 RPS                                                 │
│                                                                 │
│  DB Response Time:                                              │
│  ████████████████████████████████████████████████  500ms        │
│                                                                 │
│  Error Rate:                                                    │
│  ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█████  15%            │
│                                                                 │
│  Result: Users leaving, revenue dropping                        │
└─────────────────────────────────────────────────────────────────┘
```

### Реальный пример: С кэшем

```
Тот же сценарий, но с Redis кэшем (95% hit rate):

User → API → Cache Hit?
              ↓ YES (95% случаев)
              → Return from Redis → 2ms

              ↓ NO (5% случаев)
              → Service → DB → Store in Redis → Return

Что происходит:
• 950 запросов обслуживаются из Redis (2ms)
• 50 запросов идут в БД (150ms)
• БД под контролем
• Latency стабильный

┌─────────────────────────────────────────────────────────────────┐
│  Load: 1000 RPS (same)                                          │
│                                                                 │
│  Cache Hit Rate:                                                │
│  ██████████████████████████████████████████████████  95%        │
│                                                                 │
│  DB Load (only misses):                                         │
│  ██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░  50 RPS      │
│                                                                 │
│  Result: Happy users, stable system                             │
└─────────────────────────────────────────────────────────────────┘
```

### Реальные компании, которые столкнулись с проблемой

**Twitter (2008-2009):**
- "Fail Whale" — знаменитый кит ошибки
- Причина: MySQL не справлялся с нагрузкой
- Решение: Massive Redis/Memcached layer
- Результат: 99.9% uptime

**GitHub (2012):**
- Частые падения при всплесках трафика
- Причина: Каждый запрос шёл напрямую в БД
- Решение: Redis + Memcached + CDN
- Результат: Обслуживает 100M+ разработчиков

**Shopify (Black Friday):**
- Нагрузка x100 в "чёрную пятницу"
- Решение: Multi-tier caching (CDN + Redis + Local)
- Результат: Миллионы транзакций без падений

---

## Терминология (с аналогиями)

| Термин | Значение | Аналогия |
|--------|----------|----------|
| **Cache** | Быстрое хранилище данных | Холодильник на кухне |
| **Cache hit** | Данные найдены в кэше | Нашёл еду в холодильнике |
| **Cache miss** | Данных нет, идём в источник | Холодильник пуст, идём в магазин |
| **Hit rate** | % запросов из кэша | Как часто еда есть дома |
| **TTL** | Time To Live — время жизни | Срок годности молока |
| **Invalidation** | Удаление устаревших данных | Выбросить испорченные продукты |
| **Eviction** | Освобождение места | Выбросить старое, чтобы положить новое |
| **Warm cache** | Кэш заполнен данными | Полный холодильник |
| **Cold cache** | Кэш пуст (после рестарта) | Пустой холодильник после переезда |
| **Origin** | Основной источник данных | Магазин, ферма |
| **Edge** | Кэш ближе к пользователю | Мини-маркет в вашем доме |

### Единицы измерения

| Метрика | Хорошее значение | Плохое значение |
|---------|------------------|-----------------|
| Hit rate | 90-99% | < 70% |
| P99 latency (Redis) | < 5 мс | > 50 мс |
| Eviction rate | < 5%/час | > 20%/час |
| Memory usage | 60-80% | > 95% |

---

## Уровни кэширования

Кэширование происходит на разных "расстояниях" от пользователя:

```
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│  ПОЛЬЗОВАТЕЛЬ                                                           │
│       │                                                                 │
│       ▼                                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │ Level 1: BROWSER CACHE                                          │    │
│  │                                                                 │    │
│  │ Что: Статические файлы (JS, CSS, картинки)                      │    │
│  │ Где: В браузере пользователя                                    │    │
│  │ Скорость: 0ms (уже на устройстве)                               │    │
│  │ Аналогия: Записная книжка в кармане                             │    │
│  │                                                                 │    │
│  │ Управление: Cache-Control headers, Service Workers              │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│       │                                                                 │
│       ▼                                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │ Level 2: CDN CACHE (Edge)                                       │    │
│  │                                                                 │    │
│  │ Что: Статика + часто запрашиваемые API responses                │    │
│  │ Где: Серверы по всему миру (ближе к пользователю)               │    │
│  │ Скорость: 5-50ms                                                │    │
│  │ Аналогия: Мини-маркет в вашем районе                            │    │
│  │                                                                 │    │
│  │ Примеры: Cloudflare, CloudFront, Fastly                         │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│       │                                                                 │
│       ▼                                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │ Level 3: APPLICATION CACHE (In-Memory)                          │    │
│  │                                                                 │    │
│  │ Что: API responses, sessions, computed data                     │    │
│  │ Где: В памяти сервера или Redis кластере                        │    │
│  │ Скорость: 0.1-5ms                                               │    │
│  │ Аналогия: Холодильник на кухне                                  │    │
│  │                                                                 │    │
│  │ Примеры: Redis, Memcached, in-process cache (Caffeine, Guava)   │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│       │                                                                 │
│       ▼                                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │ Level 4: DATABASE CACHE                                         │    │
│  │                                                                 │    │
│  │ Что: Результаты запросов, индексы                               │    │
│  │ Где: Внутри базы данных                                         │    │
│  │ Скорость: Автоматически, прозрачно                              │    │
│  │ Аналогия: Полки в магазине (не в подсобке)                      │    │
│  │                                                                 │    │
│  │ Примеры: Query cache, Buffer pool, Index cache                  │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│       │                                                                 │
│       ▼                                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │ Level 5: DISK / ORIGIN DATABASE                                 │    │
│  │                                                                 │    │
│  │ Что: Все данные (source of truth)                               │    │
│  │ Где: На жёстком диске                                           │    │
│  │ Скорость: 10-150ms                                              │    │
│  │ Аналогия: Склад на окраине города                               │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Multi-Tier Caching в реальности

Netflix использует все уровни одновременно:

```
Пользователь смотрит фильм:

1. Browser Cache — интерфейс приложения (HTML/JS/CSS)
2. CDN (Open Connect) — сам видеоконтент с ближайшего сервера
3. EVCache (Redis) — метаданные фильма, рекомендации
4. Cassandra — история просмотров (когда нет в кэше)

Результат: Видео начинается за < 2 секунды
```

---

## Стратегии кэширования

Есть 4 основные стратегии. Каждая — как разный подход к покупке продуктов:

### 1. Cache-Aside (Lazy Loading) — "Покупаю когда нужно"

**Аналогия:** Хотите перекусить → Смотрите в холодильник → Пусто → Идёте в магазин → Покупаете → Кладёте в холодильник → Едите

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         CACHE-ASIDE PATTERN                             │
│                                                                         │
│   ┌──────────┐          ┌───────────┐          ┌───────────┐            │
│   │   App    │          │   Cache   │          │ Database  │            │
│   └────┬─────┘          └─────┬─────┘          └─────┬─────┘            │
│        │                      │                      │                  │
│        │ 1. GET user:123      │                      │                  │
│        │─────────────────────▶│                      │                  │
│        │                      │                      │                  │
│        │     2a. HIT: return  │                      │                  │
│        │◀─────────────────────│                      │                  │
│        │                      │                      │                  │
│   ─ ─ ─│─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ │ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ │─ ─ ─ ─ ─         │
│        │                      │                      │                  │
│        │     2b. MISS         │                      │                  │
│        │◀ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ │                      │                  │
│        │                      │                      │                  │
│        │ 3. SELECT * FROM users WHERE id=123        │                  │
│        │────────────────────────────────────────────▶│                  │
│        │                      │                      │                  │
│        │ 4. {id: 123, name: "John", ...}            │                  │
│        │◀────────────────────────────────────────────│                  │
│        │                      │                      │                  │
│        │ 5. SET user:123      │                      │                  │
│        │─────────────────────▶│                      │                  │
│        │                      │                      │                  │
│        │ 6. Return to caller  │                      │                  │
│        │                      │                      │                  │
└─────────────────────────────────────────────────────────────────────────┘
```

**Когда использовать:**
- ✅ Read-heavy приложения (чтение >> записи)
- ✅ Когда можно пережить первый медленный запрос
- ✅ Когда нужен полный контроль над кэшированием

**Когда НЕ использовать:**
- ❌ Когда критична мгновенная готовность данных
- ❌ Когда данные меняются очень часто

**Плюсы:**
- Кэшируем только то, что реально запрашивается
- Падение кэша не ломает систему (fallback в БД)
- Полный контроль

**Минусы:**
- Первый запрос всегда медленный (cache miss)
- Код сложнее — логика кэширования везде

**Код с пошаговыми объяснениями:**

```typescript
// =============================================================
// CACHE-ASIDE: Пошаговая реализация
// =============================================================

class UserService {
  // Инъекция зависимостей — Redis для кэша, Database для данных
  constructor(
    private cache: Redis,    // Наш "холодильник"
    private db: Database     // Наш "магазин"
  ) {}

  async getUserById(id: string): Promise<User | null> {
    // ШАГ 1: Формируем ключ кэша
    // Конвенция: entity:id (например, user:123, product:456)
    const cacheKey = `user:${id}`;

    // ШАГ 2: Проверяем кэш (смотрим в холодильник)
    // Это ВСЕГДА первое действие в cache-aside
    const cached = await this.cache.get(cacheKey);

    // ШАГ 3: Если нашли — возвращаем (cache hit)
    // Это быстрый путь: ~1-2ms
    if (cached) {
      // JSON.parse потому что Redis хранит только строки
      // В реальности можно использовать бинарные форматы (msgpack, protobuf)
      return JSON.parse(cached);
    }

    // ШАГ 4: Cache miss — идём в базу данных (в магазин)
    // Это медленный путь: ~50-150ms
    const user = await this.db.query(
      'SELECT * FROM users WHERE id = $1',
      [id]
    );

    // ШАГ 5: Если нашли — сохраняем в кэш для следующих запросов
    if (user) {
      await this.cache.set(
        cacheKey,              // Ключ
        JSON.stringify(user),  // Значение (сериализованное)
        'EX',                  // EX = expiration в секундах
        3600                   // TTL: 1 час
      );
    }

    // ШАГ 6: Возвращаем результат
    return user;
  }

  // При обновлении данных — ИНВАЛИДИРУЕМ кэш
  async updateUser(id: string, data: Partial<User>): Promise<User> {
    // ШАГ 1: Обновляем источник истины (БД)
    // ВАЖНО: Сначала БД, потом кэш. Не наоборот!
    const user = await this.db.query(
      'UPDATE users SET name = $2, email = $3 WHERE id = $1 RETURNING *',
      [id, data.name, data.email]
    );

    // ШАГ 2: Инвалидируем кэш (удаляем старые данные)
    // Почему удаляем, а не обновляем?
    // - Проще (не нужно дублировать логику)
    // - Безопаснее (меньше шансов на inconsistency)
    // - Следующий GET подгрузит свежие данные
    await this.cache.del(`user:${id}`);

    return user;
  }
}
```

### 2. Write-Through — "Записываю везде сразу"

**Аналогия:** Купили продукты → Одновременно кладёте в холодильник И записываете в список покупок. Всё синхронизировано!

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        WRITE-THROUGH PATTERN                            │
│                                                                         │
│   ┌──────────┐          ┌───────────┐          ┌───────────┐            │
│   │   App    │          │   Cache   │          │ Database  │            │
│   └────┬─────┘          └─────┬─────┘          └─────┬─────┘            │
│        │                      │                      │                  │
│        │ 1. WRITE user:123    │                      │                  │
│        │─────────────────────▶│                      │                  │
│        │                      │                      │                  │
│        │                      │ 2. WRITE to DB       │                  │
│        │                      │─────────────────────▶│                  │
│        │                      │                      │                  │
│        │                      │ 3. Confirm           │                  │
│        │                      │◀─────────────────────│                  │
│        │                      │                      │                  │
│        │ 4. Confirm (both)    │                      │                  │
│        │◀─────────────────────│                      │                  │
│        │                      │                      │                  │
│   Кэш всегда актуален!        │                      │                  │
└─────────────────────────────────────────────────────────────────────────┘
```

**Когда использовать:**
- ✅ Когда консистентность данных критична
- ✅ Банковские системы, инвентарь e-commerce
- ✅ Когда записей относительно мало

**Минусы:**
- Запись медленнее (ждём и кэш, и БД)
- Если одна система упадёт — inconsistency

**Реальный пример:** Баланс банковского счёта — после пополнения вы должны сразу видеть новый баланс.

### 3. Write-Behind (Write-Back) — "Записываю потом"

**Аналогия:** Курьерская служба — вы отдаёте посылку в пункт выдачи (кэш), а они отправляют её в главный склад (БД) вечером, когда накопится партия.

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        WRITE-BEHIND PATTERN                             │
│                                                                         │
│   ┌──────────┐          ┌───────────┐          ┌───────────┐            │
│   │   App    │          │   Cache   │          │ Database  │            │
│   └────┬─────┘          └─────┬─────┘          └─────┬─────┘            │
│        │                      │                      │                  │
│        │ 1. WRITE user:123    │                      │                  │
│        │─────────────────────▶│                      │                  │
│        │                      │                      │                  │
│        │ 2. Confirm (fast!)   │                      │                  │
│        │◀─────────────────────│                      │                  │
│        │                      │                      │                  │
│        │                      │  ┌─────────────────┐ │                  │
│        │                      │  │ Background Job  │ │                  │
│        │                      │  │ (async batch)   │ │                  │
│        │                      │  └────────┬────────┘ │                  │
│        │                      │           │          │                  │
│        │                      │           │ 3. Batch │                  │
│        │                      │           │   Write  │                  │
│        │                      │           │─────────▶│                  │
│        │                      │           │          │                  │
└─────────────────────────────────────────────────────────────────────────┘
```

**Когда использовать:**
- ✅ Высокая частота записей (лайки, просмотры, метрики)
- ✅ Когда можно потерять несколько секунд данных
- ✅ IoT данные с сенсоров

**ОПАСНОСТЬ:**
- ⚠️ Если Redis упадёт до записи в БД — данные ПОТЕРЯНЫ
- ⚠️ Нет автоматического recovery
- ⚠️ Eventually consistent — не для финансов!

**Реальный пример:** Instagram лайки — если вы лайкнули пост и через 1 секунду сервер упал, лайк может не сохраниться. Это приемлемо для лайков, но не для денег.

### 4. Read-Through — "Кэш сам всё достанет"

**Аналогия:** Библиотекарь — вы просите книгу, и если её нет на полке, библиотекарь сам идёт на склад, приносит и выдаёт вам.

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        READ-THROUGH PATTERN                             │
│                                                                         │
│   ┌──────────┐          ┌───────────┐          ┌───────────┐            │
│   │   App    │          │   Cache   │          │ Database  │            │
│   └────┬─────┘          └─────┬─────┘          └─────┬─────┘            │
│        │                      │                      │                  │
│        │ 1. GET user:123      │                      │                  │
│        │─────────────────────▶│                      │                  │
│        │                      │                      │                  │
│        │                      │ Miss? Load from DB   │                  │
│        │                      │─────────────────────▶│                  │
│        │                      │                      │                  │
│        │                      │◀─────────────────────│                  │
│        │                      │ Store in cache       │                  │
│        │                      │                      │                  │
│        │ 2. Return data       │                      │                  │
│        │◀─────────────────────│                      │                  │
│        │                      │                      │                  │
│   App не знает про DB!        │                      │                  │
└─────────────────────────────────────────────────────────────────────────┘
```

**Отличие от Cache-Aside:** В Cache-Aside приложение само управляет и кэшем, и БД. В Read-Through приложение работает только с кэшем.

**Когда использовать:**
- ✅ Когда хотите упростить код приложения
- ✅ Когда используете специализированные caching решения

### Сравнение стратегий

| Стратегия | Скорость чтения | Скорость записи | Консистентность | Риск |
|-----------|-----------------|-----------------|-----------------|------|
| Cache-Aside | Первый miss медленный | Средняя | Eventually | Низкий |
| Write-Through | Быстро | Медленно | Strong | Средний |
| Write-Behind | Быстро | Очень быстро | Eventually | ВЫСОКИЙ |
| Read-Through | Первый miss медленный | - | Eventually | Низкий |

**Рекомендация 2025:**
```
90% случаев → Cache-Aside
Это самый гибкий и безопасный паттерн.

Только если нужна консистентность → Write-Through
Только для некритичных данных → Write-Behind
```

---

## Redis: Швейцарский нож кэширования

Redis (REmote DIctionary Server) — самый популярный кэш в мире. Это in-memory database с persistence.

### Почему Redis?

| Характеристика | Описание |
|----------------|----------|
| **Скорость** | 100,000+ операций/сек на одном ядре |
| **Структуры данных** | Не только strings, но и lists, sets, hashes, sorted sets |
| **Persistence** | RDB snapshots + AOF log |
| **Pub/Sub** | Встроенная система сообщений |
| **Lua scripting** | Атомарные операции |
| **Cluster mode** | Горизонтальное масштабирование |

### Redis vs Memcached (2025)

| Критерий | Redis | Memcached |
|----------|-------|-----------|
| **Структуры данных** | Rich (10+ типов) | Только strings |
| **Persistence** | ✅ RDB + AOF | ❌ Нет |
| **Pub/Sub** | ✅ Есть | ❌ Нет |
| **Multi-threading** | Single + I/O threads | ✅ Full multi-threaded |
| **Скорость простых ops** | Очень быстро | Чуть быстрее |
| **Лицензия (2025)** | AGPLv3 (Redis 8.0+) | BSD (open source) |
| **Use case** | Универсальный | Простой high-throughput cache |

**Важно 2025:** Redis 8.0+ перешёл на AGPLv3. Альтернативы:
- **Valkey** — форк от Linux Foundation (полностью open source)
- **KeyDB** — многопоточный форк
- **Dragonfly** — современная альтернатива

### Базовые операции Redis (с объяснениями)

```typescript
// =============================================================
// ПОДКЛЮЧЕНИЕ К REDIS
// =============================================================
import Redis from 'ioredis';

// Создаём подключение с настройками отказоустойчивости
const redis = new Redis({
  host: 'localhost',           // Адрес сервера Redis
  port: 6379,                  // Стандартный порт Redis
  password: process.env.REDIS_PASSWORD,  // Пароль (если есть)

  // Настройки retry — что делать если Redis недоступен
  retryDelayOnFailover: 100,   // Ждать 100ms перед повтором
  maxRetriesPerRequest: 3      // Максимум 3 попытки
});

// =============================================================
// ПРОСТЫЕ ОПЕРАЦИИ (Strings)
// =============================================================

// SET — сохранить значение
await redis.set('key', 'value');
// Результат: OK

// SET с TTL — значение "умрёт" через 3600 секунд (1 час)
await redis.set('key', 'value', 'EX', 3600);
// EX = Expiration в секундах
// PX = Expiration в миллисекундах

// GET — получить значение
const value = await redis.get('key');  // 'value'

// DEL — удалить
await redis.del('key');

// EXISTS — проверить существование (1 = есть, 0 = нет)
const exists = await redis.exists('key');

// =============================================================
// МНОЖЕСТВЕННЫЕ ОПЕРАЦИИ (эффективнее чем по одному)
// =============================================================

// MSET — установить несколько значений за один запрос
await redis.mset('key1', 'val1', 'key2', 'val2', 'key3', 'val3');
// Одна команда вместо трёх = меньше network round-trips

// MGET — получить несколько значений
const values = await redis.mget('key1', 'key2', 'key3');
// Результат: ['val1', 'val2', 'val3']

// =============================================================
// АТОМАРНЫЕ СЧЁТЧИКИ
// =============================================================

// INCR — увеличить на 1 (атомарно!)
await redis.incr('page_views');
// Если ключа не было — создаст со значением 1
// Если был "5" — станет "6"

// INCRBY — увеличить на N
await redis.incrby('page_views', 10);

// Почему это важно?
// В многопоточной среде без атомарности:
// Thread 1: read 5, add 1, write 6
// Thread 2: read 5, add 1, write 6  <- потеряли инкремент!
//
// С INCR:
// Thread 1: INCR → 6
// Thread 2: INCR → 7  <- всё правильно!
```

### Структуры данных Redis (с примерами)

```typescript
// =============================================================
// HASH — для хранения объектов
// =============================================================
// Аналогия: Папка с именованными документами внутри

// Сохраняем пользователя как hash
await redis.hset('user:123', {
  name: 'John',
  email: 'john@example.com',
  role: 'admin',
  loginCount: '42'
});

// Получаем одно поле
const name = await redis.hget('user:123', 'name');  // 'John'

// Получаем все поля
const user = await redis.hgetall('user:123');
// { name: 'John', email: 'john@example.com', role: 'admin', loginCount: '42' }

// Увеличиваем поле (атомарно)
await redis.hincrby('user:123', 'loginCount', 1);  // Теперь 43

// ПОЧЕМУ Hash лучше JSON строки?
// 1. Можно обновить одно поле без чтения всего объекта
// 2. Меньше памяти (Redis оптимизирует маленькие hash)
// 3. Атомарные операции над полями

// =============================================================
// SET — уникальные значения (без порядка)
// =============================================================
// Аналогия: Мешок с уникальными шариками

// Добавляем права пользователя
await redis.sadd('user:123:permissions', 'read', 'write', 'delete');
// Повторное добавление 'read' ничего не изменит

// Проверяем есть ли право
const canDelete = await redis.sismember('user:123:permissions', 'delete');
// 1 (true) или 0 (false)

// Все права
const permissions = await redis.smembers('user:123:permissions');
// ['read', 'write', 'delete'] (порядок не гарантирован)

// Полезно для:
// - Теги товаров
// - Права доступа
// - Уникальные посетители (сегодня)

// =============================================================
// SORTED SET (ZSET) — упорядоченные уникальные значения
// =============================================================
// Аналогия: Таблица рейтингов

// Добавляем игроков с их очками
await redis.zadd('leaderboard',
  100, 'player1',   // score, member
  85, 'player2',
  120, 'player3',
  95, 'player4'
);

// Топ 3 игрока (по убыванию очков)
const top3 = await redis.zrevrange('leaderboard', 0, 2);
// ['player3', 'player1', 'player4']  (120, 100, 95)

// С очками
const top3WithScores = await redis.zrevrange('leaderboard', 0, 2, 'WITHSCORES');
// ['player3', '120', 'player1', '100', 'player4', '95']

// Позиция конкретного игрока (0-based, по возрастанию)
const rank = await redis.zrank('leaderboard', 'player1');  // 2 (третий снизу)
const revRank = await redis.zrevrank('leaderboard', 'player1');  // 1 (второй сверху)

// Полезно для:
// - Лидерборды игр
// - Trending topics
// - Rate limiting с timestamps

// =============================================================
// LIST — упорядоченный список
// =============================================================
// Аналогия: Очередь в магазине

// Добавляем в начало (слева)
await redis.lpush('queue', 'task3', 'task2', 'task1');
// Очередь теперь: task1, task2, task3

// Забираем с конца (справа) — FIFO очередь
const task = await redis.rpop('queue');  // 'task3'

// Забираем с начала — LIFO стек
const lastTask = await redis.lpop('queue');  // 'task1'

// Полезно для:
// - Job queues
// - Activity feeds
// - Last N items
```

### Паттерны использования Redis

```typescript
// =============================================================
// ПАТТЕРН 1: Универсальный Cache Wrapper
// =============================================================

async function getWithCache<T>(
  key: string,
  ttlSeconds: number,
  fallback: () => Promise<T>  // Функция для получения данных если нет в кэше
): Promise<T> {

  // Шаг 1: Проверяем кэш
  const cached = await redis.get(key);
  if (cached) {
    // Шаг 2a: Нашли — возвращаем (десериализуем из JSON)
    return JSON.parse(cached);
  }

  // Шаг 2b: Не нашли — вызываем fallback (идём в БД/API)
  const data = await fallback();

  // Шаг 3: Сохраняем в кэш для следующих запросов
  await redis.set(key, JSON.stringify(data), 'EX', ttlSeconds);

  return data;
}

// Использование — элегантно и просто:
const user = await getWithCache(
  `user:${id}`,           // Ключ кэша
  3600,                   // TTL: 1 час
  () => db.users.findById(id)  // Fallback: запрос в БД
);

// =============================================================
// ПАТТЕРН 2: Distributed Lock (Mutex)
// =============================================================
// Проблема: Только один процесс должен выполнять операцию
// Пример: Обновление курса валют — не нужно 100 параллельных запросов к API

async function withLock<T>(
  lockKey: string,      // Имя лока
  ttlMs: number,        // Максимальное время удержания
  fn: () => Promise<T>  // Функция для выполнения
): Promise<T> {

  // Генерируем уникальный ID для этого держателя лока
  // Нужен чтобы только владелец мог освободить лок
  const lockValue = crypto.randomUUID();

  // Пытаемся получить лок
  // SET key value PX ttl NX — атомарная операция
  const acquired = await redis.set(
    lockKey,
    lockValue,
    'PX', ttlMs,  // PX = expire в миллисекундах
    'NX'          // NX = Only if Not eXists
  );

  // Если лок уже занят — кто-то другой работает
  if (!acquired) {
    throw new Error('Could not acquire lock');
  }

  try {
    // Выполняем защищённую операцию
    return await fn();
  } finally {
    // КРИТИЧНО: Освобождаем лок только если это НАШ лок
    // Используем Lua script для атомарности
    const releaseLockScript = `
      -- Проверяем что значение совпадает (это наш лок)
      if redis.call("get", KEYS[1]) == ARGV[1] then
        -- Удаляем лок
        return redis.call("del", KEYS[1])
      else
        -- Это не наш лок — не трогаем
        return 0
      end
    `;
    await redis.eval(releaseLockScript, 1, lockKey, lockValue);
  }
}

// Использование:
const exchangeRates = await withLock(
  'lock:exchange-rates',
  30000,  // Максимум 30 секунд
  async () => {
    // Только один процесс выполнит этот код
    return await fetchExchangeRatesFromAPI();
  }
);
```

**Почему Lua скрипт для освобождения лока?**

```
БЕЗ Lua (НЕ безопасно):
┌────────────────────────────────────────────────────────────────┐
│ Process A:                                                     │
│   1. GET lock:mylock → "uuid-A" (мой!)                         │
│   2. ... network delay ...                                     │
│   3. DEL lock:mylock                                           │
│                                                                │
│ Process B (между шагами 1 и 3 процесса A):                     │
│   1. Лок A истёк по TTL                                        │
│   2. SET lock:mylock "uuid-B" NX → успех!                      │
│   3. Начинает работу...                                        │
│                                                                │
│ Process A:                                                     │
│   3. DEL lock:mylock — УДАЛИЛ ЛОК ПРОЦЕССА B!                  │
│                                                                │
│ Результат: Два процесса работают одновременно = BAD!           │
└────────────────────────────────────────────────────────────────┘

С Lua (безопасно):
┌────────────────────────────────────────────────────────────────┐
│ Lua скрипт атомарен — между GET и DEL никто не вклинится       │
│                                                                │
│ Process A:                                                     │
│   EVAL "if get == myvalue then del" → 0 (не мой лок)           │
│                                                                │
│ Лок Process B не затронут!                                     │
└────────────────────────────────────────────────────────────────┘
```

---

## HTTP Caching

Браузеры и CDN используют HTTP заголовки для кэширования.

### Cache-Control заголовок

```
┌─────────────────────────────────────────────────────────────────┐
│                    CACHE-CONTROL HEADER                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Cache-Control: max-age=3600, public                            │
│                                                                 │
│  Директивы:                                                     │
│  ─────────                                                      │
│  max-age=N     Кэшировать N секунд                              │
│                Пример: max-age=86400 = 1 день                   │
│                                                                 │
│  public        Можно кэшировать везде                           │
│                CDN, proxy, браузер                              │
│                                                                 │
│  private       ТОЛЬКО браузер пользователя                      │
│                Для персональных данных                          │
│                                                                 │
│  no-cache      Можно кэшировать, но ВСЕГДА проверять свежесть   │
│                Браузер спросит "изменилось?"                    │
│                                                                 │
│  no-store      НИКОГДА не кэшировать                            │
│                Для sensitive данных (пароли, токены)            │
│                                                                 │
│  immutable     Контент НИКОГДА не изменится                     │
│                Для файлов с хешем в имени (app.abc123.js)       │
│                                                                 │
│  stale-while-  Можно использовать stale, пока обновляется       │
│  revalidate    Для лучшего UX                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### ETag — проверка изменений

```
ETag (Entity Tag) — "отпечаток" контента

Первый запрос:
┌─────────────────────────────────────────────────────────────────┐
│ Client                         Server                           │
│                                                                 │
│ GET /api/product/123                                            │
│ ─────────────────────────────▶                                  │
│                                                                 │
│                               HTTP/1.1 200 OK                   │
│                               ETag: "abc123def456"              │
│                               Content-Type: application/json    │
│                               {"id": 123, "name": "Widget"}     │
│ ◀─────────────────────────────                                  │
│                                                                 │
│ [Браузер сохраняет ETag]                                        │
└─────────────────────────────────────────────────────────────────┘

Следующий запрос (данные не изменились):
┌─────────────────────────────────────────────────────────────────┐
│ Client                         Server                           │
│                                                                 │
│ GET /api/product/123                                            │
│ If-None-Match: "abc123def456"                                   │
│ ─────────────────────────────▶                                  │
│                                                                 │
│                               Проверяет: ETag совпадает?        │
│                               Да → данные не изменились         │
│                                                                 │
│                               HTTP/1.1 304 Not Modified         │
│                               [Тело НЕ передаётся]              │
│ ◀─────────────────────────────                                  │
│                                                                 │
│ [Браузер использует закэшированную версию]                      │
│                                                                 │
│ Экономия: не передаём тело ответа                               │
└─────────────────────────────────────────────────────────────────┘
```

### Примеры HTTP кэширования

```typescript
// =============================================================
// EXPRESS: Настройка кэширования для разных типов данных
// =============================================================

// ПУБЛИЧНЫЙ КОНТЕНТ — кэшировать везде
// Пример: Каталог товаров (одинаковый для всех)
app.get('/api/products', (req, res) => {
  const products = getProducts();

  // public = CDN и браузер могут кэшировать
  // max-age=3600 = кэш валиден 1 час
  res.set('Cache-Control', 'public, max-age=3600');

  // ETag для проверки изменений
  res.set('ETag', generateETag(products));

  res.json(products);
});

// ПРИВАТНЫЙ КОНТЕНТ — только браузер пользователя
// Пример: Профиль пользователя
app.get('/api/user/profile', authenticate, (req, res) => {
  const profile = getUserProfile(req.user.id);

  // private = ТОЛЬКО браузер этого пользователя
  // НЕ CDN, НЕ shared proxy
  res.set('Cache-Control', 'private, max-age=300');  // 5 минут

  res.json(profile);
});

// НЕ КЭШИРОВАТЬ — sensitive или часто меняющиеся данные
// Пример: Уведомления, баланс счёта
app.get('/api/user/notifications', authenticate, (req, res) => {
  const notifications = getNotifications(req.user.id);

  // no-store = НИКОГДА не сохранять
  res.set('Cache-Control', 'no-store');

  res.json(notifications);
});

// СТАТИЧЕСКИЕ ФАЙЛЫ с версионированием
// Файлы с хешем в имени: app.abc123.js
app.use('/static', express.static('public', {
  maxAge: '1y',      // Кэшировать год
  immutable: true,   // Файл НИКОГДА не изменится (хеш гарантирует)
  etag: false        // ETag не нужен — immutable достаточно
}));

// ВАЖНО: При изменении кода генерируется НОВЫЙ файл с НОВЫМ хешем
// Старый: /static/app.abc123.js
// Новый:  /static/app.def456.js
// Браузер автоматически загрузит новый файл
```

---

## Инвалидация кэша

> "There are only two hard things in Computer Science: cache invalidation and naming things."
> — Phil Karlton

### Почему это сложно?

```
Проблема:
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  1. Пользователь меняет email в настройках                      │
│                                                                 │
│  2. База данных обновлена:                                      │
│     users SET email = 'new@example.com' WHERE id = 123          │
│                                                                 │
│  3. В кэше всё ещё старый email:                                │
│     user:123 = {"email": "old@example.com", ...}                │
│                                                                 │
│  4. Другой пользователь видит старый email на странице профиля  │
│                                                                 │
│  Результат: STALE DATA (устаревшие данные)                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Стратегии инвалидации

#### 1. TTL (Time To Live) — самый простой

```
Идея: Данные автоматически устаревают через N секунд

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  SET user:123 "{...}" EX 3600                                   │
│                       ↑                                         │
│                    1 час TTL                                    │
│                                                                 │
│  Timeline:                                                      │
│  ─────────────────────────────────────────────────────────────  │
│  T=0         T=30min       T=1h          T=1h+1s                │
│  │           │             │             │                      │
│  SET         GET (hit)     GET (hit)     GET (miss → DB)        │
│  ↓           ↓             ↓             ↓                      │
│  Cache:      Cache:        Cache:        Cache:                 │
│  FRESH       FRESH         STALE         EMPTY → reload         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

✅ Плюсы:
   - Просто реализовать (одна строка кода)
   - Не требует tracking зависимостей
   - Гарантированное обновление

❌ Минусы:
   - Данные неактуальны до TTL
   - Короткий TTL = больше нагрузки на БД
   - Длинный TTL = дольше stale data
```

**Как выбрать TTL:**

| Тип данных | TTL | Почему |
|------------|-----|--------|
| Статические (конфиги) | 24ч+ | Меняются редко |
| Каталог товаров | 1-4ч | Обновления нечастые |
| Профиль пользователя | 5-30 мин | Может измениться |
| Live данные (акции) | 5-60 сек | Частые изменения |
| Session data | Пока активен | Нельзя устареть |

#### 2. Event-Based — инвалидация при изменении

```
Идея: При изменении данных — сразу удаляем/обновляем кэш

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  UPDATE users SET email = '...' WHERE id = 123                  │
│                   │                                             │
│                   ▼                                             │
│  After DB Update Trigger:                                       │
│                   │                                             │
│                   ▼                                             │
│  DEL user:123    (удаляем старый кэш)                           │
│                                                                 │
│  Следующий GET → Cache miss → Загрузка свежих данных            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

✅ Плюсы:
   - Данные всегда актуальны
   - Нет stale data

❌ Минусы:
   - Нужно знать ВСЕ зависимые ключи
   - Сложнее реализовать
   - Риск "забыть" инвалидировать что-то
```

```typescript
// =============================================================
// EVENT-BASED ИНВАЛИДАЦИЯ: Паттерн с регистрацией зависимостей
// =============================================================

class CacheInvalidator {
  private redis: Redis;

  // Карта: какие ключи инвалидировать при изменении какой сущности
  private patterns: Map<string, string[]> = new Map();

  constructor(redis: Redis) {
    this.redis = redis;

    // Регистрируем паттерны зависимостей
    // Формат: entity → [ключи, которые нужно инвалидировать]

    this.patterns.set('user', [
      'user:*',              // Профиль пользователя
      'team:*:members',      // Списки членов команд (содержат имена)
      'feed:*',              // Ленты (могут показывать данные пользователя)
      'leaderboard:*'        // Рейтинги (имена игроков)
    ]);

    this.patterns.set('post', [
      'post:*',              // Сам пост
      'feed:*',              // Ленты с постами
      'user:*:posts',        // Списки постов пользователя
      'search:posts:*'       // Результаты поиска
    ]);

    this.patterns.set('product', [
      'product:*',           // Сам продукт
      'category:*:products', // Списки продуктов в категориях
      'cart:*',              // Корзины (цены могли измениться)
      'search:*'             // Результаты поиска
    ]);
  }

  async invalidate(entity: string, id: string) {
    const patterns = this.patterns.get(entity) || [];

    // Удаляем все зависимые ключи
    for (const pattern of patterns) {
      const key = pattern.replace('*', id);
      await this.redis.del(key);
    }

    // Для распределённой системы: уведомляем другие инстансы
    // через Pub/Sub
    await this.redis.publish('cache:invalidate', JSON.stringify({
      entity,
      id,
      timestamp: Date.now()
    }));
  }
}

// Использование в сервисе
class UserService {
  constructor(
    private db: Database,
    private cache: Redis,
    private invalidator: CacheInvalidator
  ) {}

  async updateUser(id: string, data: UserUpdate) {
    // 1. Обновляем БД (source of truth)
    const user = await this.db.users.update(id, data);

    // 2. Инвалидируем все зависимые кэши
    await this.invalidator.invalidate('user', id);

    return user;
  }
}
```

#### 3. Version-Based — версионирование ключей

```
Идея: Вместо удаления — увеличиваем версию, старые ключи игнорируются

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  Старый подход:                                                 │
│  user:123 → данные                                              │
│  При изменении: DEL user:123                                    │
│                                                                 │
│  Version-based:                                                 │
│  user:123:v1 → старые данные                                    │
│  user:123:v2 → новые данные   ← текущая версия                  │
│                                                                 │
│  global:user:123:version = 2                                    │
│                                                                 │
│  При чтении:                                                    │
│  1. Получить текущую версию: GET global:user:123:version → 2    │
│  2. Читать ключ: GET user:123:v2                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

✅ Плюсы:
   - Инвалидация = просто увеличить версию (быстро)
   - Старые данные сами "вымрутся" по TTL
   - Можно откатиться на предыдущую версию

❌ Минусы:
   - Память заполняется старыми версиями
   - Лишний запрос на получение версии
   - Сложнее в реализации
```

---

## Подводные камни

### Проблема 1: Thundering Herd (Cache Stampede)

**Что это:** Популярный ключ истекает → тысячи запросов одновременно идут в БД → БД падает.

```
┌─────────────────────────────────────────────────────────────────┐
│                    CACHE STAMPEDE                               │
│                                                                 │
│  Время: 12:00:00 — Ключ "hot_product:123" истекает              │
│                                                                 │
│  12:00:00.001  Request 1 ──▶ Cache Miss ──▶ DB Query            │
│  12:00:00.002  Request 2 ──▶ Cache Miss ──▶ DB Query            │
│  12:00:00.003  Request 3 ──▶ Cache Miss ──▶ DB Query            │
│  ...                                                            │
│  12:00:00.100  Request 1000 ──▶ Cache Miss ──▶ DB Query         │
│                                                                 │
│                                        ▼                        │
│                               ┌─────────────────┐               │
│                               │   💥 DATABASE    │               │
│                               │   OVERLOADED    │               │
│                               │   TIMEOUT       │               │
│                               └─────────────────┘               │
│                                                                 │
│  Все 1000 запросов делают ОДИНАКОВЫЙ запрос к БД!               │
│  Это называется Thundering Herd — "стадо бизонов"               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Реальные случаи:**
- Twitter, Reddit, Instagram публично описывали такие инциденты
- Black Friday распродажи с "горячими" товарами
- Выход популярного контента (Apple keynote, Game of Thrones)

**Решения:**

#### Решение 1: Distributed Lock (только один обновляет)

```typescript
// Только ОДИН запрос идёт в БД, остальные ждут

async function getWithLock<T>(
  key: string,
  ttl: number,
  fallback: () => Promise<T>
): Promise<T> {

  // Пробуем получить из кэша
  const cached = await redis.get(key);
  if (cached) {
    return JSON.parse(cached);
  }

  // Cache miss — пробуем получить лок
  const lockKey = `${key}:lock`;
  const acquired = await redis.set(lockKey, '1', 'EX', 30, 'NX');

  if (acquired) {
    // МЫ получили лок — идём в БД
    try {
      const data = await fallback();
      await redis.set(key, JSON.stringify(data), 'EX', ttl);
      return data;
    } finally {
      await redis.del(lockKey);
    }
  } else {
    // Кто-то другой обновляет — ждём и повторяем
    await sleep(100);  // Ждём 100ms
    return getWithLock(key, ttl, fallback);  // Рекурсия
  }
}
```

#### Решение 2: Stale-While-Revalidate (отдаём старое, обновляем в фоне)

```typescript
// Отдаём stale данные сразу, обновляем асинхронно

async function getWithSWR<T>(
  key: string,
  ttl: number,
  staleTtl: number,  // Дополнительное время для stale данных
  fallback: () => Promise<T>
): Promise<T> {

  const cached = await redis.get(key);
  if (cached) {
    const { data, expireAt } = JSON.parse(cached);
    const now = Date.now();

    if (now < expireAt) {
      // Данные свежие — отдаём
      return data;
    }

    if (now < expireAt + staleTtl * 1000) {
      // Данные stale, но ещё можно использовать
      // Запускаем обновление в ФОНЕ
      refreshInBackground(key, ttl, staleTtl, fallback);

      // Отдаём stale данные СРАЗУ (пользователь не ждёт)
      return data;
    }
  }

  // Нет данных или совсем устарели — синхронное обновление
  return refresh(key, ttl, staleTtl, fallback);
}

async function refreshInBackground<T>(...args) {
  // Запускаем без await — не блокируем ответ
  refresh(...args).catch(err => console.error('Background refresh failed:', err));
}
```

#### Решение 3: TTL Jitter (рандомизация)

```typescript
// Добавляем случайность к TTL чтобы ключи не истекали одновременно

function getRandomizedTTL(baseTTL: number): number {
  // TTL ± 10-20%
  const jitter = baseTTL * 0.1 * (Math.random() * 2 - 1);
  return Math.floor(baseTTL + jitter);
}

// Вместо:
await redis.set(key, value, 'EX', 3600);

// Используем:
await redis.set(key, value, 'EX', getRandomizedTTL(3600));
// Результат: TTL от 3240 до 3960 секунд

// Теперь 1000 ключей не истекут одновременно!
```

### Проблема 2: Cache Penetration

**Что это:** Запросы несуществующих данных всегда идут в БД (кэш не помогает).

```
┌─────────────────────────────────────────────────────────────────┐
│                    CACHE PENETRATION                            │
│                                                                 │
│  Атакующий или баг запрашивает несуществующие данные:           │
│                                                                 │
│  GET /api/user/999999999  → Cache miss → DB: not found          │
│  GET /api/user/999999998  → Cache miss → DB: not found          │
│  GET /api/user/999999997  → Cache miss → DB: not found          │
│  ...                                                            │
│                                                                 │
│  Каждый запрос:                                                 │
│  1. Смотрим в кэш → пусто                                       │
│  2. Идём в БД → null                                            │
│  3. Не кэшируем null                                            │
│  4. Следующий запрос → repeat                                   │
│                                                                 │
│  Кэш НЕ ПОМОГАЕТ — 100% запросов идут в БД!                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Решения:**

```typescript
// Решение 1: Кэшировать NULL значения
async function getUser(id: string): Promise<User | null> {
  const cached = await redis.get(`user:${id}`);

  // Проверяем на специальное NULL значение
  if (cached === 'NULL') {
    return null;  // Не идём в БД — мы знаем что там пусто
  }

  if (cached) {
    return JSON.parse(cached);
  }

  const user = await db.users.findById(id);

  if (user) {
    await redis.set(`user:${id}`, JSON.stringify(user), 'EX', 3600);
  } else {
    // Кэшируем NULL с коротким TTL
    await redis.set(`user:${id}`, 'NULL', 'EX', 300);  // 5 минут
  }

  return user;
}

// Решение 2: Bloom Filter для быстрой проверки "точно нет"
// Bloom Filter — вероятностная структура данных
// Говорит: "точно нет" или "возможно есть"
const bloomFilter = new BloomFilter();
bloomFilter.addAll(existingUserIds);

async function getUserWithBloom(id: string): Promise<User | null> {
  // Быстрая проверка — O(1), без сети
  if (!bloomFilter.mightContain(id)) {
    return null;  // 100% гарантия что нет
  }

  // Дальше обычная логика...
}
```

### Проблема 3: Hot Key

**Что это:** Один ключ получает непропорционально много запросов.

```
┌─────────────────────────────────────────────────────────────────┐
│                       HOT KEY PROBLEM                           │
│                                                                 │
│  Распределение запросов:                                        │
│                                                                 │
│  product:iphone15  ████████████████████████████████  10,000 RPS │
│  product:samsung   ████                                500 RPS  │
│  product:pixel     ██                                  200 RPS  │
│  product:others    █                                   100 RPS  │
│                                                                 │
│  Проблема:                                                      │
│  - Один ключ = один Redis shard                                 │
│  - 10,000 RPS на один сервер                                    │
│  - Network bottleneck                                           │
│  - Redis CPU saturated                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Решения:**

```typescript
// Решение 1: Local Cache (L1) + Redis (L2)
// Горячие ключи держим в памяти процесса

import { LRUCache } from 'lru-cache';

const localCache = new LRUCache<string, any>({
  max: 1000,           // Максимум 1000 записей
  ttl: 1000 * 60,      // TTL 1 минута
});

async function getWithL1L2<T>(key: string, fallback: () => Promise<T>): Promise<T> {
  // L1: Проверяем локальный кэш (память процесса)
  const local = localCache.get(key);
  if (local) return local;  // 0ms, без сети

  // L2: Проверяем Redis
  const cached = await redis.get(key);
  if (cached) {
    const data = JSON.parse(cached);
    localCache.set(key, data);  // Сохраняем в L1
    return data;
  }

  // Cache miss — идём в БД
  const data = await fallback();
  await redis.set(key, JSON.stringify(data), 'EX', 3600);
  localCache.set(key, data);
  return data;
}

// Решение 2: Key Replication (несколько копий ключа)
async function getHotKey(baseKey: string): Promise<any> {
  // Случайно выбираем одну из реплик
  const replicaNumber = Math.floor(Math.random() * 5);  // 0-4
  const key = `${baseKey}:replica:${replicaNumber}`;

  return await redis.get(key);
}

// При записи — обновляем все реплики
async function setHotKey(baseKey: string, value: any): Promise<void> {
  const pipeline = redis.pipeline();
  for (let i = 0; i < 5; i++) {
    pipeline.set(`${baseKey}:replica:${i}`, value, 'EX', 3600);
  }
  await pipeline.exec();
}
```

---

## Мониторинг кэша

### Ключевые метрики

| Метрика | Что означает | Целевое значение |
|---------|--------------|------------------|
| **Hit Rate** | % запросов из кэша | > 90% |
| **Miss Rate** | % запросов в БД | < 10% |
| **Latency P50/P99** | Время ответа | P50 < 1ms, P99 < 5ms |
| **Memory Usage** | Использование памяти | 60-80% |
| **Eviction Rate** | Скорость вытеснения | < 5%/час |
| **Connection Count** | Активные соединения | Стабильно |

### Redis INFO команды

```bash
# Получить статистику по хитам/миссам
redis-cli INFO stats | grep keyspace

# Результат:
# keyspace_hits:1234567    ← Количество hit
# keyspace_misses:1234     ← Количество miss

# Hit rate = hits / (hits + misses) = 99.9%

# Память
redis-cli INFO memory | grep used_memory_human
# used_memory_human:1.5G

# Подключения
redis-cli INFO clients | grep connected_clients
# connected_clients:150
```

---

## Actionable: С чего начать

### Минимальный Redis wrapper

```typescript
// Скопируйте этот код и начните использовать

const cache = {
  // Получить с fallback
  async get<T>(
    key: string,
    fallback: () => Promise<T>,
    ttl = 3600
  ): Promise<T> {
    const cached = await redis.get(key);
    if (cached) return JSON.parse(cached);

    const data = await fallback();
    await redis.set(key, JSON.stringify(data), 'EX', ttl);
    return data;
  },

  // Инвалидация
  async invalidate(...keys: string[]): Promise<void> {
    if (keys.length) await redis.del(...keys);
  },

  // Установить напрямую
  async set(key: string, data: any, ttl = 3600): Promise<void> {
    await redis.set(key, JSON.stringify(data), 'EX', ttl);
  }
};

// Использование:
const user = await cache.get(
  `user:${id}`,
  () => db.users.findById(id),
  3600
);
```

### Чеклист внедрения кэширования

```
□ Определить что кэшировать
  ├── Частые запросы (top 20% по трафику)
  ├── Тяжёлые запросы (> 100ms)
  └── Редко меняющиеся данные

□ Выбрать TTL для каждого типа данных
  ├── Статические данные: 1-24 часа
  ├── Динамические данные: 1-30 минут
  └── Добавить jitter ±10%

□ Продумать инвалидацию
  ├── Какие события требуют инвалидации?
  ├── Какие ключи зависят друг от друга?
  └── TTL + Event-based = надёжнее

□ Настроить мониторинг
  ├── Hit rate (цель: > 90%)
  ├── Latency P99
  └── Memory usage

□ Подготовить план на случай падения кэша
  ├── Приложение должно работать без кэша
  ├── Rate limiting на БД
  └── Graceful degradation
```

---

## Распространённые ошибки

| Ошибка | Почему плохо | Как правильно |
|--------|--------------|---------------|
| Кэшировать всё подряд | Память не бесконечна | Только горячие данные |
| TTL = 0 или нет TTL | Данные никогда не обновятся | Всегда ставить TTL |
| Забыть про инвалидацию | Stale data | Event-based + TTL |
| Кэш как source of truth | Потеря данных при падении | БД = source of truth |
| Сложные ключи | Сложно инвалидировать | Простая структура: entity:id |
| Игнорировать cache miss | Thundering herd | Locking или SWR |

---

## Связи

- Кэш в микросервисах: [[microservices-vs-monolith]]
- API rate limiting: [[api-design]]
- Мониторинг кэша: [[observability]]
- HTTP кэширование: [[network-http-evolution]]
- Память JVM: [[jvm-memory-model]]

---

## Источники

| # | Источник | Тип | Достоверность | Вклад |
|---|----------|-----|---------------|-------|
| 1 | [AWS: Database Caching Strategies Using Redis](https://docs.aws.amazon.com/whitepapers/latest/database-caching-strategies-using-redis/caching-patterns.html) | Whitepaper | 0.95 | Caching patterns |
| 2 | [Redis Documentation](https://redis.io/docs/) | Документация | 0.95 | Commands, data structures |
| 3 | [Cache Strategies: A Complete Guide with Real-Life Examples](https://dev.to/jaiminbariya/cache-strategies-a-complete-guide-with-real-life-examples-416p) | Статья | 0.85 | Аналогии, примеры |
| 4 | [ByteByteGo: A Crash Course in Caching](https://blog.bytebytego.com/p/a-crash-course-in-caching-final-part) | Статья | 0.90 | Stampede solutions |
| 5 | [Azure: Caching Guidance](https://learn.microsoft.com/en-us/azure/architecture/best-practices/caching) | Документация | 0.95 | Best practices |
| 6 | [Redis: Distributed Locks](https://redis.io/docs/latest/develop/clients/patterns/distributed-locks/) | Документация | 0.95 | Redlock algorithm |
| 7 | [Medium: Multi-Level Caching in Microservices](https://medium.com/@jazeem10/distributed-multi-level-caching-in-microservices-a0bc29221dcb) | Статья | 0.80 | L1/L2 architecture |
| 8 | [Hazelcast: Caching Best Practices](https://hazelcast.com/foundations/caching/caching-best-practices/) | Руководство | 0.85 | Best practices |
| 9 | [Redis Blog: Caching Strategies](https://redis.io/blog/why-your-caching-strategies-might-be-holding-you-back-and-what-to-consider-next/) | Статья | 0.90 | Modern patterns |
| 10 | [Martin Fowler: Two Hard Things](https://martinfowler.com/bliki/TwoHardThings.html) | Статья | 0.95 | Cache invalidation |
| 11 | [Thundering Herd Problem Solutions](https://howtech.substack.com/p/thundering-herd-problem-cache-stampede) | Статья | 0.85 | Stampede prevention |
| 12 | [CodeAnalogies: Web Caching Explained](https://blog.codeanalogies.com/2018/06/11/web-caching-explained-by-buying-milk-at-the-supermarket/) | Статья | 0.80 | Beginner analogies |

---

**Последняя верификация**: 2026-01-02
**Уровень достоверности**: high

---

*Проверено: 2026-01-09*
