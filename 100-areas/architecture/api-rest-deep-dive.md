---
title: "REST API: от диссертации Филдинга до production"
created: 2026-02-10
modified: 2026-02-10
type: deep-dive
status: published
confidence: high
sources_verified: true
tags:
  - topic/architecture
  - architecture/api
  - architecture/rest
  - backend/rest
  - type/deep-dive
  - level/intermediate
related:
  - "[[api-design]]"
  - "[[api-graphql-deep-dive]]"
  - "[[api-grpc-deep-dive]]"
  - "[[api-modern-patterns]]"
  - "[[network-http-evolution]]"
  - "[[caching-strategies]]"
  - "[[architecture-resilience-patterns]]"
  - "[[security-api-protection]]"
cs-foundations:
  - client-server
  - statelessness
  - caching
  - idempotency
  - content-negotiation
  - uniform-interface
---

# REST API: от диссертации Филдинга до production

В 2000 году Рой Филдинг защитил докторскую в UC Irvine. Он не изобретал новую технологию — он описал, *почему* Web уже работает. Шесть архитектурных ограничений, которые он вывел, стали фундаментом REST. Ирония в том, что большинство «RESTful» API нарушают минимум три из них.

---

## Prerequisites

| Тема | Зачем нужна | Где изучить |
|------|-------------|-------------|
| **HTTP протокол** | REST построен поверх HTTP — методы, статусы, заголовки | [[network-http-evolution]] |
| **JSON** | Основной формат обмена данными в REST API | Базовые знания |
| **Клиент-серверная архитектура** | Фундаментальное разделение ответственности | [[api-design]] |
| **Базовое кэширование** | Один из шести REST constraints | [[caching-strategies]] |

---

## Терминология

| Термин | Что это | Аналогия |
|--------|---------|----------|
| **REST** | Representational State Transfer — архитектурный стиль, не протокол | Набор правил проектирования, как ГОСТ для зданий |
| **Resource** | Любая сущность, к которой можно обратиться по URI | Книга в библиотеке с уникальным шифром |
| **Representation** | Конкретное представление ресурса (JSON, XML, HTML) | Книга может быть в бумаге, аудио или электронном виде |
| **URI** | Uniform Resource Identifier — уникальный адрес ресурса | Адрес дома: город/улица/дом/квартира |
| **Statelessness** | Каждый запрос содержит всю информацию для обработки | Каждый звонок в поддержку — с нуля, оператор не помнит прошлый |
| **Idempotency** | Повторный запрос даёт тот же результат | Нажатие кнопки лифта: жми 10 раз — приедет один раз |
| **HATEOAS** | Hypermedia As The Engine Of Application State | Меню сайта — навигация встроена в ответ |
| **Content Negotiation** | Клиент и сервер договариваются о формате данных | Просишь «то же блюдо, но без глютена» |
| **ETag** | Entity Tag — хеш версии ресурса для кэширования | Серийный номер на товаре — изменился номер = изменился товар |
| **Idempotency Key** | Уникальный ключ запроса для безопасного retry | Номер квитанции — повторная оплата по тому же номеру не спишет дважды |

---

## Зачем это нужно: история и проблема

### Контекст: Web в конце 1990-х

К 1999 году Web уже обслуживал миллионы пользователей. HTTP/1.0 превратился в HTTP/1.1. Но архитектурных принципов, объясняющих *почему* Web масштабируется, не существовало. Каждый строил распределённые системы по-своему.

Параллельно набирал обороты SOAP — протокол от Microsoft, IBM и других гигантов enterprise-мира. SOAP обещал стандартизированный RPC (Remote Procedure Call) через XML:

```xml
<!-- SOAP-запрос: получить пользователя -->
<!-- Обрати внимание на объём XML для простейшей операции -->
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Header>
    <auth:Token>abc123</auth:Token>
  </soap:Header>
  <soap:Body>
    <GetUser xmlns="http://api.example.com/users">
      <UserId>123</UserId>
    </GetUser>
  </soap:Body>
</soap:Envelope>
```

SOAP работал. Oracle, HP, Sun строили на нём enterprise-системы. Но были проблемы:

- **Вербозность**: XML-обёртка раздувала запросы в 5-10 раз
- **Сложность**: стандарты WS-Security, WS-ReliableMessaging, WS-AtomicTransaction — каждый добавлял слой абстракции
- **Жёсткая связность**: WSDL-контракты привязывали клиента к серверу намертво
- **Один endpoint, один метод**: всё шло через POST на один URL — HTTP использовался как транспорт, не как протокол

### Рой Филдинг и рождение REST (2000)

Рой Филдинг не был теоретиком. Он соавтор спецификации HTTP/1.1 (RFC 2616) и один из основателей Apache HTTP Server. Когда он садился за диссертацию, у него были годы практического опыта с протоколом, который уже масштабировался на весь мир.

Диссертация «Architectural Styles and the Design of Network-based Software Architectures» не предлагала новый протокол. Филдинг пошёл в обратном направлении — **вывел архитектурный стиль из работающей системы** (Web), постепенно добавляя ограничения к «чистому» клиент-серверу.

Метод Филдинга:
1. Начать с нуля — без ограничений
2. Добавить Client-Server → получить разделение ответственности
3. Добавить Statelessness → получить масштабируемость
4. Добавить Cacheability → получить производительность
5. Добавить Uniform Interface → получить простоту и независимую эволюцию
6. Добавить Layered System → получить гибкость инфраструктуры
7. Опционально: Code-on-Demand → получить расширяемость

Результат — шесть ограничений, которые объясняют, почему Web работает. И одновременно — набор принципов для проектирования API, которые масштабируются.

### Почему REST победил SOAP

```
┌───────────────────────────────────────────────────────────────────┐
│                    SOAP vs REST: ПОЧЕМУ REST ПОБЕДИЛ              │
├───────────────────────────────────────────────────────────────────┤
│                                                                   │
│  SOAP (2000-е)                    REST (2000+)                    │
│  ──────────────                   ─────────────                   │
│  XML обязателен                   Любой формат (JSON, XML, HTML)  │
│  Один URL, один метод (POST)      Разные URL для разных ресурсов  │
│  WSDL для описания                URI + HTTP-глаголы              │
│  WS-* стек (сложность)            HTTP-заголовки (простота)       │
│  Своя система ошибок              HTTP status codes               │
│  Enterprise-инструменты           curl + браузер                  │
│                                                                   │
│  ПЕРЕЛОМНЫЙ МОМЕНТ:                                               │
│  2006: Amazon Web Services — REST API получает в 6 раз            │
│  больше трафика, чем SOAP-версия того же сервиса.                 │
│                                                                   │
│  2008-2012: Salesforce, eBay, Yahoo, Google, Twitter —             │
│  все переходят на REST. SOAP остаётся в enterprise-legacy.        │
│                                                                   │
│  ГДЕ SOAP ЕЩЁ ЖИВ:                                               │
│  • Банки (ACID-транзакции через WS-AtomicTransaction)             │
│  • Госсистемы (СМЭВ в России, legacy-интеграции)                  │
│  • SAP, Oracle ERP (исторические интерфейсы)                      │
│  • Здравоохранение (HL7 + SOAP)                                   │
│                                                                   │
└───────────────────────────────────────────────────────────────────┘
```

---

## Шесть REST constraints: фундамент архитектуры

Это не «рекомендации» — это **ограничения**, нарушение которых означает, что система не является RESTful. Филдинг неоднократно подчёркивал: если API не реализует все шесть constraints — это не REST, даже если использует JSON поверх HTTP.

```
┌───────────────────────────────────────────────────────────────────┐
│                    6 REST CONSTRAINTS                              │
├───────────────────────────────────────────────────────────────────┤
│                                                                   │
│   ┌─────────────┐  ┌──────────────┐  ┌─────────────────┐         │
│   │  1. Client  │  │ 2. Stateless │  │  3. Cacheable   │         │
│   │   Server    │  │              │  │                 │         │
│   │ Разделение  │  │ Каждый запрос│  │ Ответы должны   │         │
│   │ забот       │→ │ самодостаточ.│→ │ помечаться как   │         │
│   │             │  │              │  │ кэшируемые      │         │
│   └─────────────┘  └──────────────┘  └─────────────────┘         │
│          │                │                    │                   │
│          ▼                ▼                    ▼                   │
│   ┌─────────────┐  ┌──────────────┐  ┌─────────────────┐         │
│   │ 4. Uniform  │  │  5. Layered  │  │ 6. Code on      │         │
│   │  Interface  │  │   System     │  │   Demand (opt.) │         │
│   │ Единый      │  │ Клиент не    │  │ Сервер может    │         │
│   │ интерфейс   │  │ знает, с кем │  │ отправить код   │         │
│   │ для всех    │  │ говорит      │  │ для выполнения  │         │
│   └─────────────┘  └──────────────┘  └─────────────────┘         │
│                                                                   │
└───────────────────────────────────────────────────────────────────┘
```

### Constraint 1: Client-Server

**Что:** Клиент и сервер — отдельные компоненты с разной ответственностью. Клиент отвечает за UI и взаимодействие с пользователем. Сервер — за хранение данных и бизнес-логику.

**Почему это работает:** Разделение позволяет развивать клиент и сервер *независимо*. Мобильное приложение, веб-интерфейс и CLI могут использовать один и тот же API. Сервер может мигрировать с PostgreSQL на MongoDB — клиенты об этом не знают.

**На практике:** Этот constraint нарушается реже всего. Но нарушения случаются — например, когда сервер генерирует HTML с встроенным JavaScript для конкретного клиента вместо отдачи данных через API.

### Constraint 2: Statelessness

**Что:** Каждый запрос от клиента к серверу содержит **всю** информацию, необходимую для обработки. Сервер не хранит состояние клиента между запросами.

**Аналогия:** Представь, что каждый раз звонишь в новый колл-центр. Оператор не знает историю твоих предыдущих обращений — ты каждый раз называешь имя, номер заказа, проблему. Неудобно? Да. Но масштабируется: можно добавить 1000 операторов, и любой из них обработает любой звонок.

**Почему это критично для масштабируемости:**

```
С СОСТОЯНИЕМ НА СЕРВЕРЕ (sessions):
┌─────────────────────────────────────────────────────┐
│  Клиент A ──→ Сервер 1 (хранит session A)           │
│  Клиент B ──→ Сервер 2 (хранит session B)           │
│                                                      │
│  Проблема: Клиент A не может пойти на Сервер 2!     │
│  Нужен sticky sessions или общее хранилище.          │
│  Добавить сервер 3? Перебалансировать sessions.      │
└─────────────────────────────────────────────────────┘

БЕЗ СОСТОЯНИЯ (stateless, REST):
┌─────────────────────────────────────────────────────┐
│  Клиент A ──→ Любой сервер (токен в заголовке)      │
│  Клиент B ──→ Любой сервер (токен в заголовке)      │
│                                                      │
│  Добавить сервер 3? Просто запусти.                  │
│  Балансировка? Round-robin, без хитростей.           │
│  Сервер упал? Следующий запрос — на другой.          │
└─────────────────────────────────────────────────────┘
```

**Цена:** Каждый запрос чуть больше (токен авторизации, контекст). Но выигрыш в масштабируемости, надёжности и простоте балансировки несоизмеримо больше.

**Типичное нарушение:** Server-side sessions, привязанные к конкретному серверу. JWT и OAuth-токены решают эту проблему — вся информация о сессии путешествует с запросом.

### Constraint 3: Cacheability

**Что:** Каждый ответ сервера должен явно указывать, можно ли его кэшировать и как долго. Клиент, прокси, CDN — все должны понимать правила кэширования.

**Почему:** Кэширование — главный источник масштабируемости в Web. Без кэширования каждый запрос идёт до origin-сервера. С кэшированием — 90% запросов обслуживаются из промежуточных слоёв.

**HTTP-заголовки кэширования:**

```
Ответ сервера:

HTTP/1.1 200 OK
Cache-Control: public, max-age=3600     ← Кэшировать 1 час
ETag: "abc123"                           ← Версия ресурса
Last-Modified: Wed, 10 Feb 2026 10:00:00 ← Дата изменения
Vary: Accept                             ← Кэшировать отдельно
                                            для разных Accept

Что означают директивы Cache-Control:
─────────────────────────────────────
public        → Кэшировать где угодно (CDN, прокси, браузер)
private       → Только в браузере (данные конкретного пользователя)
no-cache      → Кэшировать, но проверять свежесть при каждом запросе
no-store      → НЕ кэшировать вообще (sensitive data)
max-age=3600  → Свежесть: 3600 секунд (1 час)
s-maxage=600  → Для shared кэшей (CDN): 600 секунд
```

**На практике:** GET-запросы кэшируются по умолчанию. POST, PUT, DELETE — нет. Если API не выставляет Cache-Control — поведение непредсказуемо: браузер может кэшировать, а может нет. Явные заголовки убирают эту неопределённость.

### Constraint 4: Uniform Interface

Это **главный** constraint REST. Именно он отличает REST от других архитектурных стилей. Uniform Interface состоит из четырёх суб-ограничений:

**4.1. Идентификация ресурсов (URI)**

Каждый ресурс имеет уникальный URI. Ресурс — не данные в базе, а *концепция*:

```
/users/123         → Пользователь 123 (конкретный ресурс)
/users             → Коллекция пользователей
/users/123/orders  → Заказы пользователя 123 (подколлекция)

Ресурс ≠ строка в базе. Ресурс «текущий курс валюты» —
один и тот же URI, но данные меняются каждую секунду.
```

**4.2. Манипуляция через представления**

Клиент не видит внутреннее устройство ресурса. Он работает с *представлением* (JSON, XML, HTML). Чтобы обновить ресурс — отправляешь новое представление:

```
PUT /users/123
Content-Type: application/json

{
  "name": "Иван Петров",
  "email": "ivan@example.com"
}

Сервер может хранить это в PostgreSQL, MongoDB, файловой системе —
клиенту всё равно. Он работает только с JSON-представлением.
```

**4.3. Self-descriptive messages**

Каждое сообщение содержит всё необходимое для понимания. Content-Type говорит, как парсить тело. Статус-код говорит, что произошло. Заголовки говорят, как кэшировать.

**4.4. HATEOAS** (подробнее ниже — это отдельная большая тема)

Ответ содержит ссылки на доступные действия. Клиент навигирует по API через гиперссылки, а не через зашитые URL.

### Constraint 5: Layered System

**Что:** Клиент не знает, общается ли он напрямую с сервером или через цепочку прокси, CDN, API Gateway, load balancer. Каждый слой видит только соседний.

```
┌─────────┐     ┌────────┐     ┌─────────┐     ┌────────┐
│ Клиент  │ ──→ │  CDN   │ ──→ │ API GW  │ ──→ │ Сервер │
│         │     │        │     │         │     │        │
│ Не знает│     │ Кэш    │     │ Auth    │     │ Бизнес │
│ о CDN   │     │ Сжатие │     │ Rate    │     │ логика │
│         │     │        │     │ Limit   │     │        │
└─────────┘     └────────┘     └─────────┘     └────────┘
```

**Почему это ценно:** Можно добавить WAF (Web Application Firewall) между клиентом и сервером — клиент об этом не узнает. Можно переключить API Gateway с Kong на AWS API Gateway. Слои развиваются независимо.

### Constraint 6: Code-on-Demand (опциональный)

**Что:** Сервер может отправить исполняемый код клиенту — JavaScript, Java-апплеты, Flash. Это единственный опциональный constraint.

**На практике:** JavaScript, загружаемый браузером — классический пример. Для REST API используется редко, но технически допустим. Например, сервер может вернуть формулу для вычисления стоимости доставки, вместо того чтобы вычислять её на сервере.

---

## Richardson Maturity Model: четыре уровня REST

В 2008 году Леонард Ричардсон предложил модель зрелости REST API. Она помогает оценить, насколько API соответствует REST-принципам. Мартин Фаулер популяризировал эту модель.

```
┌─────────────────────────────────────────────────────────────────┐
│              RICHARDSON MATURITY MODEL                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  LEVEL 3: HATEOAS ──────────────────────── «Настоящий REST»     │
│  │  Гиперссылки в ответах управляют навигацией                  │
│  │  Клиент не зашивает URL, а следует ссылкам                   │
│  │  Примеры: PayPal API, Spring HATEOAS                         │
│  │                                                               │
│  LEVEL 2: HTTP Verbs ──────────────────── Большинство API       │
│  │  GET для чтения, POST для создания, PUT/PATCH/DELETE         │
│  │  Правильные HTTP-статусы (200, 201, 404, 409...)             │
│  │  Примеры: Stripe, GitHub REST v3, Twilio                     │
│  │                                                               │
│  LEVEL 1: Resources ───────────────────── Минимальный REST      │
│  │  Множество URI, но один HTTP-метод (обычно POST)             │
│  │  /users/123, /orders/456 — ресурсы разделены                 │
│  │                                                               │
│  LEVEL 0: The Swamp of POX ───────────── SOAP-стиль             │
│     Один endpoint, один метод, XML-tunneling                    │
│     POST /api → {"action": "getUser", "id": 123}               │
│     Примеры: XML-RPC, SOAP, legacy enterprise                   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Level 0: The Swamp of POX

```
POST /api
Content-Type: application/json

{"action": "getUser", "id": 123}
{"action": "createUser", "name": "Иван"}
{"action": "deleteUser", "id": 123}

Всё через POST на один URL.
HTTP используется как транспорт, не как протокол.
Типичный SOAP-подход.
```

### Level 1: Resources

```
POST /users/123           ← Получить (но почему POST?)
POST /users               ← Создать
POST /users/123/delete    ← Удалить (action в URL)

Ресурсы выделены, но HTTP-глаголы игнорируются.
Шаг вперёд от Level 0, но REST-идиоматики нет.
```

### Level 2: HTTP Verbs

```
GET    /users/123         ← Читать
POST   /users             ← Создать
PUT    /users/123         ← Полное обновление
PATCH  /users/123         ← Частичное обновление
DELETE /users/123         ← Удалить

Правильные статусы: 200, 201, 204, 400, 404, 409
HTTP-методы определяют семантику операции.
```

**Реальность:** 95% «REST» API в продакшене — Level 2. И для большинства задач этого достаточно. Stripe, GitHub v3, Twilio, Shopify — все работают на Level 2. Полноценный HATEOAS (Level 3) применяется редко, потому что добавляет сложность без очевидного выигрыша для типичных задач.

### Level 3: HATEOAS

HATEOAS — самый спорный и непонятый аспект REST. Филдинг настаивал, что без HATEOAS API не является RESTful. Разберём подробно.

---

## HATEOAS: что это на самом деле

**HATEOAS** = Hypermedia As The Engine Of Application State.

Идея простая: клиент не должен знать URL заранее. Сервер в каждом ответе возвращает ссылки на доступные действия. Клиент *следует* этим ссылкам, как пользователь переходит по ссылкам на веб-сайте.

**Аналогия:** Ты заходишь на сайт. Не вбиваешь URL каждой страницы вручную — кликаешь по ссылкам. Главная → Каталог → Товар → Корзина → Оплата. Каждая страница подсказывает, куда можно пойти дальше. HATEOAS переносит эту идею на API.

### Без HATEOAS (Level 2)

```json
// GET /orders/42

{
  "id": 42,
  "status": "pending",
  "total": 1500,
  "items": [
    {"product": "Ноутбук", "qty": 1}
  ]
}

// Клиент ДОЛЖЕН ЗНАТЬ заранее:
// - Отменить заказ: DELETE /orders/42
// - Оплатить: POST /orders/42/payment
// - Получить товары: GET /products/{id}
//
// Эти URL зашиты в клиентском коде.
// Если сервер изменит URL — клиент сломается.
```

### С HATEOAS (Level 3)

```json
// GET /orders/42

{
  "id": 42,
  "status": "pending",
  "total": 1500,
  "items": [
    {"product": "Ноутбук", "qty": 1}
  ],
  "_links": {
    "self": {"href": "/orders/42"},
    "cancel": {"href": "/orders/42", "method": "DELETE"},
    "payment": {"href": "/orders/42/payment", "method": "POST"},
    "items": {"href": "/orders/42/items"}
  }
}
```

Клиент не знает URL для оплаты заранее. Он получает их из ответа. Если заказ уже оплачен — ссылка `payment` исчезает, появляется `refund`. Сервер управляет навигацией.

### Реальные примеры HATEOAS

**GitHub API:**
```json
// GET https://api.github.com/repos/octocat/Hello-World/issues/1

{
  "id": 1,
  "title": "Found a bug",
  "url": "https://api.github.com/repos/octocat/Hello-World/issues/1",
  "comments_url": "https://api.github.com/repos/octocat/Hello-World/issues/1/comments",
  "labels_url": "https://api.github.com/repos/octocat/Hello-World/issues/1/labels{/name}",
  "events_url": "https://api.github.com/repos/octocat/Hello-World/issues/1/events"
}
```

**PayPal API:**
```json
// Ответ при создании платежа

{
  "id": "PAY-123",
  "state": "created",
  "links": [
    {
      "href": "https://api.paypal.com/v1/payments/PAY-123",
      "rel": "self",
      "method": "GET"
    },
    {
      "href": "https://www.paypal.com/cgi-bin/webscr?cmd=_express-checkout&token=EC-123",
      "rel": "approval_url",
      "method": "REDIRECT"
    },
    {
      "href": "https://api.paypal.com/v1/payments/PAY-123/execute",
      "rel": "execute",
      "method": "POST"
    }
  ]
}
```

### Почему HATEOAS редко используется полностью

| Аргумент «за» | Аргумент «против» |
|----------------|-------------------|
| Loose coupling — сервер может менять URL | Клиенты всё равно зашивают URL (мобильные SDK) |
| API самодокументируемый | Увеличивает размер payload |
| Динамическая навигация | Нет стандарта (HAL, JSON:API, Siren — несовместимы) |
| Сервер контролирует workflow | Сложнее тестировать и дебажить |
| Легче эволюция API | Мало инструментов и библиотек |

**Практический совет:** Для внутренних API между микросервисами — HATEOAS избыточен. Для публичных API, где клиенты разнообразны и эволюция неизбежна — рассмотри как минимум ссылки пагинации и `self`.

---

## Идемпотентность: безопасные повторы

### Что это и почему критично

**Идемпотентность** означает: повторный запрос с теми же параметрами даёт тот же результат. Это не про кэширование — это про **безопасность повторных запросов**.

Почему это критично? Сети ненадёжны:

```
Сценарий: Клиент отправляет запрос на оплату

Клиент ──── POST /payments ────→ Сервер
         (создать платёж $100)

Сервер обработал. Списал $100.
Начал отправлять ответ...

Клиент ←── 504 Gateway Tim... ──── Сервер
         (ответ не дошёл!)

Клиент не знает: платёж прошёл или нет?
Если повторить POST — спишется $200!
```

### Идемпотентность HTTP-методов

| Метод | Идемпотентный? | Безопасный? | Почему |
|-------|:---:|:---:|--------|
| **GET** | Да | Да | Только чтение, не меняет состояние |
| **HEAD** | Да | Да | То же что GET, но без тела ответа |
| **PUT** | Да | Нет | Полная замена — повторная замена = тот же результат |
| **DELETE** | Да | Нет | Удалить 1 раз или 10 — ресурс удалён |
| **PATCH** | Нет | Нет | Зависит от реализации (может быть идемпотентным) |
| **POST** | **Нет** | Нет | Создание нового ресурса при каждом вызове |

**Безопасный** = не меняет состояние сервера. **Идемпотентный** = повторный вызов не меняет результат.

### PUT vs PATCH: разница в идемпотентности

```json
// PUT /users/123 — ИДЕМПОТЕНТНЫЙ
// Полная замена ресурса. Повторный PUT с теми же данными = тот же результат.
{
  "name": "Иван",
  "email": "ivan@example.com",
  "role": "admin"
}

// PATCH /users/123 — НЕ ОБЯЗАТЕЛЬНО ИДЕМПОТЕНТНЫЙ
// Примеры:

// Идемпотентный PATCH (замена поля):
{"email": "new@example.com"}
// Повторный вызов → тот же результат ✓

// НЕ идемпотентный PATCH (инкремент):
{"operation": "increment", "field": "login_count", "value": 1}
// Первый вызов: login_count = 6
// Второй вызов: login_count = 7 ← Разный результат!
```

### Idempotency Keys для POST

POST создаёт новый ресурс при каждом вызове — он не идемпотентен по определению. Для безопасных повторов используют **Idempotency Keys**:

```
Клиент генерирует уникальный ключ (UUID) для каждой операции
и отправляет его в заголовке:

POST /payments
Idempotency-Key: 550e8400-e29b-41d4-a716-446655440000
Content-Type: application/json

{"amount": 100, "currency": "USD"}
```

**Как работает на сервере:**

```
┌─────────────────────────────────────────────────────────────────┐
│               ОБРАБОТКА IDEMPOTENCY KEY                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. Запрос приходит с Idempotency-Key: abc-123                  │
│                                                                  │
│  2. Проверяем хранилище (Redis):                                │
│     ┌──────────────────────────────────────────┐                │
│     │ GET idempotency:abc-123                   │                │
│     │                                           │                │
│     │ Ключ НЕ найден → обрабатываем запрос      │                │
│     │ Ключ найден → возвращаем сохранённый ответ│                │
│     └──────────────────────────────────────────┘                │
│                                                                  │
│  3. Если ключ новый:                                            │
│     a) Ставим lock: SET idempotency:abc-123 "processing" NX    │
│     b) Обрабатываем запрос                                      │
│     c) Сохраняем результат: SET idempotency:abc-123 {response} │
│     d) Устанавливаем TTL: EXPIRE idempotency:abc-123 86400     │
│        (24 часа)                                                │
│                                                                  │
│  4. Если ключ уже существует:                                   │
│     a) "processing" → 409 Conflict (запрос ещё выполняется)     │
│     b) {response} → возвращаем сохранённый ответ                │
│                                                                  │
│  ВАЖНО: Кэшировать только 2xx и 409.                            │
│  НЕ кэшировать 500 — ошибка может быть временной.               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**IETF-стандарт:** Заголовок `Idempotency-Key` стандартизирован в черновике IETF (draft-ietf-httpapi-idempotency-key-header). MDN уже документирует его. Stripe, Adyen, Google Payments — все используют этот паттерн.

```python
# Пример: идемпотентный платёжный endpoint (Python/FastAPI)

from fastapi import FastAPI, Header, HTTPException
import redis
import json
import uuid

app = FastAPI()
cache = redis.Redis()

@app.post("/payments")
async def create_payment(
    payment: PaymentRequest,
    idempotency_key: str = Header(...)  # Обязательный заголовок
):
    cache_key = f"idempotency:{idempotency_key}"

    # Проверяем: был ли уже такой запрос?
    cached = cache.get(cache_key)
    if cached:
        return json.loads(cached)  # Возвращаем сохранённый ответ

    # Атомарный lock (NX = только если ключа нет)
    acquired = cache.set(cache_key, "processing", nx=True, ex=30)
    if not acquired:
        raise HTTPException(409, "Запрос уже обрабатывается")

    # Обработка платежа
    result = await process_payment(payment)

    # Сохраняем результат на 24 часа
    cache.set(cache_key, json.dumps(result), ex=86400)

    return result
```

---

## Content Negotiation: один ресурс, много представлений

### Что это

Один и тот же ресурс `/users/123` может быть представлен в JSON, XML, HTML, CSV. Content Negotiation — механизм, через который клиент и сервер *договариваются* о формате.

### Как работает

```
Клиент указывает желаемый формат через Accept:

GET /users/123
Accept: application/json          ← Хочу JSON

GET /users/123
Accept: application/xml           ← Хочу XML

GET /users/123
Accept: text/html                 ← Хочу HTML

GET /users/123
Accept: application/json, application/xml;q=0.9
       ↑ Предпочитаю JSON, но XML тоже подойдёт (качество 0.9)


Сервер отвечает с Content-Type:

HTTP/1.1 200 OK
Content-Type: application/json    ← Отдаю JSON
Vary: Accept                      ← Кэшировать отдельно для каждого Accept

{"id": 123, "name": "Иван"}
```

### Версионирование через Accept

Некоторые API используют Content Negotiation для версионирования:

```
GET /users/123
Accept: application/vnd.myapi.v2+json
              ↑           ↑    ↑
              vendor       v2   формат JSON

GitHub использует этот подход:
Accept: application/vnd.github.v3+json
```

**Сравнение с URL-версионированием:**

| Критерий | URL (`/v2/users`) | Accept header |
|----------|:-:|:-:|
| Простота | Да | Нет — нужен парсинг заголовка |
| REST-чистота | Нет — версия не часть ресурса | Да — один URI для ресурса |
| Кэширование | Простое (разные URL) | Нужен Vary: Accept |
| Дебаг | Видно в логах, URL | Скрыто в заголовках |
| Популярность | 80% API | 15% API |

---

## ETags и условные запросы

### Зачем нужны

Представь: клиент запрашивает список товаров. Список весит 500KB и обновляется раз в час. Без ETags клиент скачивает 500KB каждый запрос. С ETags — сервер отвечает «ничего не изменилось» за 100 байт.

### Strong vs Weak ETags

```
Strong ETag: "abc123"
Гарантирует побайтовую идентичность.
Два ответа с одинаковым Strong ETag — идентичны.

Weak ETag: W/"abc123"
Гарантирует семантическую эквивалентность.
Контент может немного отличаться (пробелы, порядок полей),
но смысл тот же.
```

### Conditional GET (кэширование)

```
ПЕРВЫЙ ЗАПРОС:

GET /products
→ 200 OK
  ETag: "v42"
  Content-Length: 512000    ← 500KB данных

ПОВТОРНЫЙ ЗАПРОС:

GET /products
If-None-Match: "v42"       ← У меня версия v42, есть новее?

Если данные НЕ изменились:
→ 304 Not Modified          ← 0 байт тела! Используй кэш.

Если данные изменились:
→ 200 OK
  ETag: "v43"
  Content-Length: 515000    ← Новые данные
```

### Conditional PUT (оптимистичная конкурентность)

ETags решают проблему «потерянных обновлений» — когда два клиента одновременно редактируют один ресурс:

```
ПРОБЛЕМА (без ETags):
─────────────────────
Клиент A: GET /users/123 → {"name": "Иван", "email": "old@mail.com"}
Клиент B: GET /users/123 → {"name": "Иван", "email": "old@mail.com"}

Клиент A: PUT /users/123 {"name": "Пётр", "email": "old@mail.com"}
          → 200 OK (сохранил)

Клиент B: PUT /users/123 {"name": "Иван", "email": "new@mail.com"}
          → 200 OK (перезаписал изменения клиента A!)

Результат: name = "Иван" ← изменение Клиента A потеряно!


РЕШЕНИЕ (с ETags):
──────────────────
Клиент A: GET /users/123 → ETag: "v1"
Клиент B: GET /users/123 → ETag: "v1"

Клиент A: PUT /users/123
          If-Match: "v1"     ← Обновить ТОЛЬКО если версия v1
          → 200 OK, ETag: "v2"

Клиент B: PUT /users/123
          If-Match: "v1"     ← Обновить ТОЛЬКО если версия v1
          → 412 Precondition Failed!  ← Версия уже v2, не v1

Клиент B должен перечитать ресурс, показать diff пользователю,
и повторить с правильной версией.
```

### Стратегии генерации ETag

| Стратегия | Когда использовать | Пример |
|-----------|-------------------|--------|
| **Хеш контента** | Точная проверка | SHA-256 от JSON |
| **Версия в БД** | Быстро, если есть version column | `"v42"` |
| **Timestamp** | Простейший вариант | `"1707566400"` |
| **Комбинированный** | Связанные ресурсы | `"user:42:orders:7:v3"` |

Подробнее о стратегиях кэширования: [[caching-strategies]]

---

## Версионирование: подходы и trade-offs

Сравнение основных стратегий версионирования API — тема, которая уже покрыта в [[api-design]]. Здесь разберём глубже — подход Stripe и эволюционный подход.

### Stripe: date-based versioning (золотой стандарт)

Stripe — пожалуй, лучший пример продуманного версионирования:

```
Stripe-Version: 2026-01-28.clover    ← Текущая версия

Как это работает:
1. Каждый аккаунт "привязан" к версии при регистрации
2. Все запросы по умолчанию используют привязанную версию
3. Для тестирования новой версии — добавь заголовок:
   Stripe-Version: 2026-01-28.clover
4. Когда готов — переключи версию аккаунта в dashboard

Релизный цикл (с 2024):
─────────────────────────
• Ежемесячные минорные релизы (без breaking changes)
• Два раза в год — мажорный релиз с breaking changes
• Каждый мажорный релиз получает кодовое имя:
  acacia, basil, clover...
```

**Почему это работает:**
- Клиент контролирует момент миграции
- Можно протестировать новую версию на staging
- Webhook-payloads тоже версионируются
- Чёткий changelog: что именно изменилось и как мигрировать

### Эволюционный подход (без версий)

Идея: вместо версий — делать только обратно-совместимые изменения:

```
МОЖНО (не ломает клиентов):
──────────────────────────
✓ Добавить новое поле в ответ
✓ Добавить новый опциональный параметр
✓ Добавить новый endpoint
✓ Добавить новое значение в enum (если клиент толерантен)

НЕЛЬЗЯ (ломает клиентов):
─────────────────────────
✗ Удалить поле из ответа
✗ Изменить тип поля (string → number)
✗ Переименовать поле
✗ Сделать опциональный параметр обязательным
✗ Изменить семантику status code
```

**Подход Zalando:** API First + эволюция. Вместо версий — строгие правила обратной совместимости. Если нужно breaking change — создаётся новый ресурс (`/users` → `/members`), а старый помечается deprecated.

---

## Практические паттерны в production

### REST-дизайн Stripe: эталон индустрии

Stripe часто называют золотым стандартом REST API. Почему?

```
1. КОНСИСТЕНТНОСТЬ
   Все ресурсы: POST для создания, GET для чтения
   Все ответы: одинаковая структура с id, object, created
   Все ошибки: единый формат с type, code, message, param

2. EXPAND ПАРАМЕТР (решение under-fetching)
   GET /charges/ch_123                    ← Базовый ответ
   GET /charges/ch_123?expand[]=customer  ← + данные клиента
   GET /charges/ch_123?expand[]=customer&expand[]=invoice

   Вместо:
   GET /charges/ch_123      → charge
   GET /customers/cus_456   → customer (отдельный запрос)

3. ИДЕМПОТЕНТНОСТЬ ВСТРОЕНА
   POST /charges
   Idempotency-Key: unique-key-123

   Stripe хранит результат 24 часа.
   Повторный запрос = тот же ответ.

4. ПАГИНАЦИЯ
   GET /charges?limit=10&starting_after=ch_123
   Cursor-based по умолчанию.
   Ни один endpoint не использует offset.
```

### Ошибки Stripe (формат)

```json
// Каждая ошибка содержит:
{
  "error": {
    "type": "card_error",          // Категория ошибки
    "code": "card_declined",       // Машиночитаемый код
    "message": "Your card was declined",  // Для пользователя
    "param": "number",             // Какой параметр вызвал ошибку
    "decline_code": "generic_decline",    // Причина отклонения
    "doc_url": "https://stripe.com/docs/error-codes/card-declined"
  }
}
```

### Фильтрация, сортировка, поиск

```
ФИЛЬТРАЦИЯ (по полям):
──────────────────────
GET /orders?status=pending&created_after=2026-01-01

СОРТИРОВКА:
──────────
GET /products?sort=price&order=desc
GET /products?sort=-price              ← Минус = DESC (альтернативный формат)

ПОИСК (полнотекстовый):
──────────────────────
GET /products?q=ноутбук

ВАЖНО: Не смешивай фильтрацию и поиск!
─────────────────────────────────────
Фильтрация → использует индексы БД, точное совпадение
Поиск → полнотекстовый (Elasticsearch, Meilisearch)

Если API поддерживает оба — разные параметры:
GET /products?category=electronics&q=ноутбук
              ↑ фильтр                ↑ поиск
```

---

## Мифы и заблуждения

| Миф | Реальность |
|-----|------------|
| **«REST = JSON over HTTP»** | REST — архитектурный стиль с 6 constraints. JSON — лишь один из форматов. REST может работать с XML, HTML, Protocol Buffers, чем угодно. Многие «REST API» — просто HTTP API на Level 2 |
| **«HATEOAS бесполезен на практике»** | HATEOAS полезен для навигации: пагинация (Link headers), доступные действия (кнопки в UI). PayPal и GitHub успешно используют элементы HATEOAS. Полный HATEOAS действительно избыточен для большинства API |
| **«PUT и PATCH взаимозаменяемы»** | PUT — полная замена ресурса (отправляешь ВСЁ). PATCH — частичное обновление (отправляешь только изменения). PUT идемпотентен всегда, PATCH — зависит от реализации |
| **«REST устарел, GraphQL лучше»** | REST и GraphQL решают разные задачи. REST лучше для публичных API (кэширование, простота, стандарты). GraphQL лучше для сложных клиентских запросов. 80%+ публичных API — REST |
| **«Каждый HTTP API — это REST API»** | REST требует соблюдения constraints. API с одним POST-endpoint, server-side sessions и вызовами вида `/getUser` — это JSON-RPC поверх HTTP, не REST |
| **«REST всегда медленнее gRPC»** | Да, gRPC быстрее из-за бинарного формата и HTTP/2. Но для публичных API разница в 200ms vs 25ms некритична. Главное — правильное кэширование: закэшированный REST-ответ возвращается за 0ms |
| **«POST всегда создаёт ресурс»** | POST — для небезопасных операций. Создание — частный случай. POST /users/123/deactivate (действие, не создание) — допустимо, когда нет подходящего HTTP-метода |
| **«Нужно всегда возвращать 200»** | 70%+ API-багов связаны с неправильными status codes. 200 для ошибок — антипаттерн. Клиентские библиотеки полагаются на HTTP-статусы для обработки ошибок |
| **«Версионирование через URL — лучший подход»** | Stripe, один из лучших API, использует header-based versioning. URL-версионирование проще, но header-based — гибче. Лучший подход — избегать breaking changes |

---

## Подводные камни

### Камень 1: Over-fetching и Under-fetching

```
OVER-FETCHING: API возвращает слишком много

GET /users/123 → 50 полей, клиенту нужно 3

Решения:
1. Sparse fieldsets: GET /users/123?fields=name,email
2. Разные endpoints: GET /users/123/profile (лёгкий)
3. GraphQL (если over-fetching критичен)

UNDER-FETCHING: Нужно несколько запросов

Клиенту нужны: пользователь + заказы + адрес доставки

GET /users/123           → user
GET /users/123/orders    → orders
GET /addresses/456       → address

3 запроса вместо 1.

Решения:
1. Expand/include: GET /users/123?expand=orders,address
2. Compound documents: один endpoint для связанных данных
3. BFF (Backend for Frontend): отдельный API для клиента
```

### Камень 2: N+1 запросов на клиенте

```
Клиент запрашивает список заказов:

GET /orders → [{id: 1, user_id: 10}, {id: 2, user_id: 20}, ...]

Для каждого заказа запрашивает пользователя:
GET /users/10
GET /users/20
...

100 заказов = 101 запрос!

Решение: embed/expand на сервере:
GET /orders?expand=user → [{id: 1, user: {id: 10, name: "Иван"}}, ...]
```

### Камень 3: Игнорирование идемпотентности для POST

Любой endpoint, который создаёт ресурс или изменяет состояние, должен поддерживать Idempotency-Key. Без этого — потерянные платежи, дубликаты заказов, неконсистентные данные.

### Камень 4: Offset-пагинация на больших данных

```
GET /products?offset=1000000&limit=20

PostgreSQL: SELECT * FROM products OFFSET 1000000 LIMIT 20
           ↑ Сканирует 1,000,020 строк, возвращает 20.
           На миллионе записей — секунды ожидания.

Cursor-based:
GET /products?cursor=eyJpZCI6MTAwMDAwMH0&limit=20

PostgreSQL: SELECT * FROM products WHERE id > 1000000 LIMIT 20
           ↑ Использует индекс. Микросекунды.
```

### Камень 5: Breaking changes без предупреждения

```
❌ ПЛОХО:
Понедельник: поле "name" (string)
Вторник: поле "name" удалено, вместо него "first_name" + "last_name"
→ ВСЕ клиенты сломались

✅ ХОРОШО (Stripe-подход):
1. Добавить first_name и last_name (новые поля)
2. name продолжает работать (deprecated, но функциональный)
3. Пометить name как deprecated в документации
4. Через 12 месяцев — удалить name в новой версии
5. Клиенты мигрируют в своём темпе
```

---

## CS-фундамент

| Концепция | Применение в REST |
|-----------|-------------------|
| **Client-Server** | Фундаментальный constraint REST. Клиент отвечает за UI, сервер — за данные. Разделение позволяет развивать независимо |
| **Statelessness** | Каждый запрос самодостаточен. Позволяет горизонтальное масштабирование: любой сервер обработает любой запрос |
| **Caching** | Ответы помечаются как кэшируемые. CDN, прокси, браузер — все могут кэшировать. Главный источник масштабируемости Web |
| **Idempotency** | GET, PUT, DELETE идемпотентны. POST + Idempotency-Key для безопасных повторов. Математическое свойство: f(f(x)) = f(x) |
| **Content Negotiation** | Один ресурс — много представлений. Accept/Content-Type заголовки. Связь с полиморфизмом из ООП |
| **Uniform Interface** | Единый способ взаимодействия для всех ресурсов. Как стандартизированные розетки: любой прибор подключается к любой розетке |
| **Hash Functions** | ETag = хеш содержимого ресурса. Позволяет сравнивать версии без передачи данных. SHA-256, MD5 для генерации |
| **Optimistic Concurrency** | If-Match + ETag вместо пессимистичных блокировок. Читаешь версию → обновляешь → если версия изменилась, получаешь 412 |

---

## Куда дальше

Если начинаешь изучать API:
→ [[api-design]] — обзор REST, GraphQL, gRPC: когда что выбрать, базовые паттерны, OAuth, JWT

Если хочешь понять альтернативы REST:
→ [[api-graphql-deep-dive]] — GraphQL решает проблемы over/under-fetching, но вносит свои сложности: N+1, кэширование, federation
→ [[api-grpc-deep-dive]] — gRPC для межсервисной коммуникации: в 5-7 раз быстрее REST благодаря бинарному формату и HTTP/2

Если хочешь узнать о современных паттернах:
→ [[api-modern-patterns]] — tRPC (type-safe API без codegen), Webhooks, API Gateway, BFF

HTTP-протокол, на котором построен REST:
→ [[network-http-evolution]] — HTTP/1.1 → HTTP/2 → HTTP/3/QUIC, эволюция протокола и влияние на API

Кэширование (один из REST constraints):
→ [[caching-strategies]] — Redis, CDN, HTTP-кэширование, стратегии инвалидации

Безопасность API:
→ [[security-api-protection]] — Rate limiting, input validation, API keys — защита от злоупотреблений

---

## Источники

| # | Источник | Тип | Вклад |
|---|----------|-----|-------|
| 1 | [Fielding Dissertation, Chapter 5: REST](https://ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm) | Диссертация | Оригинальное определение REST и 6 constraints |
| 2 | [Roy Fielding's Misappropriated REST Dissertation](https://twobithistory.org/2020/06/28/rest.html) | Статья | Анализ: что Филдинг имел в виду vs как REST понимают |
| 3 | [Richardson Maturity Model — Martin Fowler](https://martinfowler.com/articles/richardsonMaturityModel.html) | Статья | Четыре уровня REST-зрелости |
| 4 | [Zalando RESTful API Guidelines](https://opensource.zalando.com/restful-api-guidelines/) | Стандарт | Enterprise REST: naming, versioning, JSON |
| 5 | [Microsoft REST API Design Guidance](https://microsoft.github.io/code-with-engineering-playbook/design/design-patterns/rest-api-design-guidance/) | Документация | Design-first, TypeSpec, breaking changes |
| 6 | [Stripe API Versioning](https://stripe.com/blog/api-versioning) | Блог | Date-based versioning, migration patterns |
| 7 | [Stripe API v2 Overview](https://docs.stripe.com/api-v2-overview) | Документация | Текущий подход Stripe к API-дизайну |
| 8 | [IETF: Idempotency-Key Header](https://datatracker.ietf.org/doc/draft-ietf-httpapi-idempotency-key-header/) | RFC Draft | Стандарт Idempotency-Key заголовка |
| 9 | [MDN: Idempotency-Key Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Idempotency-Key) | Документация | Описание заголовка для разработчиков |
| 10 | [MDN: HTTP Conditional Requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Conditional_requests) | Документация | If-None-Match, If-Match, ETags |
| 11 | [MDN: HTTP Content Negotiation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Content_negotiation) | Документация | Accept, Content-Type, Vary |
| 12 | [REST API Tutorial](https://restfulapi.net/) | Руководство | Практическое объяснение REST constraints |
| 13 | [Common REST API Design Mistakes — Milan Jovanović](https://www.milanjovanovic.tech/blog/the-5-most-common-rest-api-design-mistakes-and-how-to-avoid-them) | Статья | Типичные ошибки и антипаттерны |
| 14 | [REST: Myths & Facts — Poornima Nayar](https://poornimanayar.co.uk/blog/rest-myths-facts/) | Статья | Мифы о REST и реальность |
| 15 | [From SOAP to REST: History of APIs — Treblle](https://treblle.com/blog/from-soap-to-rest-tracing-the-history-of-apis) | Статья | Историческая эволюция API |
| 16 | [Optimizing REST APIs with ETags — Zuplo](https://zuplo.com/learning-center/optimizing-rest-apis-with-conditional-requests-and-etags) | Руководство | ETags, conditional requests на практике |
| 17 | [Implementing Idempotency Keys — Zuplo](https://zuplo.com/learning-center/implementing-idempotency-keys-in-rest-apis-a-complete-guide) | Руководство | Полный guide по Idempotency Keys |
| 18 | [SOAP And REST At Odds — History of the Web](https://thehistoryoftheweb.com/soap-rest-odds/) | Статья | История противостояния SOAP и REST |
| 19 | [API Versioning Best Practices — Redocly](https://redocly.com/blog/api-versioning-best-practices) | Статья | Сравнение стратегий версионирования |
| 20 | [AWS: SOAP vs REST](https://aws.amazon.com/compare/the-difference-between-soap-rest/) | Документация | Сравнение SOAP и REST |

---

**Последняя верификация**: 2026-02-10
**Уровень достоверности**: high

---

*Проверено: 2026-02-10*
