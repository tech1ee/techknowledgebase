---
title: "Типы контента: что, когда, как"
created: 2025-11-24
modified: 2025-11-24
type: reference
status: published
confidence: high
tags:
  - system/guidelines
  - system/metadata
related:
  - "[[content-levels]]"
  - "[[cognitive-science-rules]]"
---

# Типы контента: что, когда, как

> Разные цели = разная структура. Нельзя писать tutorial как reference.

---

## Правило вводного абзаца (Lead Paragraph)

**Проблема:** Вводные части либо слишком короткие ("X — это Y"), либо отсутствуют вовсе. Читатель не понимает: что это? зачем? стоит ли читать дальше?

**Решение:** Вводный абзац из 3 элементов — в пределах рабочей памяти (4±1 элемент, Cowan 2000).

### Три элемента вводного абзаца

> **Научная база:** Рабочая память ограничена 4±1 элементами. Старые правила с 5 вопросами превышали этот лимит.

| Элемент | Что отвечает | Пример |
|---------|--------------|--------|
| **Что** | Суть в одном предложении | "Kotlin Coroutines — механизм асинхронного программирования" |
| **Зачем** | Какую проблему решает | "Позволяет писать асинхронный код как синхронный, без callback hell" |
| **Ключевой инсайт** | Принцип ИЛИ цифра ИЛИ сравнение | "1M корутин на одном потоке vs 1 поток = 1MB RAM" |

### Формула вводного абзаца

```
[Что это] + [Какую проблему решает] + [Ключевой инсайт]
```

**Ключевой инсайт** — выбери ОДИН из вариантов:
- Принцип работы: "Корутина приостанавливается, не блокируя поток"
- Масштаб/цифры: "8 из 10 enterprise-приложений работают на JVM"
- Сравнение: "Docker-образ 15MB vs VM 1.5GB — разница в 100 раз"

**Длина:** 2-4 предложения (30-100 слов). Краткость — сестра понимания.

### Чего НЕ должно быть

- **Шаблонные заголовки**: "Почему это важно:", "Для кого этот материал:" — это маркеры AI-генерированного текста
- **Объяснение очевидного**: кто открыл материал, тому он и нужен
- **Абстрактная "важность"**: лучше показать через цифры или сравнения

### Примеры

```markdown
❌ ПЛОХО (слишком кратко, неинформативно):
"JVM — универсальная платформа. Любой язык компилируется в байткод."

❌ ПЛОХО (определение без контекста):
"Kotlin Flow — это асинхронный поток данных."

✅ ХОРОШО (полная картина):
"Kotlin Flow — механизм реактивных потоков данных на базе корутин.
Решает проблему обработки последовательностей асинхронных событий:
обновления UI, потоки данных с сервера, события пользователя.

Ключевое отличие от RxJava: Flow холодный (запускается только при подписке),
использует structured concurrency и не требует отдельной библиотеки —
встроен в kotlinx.coroutines. StateFlow/SharedFlow заменяют LiveData в Android."

✅ ХОРОШО (с масштабом):
"JVM (Java Virtual Machine) — среда выполнения, которая запускает байткод
на любой ОС без перекомпиляции. Написал код один раз — работает на Windows,
Linux, macOS, серверах, Android.

Почему это важно: 8 из 10 enterprise-приложений работают на JVM. Экосистема
включает не только Java, но и Kotlin, Scala, Clojure — все компилируются
в тот же байткод и получают JIT-оптимизации, сборку мусора, доступ к
миллиардам строк Java-библиотек."
```

### Типичные ошибки

| Ошибка | Пример | Почему плохо |
|--------|--------|--------------|
| **Только определение** | "X — это Y" | Не объясняет зачем, когда, для кого |
| **Слишком абстрактно** | "Мощный инструмент для работы с данными" | Ничего конкретного |
| **Нет проблемы** | "Docker упаковывает приложения" | Не объясняет какую боль решает |
| **Нет масштаба** | "Широко используется" | Насколько широко? Кем? |
| **Жаргон без объяснения** | "Provides reactive streams with backpressure" | Непонятно без контекста |

### Чеклист для вводного абзаца

> 5 пунктов — в пределах эффективности чеклистов (Gawande, 2009: ≤7 пунктов)

```
□ ЧТО: понятна суть (даже если впервые слышишь термин)
□ ЗАЧЕМ: понятна проблема, которую решает
□ ИНСАЙТ: есть конкретика (цифра, принцип или сравнение)
□ РЕШЕНИЕ: после прочтения можно решить — читать дальше или нет
□ КРАТКОСТЬ: 2-4 предложения (30-100 слов)
```

---

## Правило полноты объяснений (Completeness)

**Проблема:** Диаграммы и схемы вводят термины/концепции, но текст их не объясняет. Читатель видит схему с 5 блоками, а в тексте описано только 2.

**Решение:** Каждый элемент визуальной схемы должен быть объяснён в тексте.

### Правило

```
Если на схеме есть элемент X — он должен быть объяснён в тексте.
Нет объяснения = не рисуй элемент.
```

### Чеклист для схем

```
□ Перечислить все элементы схемы
□ Проверить что каждый объяснён в тексте
□ Удалить элементы без объяснения ИЛИ добавить объяснение
□ Связи между элементами тоже объяснены
```

### Пример

```
❌ ПЛОХО:

Схема:
┌─────────────────────────────────────────┐
│  ┌─────────────┐  ┌─────────────┐       │
│  │ Class Loader │  │  Verifier   │       │
│  └─────────────┘  └─────────────┘       │
│  ┌─────────────┐  ┌─────────────┐       │
│  │ Interpreter  │  │ JIT Compiler│       │
│  └─────────────┘  └─────────────┘       │
└─────────────────────────────────────────┘

Текст:
"JVM загружает классы и компилирует код."
(Verifier не упомянут, разница Interpreter/JIT не объяснена)

✅ ХОРОШО:

Схема та же, но текст:
"**Class Loader** находит и загружает .class файлы.
 **Verifier** проверяет безопасность байткода (нет stack overflow атак).
 **Interpreter** выполняет байткод построчно (медленно, но сразу).
 **JIT Compiler** компилирует горячие методы в native код (быстро после warmup)."
```

### Порядок работы с материалом

1. Прочитать материал полностью
2. Выписать все элементы из всех схем
3. Проверить что каждый объяснён
4. Добавить недостающие объяснения ИЛИ упростить схему
5. Только потом переходить к следующему материалу

---

## Правило информативности (Descriptive Content)

**Проблема:** Материал состоит только из схем, примеров кода и коротких bullet-points. Нет объяснительного текста — читатель видит ЧТО, но не понимает ПОЧЕМУ и КАК.

**Решение:** Каждый раздел должен содержать описательный текст, объясняющий концепции своими словами.

### Признаки неинформативного материала

```
❌ Только схема без объяснения
❌ Только код без комментариев о происходящем
❌ Только bullet-points ("• Heap • Stack • Metaspace")
❌ Только команды без объяснения когда и зачем
❌ Только таблицы без контекста
```

### Что должно быть в каждом разделе

1. **Объяснительный текст** (2-4 абзаца) — описание концепции своими словами
2. **Схема/визуализация** — показывает структуру или процесс
3. **Пример кода** — демонстрирует применение
4. **Практические следствия** — что это значит на практике

### Пример трансформации

```markdown
❌ ПЛОХО (только схема и код):

## Heap: где живут объекты

```
Eden → Survivor → Old Gen
```

```java
Object obj = new Object(); // создаётся в Eden
```

-Xms2g -Xmx4g

---

✅ ХОРОШО (объяснительный текст + схема + код):

## Heap: где живут объекты

Heap — общая область памяти для всех потоков, где создаются объекты.
В отличие от Stack (который у каждого потока свой), Heap один на всю JVM.
Именно поэтому объекты доступны из разных потоков, но требуют синхронизации.

JVM делит Heap на поколения (generations) на основе наблюдения:
большинство объектов живут очень недолго. Типичный веб-запрос создаёт
десятки временных объектов (DTO, StringBuilder, итераторы), которые
становятся мусором через миллисекунды. Зачем проверять их вместе с
долгоживущими кэшами и синглтонами?

**Young Generation** — сюда попадают новые объекты. Сборка мусора здесь
происходит часто (Minor GC), но быстро — потому что большинство объектов
уже мертвы. Выжившие объекты "стареют" и после нескольких сборок
переезжают в Old Generation.

**Old Generation** — объекты, пережившие много Minor GC. Сборка здесь
редкая (Major GC), но долгая — нужно проверить всё. Full GC может
заморозить приложение на секунды.

```
┌─────────────────────────────────────────────┐
│     Young Generation          │  Old Gen    │
│  ┌──────────┬─────────────┐  │             │
│  │  Eden    │  Survivor   │  │  Tenured    │
│  │  (new)   │  (age 1-15) │  │  (age 15+)  │
│  └──────────┴─────────────┘  │             │
└─────────────────────────────────────────────┘
     ↑                              ↑
  new Object()               долгоживущие
  частые Minor GC            редкие Major GC
```

```java
public List<UserDTO> getUsers() {
    // Эти объекты живут миллисекунды — идеальные кандидаты для Young Gen
    List<UserDTO> dtos = new ArrayList<>();  // → Eden
    for (User user : users) {
        UserDTO dto = new UserDTO();         // → Eden
        dto.setName(user.getName());
        dtos.add(dto);
    }
    return dtos;  // Только этот список выживет
}
```

**Практические следствия:**
- Если Minor GC занимает много времени — в Eden слишком много выживающих объектов
- Если частые Full GC — утечка памяти или недостаточный heap
- Флаг `-XX:NewRatio=2` управляет соотношением Young/Old (2:1 по умолчанию)
```

### Чеклист информативности

```
□ Есть объяснительный текст (не только схемы/код)
□ Объяснено ПОЧЕМУ, не только ЧТО
□ Описаны практические следствия
□ Читатель поймёт даже без выполнения кода
□ Каждый раздел можно читать отдельно
```

### Соотношение контента

Соотношение для deep-dive и concept (intermediate+):
- **Текст (теория, объяснения, история, аналогии):** 80%+
- **Диаграммы (ASCII, таблицы):** 10-15%
- **Код (иллюстрации):** 5-10%

Код — иллюстрация к теории, не основной контент. Каждый code block окружён пояснительными абзацами (до: что покажем и зачем; после: что это демонстрирует, какой вывод).

Для reference-материала соотношение другое (больше таблиц), но даже там нужны пояснения.

Подробные требования к глубине: [[depth-standard]]

---

## Правило развёрнутых объяснений (No Orphan Bullets)

**Проблема:** Bullet-points содержат утверждения без объяснений. Читатель видит "что", но не понимает "почему", "как именно", "по сравнению с чем".

### Признаки orphan bullets

```markdown
❌ ПЛОХО:
**Почему это важно:**
- Immutability упрощает reasoning о коде
- Thread-safety без дополнительных усилий
- Functional programming style

(Три утверждения. Ноль объяснений. Три вопроса "почему?" без ответа.)
```

### Правило: каждый bullet отвечает на "почему?"

Каждое утверждение должно быть развёрнуто:
- **Что это?** — определение, если термин не очевиден
- **Почему это важно?** — какую проблему решает
- **По сравнению с чем?** — контекст, альтернативы
- **Конкретный пример** — не абстрактный, из реального кода

### Пример трансформации

```markdown
❌ ПЛОХО:
**Почему val предпочтительнее var:**
- Immutability упрощает reasoning о коде
- Thread-safety без дополнительных усилий
- Functional programming style

✅ ХОРОШО:
**Почему val предпочтительнее var:**

**Immutability упрощает понимание кода.** Когда переменная не меняется после
инициализации, вы всегда знаете её значение. Не нужно искать все места, где
она могла измениться. Это особенно важно при дебаге: вместо "где эта переменная
стала null?" — уверенность, что она такая же, как при создании.

```kotlin
// var — нужно проверить весь код, чтобы понять текущее значение
var counter = 0
// ... 100 строк кода ...
// Какое значение counter здесь? Нужно читать всё между.

// val — значение известно сразу
val maxRetries = 3
// Через 100 строк maxRetries всё ещё 3. Гарантировано.
```

**Thread-safety без дополнительных усилий.** Mutable состояние в многопоточной
среде требует синхронизации: locks, synchronized блоки, atomic операции. Один
поток читает переменную, другой её меняет — race condition. С immutable данными
проблемы нет: если значение не меняется, читать его могут сколько угодно потоков
одновременно.

```kotlin
// var в многопоточности — потенциальный баг
var sharedState = "initial"
// Поток A читает "initial"
// Поток B меняет на "updated"
// Поток A получает "initial" или "updated"? Зависит от timing.

// val в многопоточности — безопасно
val config = loadConfig()
// Любой поток читает одно и то же значение
```

**Functional programming style.** Функциональное программирование строится на
чистых функциях: одинаковый вход → одинаковый выход, без побочных эффектов.
Immutable данные — фундамент этого подхода. Kotlin collections API (map, filter,
fold) работает с immutable коллекциями — каждая операция возвращает новую
коллекцию вместо изменения существующей.

```kotlin
// Imperative (mutable):
val list = mutableListOf(1, 2, 3)
for (i in list.indices) {
    list[i] = list[i] * 2  // Мутация на месте
}

// Functional (immutable):
val doubled = list.map { it * 2 }  // Новый список, оригинал не изменён
```
```

### Чеклист для bullet-points

```
□ Каждый пункт объясняет ПОЧЕМУ, не только ЧТО
□ Термины определены (если не очевидны)
□ Есть сравнение/контекст ("по сравнению с...", "в отличие от...")
□ Есть конкретный пример кода или ситуации
□ Читатель без контекста поймёт значимость пункта
```

### Когда можно оставить короткие bullets

- **Reference-материалы:** краткость важнее глубины
- **Checklists:** формат подразумевает краткость
- **Очевидные пункты:** "Установить Docker" не требует объяснения зачем

Но в **explainer** и **deep-dive** материалах — каждое утверждение развёрнуто.

---

## Правило верификации (Fact-Checking)

**Проблема:** Утверждения могут быть неточными, устаревшими или неполными.

**Решение:** Проверять факты в нескольких источниках перед написанием.

### Что проверять

1. **Технические факты** — версии, синтаксис, поведение
2. **Цифры и статистика** — производительность, сравнения
3. **Best practices** — актуальность рекомендаций
4. **Терминология** — правильность определений

### Как проверять

1. **Официальная документация** — первый источник истины
2. **Несколько независимых источников** — минимум 2-3
3. **Дата источника** — информация актуальна?
4. **Авторитетность** — кто автор, какой опыт?

### Маркеры в тексте

```markdown
## Источники

- [Kotlin Docs: Null Safety](https://kotlinlang.org/docs/null-safety.html) — официальная документация
- [JetBrains Blog: Kotlin 2.0](https://blog.jetbrains.com/kotlin/) — проверено 2025-12-02
```

### Чеклист верификации

```
□ Проверил в официальной документации
□ Нашёл подтверждение в 2+ независимых источниках
□ Источники актуальны (не старше 2 лет для технологий)
□ Указал источники в конце материала
□ Цифры и проценты подтверждены данными
```

---

## Правило глоссария (терминология)

**Проблема:** технические тексты перегружены английскими терминами без объяснения.

**Решение:** глоссарий терминов в начале документа.

### Когда нужен глоссарий

- В тексте 5+ специфических терминов на английском
- Термины критичны для понимания
- Целевая аудитория может не знать термины

### Формат глоссария

```markdown
## Терминология

| Термин | Перевод/Значение |
|--------|------------------|
| **Thread** | Поток — независимая последовательность выполнения |
| **Lock** | Блокировка — механизм синхронизации |
| **Deadlock** | Взаимная блокировка — потоки ждут друг друга |
```

### Правила

1. **Максимум переводов** — если можно перевести, переводи
2. **Глоссарий только для непереводимого** — CAS, JVM, GC, API
3. **Первое упоминание** — термин в **жирном** при первом использовании
4. **Консистентность** — один термин = одно название везде

### Примеры

```
❌ "Thread может быть в состоянии BLOCKED когда waiting на lock"

✅ "Поток может быть заблокирован (BLOCKED) когда ожидает блокировку (lock)"
   Или с глоссарием:
   "Thread может быть в состоянии BLOCKED когда waiting на lock"
   (при наличии глоссария в начале документа)
```

### Что переводить

| English | Русский |
|---------|---------|
| Thread | Поток |
| Lock | Блокировка |
| Deadlock | Взаимоблокировка |
| Cache | Кэш |
| Buffer | Буфер |
| Queue | Очередь |
| Stack | Стек |
| Heap | Куча |
| Overhead | Накладные расходы |
| Throughput | Пропускная способность |
| Latency | Задержка |

### Что НЕ переводить (оставить + объяснить)

| Термин | Почему не переводится |
|--------|----------------------|
| CAS | Устоявшаяся аббревиатура (Compare-And-Swap) |
| JVM | Устоявшаяся аббревиатура |
| GC | Устоявшаяся аббревиатура (Garbage Collection) |
| volatile | Ключевое слово Java |
| synchronized | Ключевое слово Java |
| happens-before | Официальный термин спецификации |

---

## Быстрый выбор

```
Читатель хочет:                         → Тип:
─────────────────────────────────────────────────────
"Что это такое? Слышал термин"          → EXPLAINER
"Хочу сделать X, покажи как"            → TUTORIAL
"Как это работает внутри?"              → DEEP DIVE
"Забыл синтаксис, нужно быстро"         → REFERENCE
"Сравни A и B, что выбрать?"            → COMPARISON
```

---

## 1. EXPLAINER (объяснение концепции)

### Для кого
"Слышал термин, хочу понять что это и зачем."

### Структура

```markdown
# [Концепция]: [что делает в 5 словах]

> Одно предложение — суть.

---

## TL;DR (< 30 слов)

## Проблема, которую это решает
<!-- Зачем это придумали? Какая была боль? -->

## Как это работает
<!-- Простыми словами + аналогия из жизни + визуальная схема -->

## Пример из реальной жизни
<!-- Конкретный кейс, не абстрактный foo/bar -->

## Подводные камни
<!-- Что может пойти не так -->

## Когда НЕ использовать
<!-- Ограничения, контекст -->

## Связи
- [[X]] — почему связано
```

### Обязательные элементы
- Аналогия из жизни (не технологий!)
- Визуальная схема (ASCII или описание)
- Минимум 1 реальный пример
- Раздел "когда НЕ использовать"
- Секция "Источники" (минимум 1 признанный источник)
- Доступность: понятно человеку, впервые столкнувшемуся с темой

### Длина
- Beginner: 800-1500 слов
- Intermediate: 1500-3000 слов

### Пример крючка

```
❌ "Docker — это платформа для контейнеризации приложений."

✅ "У тебя Python 3.11, у клиента Python 2.7. Деплой — ад.
   Docker решает это раз и навсегда."
```

---

## 2. TUTORIAL (пошаговое руководство)

### Для кого
"Хочу сделать X. Покажи как, шаг за шагом."

### Структура

```markdown
# Как [сделать X]: пошаговое руководство

> Что получим в конце + сколько времени займёт.

---

## TL;DR
Делаем X за Y шагов. Результат: Z.

## Что понадобится
- Требование 1
- Требование 2
- Время: ~N минут

## Шаг 1: [Название]

[Объяснение что делаем и зачем]

```bash
# Команда или код
```

**Проверка:** Если всё правильно, увидишь [X].

## Шаг 2: [Название]
...

## Что-то пошло не так?

### Ошибка 1: [Текст ошибки]
Причина: ...
Решение: ...

### Ошибка 2: ...

## Что дальше?
- [[Следующий tutorial]]
- [[Продвинутая тема]]
```

### Обязательные элементы
- "Что понадобится" — всё для старта
- Проверка после КАЖДОГО шага
- Раздел troubleshooting
- Рабочий код (не pseudo-code)

### Длина
Столько, сколько нужно. Без padding.

### Пример шага

```
❌ "Создайте файл и добавьте в него конфигурацию."

✅ ## Шаг 2: Создаём docker-compose.yml

Этот файл описывает какие контейнеры запускать.

```yaml
version: '3.8'
services:
  web:
    build: .
    ports:
      - "8000:8000"  # localhost:8000 → контейнер:8000
```

**Проверка:** Файл должен лежать в корне проекта рядом с Dockerfile.
```

---

## 3. DEEP DIVE (глубокое погружение)

### Для кого
"Хочу понять как это работает ВНУТРИ. Почему так спроектировано."

### Структура

```markdown
# [Тема]: как это работает на самом деле

> Глубокое погружение в [X] — от истории до реализации.

---

## TL;DR

## Почему это вообще существует?
<!-- История: какая проблема была, кто решил, когда -->

## Ключевые концепции
<!-- Фундамент, без которого не понять остальное -->

### Концепция 1: [Название]
<!-- Объяснение + аналогия + визуальная схема -->

### Концепция 2: [Название]
...

## Как это работает под капотом
<!-- Технические детали, алгоритмы, структуры данных -->

## Реальные кейсы
<!-- Примеры из production: компании, цифры, уроки -->

## Подводные камни
<!-- Что может пойти не так, edge cases -->

## Мифы и заблуждения
<!-- Что люди думают неправильно -->

## Практическое применение
<!-- Что делать с этим знанием -->

## Источники
<!-- Книги, papers, talks -->
```

### Обязательные элементы
- История/контекст (зачем это придумали)
- Минимум 2 визуальные схемы с объяснением каждого элемента
- Реальные кейсы с цифрами
- Раздел "мифы и заблуждения"
- Каждая концепция — минимум 3-5 абзацев развёрнутого объяснения
- Понятность с нуля: каждый термин объяснён при первом появлении
- Секция "Источники и дальнейшее чтение" (2+ книги/papers)
- Код — иллюстрация (абзац до + абзац после каждого code block)

### Длина
- Intermediate: 5000-8000 слов (80%+ пояснительный текст)
- Advanced: 8000-12000 слов

Это полноценная глава учебника, не краткое введение.

### Пример перехода между разделами

```
❌
## Heap
[контент]

## Garbage Collection
[контент]

✅
## Heap
[контент]

Heap объясняет ГДЕ живут объекты. Но кто их убивает,
когда они больше не нужны?

## Garbage Collection
[контент]
```

---

## 4. REFERENCE (справка)

### Для кого
"Забыл синтаксис/параметры. Нужно быстро найти."

### Структура

```markdown
# [Инструмент/API]: справочник

> Быстрый доступ к [X]. Ctrl+F friendly.

---

## Самое частое

| Задача | Команда/Синтаксис |
|--------|-------------------|
| X | `...` |
| Y | `...` |

## [Категория 1]

### [Подтема]
```bash
# Синтаксис
command [options] <arguments>

# Пример
command -v --long-option value
```

**Параметры:**
| Параметр | Описание | По умолчанию |
|----------|----------|--------------|
| `-v` | ... | ... |

## [Категория 2]
...

## Типичные ошибки

| Ошибка | Причина | Решение |
|--------|---------|---------|
| ... | ... | ... |

## Связанные темы
- [[X]]
```

### Обязательные элементы
- Таблица "самое частое" в начале
- Все примеры — рабочие, копируемые
- Таблица типичных ошибок
- Ctrl+F friendly (чёткие заголовки)

### Длина
Минимальная, но достаточная. Без воды.

### Пример

```
❌ "Команда grep используется для поиска текста в файлах.
   Она имеет множество полезных параметров..."

✅ ## grep — поиск текста

```bash
# Базовый поиск
grep "pattern" file.txt

# Рекурсивно во всех файлах
grep -r "pattern" /path/

# Игнорировать регистр
grep -i "Pattern" file.txt
```

| Флаг | Что делает |
|------|------------|
| `-r` | Рекурсивно |
| `-i` | Ignore case |
| `-n` | Показать номера строк |
```

---

## 5. COMPARISON (сравнение)

### Для кого
"A или B? Что выбрать для моего случая?"

### Структура

```markdown
# [A] vs [B]: что выбрать

> Одно предложение — главное отличие.

---

## TL;DR
Выбирай A если [X]. Выбирай B если [Y].

## Быстрое сравнение

| Критерий | A | B |
|----------|---|---|
| Когда использовать | ... | ... |
| Сложность | ... | ... |
| Performance | ... | ... |
| Команда | ... | ... |

## [Критерий 1]: подробно
<!-- Детальное сравнение с примерами -->

## [Критерий 2]: подробно
...

## Реальные кейсы

### Когда A выиграл
...

### Когда B выиграл
...

## Дерево решений

```
Начни здесь
    │
    ├─► Команда < 20 человек?
    │       │
    │       ├─► Да → A
    │       └─► Нет → ...
```

## Мифы
<!-- Что люди думают неправильно о A и B -->

## Моё мнение
<!-- Субъективно: что бы выбрал автор -->
```

### Обязательные элементы
- Таблица быстрого сравнения
- Дерево решений (когда что выбирать)
- Реальные кейсы (не абстрактные)
- Раздел "моё мнение" (субъективно, но полезно)

### Длина
- Intermediate: 2500-4000 слов
- Advanced: 4000-6000 слов

### Пример TL;DR

```
❌ "Оба подхода имеют свои преимущества и недостатки."

✅ "Монолит — если команда < 20 и нет распределённых проблем.
   Микросервисы — если масштабирование команды важнее скорости."
```

---

## Чеклист перед выбором типа

```
□ Понял что хочет читатель (не что хочу написать)
□ Выбрал тип под его цель
□ Использую структуру этого типа
□ Не смешиваю типы (tutorial ≠ reference)
□ Код — иллюстрация (абзац до + абзац после каждого code block)
□ Источники указаны (для intermediate+: 2+ книг/papers)
□ Глубина соответствует стандарту: [[depth-standard]]
```

---

## Дополнительный чеклист: Научные статьи (Thinking)

Для статей раздела Thinking & Learning дополнительно проверь:

### MUST для научного контента:
```
□ Научные источники (peer-reviewed journals: Nature, Frontiers, PNAS)
□ Даты исследований (не старше 5 лет для нейронауки)
□ Meta-analysis предпочтительнее single study
□ Указание confidence level (high/medium/low)
□ Даты верификации источников
```

### SHOULD для научного контента:
```
□ Ссылка на original researcher (Bjork, Ericsson, Mark, Newport)
□ Противоречащие исследования (если есть)
□ Практические примеры для IT
□ Цифры и метрики (47 секунд, 23 минуты, 2-3x)
```

### Формат источников:
```
- [Автор (год): Название] — тип источника — проверено DATE
- Пример: [Gloria Mark (2016): Attention Span] — peer-reviewed — проверено 2025-12-19
```

---

*Последнее обновление: 2025-12-19*
