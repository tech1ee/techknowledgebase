---
title: "Модели авторизации: от ACL до Google Zanzibar"
created: 2026-02-11
modified: 2026-02-11
type: deep-dive
status: published
confidence: high
tags:
  - topic/security
  - type/deep-dive
  - level/intermediate
related:
  - "[[authentication-authorization]]"
  - "[[auth-api-service-patterns]]"
  - "[[web-security-owasp]]"
  - "[[security-fundamentals]]"
prerequisites:
  - "[[authentication-authorization]]"
reading_time: 31
difficulty: 7
study_status: not_started
mastery: 0
last_reviewed:
next_review:
---

# Модели авторизации: от ACL до Google Zanzibar

Аутентификация отвечает на вопрос "кто ты?". Авторизация -- на вопрос "что тебе можно?". Broken Access Control -- уязвимость номер один в OWASP Top 10 с 2021 года, и в подавляющем большинстве случаев причина не в отсутствии авторизации, а в неправильно выбранной модели. Этот материал разбирает все ключевые модели авторизации: от военных ACL 1970-х годов до Google Zanzibar (2019), который обрабатывает десятки миллионов проверок в секунду для YouTube, Google Drive и Google Cloud.

---

## Зачем это знать

Broken Access Control занимает первое место в OWASP Top 10 с 2021 года -- обогнав инъекции, которые удерживали лидерство более десяти лет. Это не случайность. Приложения стали сложнее: микросервисы, API-first архитектура, мультитенантность. Простая проверка `if (user.role === "admin")` больше не работает, когда десятки сервисов принимают решения о доступе независимо друг от друга.

Неправильно выбранная модель авторизации создаёт проблемы двух типов. Первый -- слишком жёсткая модель. Бизнес просит "дать доступ только сотрудникам отдела маркетинга в рабочие часы к отчётам своего региона", а система поддерживает только роли admin/editor/viewer. Начинается взрыв ролей: `editor_marketing_us`, `editor_marketing_eu`, `editor_marketing_restricted_us`. Второй -- слишком сложная модель. Команда внедряет ABAC с сотнями атрибутов для приложения, где хватило бы пяти RBAC-ролей. Результат: политики невозможно понять, невозможно отладить, невозможно аудитировать.

Реальные последствия: в 2018 году баг в Facebook позволил атакующим получить access tokens 50 миллионов пользователей из-за ошибки в модели разрешений View As. В 2019 году утечка данных Capital One произошла через SSRF, но усугубилась чрезмерно широкими IAM-правами в AWS. Каждый из этих инцидентов -- это ошибка в авторизации, а не в аутентификации.

---

## Терминология

| Термин | Значение | Аналогия из реальной жизни |
|--------|----------|---------------------------|
| **Subject** | Тот, кто запрашивает доступ (пользователь, сервис, процесс) | Посетитель музея: конкретный человек, который стоит перед дверью |
| **Resource** | То, к чему запрашивается доступ (файл, запись, API endpoint) | Экспонат в музее: картина, скульптура, закрытый зал |
| **Action** | Что субъект хочет сделать с ресурсом (read, write, delete, share) | Действие посетителя: смотреть, фотографировать, трогать руками |
| **Permission** | Разрешение на конкретное действие над конкретным ресурсом | Надпись на табличке: "фотографировать разрешено", "руками не трогать" |
| **Role** | Именованный набор permissions, назначаемый субъектам | Тип пропуска: "обычный посетитель", "VIP", "сотрудник музея" |
| **Policy** | Правило или набор правил, определяющих решение о доступе | Внутренний регламент музея: "VIP-посетители могут входить в запасники по будням с 10 до 18" |
| **Principal** | Идентифицированный субъект (subject + identity) | Посетитель с паспортом: мы знаем не просто "кто-то", а конкретно "Иван Петров" |
| **Scope** | Границы действия разрешения (какие ресурсы, какие операции) | Территория действия пропуска: "только первый этаж", "весь музей" |
| **Tuple** | Запись вида (subject, relation, object) в ReBAC-системах | Запись в журнале: "Иван Петров -- друг -- Марии Сидоровой" |

---

## Prerequisites

| Prerequisite | Что нужно знать | Почему |
|-------------|----------------|--------|
| [[authentication-authorization]] | Разница между AuthN и AuthZ, JWT, OAuth 2.0, сессии | Авторизация наступает ПОСЛЕ аутентификации -- без понимания AuthN модели AuthZ не имеют смысла |
| [[security-fundamentals]] | Базовые принципы безопасности, принцип минимальных привилегий | Все модели авторизации реализуют Principle of Least Privilege разными способами |

---

## Историческая справка

История авторизации -- это история постепенного усложнения: от простых списков к контексту, от статических ролей к динамическим отношениям. Каждая новая модель появлялась не из теоретической красоты, а из практической боли: предыдущая модель не справлялась с реальностью.

```
Эволюция моделей авторизации:

1960s        1970s         1992          2005          2019         2020s
  │            │             │             │             │             │
  ▼            ▼             ▼             ▼             ▼             ▼
┌─────┐    ┌────────┐    ┌──────┐     ┌──────┐     ┌──────┐     ┌──────┐
│ ACL │───▶│DAC/MAC │───▶│ RBAC │────▶│ ABAC │────▶│ ReBAC│────▶│Hybrid│
│     │    │        │    │      │     │      │     │      │     │ PBAC │
└─────┘    └────────┘    └──────┘     └──────┘     └──────┘     └──────┘
Lampson     Bell &        Ferraiolo    NIST SP      Zanzibar     AWS IAM
 1969      LaPadula       & Kuhn       800-162      Pang et al.  Cedar
            1973           1992         2014         2019         2023

Каждая стрелка = "предыдущая модель не справлялась"
```

В 1969 году Батлер Лампсон (Butler Lampson) опубликовал статью "Protection", в которой формализовал понятие матрицы доступа (access matrix) -- двумерной таблицы, где строки представляют субъектов, столбцы -- объекты, а ячейки -- разрешения. Это была первая теоретическая модель авторизации, и все последующие модели -- по сути, разные способы компактно представить эту матрицу.

В 1973 году Дэвид Белл и Леонард Ла Падула (David Bell, Leonard LaPadula) из MITRE Corporation создали формальную модель для Министерства обороны США -- Bell-LaPadula model. Это была первая модель Mandatory Access Control: правила задаёт центральная власть, пользователи не могут их изменять. Принцип простой: "нельзя читать выше своего уровня, нельзя писать ниже своего уровня" (no read up, no write down). Эта модель определила военную и государственную безопасность на десятилетия.

В 1992 году Дэвид Ферраиоло и Ричард Кун (David Ferraiolo, Richard Kuhn) из NIST опубликовали статью "Role-Based Access Controls", которая предложила элегантную альтернативу: вместо назначения permissions каждому пользователю, создать промежуточную абстракцию -- роль. Пользователи получают роли, роли содержат permissions. RBAC стала доминирующей моделью на следующие 25 лет.

К середине 2000-х стало очевидно, что RBAC не справляется с контекстными решениями. NIST ответил публикацией SP 800-162 (2014), формализовав Attribute-Based Access Control (ABAC): решение о доступе принимается на основе атрибутов субъекта, ресурса, действия и окружения.

Наконец, в 2019 году группа инженеров Google (Ruoming Pang и другие) опубликовала статью "Zanzibar: Google's Consistent, Global Authorization System" на конференции USENIX ATC. Zanzibar предложил совершенно новый подход: авторизация на основе отношений (Relationship-Based Access Control, ReBAC). Эта система обрабатывает более 10 миллионов проверок в секунду и обслуживает YouTube, Google Drive, Google Cloud и десятки других продуктов Google.

---

## ACL: Access Control Lists

### Что такое ACL

ACL (Access Control List) -- это самая простая и самая старая модель авторизации. Идея прямолинейная: для каждого ресурса хранится список субъектов и их разрешений. Когда субъект запрашивает доступ к ресурсу, система ищет его в списке этого ресурса и проверяет, есть ли нужное разрешение.

Концептуально ACL -- это реализация матрицы доступа Лампсона, где матрица "разрезана по столбцам": каждый ресурс хранит свой столбец (список субъектов с правами). Альтернативный способ нарезки -- по строкам: каждый субъект хранит список своих прав на ресурсы. Этот вариант называется capability list и обсуждается отдельно.

### Аналогия: список гостей на свадьбе

Представьте организатора свадьбы с блокнотом. На каждой странице -- название стола (ресурс), и рядом -- конкретные имена гостей с пометками: "Иван Петров -- стол 3, с супругой" (субъект + разрешение). Нет имени в списке -- нет входа. Для свадьбы на 50 гостей это работает идеально. Для мероприятия на 10 000 человек -- организатор сойдёт с ума, перелистывая блокнот.

### Где ACL живёт на практике

Самая известная реализация ACL -- файловая система Unix. Каждый файл имеет три группы прав: owner (владелец), group (группа), others (все остальные). Каждая группа получает комбинацию из трёх бит: read (r), write (w), execute (x). Запись `rwxr-xr--` означает: владелец может всё, группа может читать и запускать, остальные -- только читать.

Windows NTFS реализует более детальные ACL: каждый файл и каталог может иметь произвольный список ACE (Access Control Entry), где указаны конкретные пользователи и группы с конкретными разрешениями. NTFS ACL может содержать десятки записей -- и именно это создаёт проблему масштабирования.

### Преимущества и ограничения

ACL просты, явны и легко поддаются аудиту для конкретного ресурса: открыл список -- увидел, кто имеет доступ. Но они не масштабируются. Если в системе 1000 пользователей и 1000 ресурсов, ACL может содержать до миллиона записей. Добавление нового пользователя требует обновления ACL на каждом ресурсе, к которому ему нужен доступ. Нет группировки, нет наследования, нет контекста.

> **Ключевая идея:** ACL идеально подходит для файловых систем и небольших систем, где количество субъектов и ресурсов ограничено. Для веб-приложений с тысячами пользователей и динамическими ресурсами -- ACL становится неуправляемой.

Мы разобрали ACL -- самую простую модель. Но в 1970-х возник фундаментальный вопрос: КТО имеет право менять эти списки? Ответ разделил мир на два лагеря: DAC и MAC.

---

## DAC vs MAC: кто контролирует доступ

### DAC: Discretionary Access Control

DAC (Discretionary Access Control) -- модель, в которой владелец ресурса сам решает, кому дать доступ. Слово "discretionary" означает "на усмотрение": владелец файла может поделиться им с кем угодно по своему усмотрению.

**Аналогия: хозяин квартиры.** Вы купили квартиру -- вы решаете, кого приглашать. Можете дать ключ другу, можете поставить кодовый замок и сообщить код соседям. Никто не ограничивает ваши решения -- это ваша собственность. Риск очевиден: вы можете дать ключ ненадёжному человеку, и он сделает копию для третьих лиц.

DAC -- это стандартная модель большинства операционных систем. Когда вы создаёте файл в Linux, вы -- его владелец, и `chmod` позволяет вам устанавливать права. Google Drive работает по той же схеме: создатель документа решает, кому дать доступ на чтение, редактирование или комментирование. Проблема DAC -- transitive sharing: Алиса даёт доступ Бобу, Боб копирует документ и делится с Чарли. Алиса теряет контроль.

### MAC: Mandatory Access Control

MAC (Mandatory Access Control) -- модель, в которой центральная власть устанавливает правила, и ни один пользователь -- даже владелец ресурса -- не может их изменить. Правила обязательны (mandatory) для всех без исключения.

**Аналогия: комендант общежития.** В общежитии правила устанавливает комендант: вход после 23:00 запрещён, гости -- только до 21:00, в блок B допускаются только проживающие. Жилец не может изменить эти правила, даже если он живёт в комнате 10 лет. Правила одинаковы для всех, и жилец не может "поделиться" своим доступом с другом, просто отдав ему ключ.

Самая известная реализация MAC -- модель Bell-LaPadula для военной классификации. Данные имеют уровни: Unclassified < Confidential < Secret < Top Secret. Пользователи имеют допуск (clearance) на определённый уровень. Два правила: **no read up** (нельзя читать документы выше своего допуска) и **no write down** (нельзя записывать секретную информацию в несекретный документ -- это предотвращает утечку). В гражданском мире MAC реализован в SELinux и AppArmor, которые ограничивают процессы на уровне ядра Linux.

### Сравнение DAC и MAC

| Критерий | DAC | MAC |
|----------|-----|-----|
| Кто контролирует | Владелец ресурса | Центральная политика |
| Гибкость | Высокая (владелец решает сам) | Низкая (правила фиксированы) |
| Безопасность | Средняя (человеческий фактор) | Высокая (нет обходных путей) |
| Transitive sharing | Возможно (риск) | Невозможно (защита) |
| Сложность настройки | Простая | Высокая |
| Примеры | Unix filesystem, Google Drive | SELinux, AppArmor, военные системы |
| Подходит для | Офисные приложения, совместная работа | Государственные, финансовые, медицинские системы |

> **Ключевая идея:** DAC и MAC -- не конкуренты, а два полюса спектра. Большинство реальных систем комбинируют оба подхода: в Linux пользователь устанавливает chmod (DAC), но SELinux может запретить операцию даже при наличии chmod-прав (MAC).

Мы разобрали, кто контролирует доступ. Теперь -- САМАЯ популярная модель авторизации в мире: RBAC. Она решает проблему масштабирования ACL через одну элегантную абстракцию -- роль.

---

## RBAC: Role-Based Access Control

### Что такое RBAC

RBAC (Role-Based Access Control) -- модель, в которой permissions назначаются не напрямую пользователям, а ролям. Пользователи получают роли, и через роли -- разрешения. Авторизация сводится к проверке: "имеет ли роль пользователя нужное разрешение?"

Эта модель была формализована Дэвидом Ферраиоло и Ричардом Куном в 1992 году в статье для NIST. Их ключевое наблюдение: в организациях людей больше, чем должностей. Вместо того чтобы настраивать permissions для каждого из 5000 сотрудников, достаточно настроить permissions для 20 ролей и назначить сотрудников на роли. Это сократило управление правами на порядки.

### Аналогия: бейджи в офисе

Представьте офисное здание с электронными пропусками. Зелёный бейдж -- доступ на этажи 1-3 (обычный сотрудник). Синий бейдж -- этажи 1-5 плюс серверная (IT-отдел). Красный бейдж -- везде (руководство). Когда нанимают нового сотрудника в IT, ему выдают синий бейдж -- и он автоматически получает все нужные доступы. Не нужно настраивать каждую дверь отдельно. Когда сотрудник увольняется -- забирают бейдж, и все доступы отключаются одним действием.

Именно так работает RBAC. Роль -- это "цвет бейджа". Permissions -- это "какие двери открываются". Пользователь -- это "человек с бейджом". Простота этой модели объясняет её доминирование: RBAC используется в 90%+ корпоративных приложений.

### Четыре уровня RBAC (модель Sandhu)

В 1996 году Рави Сандху (Ravi Sandhu) и коллеги расширили базовую модель RBAC, определив четыре уровня -- от простого к полному.

**RBAC0 (Core/Flat RBAC)** -- базовая модель. Пользователи назначаются на роли, роли содержат permissions. Никакой иерархии: admin и editor -- независимые роли, у каждой свой набор прав. Если admin должен уметь всё, что умеет editor, плюс дополнительные действия -- permissions editor дублируются в admin.

**RBAC1 (Hierarchical RBAC)** добавляет наследование ролей. Admin наследует все permissions от Editor, Editor наследует от Viewer. Это устраняет дублирование: достаточно определить уникальные права каждого уровня, остальное наследуется. Иерархия может быть деревом (каждая роль -- один родитель) или графом (роль наследует от нескольких родителей).

**RBAC2 (Constrained RBAC)** добавляет ограничения. Самое важное -- Separation of Duties (разделение обязанностей). Статическое SoD: пользователь не может иметь роли "создатель заказа" и "одобритель заказа" одновременно. Динамическое SoD: пользователь может иметь обе роли, но не может активировать их в одной сессии. Это критично для финансовых систем: тот, кто создаёт платёж, не может его же одобрять.

**RBAC3 (Combined)** объединяет RBAC1 и RBAC2 -- иерархия плюс ограничения. Это наиболее полная модель, используемая в enterprise-системах.

```
Иерархия ролей RBAC1:

              ┌───────────┐
              │   Admin   │
              │ (manage_  │
              │  users,   │
              │  settings)│
              └─────┬─────┘
                    │ inherits
              ┌─────▼─────┐
              │  Editor   │
              │  (write,  │
              │   edit,   │
              │  publish) │
              └─────┬─────┘
                    │ inherits
              ┌─────▼─────┐
              │  Viewer   │
              │  (read,   │
              │   list,   │
              │  search)  │
              └───────────┘

Admin имеет: manage_users + settings + write + edit +
             publish + read + list + search
Editor имеет: write + edit + publish + read + list + search
Viewer имеет: read + list + search
```

### Проблема взрыва ролей

RBAC работает блестяще, пока ролей немного. Но когда бизнес-требования усложняются, начинается то, что называется role explosion -- взрывной рост количества ролей.

Представьте систему управления контентом для международной компании. Начинается всё красиво: Admin, Editor, Viewer. Потом бизнес просит: "Редакторы в US должны видеть только контент US". Появляется Editor_US и Editor_EU. Потом: "Некоторый контент -- restricted, и только определённые редакторы могут его видеть". Появляется Editor_US_Restricted. Потом: "В Азии другие правила -- редакторы могут публиковать сразу, без модерации". Появляется Editor_Asia_AutoPublish.

Реальный пример: в крупных enterprise-системах количество ролей превышает 500, а иногда -- 1000. На этом уровне RBAC теряет своё главное преимущество -- простоту. Администратор не может понять, какие права у роли `Editor_EMEA_Restricted_Internal_Level2`. Аудитор не может проверить, всё ли корректно. Именно эта проблема мотивировала создание ABAC.

### Когда RBAC достаточно

RBAC -- правильный выбор, когда: роли стабильны и меняются редко (менее 50 ролей), разрешения не зависят от контекста (времени, местоположения, содержимого ресурса), и нет потребности в fine-grained контроле на уровне отдельных записей. Типичные примеры: внутренние корпоративные приложения, CMS с фиксированными ролями, admin-панели.

### Когда RBAC не справляется

RBAC не справляется, когда: разрешения зависят от контекста ("автор может редактировать только свои посты"), требуется dynamic access control ("доступ только в рабочие часы с корпоративного IP"), или комбинации атрибутов создают взрыв ролей. Именно в этих случаях нужен ABAC.

Ниже показано, как выглядит простейший RBAC-middleware. Обратите внимание, что проверка занимает одну строку -- в этом сила модели: решение принимается мгновенно, за O(1) по хеш-таблице.

```kotlin
// RBAC: проверка через таблицу ролей → permissions
data class User(val id: String, val roles: Set<String>)

// Роли → разрешения, определённые при старте приложения
val rolePermissions = mapOf(
    "admin" to setOf("read", "write", "delete", "manage_users"),
    "editor" to setOf("read", "write"),
    "viewer" to setOf("read")
)

fun hasPermission(user: User, action: String): Boolean {
    // Проверяем ВСЕ роли пользователя — у него может быть несколько
    return user.roles.any { role ->
        rolePermissions[role]?.contains(action) == true
    }
}
```

Этот код демонстрирует суть RBAC: решение принимается через двойной lookup -- сначала находим permissions для каждой роли пользователя, затем проверяем наличие нужного action. В реальных системах `rolePermissions` хранится в базе данных или конфигурации, а не в коде -- это позволяет менять права без деплоя.

Мы разобрали RBAC -- его силу и его ограничения. Теперь -- модель, которая решает проблему взрыва ролей: ABAC.

---

## ABAC: Attribute-Based Access Control

### Что такое ABAC

ABAC (Attribute-Based Access Control) -- модель, в которой решение о доступе принимается на основе атрибутов четырёх категорий: субъекта, ресурса, действия и окружения. В отличие от RBAC, где решение зависит только от роли, ABAC учитывает произвольное количество факторов одновременно.

ABAC был формализован NIST в публикации SP 800-162 "Guide to Attribute Based Access Control (ABAC) Definition and Considerations" (2014). Хотя идеи ABAC существовали раньше -- стандарт XACML (eXtensible Access Control Markup Language) был опубликован OASIS в 2003 году -- именно документ NIST 2014 года стал канонической спецификацией.

### Аналогия: таможенный контроль в аэропорту

Представьте таможенный контроль при прилёте в страну. Офицер не просто проверяет ваш паспорт (роль = "гражданин" или "турист"). Он оценивает множество атрибутов одновременно: кто вы (паспорт, гражданство, наличие визы), что везёте (декларация, запрещённые предметы), откуда летите (страна вылета -- есть ли санкции?), когда прилетели (время суток, сезон -- усиленный контроль в праздники). Решение "пропустить/задержать" -- результат оценки всех атрибутов в совокупности.

Ни один RBAC не справится с таким количеством факторов. Пришлось бы создавать роль для каждой комбинации: `citizen_from_US_with_food_during_holiday`. Это абсурд. ABAC позволяет описать это одной политикой: IF (citizen AND from_sanctioned_country = false AND declared_items = true AND arrival_time IN working_hours) THEN allow.

### Четыре категории атрибутов

**Subject attributes** -- характеристики того, кто запрашивает доступ. Роль, отдел, уровень допуска, должность, команда, дата найма. В RBAC из всех этих атрибутов используется только роль. ABAC использует все.

**Resource attributes** -- характеристики того, к чему запрашивается доступ. Тип ресурса, владелец, уровень классификации, дата создания, регион, тэги. Это критически важно для контентных систем: "документы с пометкой Confidential доступны только сотрудникам с допуском уровня 3+".

**Action attributes** -- характеристики запрашиваемого действия. Обычно это read, write, delete, approve, share -- но могут быть и более специфичные: bulk_export, delegate_access, change_classification. Разные действия могут требовать разных уровней проверки.

**Environment attributes** -- характеристики контекста, не зависящие от субъекта или ресурса. Время запроса, IP-адрес, тип устройства, сетевая зона (корпоративная сеть или VPN), уровень текущей угрозы. Именно environment attributes делают ABAC мощнее RBAC: "сотрудник может скачивать отчёты только с корпоративного устройства в рабочие часы".

### Как ABAC принимает решение

Решение в ABAC -- это вычисление политики: набора условий на атрибутах всех четырёх категорий. Если все условия выполнены -- доступ разрешён.

```
Структура ABAC-решения:

┌─────────────────────────────────────────────────────────┐
│                   Policy Evaluation                      │
│                                                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │   Subject    │  │   Resource   │  │ Environment  │  │
│  │  Attributes  │  │  Attributes  │  │  Attributes  │  │
│  ├──────────────┤  ├──────────────┤  ├──────────────┤  │
│  │ role: editor │  │ type: report │  │ time: 14:30  │  │
│  │ dept: sales  │  │ region: EU   │  │ ip: corp_net │  │
│  │ level: 3     │  │ class: conf  │  │ device: mgd  │  │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘  │
│         │                 │                 │           │
│         └────────┬────────┴────────┬────────┘           │
│                  ▼                 ▼                     │
│         ┌──────────────────────────────┐                │
│         │  Policy Engine evaluates:    │                │
│         │                              │                │
│         │  IF subject.dept = "sales"   │                │
│         │  AND resource.region = "EU"  │                │
│         │  AND subject.level >= 3      │                │
│         │  AND env.time IN 9:00-18:00  │                │
│         │  AND env.ip IN corp_network  │                │
│         │  THEN → ALLOW               │                │
│         │  ELSE → DENY                │                │
│         └──────────────────────────────┘                │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### XACML: попытка стандартизации

XACML (eXtensible Access Control Markup Language) -- XML-стандарт для описания ABAC-политик, разработанный OASIS в 2003 году. XACML определяет архитектуру из четырёх компонентов: PEP (Policy Enforcement Point -- точка применения), PDP (Policy Decision Point -- точка принятия решения), PAP (Policy Administration Point -- точка администрирования) и PIP (Policy Information Point -- источник атрибутов).

XACML стал важным теоретическим фундаментом, но на практике его XML-синтаксис оказался слишком громоздким. Современные policy engines (OPA, Cedar, Casbin) реализуют те же идеи с гораздо более лаконичным синтаксисом.

### Преимущества и цена ABAC

Главное преимущество ABAC -- отсутствие role explosion. Вместо создания роли `Editor_EU_Confidential_WorkHours` достаточно одной политики с четырьмя условиями. ABAC масштабируется по количеству правил, а не по комбинациям ролей.

Но цена высока. Политики ABAC сложнее писать, тестировать и отлаживать. Вопрос "почему пользователю Иванову отказано в доступе к документу X?" требует анализа всех атрибутов и всех политик. В RBAC ответ прост: "у его роли нет нужного permission". В ABAC ответ может включать десяток факторов: неправильный отдел, недостаточный уровень, неправильное время, VPN вместо корпоративной сети.

Performance -- ещё одна проблема. RBAC-проверка -- это O(1) lookup по хеш-таблице. ABAC-проверка -- это вычисление политик, которое может потребовать запросов к внешним системам для получения атрибутов (например, запрос к HR-системе для проверки отдела). Кэширование помогает, но добавляет проблему инвалидации.

Мы разобрали ABAC -- его мощь и его сложность. Но есть сценарии, которые плохо описываются даже атрибутами: социальные связи. "Ты можешь видеть пост, потому что ты друг автора" -- это не атрибут, это отношение. Для таких сценариев Google создал ReBAC.

---

## ReBAC: Relationship-Based Access Control

### Что такое ReBAC

ReBAC (Relationship-Based Access Control) -- модель, в которой решение о доступе основано на отношениях (relationships) между сущностями. Не "кто ты" (RBAC), не "какие у тебя атрибуты" (ABAC), а "как ты связан с ресурсом".

ReBAC был формализован в статье "Zanzibar: Google's Consistent, Global Authorization System", опубликованной Ruoming Pang и командой из Google на конференции USENIX ATC в 2019 году. Zanzibar -- не теоретическая модель, а production-система, обрабатывающая более 10 миллионов проверок доступа в секунду для YouTube, Google Drive, Google Cloud и десятков других сервисов Google.

### Аналогия: социальные связи

Представьте ситуацию в реальной жизни. Вы приходите на закрытую вечеринку. Охранник не проверяет ваш бейдж (RBAC) и не проверяет ваш возраст, одежду и IP-адрес (ABAC). Он спрашивает: "Кто вас привёл?" Вы отвечаете: "Я пришёл с Машей, она -- подруга хозяина". Охранник проверяет цепочку: вы → пришли с → Маша → подруга → хозяин. Цепочка подтверждена -- вы проходите.

Это и есть ReBAC: авторизация через граф отношений. Не важно, какая у вас роль. Важно, как вы связаны с ресурсом -- напрямую или через цепочку отношений.

### Tuples: язык ReBAC

Центральное понятие ReBAC -- tuple (кортеж). Tuple описывает одно отношение: `(subject, relation, object)`. Примеры:

```
Tuples в ReBAC:

alice    is   owner   of   doc:report-2024
bob      is   member  of   group:engineering
group:engineering  is  viewer  of   doc:report-2024

Проверка: "Может ли bob читать doc:report-2024?"

  bob ──member──▶ group:engineering ──viewer──▶ doc:report-2024
                                                     │
  Ответ: ДА (bob → member of engineering →           │
              engineering is viewer of report)        │
                                                     ▼
Граф отношений:                                   ALLOW

  alice ──owner──▶ doc:report-2024 ◀──viewer── group:engineering
                                                      ▲
  bob ──member──▶ group:engineering ────────────────────┘

  carol ──???──▶ ???  (нет связи с doc:report-2024)
                       → DENY
```

Проверка доступа сводится к обходу графа: существует ли путь от субъекта к ресурсу через разрешённые отношения? Bob является member группы engineering, группа engineering является viewer документа report-2024 -- следовательно, Bob может читать report-2024. Carol не связана с документом ни через какую цепочку -- доступ запрещён.

### Почему Google создал Zanzibar

До Zanzibar каждый продукт Google реализовывал авторизацию по-своему. YouTube имел свою систему для видео, Drive -- для файлов, Cloud -- для ресурсов. Это создавало три проблемы: дублирование кода (каждая команда писала свой policy engine), несогласованность (разные продукты интерпретировали sharing по-разному) и масштаб (YouTube один генерирует миллионы проверок в секунду).

Zanzibar решил все три проблемы одной унифицированной системой. Ключевые архитектурные решения: глобально распределённое хранилище tuples (на базе Spanner), кэширование с leopard indexing для быстрых проверок, и zookies -- непрозрачные токены для обеспечения consistency (клиент получает zookie после записи и передаёт его при чтении, гарантируя, что система увидит свежие данные).

### Преимущества ReBAC

ReBAC интуитивен для collaborative-приложений. Когда пользователь говорит "поделиться документом с командой", это естественно описывается tuple: `(team:design, viewer, doc:roadmap)`. Наследование через группы, организации и папки работает через транзитивные отношения: member of team → team is part of org → org owns folder → folder contains doc.

ReBAC масштабируется лучше ABAC для sharing-сценариев, потому что проверка -- это обход графа, а не вычисление произвольных политик. Граф можно предвычислять (materialized views), кэшировать, индексировать.

### Ограничения ReBAC

Граф отношений может стать очень сложным. В реальных системах: пользователь является member группы, которая является частью организации, которая имеет доступ к project, в котором есть folder, в которой лежит document. Это пять уровней транзитивности. Отладка "почему у пользователя X есть доступ?" требует обхода всего графа.

ReBAC не подходит для context-dependent правил. "Доступ только в рабочие часы" или "доступ только с корпоративного устройства" -- это не отношения, это атрибуты. Для таких случаев нужна комбинация ReBAC + ABAC.

### Open-source реализации

После публикации Zanzibar paper появилось несколько open-source реализаций:

**OpenFGA** (Fine-Grained Authorization) -- проект от Okta/Auth0, принятый в CNCF (Cloud Native Computing Foundation). Реализует Zanzibar-модель с DSL для описания модели авторизации и HTTP/gRPC API для проверок.

**SpiceDB** -- проект от AuthZed, полная реализация Zanzibar с поддержкой PostgreSQL, CockroachDB и MySQL как storage backend. Используется Airbnb и другими крупными компаниями.

**Ory Keto** -- часть экосистемы Ory (open-source identity infrastructure). Реализует Google Zanzibar API.

Эти проекты делают ReBAC доступным не только для Google-scale систем. OpenFGA, например, может работать с SQLite для development и PostgreSQL для production -- достаточно для приложений с десятками тысяч пользователей.

---

## PBAC: Policy-Based Access Control

### Гибрид моделей

На практике большинство крупных систем авторизации не используют одну "чистую" модель. Они комбинируют RBAC, ABAC и ReBAC в единую policy-based систему. PBAC (Policy-Based Access Control) -- это не отдельная модель, а подход: решение о доступе принимается policy engine, который может учитывать роли, атрибуты и отношения одновременно.

Лучший пример PBAC -- **AWS IAM**. Каждая IAM Policy -- JSON-документ, описывающий: кто (Principal), что может делать (Action), с какими ресурсами (Resource) и при каких условиях (Condition). Conditions могут включать атрибуты: IP-адрес, время, наличие MFA, тэги ресурса. Это комбинация RBAC (IAM Roles) + ABAC (Conditions) + resource-based policies (кто может обращаться к конкретному S3 bucket).

Ниже показана типичная AWS IAM Policy. Обратите внимание, как в одном документе сочетаются элементы RBAC (Effect/Action), ABAC (Condition) и resource-targeting (Resource).

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:PutObject"
      ],
      "Resource": "arn:aws:s3:::company-reports/eu/*",
      "Condition": {
        "IpAddress": {
          "aws:SourceIp": "10.0.0.0/8"
        },
        "Bool": {
          "aws:MultiFactorAuthPresent": "true"
        }
      }
    }
  ]
}
```

Эта политика говорит: разрешить чтение и запись объектов в S3 bucket `company-reports`, но только в папке `eu/`, только из корпоративной сети (10.0.0.0/8), и только при наличии MFA. Ни RBAC, ни ABAC в отдельности не описывают это так лаконично. PBAC позволяет выразить сложные правила в едином формате.

Google Cloud IAM и Azure RBAC работают по аналогичным принципам: роли + условия + resource-level policies. Тренд индустрии -- конвергенция моделей в unified policy engines.

---

## Capability-Based Authorization

### Альтернативный подход: "билет вместо паспорта"

Все предыдущие модели -- identity-based: система проверяет, КТО вы, а потом решает, что вам можно. Capability-based authorization переворачивает подход: система проверяет, ЧТО ВЫ ДЕРЖИТЕ (capability token), и не интересуется, кто вы.

**Аналогия: входной билет в кино.** Когда вы предъявляете билет, контролёру не важно ваше имя, должность или возраст (для обычных фильмов). Важно только одно -- у вас есть действительный билет на конкретный сеанс в конкретный зал. Билет -- это capability: он сам по себе доказывает право доступа.

Идея была впервые описана Джеком Деннисом и Эрлом Ван Хорном (Jack Dennis, Earl Van Horn) в 1966 году в статье "Programming Semantics for Multiprogrammed Computations". Capabilities были реализованы в нескольких операционных системах (CapROS, seL4), но в mainstream OS не прижились.

### Современные capability tokens

В веб-мире capabilities реализованы как cryptographic tokens.

**Macaroons** (Google, 2014) -- capabilities с встроенными ограничениями (caveats). Macaroon можно "ослабить": если у вас есть macaroon с правом "read all files", вы можете создать производный macaroon "read files in /public only" и передать его кому-то. Обратное невозможно: нельзя усилить capability. Это делает делегирование безопасным: вы передаёте ограниченную версию своих прав.

**Biscuit tokens** -- современная реализация, сочетающая capabilities с Datalog-политиками. Biscuit -- это capability token, к которому можно добавлять ограничения (attenuation), но нельзя убирать существующие. Использует public-key криптографию для верификации.

Главная проблема capability tokens -- отзыв (revocation). Если токен попал в чужие руки, его нельзя мгновенно аннулировать -- он действителен до истечения срока. Это та же проблема, что и с JWT (описано в [[authentication-authorization]]).

---

## Дерево решений: когда какую модель выбрать

```
Какую модель авторизации выбрать?

                    Сколько ролей?
                    │
         ┌──────────┼──────────┐
         ▼          ▼          ▼
       < 20       20-100     > 100
         │          │          │
      Простая     Нужен       Взрыв
      система     контекст?   ролей!
         │          │          │
         ▼          │          ▼
     ┌──────┐  ┌────┴────┐  Нужны sharing/
     │ RBAC │  │Время,IP,│  отношения?
     │      │  │атрибуты?│     │
     └──────┘  │         │  ┌──┴──┐
               ▼         │  │     │
           ┌──────┐      │  ▼     ▼
           │ ABAC │      │ ReBAC  ABAC
           └──────┘      │
                         ▼
                    Да: ABAC
                    Нет: RBAC
                        с иерархией

Краткое правило:
- Фиксированные роли → RBAC
- Контекстные правила → ABAC
- Sharing/collaboration → ReBAC
- Всё вместе → PBAC (AWS IAM стиль)
```

### Сравнительная таблица моделей

| Критерий | ACL | RBAC | ABAC | ReBAC | PBAC |
|----------|-----|------|------|-------|------|
| **Сложность внедрения** | Низкая | Низкая-Средняя | Высокая | Средняя-Высокая | Высокая |
| **Гибкость** | Низкая | Средняя | Очень высокая | Высокая | Очень высокая |
| **Производительность** | O(n) по списку | O(1) lookup | Зависит от политик | Обход графа | Зависит от engine |
| **Аудируемость** | Легко (per resource) | Легко (per role) | Сложно | Средне | Зависит от engine |
| **Масштабируемость** | Плохая | Хорошая (до 50 ролей) | Отличная | Отличная | Отличная |
| **Лучше всего для** | Файловые системы | Корпоративные приложения | Compliance, контекст | Collaboration, sharing | Облачные платформы |
| **Реальные примеры** | Unix permissions | WordPress, Jira | Healthcare, Banking | Google Docs, Notion | AWS IAM, GCP IAM |

---

## Policy engines: инструменты

| Engine | Язык политик | Модель | Open-source | Используется в |
|--------|-------------|--------|-------------|---------------|
| **OPA** (Open Policy Agent) | Rego | ABAC/PBAC | Да (CNCF graduated) | Kubernetes admission control, Netflix, Goldman Sachs |
| **AWS Cedar** | Cedar | RBAC + ABAC | Да (Apache 2.0) | Amazon Verified Permissions, AWS |
| **Casbin** | Встроенный DSL | RBAC/ABAC/ReBAC | Да (Apache 2.0) | Intel, IBM, Microsoft |
| **Oso** | Polar | RBAC/ABAC/ReBAC | Да (Apache 2.0) | Intercom, Wayfair |
| **OpenFGA** | DSL | ReBAC (Zanzibar) | Да (CNCF sandbox) | Okta/Auth0, Twitch |
| **SpiceDB** | Schema DSL | ReBAC (Zanzibar) | Да (Apache 2.0) | Airbnb, Red Hat |

> **Ключевая идея:** Не изобретайте свой policy engine. Каждый из перечисленных инструментов -- результат тысяч часов работы команд, специализирующихся на авторизации. Ваш самописный `if-else` рано или поздно станет неуправляемым.

---

## Распространённые заблуждения

### "RBAC устарел"

НЕВЕРНО. RBAC остаётся правильным выбором для большинства приложений. Если в системе менее 50 ролей, разрешения не зависят от контекста, и нет сложных sharing-сценариев -- RBAC проще внедрить, проще аудитировать, проще объяснить новому разработчику. WordPress, Jira, большинство SaaS-продуктов используют RBAC -- и это не "устаревший подход", а обоснованный выбор.

### "ABAC решает всё"

НЕВЕРНО. ABAC решает проблему role explosion, но создаёт проблему policy explosion. Сотня ABAC-политик с десятками атрибутов каждая -- это система, которую невозможно понять без специализированных инструментов визуализации и аудита. Стоимость внедрения и поддержки ABAC кратно выше RBAC. Выбирать ABAC "на всякий случай" -- overengineering.

### "ReBAC только для Google-scale"

НЕВЕРНО. OpenFGA работает с SQLite в development mode и PostgreSQL в production. SpiceDB можно запустить локально за минуту. Если ваше приложение -- это collaborative tool (документы, проекты, доски задач), ReBAC может быть проще ABAC, потому что sharing-модель естественно описывается графом отношений, а не набором атрибутов.

### "Нужно выбрать одну модель"

НЕВЕРНО. Большинство production-систем -- гибриды. AWS IAM -- это RBAC (IAM Roles) + ABAC (Conditions) + resource-based policies. GitHub -- это RBAC (owner, maintainer, contributor) + ReBAC (organization → team → repository). Выбор "чистой" модели -- это учебная абстракция, а не production-реальность.

### "Authorization = Authentication"

КРИТИЧЕСКОЕ заблуждение. Аутентификация (AuthN) -- "кто ты?". Авторизация (AuthZ) -- "что тебе можно?". Это два разных процесса, два разных слоя, часто два разных сервиса. Пользователь может быть аутентифицирован (мы знаем, что это Иван Петров) и при этом не авторизован для конкретного действия (Иван Петров не может удалять чужие посты). Проверка AuthN без AuthZ -- это Broken Access Control, уязвимость #1 в OWASP. Подробнее: [[authentication-authorization]].

---

## Подводные камни

### Тестирование авторизации

Авторизация -- одна из самых сложных вещей для тестирования. Проблема не в unit-тестах (проверить `hasPermission(user, action)` легко), а в integration-тестах: проверить, что ни один API endpoint не пропускает несанкционированный доступ. В больших системах с сотнями endpoints легко забыть добавить проверку на одном из них -- и это становится уязвимостью.

Решение: policy-as-code с автоматическими тестами. OPA позволяет писать unit-тесты для Rego-политик. OpenFGA предоставляет assertion tests для модели авторизации. Casbin имеет встроенный enforcer testing. Покрытие авторизации тестами должно быть не менее 100% -- это не та область, где допустим "80% coverage is enough".

### Policy conflicts в ABAC

Когда в системе десятки ABAC-политик, они могут конфликтовать. Одна политика разрешает доступ, другая -- запрещает. Как система должна решать? Стандартные стратегии: deny-overrides (хотя бы один deny → отказ), permit-overrides (хотя бы один permit → разрешение), first-applicable (первое совпавшее правило побеждает). Выбор стратегии -- архитектурное решение, и его нужно принять до написания первой политики.

### Orphaned permissions в RBAC

Когда сотрудник меняет должность, его роли нужно обновить. На практике старые роли часто остаются -- это называется permission creep (накопление прав). За 5 лет работы сотрудник может накопить роли из 3-4 отделов. Решение: periodic access review -- регулярный аудит ролей каждого пользователя. Многие compliance-стандарты (SOC 2, ISO 27001) требуют access review раз в квартал.

### Relationship cycles в ReBAC

В графе отношений возможны циклы: Group A включает Group B, Group B включает Group A. Это может привести к бесконечному обходу графа при проверке доступа. Zanzibar-реализации решают это ограничением глубины обхода и детекцией циклов. При проектировании модели авторизации важно определить максимальную глубину транзитивности и запретить циклические отношения на уровне schema.

### Производительность на горячем пути

Проверка авторизации происходит на каждом запросе -- это горячий путь. RBAC-проверка (lookup по хеш-таблице) занимает микросекунды. ABAC-проверка (вычисление политик с загрузкой атрибутов) может занимать миллисекунды. ReBAC-проверка (обход графа) -- от микросекунд (кэшированный результат) до десятков миллисекунд (глубокий обход). Кэширование результатов проверок обязательно, но создаёт проблему инвалидации: если права изменились, кэш должен обновиться мгновенно.

---

## Когда НЕ применяется

**ACL не применяется** в системах с динамическим контентом и тысячами пользователей. Управление индивидуальными списками для каждого ресурса становится невозможным.

**RBAC не применяется** когда разрешения зависят от контекста (время, место, устройство) или от содержимого ресурса (автор, регион, уровень секретности). Если для описания правил бизнеса нужно более 50-100 ролей -- это сигнал, что RBAC не подходит.

**ABAC не применяется** в простых системах с 3-5 ролями и статическими правилами. Overhead на определение атрибутов, написание политик и настройку policy engine не оправдан, если `if (user.role === "admin")` решает задачу.

**ReBAC не применяется** в системах без collaboration и sharing. Если пользователи не делятся ресурсами друг с другом, граф отношений -- избыточная абстракция. ReBAC также не подходит для context-dependent правил (время, IP, устройство) без комбинации с ABAC.

**Capability-based подход не применяется** когда требуется мгновенный отзыв прав или полный аудит "кто к чему имеет доступ". Capabilities -- это токены, и отслеживание всех выданных токенов противоречит самой идее decentralized authorization.

---

## Связь с другими темами

**[[authentication-authorization]]** -- prerequisite для этого материала. Там разбираются аутентификация (AuthN), JWT, OAuth 2.0, сессии -- всё, что происходит ДО авторизации. Авторизация начинается после того, как мы знаем, КТО обращается. Рекомендуемый порядок: сначала authentication-authorization, потом этот файл.

**[[auth-api-service-patterns]]** -- следующий шаг после понимания моделей. Этот материал объясняет КАК реализовать авторизацию в API-сервисах: middleware-паттерны, централизованный vs. distributed policy enforcement, sidecar-proxy authorization. Рекомендуется читать после этого файла.

**[[web-security-owasp]]** -- контекст для понимания, ПОЧЕМУ авторизация так важна. Broken Access Control -- уязвимость #1 в OWASP Top 10 с 2021 года. Этот материал описывает конкретные атаки: IDOR (Insecure Direct Object Reference), privilege escalation, forced browsing. Каждая из этих атак -- следствие неправильной авторизации.

**[[security-fundamentals]]** -- фундамент: принцип минимальных привилегий (Principle of Least Privilege), defense in depth, fail-safe defaults. Все модели авторизации -- это разные реализации этих принципов. Понимание принципов помогает выбрать правильную модель.

---

## Источники и дальнейшее чтение

- **Ferraiolo, D. & Kuhn, R. (1992). "Role-Based Access Controls"** -- оригинальная статья NIST, формализовавшая RBAC. Читать для понимания, зачем были введены роли как абстракция и какие проблемы это решило. Короткая (15 страниц), ясно написанная, обязательна для понимания RBAC.

- **Pang, R. et al. (2019). "Zanzibar: Google's Consistent, Global Authorization System"** -- USENIX ATC paper, описывающий ReBAC-систему Google. Читать для понимания, как авторизация работает на масштабе миллиардов пользователей. Содержит архитектурные решения (leopard indexing, zookies), применимые в любой ReBAC-реализации.

- **NIST SP 800-162 (2014). "Guide to Attribute Based Access Control (ABAC) Definition and Considerations"** -- стандарт ABAC от NIST. Читать для формального понимания четырёх категорий атрибутов и архитектуры ABAC (PEP, PDP, PAP, PIP). Объёмный документ (160+ страниц), но первые 40 страниц содержат всю ключевую информацию.

- **Sandhu, R. et al. (1996). "Role-Based Access Control Models"** -- расширенная теория RBAC: RBAC0-RBAC3, иерархии, constraints, Separation of Duties. Читать для понимания разных уровней RBAC и когда какой нужен.

- **Lampson, B. (1974). "Protection"** -- фундаментальная работа по access control, определившая понятия access matrix, capabilities, ACL. Читать для исторического контекста и понимания, что все модели -- разные способы представления одной матрицы.

- **Birgisson, A. et al. (2014). "Macaroons: Cookies with Contextual Caveats for Decentralized Authorization in the Cloud"** -- Google paper о capability tokens с ограничениями. Читать для понимания capability-based подхода и его преимуществ для делегирования.

---

## Проверь себя

> [!question]- Почему RBAC-проверка работает за O(1), а ABAC-проверка может занимать миллисекунды? Какие архитектурные последствия это создаёт для микросервисов?
> RBAC-проверка — это lookup по хеш-таблице: роль пользователя → набор permissions → наличие нужного permission. Все данные локальны и предвычислены. ABAC-проверка — это вычисление политик, которое может потребовать запросов к внешним системам (HR-система для отдела, GeoIP для местоположения, device management для типа устройства). В микросервисной архитектуре каждый сервис выполняет проверку авторизации на каждом запросе (горячий путь), поэтому ABAC требует обязательного кэширования атрибутов и продуманной стратегии инвалидации кэша, иначе латентность запросов вырастает кратно.

> [!question]- Компания разрабатывает SaaS-платформу для совместной работы с документами. Сейчас используется RBAC с ролями Admin, Editor, Viewer. Бизнес просит: "Пользователь может редактировать только документы, к которым его явно пригласили, и только если он — член той же организации". Какую модель вы бы предложили и почему?
> Чистый RBAC не справится, потому что разрешение зависит от отношений (приглашение, членство в организации), а не от статической роли. Оптимальный выбор — ReBAC: `(alice, editor, doc:report)` и `(alice, member, org:acme)`. Проверка сводится к обходу графа: есть ли у пользователя отношение editor с документом И отношение member с организацией, которой принадлежит документ. Можно реализовать через OpenFGA или SpiceDB. При необходимости добавить контекстные условия (время, IP) — комбинировать ReBAC с элементами ABAC.

> [!question]- Как принцип Separation of Duties (SoD) из RBAC2 связан с уязвимостью Broken Access Control из OWASP Top 10? Приведите конкретный сценарий атаки при отсутствии SoD.
> SoD предотвращает ситуацию, когда один пользователь контролирует весь процесс. Без SoD возникает privilege escalation по бизнес-логике. Сценарий: в финансовой системе сотрудник имеет роли "создатель платежа" и "одобритель платежа". Он создаёт фиктивный платёж на подставной счёт и сам же его одобряет. Это классический Broken Access Control — не техническая уязвимость, а архитектурная. OWASP рекомендует именно SoD как контрмеру: тот, кто создаёт платёж, не может его одобрять (статическое SoD) или хотя бы не может одобрить в той же сессии (динамическое SoD).

> [!question]- В системе используется ABAC с 80 политиками. Пользователю отказано в доступе к ресурсу, но он утверждает, что доступ должен быть. Как вы будете отлаживать эту ситуацию? Сравните сложность отладки с RBAC.
> В RBAC отладка тривиальна: проверить роли пользователя → проверить permissions этих ролей → найти отсутствующий permission. Занимает минуту. В ABAC нужно: (1) собрать все атрибуты субъекта (роль, отдел, уровень допуска), (2) собрать атрибуты ресурса (тип, регион, классификация), (3) собрать атрибуты окружения (время, IP, устройство), (4) прогнать все 80 политик и найти, какие сработали на deny. Проблему могут вызвать: устаревший атрибут в PIP, конфликт политик с deny-overrides стратегией, неверный environment-атрибут (VPN вместо корпоративной сети). Именно поэтому ABAC требует инструментов policy simulation и decision logging (OPA decision logs, Cedar policy simulator).

---

## Ключевые карточки

ACL (Access Control List) — что это и когда применяется?
?
Модель, где для каждого ресурса хранится список субъектов с их разрешениями. Подходит для файловых систем и небольших систем. Не масштабируется при тысячах пользователей из-за отсутствия группировки и наследования.

DAC vs MAC — в чём фундаментальное различие?
?
DAC (Discretionary) — владелец ресурса сам решает, кому дать доступ (пример: chmod в Linux). MAC (Mandatory) — центральная власть устанавливает правила, которые никто не может изменить (пример: SELinux, Bell-LaPadula). DAC допускает transitive sharing, MAC — нет.

Что такое role explosion в RBAC и когда она возникает?
?
Взрывной рост количества ролей при попытке описать комбинации регионов, уровней доступа и типов контента (Editor_US_Restricted, Editor_EU_AutoPublish). Возникает, когда разрешения зависят от контекста, а не только от должности. Сигнал: более 50–100 ролей в системе.

Какие четыре категории атрибутов использует ABAC?
?
Subject (роль, отдел, уровень допуска), Resource (тип, владелец, классификация), Action (read, write, delete, approve), Environment (время, IP-адрес, тип устройства, сетевая зона). Именно environment-атрибуты отличают ABAC от RBAC.

Что такое tuple в ReBAC и как происходит проверка доступа?
?
Tuple — запись вида (subject, relation, object), описывающая одно отношение: `alice is owner of doc:report`. Проверка доступа — обход графа отношений: существует ли путь от субъекта к ресурсу через разрешённые отношения (транзитивная проверка).

RBAC0, RBAC1, RBAC2, RBAC3 — чем отличаются уровни модели Sandhu?
?
RBAC0 (Core) — пользователи → роли → permissions, без иерархии. RBAC1 — добавляет наследование ролей (Admin наследует от Editor). RBAC2 — добавляет ограничения, включая Separation of Duties. RBAC3 — объединяет иерархию и ограничения.

Что такое PBAC и почему AWS IAM — его пример?
?
PBAC (Policy-Based Access Control) — подход, где policy engine комбинирует роли, атрибуты и отношения одновременно. AWS IAM сочетает RBAC (IAM Roles), ABAC (Conditions: IP, MFA, время) и resource-based policies в едином JSON-формате.

Capability-based authorization — чем отличается от identity-based моделей?
?
Identity-based модели проверяют КТО вы (и решают, что можно). Capability-based проверяет ЧТО ВЫ ДЕРЖИТЕ — токен сам по себе доказывает право доступа. Примеры: Macaroons (Google), Biscuit tokens. Главная проблема — невозможность мгновенного отзыва токена.

Какую модель выбрать: RBAC, ABAC или ReBAC?
?
RBAC — когда роли стабильны (<50), права не зависят от контекста. ABAC — когда нужны контекстные правила (время, IP, атрибуты ресурса). ReBAC — когда есть sharing и collaboration (документы, проекты). На практике большинство систем — гибриды (PBAC).

Что такое Separation of Duties (SoD) и зачем оно нужно?
?
Ограничение из RBAC2: пользователь не может совмещать конфликтующие роли. Статическое SoD — нельзя иметь обе роли одновременно. Динамическое SoD — нельзя активировать обе в одной сессии. Критично для финансов: создатель платежа не может его же одобрять.

---

## Куда дальше

| Направление | Файл | Зачем |
|-------------|------|-------|
| Аутентификация и фундамент AuthZ | [[authentication-authorization]] | Понять AuthN (JWT, OAuth 2.0, сессии) — prerequisite для всех моделей авторизации |
| Авторизация в API-сервисах | [[auth-api-service-patterns]] | Узнать, КАК реализовать выбранную модель: middleware, централизованный vs distributed enforcement, sidecar-proxy |
| Уязвимости и атаки | [[web-security-owasp]] | Увидеть, ЧТО происходит при неправильной авторизации: IDOR, privilege escalation, forced browsing (OWASP Top 10 #1) |
| Базовые принципы безопасности | [[security-fundamentals]] | Закрепить фундамент: Principle of Least Privilege, defense in depth, fail-safe defaults — принципы, стоящие за всеми моделями |

---

*Создано: 2026-02-11*
