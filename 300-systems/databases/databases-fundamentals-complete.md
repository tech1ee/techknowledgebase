---
title: "Базы данных: Полный фундаментальный гайд"
type: guide
status: published
tags:
  - topic/databases
  - type/guide
  - level/beginner
modified: 2026-02-13
related:
  - "[[sql-databases-complete]]"
  - "[[nosql-databases-complete]]"
  - "[[architecture-distributed-systems]]"
reading_time: 41
difficulty: 3
study_status: not_started
mastery: 0
last_reviewed:
next_review:
---

# Базы данных: Полный фундаментальный гайд

> **Уровень:** Начинающий → Средний
> **Время изучения:** 4-6 часов
> **Связанные материалы:** [[databases-overview]], [[sql-fundamentals]], [[nosql-overview]]

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **Базовое программирование** | Понимание переменных, типов данных, циклов | Любой курс по программированию |
| **Что такое API** | БД обычно используются через API приложения | [[api-design]] |
| **Файловая система** | Понимание как данные хранятся без БД | Основы ОС |
| **JSON** | Многие NoSQL используют JSON-подобные форматы | [[json-basics]] |

### Для кого этот материал

| Уровень | Что получите |
|---------|--------------|
| **Полный новичок** | Понимание что такое БД, зачем нужны, как устроены изнутри |
| **Junior разработчик** | CRUD, нормализация, индексы, транзакции — основы для работы |
| **Переходящий с файлов** | Почему БД лучше файлов, как мигрировать |

---

## Терминология

> 💡 **Главная аналогия для понимания баз данных:**
>
> **База данных = Библиотека**. Книжные полки — это таблицы. Книги — это записи. Каталог — это индексы. Библиотекарь — это СУБД. Читательский билет — это Primary Key. Без библиотеки вам пришлось бы искать книгу по всем домам города (файлы на диске).

| Термин | Значение | Аналогия для новичка |
|--------|----------|---------------------|
| **База данных (Database)** | Организованная коллекция данных с управляющей программой | **Библиотека** — не просто склад книг, а организованная система с каталогом |
| **СУБД (DBMS)** | Программа для управления БД (PostgreSQL, MySQL) | **Библиотекарь** — знает где что лежит, выполняет запросы |
| **Таблица (Table)** | Структура для хранения данных в строках и колонках | **Книжная полка** — определённая категория книг |
| **Строка (Row/Record)** | Одна запись в таблице | **Книга** — конкретный экземпляр на полке |
| **Колонка (Column)** | Атрибут записи (имя, возраст) | **Характеристика книги** — название, автор, ISBN |
| **Primary Key (PK)** | Уникальный идентификатор каждой записи | **Инвентарный номер книги** — уникален для каждой |
| **Foreign Key (FK)** | Ссылка на запись в другой таблице | **Номер читательского билета в записи выдачи** |
| **SQL** | Structured Query Language — язык запросов | **Язык общения с библиотекарем** — "найди книги автора X" |
| **Индекс (Index)** | Структура для ускорения поиска | **Алфавитный указатель** — сразу к нужной странице |
| **Транзакция** | Атомарная операция: всё или ничего | **Взять книгу + записать в журнал** — либо оба действия, либо ни одного |
| **ACID** | Atomicity, Consistency, Isolation, Durability | **Правила библиотеки** — гарантии надёжности |
| **Нормализация** | Устранение дублирования данных | **Не писать адрес автора в каждой книге** — только ссылка на карточку автора |
| **JOIN** | Объединение данных из нескольких таблиц | **Связать книгу с карточкой автора** — получить полную информацию |
| **CAP теорема** | Выбор 2 из 3: Consistency, Availability, Partition Tolerance | **Компромисс**: быстро, качественно, дёшево — выбери два |
| **NoSQL** | Не-реляционные БД (MongoDB, Redis) | **Альтернативные библиотеки** — другие способы организации |

---

## Содержание

1. [Что такое база данных](#что-такое-база-данных)
2. [Зачем нужны базы данных](#зачем-нужны-базы-данных)
3. [Файлы vs Базы данных](#файлы-vs-базы-данных)
4. [СУБД (DBMS)](#субд-dbms)
5. [Типы баз данных](#типы-баз-данных)
6. [CRUD операции](#crud-операции)
7. [Ключевые концепции](#ключевые-концепции)
8. [ACID свойства](#acid-свойства)
9. [Индексирование](#индексирование)
10. [Нормализация](#нормализация)
11. [CAP теорема](#cap-теорема)
12. [Типичные ошибки](#типичные-ошибки)
13. [Практические задания](#практические-задания)

---

## Что такое база данных

### Определение

**База данных (Database, DB)** — это организованная коллекция структурированных данных, хранящаяся электронно в компьютерной системе и управляемая специальной программой — СУБД.

```
// WHY: Почему "организованная" и "структурированная"?
//
// Представь разницу между:
// 1. Кучей бумаг на столе (неорганизованные данные)
// 2. Папками с документами в шкафу (файловая система)
// 3. Библиотечным каталогом (база данных)
//
// База данных не просто хранит данные — она ЗНАЕТ, как они связаны,
// и позволяет быстро находить нужную информацию.
```

### Аналогия: Библиотека

```
БИБЛИОТЕКА = БАЗА ДАННЫХ

Книжные полки          → Таблицы (tables)
Книги                  → Записи/строки (rows/records)
Информация о книге     → Колонки/поля (columns/fields)
  (название, автор)
Каталог                → Индексы (indexes)
Библиотекарь           → СУБД (DBMS)
Читательский билет     → Первичный ключ (primary key)
Номер книги = билет    → Внешний ключ (foreign key)
```

### Визуальное представление

```
┌────────────────────────────────────────────────────────────┐
│                    БАЗА ДАННЫХ                             │
├────────────────────────────────────────────────────────────┤
│  ┌──────────────────────────────────────────────────────┐  │
│  │                  ТАБЛИЦА: Users                      │  │
│  ├──────────┬────────────┬─────────────┬───────────────┤  │
│  │    id    │    name    │    email    │   created_at  │  │
│  ├──────────┼────────────┼─────────────┼───────────────┤  │
│  │    1     │   "Иван"   │ ivan@...    │  2024-01-15   │  │ ← Строка (row)
│  │    2     │   "Мария"  │ maria@...   │  2024-02-20   │  │
│  │    3     │   "Пётр"   │ petr@...    │  2024-03-10   │  │
│  └──────────┴────────────┴─────────────┴───────────────┘  │
│       ↑           ↑            ↑              ↑           │
│    Колонки (columns) - атрибуты/поля                      │
│                                                            │
│  ┌──────────────────────────────────────────────────────┐  │
│  │                 ТАБЛИЦА: Orders                      │  │
│  ├──────────┬────────────┬─────────────┬───────────────┤  │
│  │ order_id │  user_id   │   amount    │    status     │  │
│  ├──────────┼────────────┼─────────────┼───────────────┤  │
│  │    101   │     1      │    1500     │   "pending"   │  │
│  │    102   │     2      │    2300     │   "shipped"   │  │
│  └──────────┴────────────┴─────────────┴───────────────┘  │
│                    ↑                                       │
│           user_id → ссылается на Users.id                  │
│           (Foreign Key → Primary Key)                      │
└────────────────────────────────────────────────────────────┘
```

---

## Зачем нужны базы данных

### Проблемы без баз данных

```python
# АНТИПРИМЕР: Хранение данных в файле
# users.txt:
# Иван,ivan@mail.com,2024-01-15
# Мария,maria@mail.com,2024-02-20

# Проблема 1: Как найти пользователя по email?
def find_user_by_email(email):
    with open("users.txt", "r") as f:
        for line in f:  # O(n) - читаем ВСЕ строки!
            parts = line.strip().split(",")
            if parts[1] == email:
                return parts
    return None

# WHY: Почему это плохо?
# 1. Медленно: при 1 млн пользователей = 1 млн итераций
# 2. Нет валидации: можно записать что угодно
# 3. Нет связей: как связать заказы с пользователями?
# 4. Нет concurrent access: что если 2 процесса пишут одновременно?
```

### 7 причин использовать базу данных

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ПРОБЛЕМА → РЕШЕНИЕ                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. DATA REDUNDANCY (дублирование)                                  │
│     Файлы: Имя клиента в каждом заказе                              │
│     БД: Один раз в таблице Clients, ссылка через ID                 │
│                                                                     │
│  2. DATA INCONSISTENCY (несогласованность)                          │
│     Файлы: "Иван" в одном файле, "Ivan" в другом                    │
│     БД: Единый источник правды + constraints                        │
│                                                                     │
│  3. DIFFICULTY IN ACCESSING DATA (сложность доступа)                │
│     Файлы: Писать код парсинга для каждого запроса                  │
│     БД: SQL-запрос: SELECT * FROM users WHERE age > 25              │
│                                                                     │
│  4. DATA ISOLATION (изоляция данных)                                │
│     Файлы: Данные разбросаны по разным файлам/форматам              │
│     БД: Всё в одном месте с единым API                              │
│                                                                     │
│  5. INTEGRITY PROBLEMS (проблемы целостности)                       │
│     Файлы: Можно записать отрицательный возраст                     │
│     БД: CHECK (age >= 0 AND age <= 150)                             │
│                                                                     │
│  6. ATOMICITY PROBLEMS (проблемы атомарности)                       │
│     Файлы: Перевод денег: списал, но не зачислил (сбой)             │
│     БД: Транзакции — или всё, или ничего                            │
│                                                                     │
│  7. CONCURRENT ACCESS (параллельный доступ)                         │
│     Файлы: Два процесса пишут → данные повреждены                   │
│     БД: Locks, MVCC — безопасный параллельный доступ                │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Реальный пример: E-commerce

```
БЕЗ БАЗЫ ДАННЫХ:

orders.json:
{
  "order_id": 101,
  "customer_name": "Иван Петров",        ← Дублирование!
  "customer_email": "ivan@mail.com",      ← При смене email
  "customer_address": "ул. Ленина, 1",    ← нужно обновить
  "product_name": "iPhone 15",            ← ВСЕ заказы
  "product_price": 99990,
  "quantity": 1
}

// WHY: Проблемы:
// 1. Клиент сменил email → обновить ВСЕ его заказы
// 2. Цена iPhone изменилась → историческая цена потеряна
// 3. 1000 заказов = 1000 копий данных клиента

─────────────────────────────────────────────────────

С БАЗОЙ ДАННЫХ:

┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  Customers  │     │   Orders    │     │  Products   │
├─────────────┤     ├─────────────┤     ├─────────────┤
│ id          │←────│ customer_id │     │ id          │
│ name        │     │ product_id  │────→│ name        │
│ email       │     │ quantity    │     │ price       │
│ address     │     │ price_at_   │     │ description │
└─────────────┘     │  purchase   │     └─────────────┘
                    └─────────────┘

// WHY: Преимущества:
// 1. Данные клиента хранятся ОДИН раз
// 2. price_at_purchase сохраняет историческую цену
// 3. Связи через ID — целостность гарантирована
```

---

## Файлы vs Базы данных

### Сравнительная таблица

```
┌────────────────────┬─────────────────────────┬─────────────────────────┐
│     Критерий       │    ФАЙЛЫ                │    БАЗЫ ДАННЫХ          │
├────────────────────┼─────────────────────────┼─────────────────────────┤
│ Структура          │ Произвольная            │ Определённая схема      │
├────────────────────┼─────────────────────────┼─────────────────────────┤
│ Поиск данных       │ O(n) — полный скан      │ O(log n) — индексы      │
├────────────────────┼─────────────────────────┼─────────────────────────┤
│ Параллельный       │ Конфликты, потеря       │ Безопасный (locks,      │
│ доступ             │ данных                  │ MVCC)                   │
├────────────────────┼─────────────────────────┼─────────────────────────┤
│ Валидация          │ Ручная в коде           │ Constraints, типы       │
├────────────────────┼─────────────────────────┼─────────────────────────┤
│ Связи между        │ Ручное управление       │ Foreign keys,           │
│ данными            │                         │ автоматические JOIN     │
├────────────────────┼─────────────────────────┼─────────────────────────┤
│ Восстановление     │ Потеря при сбое         │ WAL, backup, recovery   │
├────────────────────┼─────────────────────────┼─────────────────────────┤
│ Безопасность       │ Файловые права          │ Роли, гранулярные       │
│                    │                         │ permissions             │
├────────────────────┼─────────────────────────┼─────────────────────────┤
│ Масштаб            │ До ~10K записей         │ Миллионы/миллиарды      │
├────────────────────┼─────────────────────────┼─────────────────────────┤
│ Сложность          │ Низкая                  │ Средняя-Высокая         │
├────────────────────┼─────────────────────────┼─────────────────────────┤
│ Накладные расходы  │ Минимальные             │ Память, CPU, диск       │
└────────────────────┴─────────────────────────┴─────────────────────────┘
```

### Когда использовать файлы

```python
# Файлы подходят для:

# 1. Конфигурация
config = {
    "api_key": "xxx",
    "debug": True,
    "max_connections": 100
}
# → config.json / config.yaml

# 2. Логи (append-only)
with open("app.log", "a") as f:
    f.write(f"{datetime.now()}: {message}\n")

# 3. Кэш статических данных
# → countries.json (редко меняется)

# 4. Обмен данными между системами
# → export.csv, data.xml

# 5. Бинарные данные
# → images/*.png, videos/*.mp4
```

### Когда использовать базу данных

```python
# Базы данных подходят для:

# 1. Пользователи и аутентификация
# → users таблица с паролями, ролями

# 2. Транзакции (финансы)
# → перевод денег = атомарная операция

# 3. Связанные данные
# → orders → products → categories

# 4. Поиск и фильтрация
# → SELECT * FROM products WHERE price < 1000

# 5. Многопользовательский доступ
# → 1000 пользователей одновременно

# 6. Исторические данные
# → аудит, версионирование
```

---

## СУБД (DBMS)

### Что такое СУБД

**СУБД (DBMS — Database Management System)** — программное обеспечение для создания, управления и взаимодействия с базами данных.

```
┌───────────────────────────────────────────────────────────────────┐
│                         ПРИЛОЖЕНИЕ                                │
│                    (Python, Java, Go...)                          │
└───────────────────────────────────────────────────────────────────┘
                              │
                              │ SQL запросы / API
                              ▼
┌───────────────────────────────────────────────────────────────────┐
│                            СУБД                                   │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐               │
│  │   Query     │  │ Transaction │  │   Storage   │               │
│  │  Processor  │  │   Manager   │  │   Engine    │               │
│  └─────────────┘  └─────────────┘  └─────────────┘               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐               │
│  │   Buffer    │  │    Lock     │  │   Recovery  │               │
│  │   Manager   │  │   Manager   │  │   Manager   │               │
│  └─────────────┘  └─────────────┘  └─────────────┘               │
└───────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌───────────────────────────────────────────────────────────────────┐
│                         ФАЙЛОВАЯ СИСТЕМА                          │
│                    (data files, indexes, logs)                    │
└───────────────────────────────────────────────────────────────────┘
```

### Компоненты СУБД

```
┌─────────────────────────────────────────────────────────────────────┐
│                      КОМПОНЕНТЫ СУБД                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  QUERY PROCESSOR (Обработчик запросов)                              │
│  ├── Parser          — разбор SQL синтаксиса                        │
│  ├── Optimizer       — выбор лучшего плана выполнения               │
│  └── Executor        — выполнение запроса                           │
│                                                                     │
│  STORAGE ENGINE (Движок хранения)                                   │
│  ├── Buffer Pool     — кэш страниц в памяти                         │
│  ├── File Manager    — работа с файлами на диске                    │
│  └── Index Manager   — управление индексами (B-Tree, Hash)          │
│                                                                     │
│  TRANSACTION MANAGER (Менеджер транзакций)                          │
│  ├── Lock Manager    — блокировки для concurrent access             │
│  ├── Log Manager     — журнал транзакций (WAL)                      │
│  └── Recovery        — восстановление после сбоев                   │
│                                                                     │
│  SECURITY (Безопасность)                                            │
│  ├── Authentication  — кто ты?                                      │
│  ├── Authorization   — что тебе можно?                              │
│  └── Encryption      — защита данных                                │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Популярные СУБД

```
┌─────────────────────────────────────────────────────────────────────┐
│                     ПОПУЛЯРНЫЕ СУБД                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  РЕЛЯЦИОННЫЕ (SQL):                                                 │
│  ┌─────────────┬───────────────────────────────────────────────┐    │
│  │ PostgreSQL  │ Мощный, расширяемый, open source              │    │
│  │             │ JSON, полнотекстовый поиск, расширения        │    │
│  ├─────────────┼───────────────────────────────────────────────┤    │
│  │ MySQL       │ Популярный, простой, быстрый для чтения       │    │
│  │             │ WordPress, Drupal, большинство хостингов      │    │
│  ├─────────────┼───────────────────────────────────────────────┤    │
│  │ SQLite      │ Встраиваемый, без сервера, один файл          │    │
│  │             │ Мобильные приложения, браузеры, Electron      │    │
│  ├─────────────┼───────────────────────────────────────────────┤    │
│  │ Oracle      │ Enterprise, масштабируемый, дорогой           │    │
│  │             │ Банки, телеком, крупные корпорации            │    │
│  ├─────────────┼───────────────────────────────────────────────┤    │
│  │ SQL Server  │ Microsoft, интеграция с .NET                  │    │
│  │             │ Enterprise Windows среда                      │    │
│  └─────────────┴───────────────────────────────────────────────┘    │
│                                                                     │
│  НЕРЕЛЯЦИОННЫЕ (NoSQL):                                             │
│  ┌─────────────┬───────────────────────────────────────────────┐    │
│  │ MongoDB     │ Document store, JSON-like (BSON)              │    │
│  │             │ Гибкая схема, агрегации                       │    │
│  ├─────────────┼───────────────────────────────────────────────┤    │
│  │ Redis       │ In-memory key-value, кэш, pub/sub             │    │
│  │             │ Сессии, очереди, real-time                    │    │
│  ├─────────────┼───────────────────────────────────────────────┤    │
│  │ Cassandra   │ Wide-column, распределённая, AP               │    │
│  │             │ Big data, высокая доступность                 │    │
│  ├─────────────┼───────────────────────────────────────────────┤    │
│  │ Neo4j       │ Graph database, узлы и связи                  │    │
│  │             │ Social networks, recommendations              │    │
│  ├─────────────┼───────────────────────────────────────────────┤    │
│  │ Elasticsearch│ Search engine, полнотекстовый поиск          │    │
│  │             │ Логи, аналитика, поиск                        │    │
│  └─────────────┴───────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Типы баз данных

### Иерархия типов

```
                            БАЗЫ ДАННЫХ
                                 │
            ┌────────────────────┼────────────────────┐
            │                    │                    │
       РЕЛЯЦИОННЫЕ          НЕРЕЛЯЦИОННЫЕ         СПЕЦИАЛЬНЫЕ
         (SQL)                (NoSQL)
            │                    │                    │
    ┌───────┴───────┐    ┌───────┴───────┐    ┌──────┴──────┐
    │               │    │               │    │             │
PostgreSQL    SQLite  Document    Graph    Vector   Time-Series
MySQL        Oracle   Key-Value  Column   Search
SQL Server            Wide-Column
```

### Реляционные базы данных (SQL)

```
ХАРАКТЕРИСТИКИ:
├── Данные в таблицах (rows × columns)
├── Строгая схема (schema)
├── Связи через Foreign Keys
├── SQL для запросов
├── ACID гарантии
└── Вертикальное масштабирование

┌─────────────────────────────────────────────────────────────┐
│                    РЕЛЯЦИОННАЯ МОДЕЛЬ                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   USERS                        ORDERS                       │
│   ┌────┬─────────┬──────────┐  ┌────────┬─────┬──────────┐  │
│   │ id │  name   │  email   │  │order_id│user_│  total   │  │
│   ├────┼─────────┼──────────┤  │        │ id  │          │  │
│   │ 1  │ "Иван"  │ivan@...  │  ├────────┼─────┼──────────┤  │
│   │ 2  │ "Мария" │maria@... │  │  101   │  1  │  1500    │  │
│   └────┴─────────┴──────────┘  │  102   │  1  │  2300    │  │
│          │                     │  103   │  2  │   800    │  │
│          │ Primary Key         └────────┴─────┴──────────┘  │
│          └──────────────────────────↑                       │
│                              Foreign Key                    │
│                                                             │
│   SQL:                                                      │
│   SELECT u.name, SUM(o.total)                               │
│   FROM users u                                              │
│   JOIN orders o ON u.id = o.user_id                         │
│   GROUP BY u.name;                                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Document Databases (MongoDB, CouchDB)

```
ХАРАКТЕРИСТИКИ:
├── Данные в документах (JSON/BSON)
├── Гибкая схема (schemaless)
├── Вложенные структуры
├── Горизонтальное масштабирование
└── Eventual consistency (опционально ACID)

┌─────────────────────────────────────────────────────────────┐
│                    DOCUMENT MODEL                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   // Один документ содержит всё связанное                   │
│   {                                                         │
│     "_id": ObjectId("507f1f77bcf86cd799439011"),            │
│     "name": "Иван Петров",                                  │
│     "email": "ivan@mail.com",                               │
│     "address": {                         ← Вложенный объект │
│       "city": "Москва",                                     │
│       "street": "ул. Ленина, 1"                             │
│     },                                                      │
│     "orders": [                          ← Вложенный массив │
│       {                                                     │
│         "order_id": 101,                                    │
│         "total": 1500,                                      │
│         "items": ["iPhone", "Case"]                         │
│       },                                                    │
│       {                                                     │
│         "order_id": 102,                                    │
│         "total": 2300,                                      │
│         "items": ["MacBook"]                                │
│       }                                                     │
│     ]                                                       │
│   }                                                         │
│                                                             │
│   // WHY: Когда использовать?                               │
│   // ✓ Быстрое прототипирование                             │
│   // ✓ Часто меняющаяся схема                               │
│   // ✓ Иерархические данные                                 │
│   // ✓ Данные читаются вместе (denormalized)                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Key-Value Stores (Redis, Memcached)

```
ХАРАКТЕРИСТИКИ:
├── Простейшая модель: key → value
├── Очень быстрый доступ O(1)
├── In-memory (Redis) или на диске
├── Идеально для кэширования
└── Ограниченные запросы (только по ключу)

┌─────────────────────────────────────────────────────────────┐
│                    KEY-VALUE MODEL                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   KEY                          VALUE                        │
│   ┌─────────────────────────┐  ┌─────────────────────────┐  │
│   │ "user:1"                │→ │ {"name":"Иван",...}     │  │
│   ├─────────────────────────┤  ├─────────────────────────┤  │
│   │ "session:abc123"        │→ │ {"user_id":1,"exp":...} │  │
│   ├─────────────────────────┤  ├─────────────────────────┤  │
│   │ "cache:products:list"   │→ │ [{...}, {...}, {...}]   │  │
│   ├─────────────────────────┤  ├─────────────────────────┤  │
│   │ "counter:page_views"    │→ │ 1234567                 │  │
│   └─────────────────────────┘  └─────────────────────────┘  │
│                                                             │
│   Redis команды:                                            │
│   SET user:1 '{"name":"Иван"}'                              │
│   GET user:1                                                │
│   INCR counter:page_views                                   │
│   EXPIRE session:abc123 3600   ← TTL 1 час                  │
│                                                             │
│   // WHY: Когда использовать?                               │
│   // ✓ Кэширование (sessions, API responses)                │
│   // ✓ Rate limiting                                        │
│   // ✓ Real-time leaderboards                               │
│   // ✓ Pub/Sub messaging                                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Graph Databases (Neo4j, Amazon Neptune)

```
ХАРАКТЕРИСТИКИ:
├── Данные как узлы и связи
├── Оптимизированы для обхода графа
├── Язык запросов: Cypher (Neo4j)
├── Идеально для социальных сетей
└── Рекомендации, fraud detection

┌─────────────────────────────────────────────────────────────┐
│                    GRAPH MODEL                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│         ┌─────────┐                                         │
│         │  Иван   │                                         │
│         │ (User)  │                                         │
│         └────┬────┘                                         │
│              │                                              │
│    ┌─────────┼─────────┐                                    │
│    │ FOLLOWS │ LIKES   │                                    │
│    ▼         ▼         ▼                                    │
│ ┌─────┐  ┌─────────┐ ┌─────────┐                            │
│ │Мария│  │  Post1  │ │  Книга  │                            │
│ │(User)│ │(Content)│ │(Product)│                            │
│ └──┬──┘  └─────────┘ └─────────┘                            │
│    │                                                        │
│    │ BOUGHT                                                 │
│    ▼                                                        │
│ ┌─────────┐                                                 │
│ │  Книга  │                                                 │
│ │(Product)│                                                 │
│ └─────────┘                                                 │
│                                                             │
│   Cypher (Neo4j):                                           │
│   // Найти друзей друзей                                    │
│   MATCH (me:User {name:'Иван'})-[:FOLLOWS]->()              │
│         -[:FOLLOWS]->(fof:User)                             │
│   WHERE NOT (me)-[:FOLLOWS]->(fof)                          │
│   RETURN fof.name                                           │
│                                                             │
│   // WHY: Когда использовать?                               │
│   // ✓ Social networks (друзья, подписчики)                 │
│   // ✓ Recommendation engines                               │
│   // ✓ Fraud detection (связи между аккаунтами)             │
│   // ✓ Knowledge graphs                                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Column-Family (Cassandra, HBase)

```
ХАРАКТЕРИСТИКИ:
├── Данные хранятся по колонкам
├── Оптимизированы для записи
├── Горизонтальное масштабирование
├── High availability (AP в CAP)
└── Идеально для time-series, IoT

┌─────────────────────────────────────────────────────────────┐
│                 COLUMN-FAMILY MODEL                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Row Key: "user:1"                                         │
│   ┌──────────────────────────────────────────────────────┐  │
│   │  Column Family: "profile"                            │  │
│   │  ┌─────────┬─────────┬─────────────┐                 │  │
│   │  │  name   │  email  │   phone     │                 │  │
│   │  │ "Иван"  │ivan@... │ +7...       │                 │  │
│   │  └─────────┴─────────┴─────────────┘                 │  │
│   │                                                      │  │
│   │  Column Family: "activity"                           │  │
│   │  ┌─────────────┬─────────────┬─────────────┐         │  │
│   │  │ last_login  │ page_views  │ purchases   │         │  │
│   │  │ 2024-12-30  │    150      │     5       │         │  │
│   │  └─────────────┴─────────────┴─────────────┘         │  │
│   └──────────────────────────────────────────────────────┘  │
│                                                             │
│   // WHY: Когда использовать?                               │
│   // ✓ Time-series данные (метрики, логи)                   │
│   // ✓ IoT данные с миллиардами записей                     │
│   // ✓ Write-heavy workloads                                │
│   // ✓ Географически распределённые системы                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Vector Databases (FAISS, Pinecone, Qdrant)

```
ХАРАКТЕРИСТИКИ:
├── Хранят векторные embeddings
├── Similarity search (k-NN)
├── Оптимизированы для AI/ML
├── ANN (Approximate Nearest Neighbors)
└── RAG, semantic search, recommendations

┌─────────────────────────────────────────────────────────────┐
│                    VECTOR MODEL                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Документ → Embedding Model → Vector                       │
│                                                             │
│   "Как приготовить пиццу"                                   │
│        │                                                    │
│        ▼                                                    │
│   [0.23, -0.15, 0.87, 0.42, ..., 0.11]  ← 1536 dimensions   │
│                                                             │
│   Хранение:                                                 │
│   ┌────────────────────────────────────────────────────┐    │
│   │ id: "doc_001"                                      │    │
│   │ vector: [0.23, -0.15, 0.87, ...]                   │    │
│   │ metadata: {                                        │    │
│   │   "title": "Рецепт пиццы",                         │    │
│   │   "category": "cooking"                            │    │
│   │ }                                                  │    │
│   └────────────────────────────────────────────────────┘    │
│                                                             │
│   Поиск по similarity:                                      │
│   query = "рецепт итальянской еды"                          │
│   query_vector = embed(query)                               │
│   results = db.search(query_vector, top_k=5)                │
│                                                             │
│   // WHY: Когда использовать?                               │
│   // ✓ Semantic search (поиск по смыслу)                    │
│   // ✓ RAG для LLM (контекст для ChatGPT)                   │
│   // ✓ Image/audio similarity                               │
│   // ✓ Recommendation systems                               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Time-Series Databases (InfluxDB, TimescaleDB)

```
ХАРАКТЕРИСТИКИ:
├── Оптимизированы для временных рядов
├── Эффективная компрессия
├── Агрегации по времени
├── Автоматическое retention
└── IoT, мониторинг, метрики

┌─────────────────────────────────────────────────────────────┐
│                 TIME-SERIES MODEL                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Measurement: "temperature"                                │
│   Tags: {location: "moscow", sensor: "A1"}                  │
│                                                             │
│   ┌───────────────────┬──────────┬──────────────────────┐   │
│   │     timestamp     │  value   │       tags           │   │
│   ├───────────────────┼──────────┼──────────────────────┤   │
│   │ 2024-12-30 10:00  │   22.5   │ location=moscow      │   │
│   │ 2024-12-30 10:01  │   22.6   │ location=moscow      │   │
│   │ 2024-12-30 10:02  │   22.4   │ location=moscow      │   │
│   │ ...               │   ...    │ ...                  │   │
│   └───────────────────┴──────────┴──────────────────────┘   │
│                                                             │
│   InfluxQL:                                                 │
│   SELECT MEAN(value) FROM temperature                       │
│   WHERE time > now() - 1h                                   │
│   GROUP BY time(5m), location                               │
│                                                             │
│   // WHY: Когда использовать?                               │
│   // ✓ Мониторинг серверов (CPU, RAM, disk)                 │
│   // ✓ IoT сенсоры (температура, давление)                  │
│   // ✓ Финансовые данные (цены акций)                       │
│   // ✓ Application metrics (latency, errors)                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## CRUD операции

### Что такое CRUD

```
CRUD — четыре базовые операции с данными:

┌──────────────┬─────────────┬─────────────────────────────────────┐
│   Операция   │     SQL     │            Описание                 │
├──────────────┼─────────────┼─────────────────────────────────────┤
│   CREATE     │   INSERT    │ Создание новых записей              │
│   READ       │   SELECT    │ Чтение/поиск данных                 │
│   UPDATE     │   UPDATE    │ Изменение существующих записей      │
│   DELETE     │   DELETE    │ Удаление записей                    │
└──────────────┴─────────────┴─────────────────────────────────────┘
```

### Примеры CRUD в SQL

```sql
-- ═══════════════════════════════════════════════════════════════
-- CREATE (INSERT)
-- ═══════════════════════════════════════════════════════════════

-- Создание одной записи
INSERT INTO users (name, email, age)
VALUES ('Иван Петров', 'ivan@mail.com', 25);

-- Создание нескольких записей
INSERT INTO users (name, email, age) VALUES
  ('Мария Сидорова', 'maria@mail.com', 30),
  ('Пётр Иванов', 'petr@mail.com', 28);

-- WHY: INSERT создаёт новую строку в таблице.
-- Если id автоинкрементный, он присвоится автоматически.


-- ═══════════════════════════════════════════════════════════════
-- READ (SELECT)
-- ═══════════════════════════════════════════════════════════════

-- Выбрать все колонки
SELECT * FROM users;

-- Выбрать конкретные колонки
SELECT name, email FROM users;

-- С условием WHERE
SELECT * FROM users WHERE age > 25;

-- С сортировкой
SELECT * FROM users ORDER BY age DESC;

-- С ограничением количества
SELECT * FROM users LIMIT 10;

-- С агрегацией
SELECT COUNT(*) as total, AVG(age) as avg_age FROM users;

-- С JOIN (связь таблиц)
SELECT u.name, o.total
FROM users u
JOIN orders o ON u.id = o.user_id;

-- WHY: SELECT — самая частая операция.
-- БД оптимизирует запросы через индексы и query planner.


-- ═══════════════════════════════════════════════════════════════
-- UPDATE
-- ═══════════════════════════════════════════════════════════════

-- Обновить одно поле
UPDATE users
SET email = 'ivan_new@mail.com'
WHERE id = 1;

-- Обновить несколько полей
UPDATE users
SET email = 'ivan_new@mail.com', age = 26
WHERE id = 1;

-- Обновить по условию (несколько строк)
UPDATE users
SET status = 'inactive'
WHERE last_login < '2024-01-01';

-- ⚠️ ОПАСНО: UPDATE без WHERE обновит ВСЕ строки!
-- UPDATE users SET status = 'deleted';  -- НЕ ДЕЛАЙ ТАК!


-- ═══════════════════════════════════════════════════════════════
-- DELETE
-- ═══════════════════════════════════════════════════════════════

-- Удалить одну запись
DELETE FROM users WHERE id = 1;

-- Удалить по условию
DELETE FROM users WHERE status = 'inactive';

-- ⚠️ ОПАСНО: DELETE без WHERE удалит ВСЕ строки!
-- DELETE FROM users;  -- НЕ ДЕЛАЙ ТАК!

-- Лучше: Soft delete (не удаляем, а помечаем)
UPDATE users SET deleted_at = NOW() WHERE id = 1;

-- WHY: Soft delete сохраняет данные для аудита и восстановления.
```

### Примеры CRUD в NoSQL (MongoDB)

```javascript
// ═══════════════════════════════════════════════════════════════
// CREATE
// ═══════════════════════════════════════════════════════════════

// Вставка одного документа
db.users.insertOne({
  name: "Иван Петров",
  email: "ivan@mail.com",
  age: 25
});

// Вставка нескольких документов
db.users.insertMany([
  { name: "Мария", email: "maria@mail.com" },
  { name: "Пётр", email: "petr@mail.com" }
]);


// ═══════════════════════════════════════════════════════════════
// READ
// ═══════════════════════════════════════════════════════════════

// Найти все документы
db.users.find();

// С условием
db.users.find({ age: { $gt: 25 } });

// Проекция (только нужные поля)
db.users.find({}, { name: 1, email: 1 });

// Сортировка и лимит
db.users.find().sort({ age: -1 }).limit(10);


// ═══════════════════════════════════════════════════════════════
// UPDATE
// ═══════════════════════════════════════════════════════════════

// Обновить один документ
db.users.updateOne(
  { _id: ObjectId("...") },
  { $set: { email: "ivan_new@mail.com" } }
);

// Обновить несколько
db.users.updateMany(
  { status: "inactive" },
  { $set: { archived: true } }
);


// ═══════════════════════════════════════════════════════════════
// DELETE
// ═══════════════════════════════════════════════════════════════

// Удалить один документ
db.users.deleteOne({ _id: ObjectId("...") });

// Удалить несколько
db.users.deleteMany({ status: "deleted" });
```

---

## Ключевые концепции

### Primary Key (Первичный ключ)

```sql
-- Primary Key — уникальный идентификатор каждой строки

CREATE TABLE users (
    id SERIAL PRIMARY KEY,  -- PostgreSQL: auto-increment
    -- или
    id INT PRIMARY KEY AUTO_INCREMENT,  -- MySQL
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL
);

-- WHY: Зачем нужен Primary Key?
-- 1. Уникально идентифицирует каждую запись
-- 2. Автоматически создаётся индекс (быстрый поиск)
-- 3. Используется для Foreign Key связей
-- 4. Не может быть NULL

-- АНТИПРИМЕР: Использование бизнес-поля как PK
CREATE TABLE users (
    email VARCHAR(255) PRIMARY KEY,  -- ПЛОХО!
    name VARCHAR(100)
);
-- WHY плохо: email может измениться, дублироваться в legacy данных
```

### Foreign Key (Внешний ключ)

```sql
-- Foreign Key — ссылка на Primary Key другой таблицы

CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INT NOT NULL,
    total DECIMAL(10, 2) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),

    -- Foreign Key constraint
    FOREIGN KEY (user_id) REFERENCES users(id)
        ON DELETE CASCADE    -- при удалении user удаляются его orders
        ON UPDATE CASCADE    -- при изменении user.id обновляется user_id
);

-- WHY: Зачем нужен Foreign Key?
-- 1. Referential Integrity — нельзя вставить order с несуществующим user_id
-- 2. Cascading actions — автоматические действия при изменении/удалении
-- 3. Документирует связи между таблицами

-- Варианты ON DELETE:
-- CASCADE — удалить связанные записи
-- SET NULL — установить NULL
-- RESTRICT — запретить удаление если есть связи
-- NO ACTION — как RESTRICT (по умолчанию)
```

### Schema (Схема)

```sql
-- Schema — структура базы данных

-- Определение схемы таблицы
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    price DECIMAL(10, 2) NOT NULL CHECK (price >= 0),
    category_id INT REFERENCES categories(id),
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP
);

-- WHY: Зачем нужна схема?
-- 1. Валидация данных на уровне БД (типы, constraints)
-- 2. Документация структуры
-- 3. Оптимизация хранения
-- 4. Предсказуемость запросов
```

### Constraints (Ограничения)

```sql
-- Constraints — правила валидации данных

CREATE TABLE employees (
    id SERIAL PRIMARY KEY,

    -- NOT NULL — обязательное поле
    name VARCHAR(100) NOT NULL,

    -- UNIQUE — уникальное значение
    email VARCHAR(255) UNIQUE,

    -- CHECK — произвольное условие
    age INT CHECK (age >= 18 AND age <= 120),
    salary DECIMAL(12, 2) CHECK (salary >= 0),

    -- DEFAULT — значение по умолчанию
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT NOW(),

    -- FOREIGN KEY — ссылка на другую таблицу
    department_id INT REFERENCES departments(id)
);

-- Composite UNIQUE (уникальная комбинация)
CREATE TABLE enrollments (
    student_id INT REFERENCES students(id),
    course_id INT REFERENCES courses(id),
    enrolled_at TIMESTAMP DEFAULT NOW(),

    -- Один студент не может записаться на курс дважды
    UNIQUE (student_id, course_id)
);
```

---

## ACID свойства

### Что такое ACID

```
ACID — свойства, гарантирующие надёжность транзакций:

┌───────────────────────────────────────────────────────────────────┐
│                         ACID                                      │
├───────────────────────────────────────────────────────────────────┤
│                                                                   │
│   A — ATOMICITY (Атомарность)                                     │
│   ─────────────────────────────                                   │
│   "Всё или ничего"                                                │
│                                                                   │
│   Транзакция либо выполняется полностью,                          │
│   либо не выполняется вообще.                                     │
│                                                                   │
│   Пример: Перевод денег                                           │
│   BEGIN TRANSACTION;                                              │
│     UPDATE accounts SET balance = balance - 100 WHERE id = 1;     │
│     UPDATE accounts SET balance = balance + 100 WHERE id = 2;     │
│   COMMIT;                                                         │
│                                                                   │
│   Если второй UPDATE упадёт — первый откатится!                   │
│                                                                   │
├───────────────────────────────────────────────────────────────────┤
│                                                                   │
│   C — CONSISTENCY (Согласованность)                               │
│   ─────────────────────────────────                               │
│   "Из валидного состояния в валидное"                             │
│                                                                   │
│   После транзакции БД остаётся в корректном состоянии.            │
│   Все constraints, foreign keys, triggers соблюдены.              │
│                                                                   │
│   Пример:                                                         │
│   - Сумма балансов до = сумма после (инвариант)                   │
│   - Нельзя списать больше, чем есть (CHECK constraint)            │
│                                                                   │
├───────────────────────────────────────────────────────────────────┤
│                                                                   │
│   I — ISOLATION (Изолированность)                                 │
│   ───────────────────────────────                                 │
│   "Транзакции не мешают друг другу"                               │
│                                                                   │
│   Параллельные транзакции не видят промежуточные состояния.       │
│   Результат = как если бы транзакции выполнялись последовательно. │
│                                                                   │
│   Пример: Два параллельных списания                               │
│   T1: SELECT balance FROM accounts WHERE id=1; -- 1000            │
│   T2: SELECT balance FROM accounts WHERE id=1; -- 1000            │
│   T1: UPDATE accounts SET balance = 900 WHERE id=1;               │
│   T2: UPDATE accounts SET balance = 900 WHERE id=1; -- Conflict!  │
│                                                                   │
│   Без изоляции: баланс 900 вместо 800 (lost update)               │
│                                                                   │
├───────────────────────────────────────────────────────────────────┤
│                                                                   │
│   D — DURABILITY (Устойчивость)                                   │
│   ─────────────────────────────                                   │
│   "Закоммиченные данные не пропадут"                              │
│                                                                   │
│   После COMMIT данные сохранены даже при:                         │
│   - Crash сервера                                                 │
│   - Потере питания                                                │
│   - Hardware failure                                              │
│                                                                   │
│   Реализация: WAL (Write-Ahead Logging)                           │
│   Сначала пишем в лог, потом в данные.                            │
│   При сбое — восстанавливаем из лога.                             │
│                                                                   │
└───────────────────────────────────────────────────────────────────┘
```

### Пример транзакции

```sql
-- Банковский перевод: атомарная операция

BEGIN TRANSACTION;

-- Проверяем достаточно ли средств
SELECT balance FROM accounts WHERE id = 1;

-- Списываем с отправителя
UPDATE accounts
SET balance = balance - 500
WHERE id = 1 AND balance >= 500;

-- Проверяем, что списание прошло
IF @@ROWCOUNT = 0 THEN
    ROLLBACK;  -- Откат: недостаточно средств
END IF;

-- Зачисляем получателю
UPDATE accounts
SET balance = balance + 500
WHERE id = 2;

-- Логируем операцию
INSERT INTO transactions (from_id, to_id, amount, created_at)
VALUES (1, 2, 500, NOW());

COMMIT;  -- Всё успешно — сохраняем

-- WHY: Почему нужна транзакция?
-- Без неё: списали с одного, не зачислили другому → деньги потеряны
-- С ней: или всё вместе, или ничего
```

### Уровни изоляции

```
┌────────────────────────────────────────────────────────────────────┐
│               УРОВНИ ИЗОЛЯЦИИ ТРАНЗАКЦИЙ                           │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  1. READ UNCOMMITTED (самый слабый)                                │
│     ─────────────────────────────────                              │
│     Видны незакоммиченные изменения других транзакций              │
│     Проблема: Dirty Read                                           │
│     Применение: Редко, только для примерных подсчётов              │
│                                                                    │
│  2. READ COMMITTED (по умолчанию в PostgreSQL)                     │
│     ─────────────────────────────────────────                      │
│     Видны только закоммиченные данные                              │
│     Проблема: Non-repeatable Read                                  │
│     Применение: Большинство приложений                             │
│                                                                    │
│  3. REPEATABLE READ (по умолчанию в MySQL InnoDB)                  │
│     ─────────────────────────────────────────────                  │
│     Повторное чтение даёт тот же результат                         │
│     Проблема: Phantom Read                                         │
│     Применение: Финансовые отчёты                                  │
│                                                                    │
│  4. SERIALIZABLE (самый строгий)                                   │
│     ─────────────────────────────                                  │
│     Полная изоляция, как последовательное выполнение               │
│     Проблема: Низкая производительность                            │
│     Применение: Критичные операции                                 │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘

Аномалии чтения:

Dirty Read:       T1 читает незакоммиченные данные T2
                  T2 делает ROLLBACK
                  T1 использовала "фантомные" данные

Non-repeatable:   T1: SELECT balance → 1000
                  T2: UPDATE balance = 500; COMMIT;
                  T1: SELECT balance → 500 (изменилось!)

Phantom Read:     T1: SELECT COUNT(*) WHERE age > 25 → 10
                  T2: INSERT новый user с age=30; COMMIT;
                  T1: SELECT COUNT(*) WHERE age > 25 → 11 (появились новые!)
```

---

## Индексирование

### Что такое индекс

```
ИНДЕКС — структура данных для ускорения поиска.

Аналогия: Алфавитный указатель в книге
─────────────────────────────────────
Без индекса: читаем всю книгу, чтобы найти слово
С индексом: смотрим в указатель → сразу на нужную страницу

┌────────────────────────────────────────────────────────────────────┐
│                    КАК РАБОТАЕТ ИНДЕКС                             │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  БЕЗ ИНДЕКСА (Full Table Scan):                                    │
│                                                                    │
│  SELECT * FROM users WHERE email = 'ivan@mail.com';                │
│                                                                    │
│  ┌────┬─────────────┬──────────────────┐                           │
│  │ id │    name     │      email       │                           │
│  ├────┼─────────────┼──────────────────┤                           │
│  │ 1  │   Мария     │ maria@mail.com   │  ← проверить              │
│  │ 2  │   Пётр      │ petr@mail.com    │  ← проверить              │
│  │ 3  │   Иван      │ ivan@mail.com    │  ← НАЙДЕНО!               │
│  │ ...│   ...       │ ...              │  ← всё равно проверить    │
│  │1000│   Анна      │ anna@mail.com    │  ← проверить              │
│  └────┴─────────────┴──────────────────┘                           │
│                                                                    │
│  Сложность: O(n) — проверяем ВСЕ строки                            │
│                                                                    │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  С ИНДЕКСОМ (B-Tree Lookup):                                       │
│                                                                    │
│  CREATE INDEX idx_users_email ON users(email);                     │
│                                                                    │
│           ┌──────────────────────┐                                 │
│           │    ivan@mail.com     │ ← Корень B-Tree                 │
│           └──────────┬───────────┘                                 │
│                      │                                             │
│         ┌────────────┴────────────┐                                │
│         ▼                         ▼                                │
│  ┌─────────────┐           ┌─────────────┐                         │
│  │ a... - i... │           │ j... - z... │                         │
│  └──────┬──────┘           └─────────────┘                         │
│         ▼                                                          │
│  ┌─────────────────────────────────────┐                           │
│  │ ivan@mail.com → Row Pointer (id=3)  │                           │
│  └─────────────────────────────────────┘                           │
│                                                                    │
│  Сложность: O(log n) — логарифмическое время                       │
│                                                                    │
│  При 1,000,000 записей:                                            │
│  - Без индекса: ~1,000,000 операций                                │
│  - С индексом: ~20 операций (log₂ 1,000,000 ≈ 20)                  │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### Типы индексов

```sql
-- ═══════════════════════════════════════════════════════════════
-- 1. B-TREE INDEX (по умолчанию)
-- ═══════════════════════════════════════════════════════════════

CREATE INDEX idx_users_email ON users(email);

-- Подходит для:
-- - Точный поиск: WHERE email = 'ivan@mail.com'
-- - Диапазоны: WHERE age BETWEEN 20 AND 30
-- - Сортировка: ORDER BY created_at
-- - LIKE с префиксом: WHERE name LIKE 'Иван%'

-- НЕ подходит для:
-- - LIKE без префикса: WHERE name LIKE '%ван%'
-- - Функции над колонкой: WHERE LOWER(email) = 'ivan@mail.com'


-- ═══════════════════════════════════════════════════════════════
-- 2. HASH INDEX
-- ═══════════════════════════════════════════════════════════════

CREATE INDEX idx_users_email_hash ON users USING HASH (email);

-- Подходит для:
-- - ТОЛЬКО точный поиск: WHERE email = 'ivan@mail.com'
-- - Быстрее B-Tree для equality

-- НЕ подходит для:
-- - Диапазоны, сортировка, LIKE


-- ═══════════════════════════════════════════════════════════════
-- 3. COMPOSITE INDEX (составной)
-- ═══════════════════════════════════════════════════════════════

CREATE INDEX idx_orders_user_date
ON orders(user_id, created_at);

-- Работает для:
-- WHERE user_id = 1                          ✓ (leftmost prefix)
-- WHERE user_id = 1 AND created_at > '2024'  ✓ (оба поля)
-- WHERE user_id = 1 ORDER BY created_at      ✓ (поиск + сортировка)

-- НЕ работает для:
-- WHERE created_at > '2024'  ✗ (не leftmost)

-- WHY: Порядок колонок важен!
-- Индекс (A, B, C) работает для:
-- (A), (A,B), (A,B,C), но НЕ для (B), (C), (B,C)


-- ═══════════════════════════════════════════════════════════════
-- 4. PARTIAL INDEX (частичный)
-- ═══════════════════════════════════════════════════════════════

CREATE INDEX idx_active_users
ON users(email)
WHERE is_active = true;

-- Индексирует только активных пользователей
-- Меньше размер, быстрее обновление

-- WHY: Если 90% запросов к активным пользователям,
-- зачем индексировать неактивных?


-- ═══════════════════════════════════════════════════════════════
-- 5. UNIQUE INDEX
-- ═══════════════════════════════════════════════════════════════

CREATE UNIQUE INDEX idx_users_email_unique ON users(email);

-- Комбинация индекса + UNIQUE constraint
-- Гарантирует уникальность + ускоряет поиск


-- ═══════════════════════════════════════════════════════════════
-- 6. FULL-TEXT INDEX (PostgreSQL)
-- ═══════════════════════════════════════════════════════════════

CREATE INDEX idx_products_search
ON products
USING GIN (to_tsvector('russian', name || ' ' || description));

-- Для полнотекстового поиска
-- SELECT * FROM products
-- WHERE to_tsvector('russian', name) @@ to_tsquery('телефон');
```

### Когда создавать индексы

```
┌────────────────────────────────────────────────────────────────────┐
│                 СОЗДАВАТЬ ИНДЕКС                                   │
├────────────────────────────────────────────────────────────────────┤
│ ✓ Колонки в WHERE часто используются                              │
│ ✓ Колонки в JOIN (foreign keys)                                   │
│ ✓ Колонки в ORDER BY                                              │
│ ✓ Колонки с высокой селективностью (много уникальных значений)    │
│ ✓ Таблица большая (>10,000 строк)                                 │
└────────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────────┐
│              НЕ СОЗДАВАТЬ ИНДЕКС                                   │
├────────────────────────────────────────────────────────────────────┤
│ ✗ Маленькие таблицы (full scan быстрее)                           │
│ ✗ Колонки редко используются в запросах                           │
│ ✗ Колонки с низкой селективностью (status: 'active'/'inactive')   │
│ ✗ Таблицы с частыми INSERT/UPDATE (замедляет запись)              │
│ ✗ Колонки часто обновляются                                       │
└────────────────────────────────────────────────────────────────────┘
```

### Trade-offs индексов

```
ПЛЮСЫ:
+ Ускорение SELECT в 100-1000 раз
+ Ускорение JOIN операций
+ Ускорение ORDER BY (если индекс отсортирован)

МИНУСЫ:
- Замедление INSERT (нужно обновить индекс)
- Замедление UPDATE (если индексированная колонка меняется)
- Замедление DELETE (нужно обновить индекс)
- Дополнительное место на диске
- Усложнение maintenance (REINDEX, VACUUM)

ПРАВИЛО:
Больше индексов → Быстрее чтение, Медленнее запись
Меньше индексов → Медленнее чтение, Быстрее запись
```

---

## Нормализация

### Что такое нормализация

```
НОРМАЛИЗАЦИЯ — процесс организации данных для:
1. Устранения дублирования (data redundancy)
2. Обеспечения целостности (data integrity)
3. Упрощения модификации (easier updates)

Нормальные формы — этапы нормализации:
1NF → 2NF → 3NF → BCNF → 4NF → 5NF

Для большинства приложений достаточно 3NF.
```

### Первая нормальная форма (1NF)

```
1NF ТРЕБОВАНИЯ:
1. Все значения атомарны (неделимы)
2. Каждая строка уникальна (есть Primary Key)
3. Порядок строк не имеет значения

───────────────────────────────────────────────────

НЕНОРМАЛИЗОВАННАЯ ТАБЛИЦА:

┌────┬───────────┬─────────────────────────────────────┐
│ id │   name    │             phones                  │
├────┼───────────┼─────────────────────────────────────┤
│ 1  │   Иван    │ +7-999-111-11-11, +7-999-222-22-22  │  ← НЕ атомарно!
│ 2  │   Мария   │ +7-999-333-33-33                    │
└────┴───────────┴─────────────────────────────────────┘

Проблемы:
- Как найти пользователя по второму номеру?
- Как добавить третий номер?
- Разные форматы хранения

───────────────────────────────────────────────────

1NF НОРМАЛИЗАЦИЯ:

Вариант 1: Отдельные колонки (плохо)
┌────┬───────────┬──────────────────┬──────────────────┐
│ id │   name    │     phone_1      │     phone_2      │
├────┼───────────┼──────────────────┼──────────────────┤
│ 1  │   Иван    │ +7-999-111-11-11 │ +7-999-222-22-22 │
│ 2  │   Мария   │ +7-999-333-33-33 │      NULL        │
└────┴───────────┴──────────────────┴──────────────────┘
WHY плохо: А если 10 телефонов? А если 0?

Вариант 2: Отдельная таблица (хорошо)
┌────┬───────────┐     ┌────┬─────────┬──────────────────┐
│ id │   name    │     │ id │ user_id │      phone       │
├────┼───────────┤     ├────┼─────────┼──────────────────┤
│ 1  │   Иван    │     │ 1  │    1    │ +7-999-111-11-11 │
│ 2  │   Мария   │     │ 2  │    1    │ +7-999-222-22-22 │
└────┴───────────┘     │ 3  │    2    │ +7-999-333-33-33 │
                       └────┴─────────┴──────────────────┘
```

### Вторая нормальная форма (2NF)

```
2NF ТРЕБОВАНИЯ:
1. Таблица в 1NF
2. Каждый неключевой атрибут зависит от ВСЕГО первичного ключа

Актуально для составных ключей.

───────────────────────────────────────────────────

НЕ В 2NF:

Таблица: order_items (составной ключ: order_id + product_id)

┌──────────┬────────────┬──────────────┬─────────────┬───────────┐
│ order_id │ product_id │ product_name │ quantity    │ price     │
├──────────┼────────────┼──────────────┼─────────────┼───────────┤
│    1     │    101     │   "iPhone"   │     2       │   999.99  │
│    1     │    102     │   "Case"     │     1       │    29.99  │
│    2     │    101     │   "iPhone"   │     1       │   999.99  │
└──────────┴────────────┴──────────────┴─────────────┴───────────┘

Проблема: product_name зависит ТОЛЬКО от product_id, не от order_id
- Дублирование "iPhone" в каждом заказе
- Изменение имени требует обновления всех строк

───────────────────────────────────────────────────

2NF НОРМАЛИЗАЦИЯ:

products:                    order_items:
┌────────────┬─────────────┐ ┌──────────┬────────────┬──────────┐
│ product_id │ product_name│ │ order_id │ product_id │ quantity │
├────────────┼─────────────┤ ├──────────┼────────────┼──────────┤
│    101     │  "iPhone"   │ │    1     │    101     │    2     │
│    102     │  "Case"     │ │    1     │    102     │    1     │
└────────────┴─────────────┘ │    2     │    101     │    1     │
                             └──────────┴────────────┴──────────┘
```

### Третья нормальная форма (3NF)

```
3NF ТРЕБОВАНИЯ:
1. Таблица в 2NF
2. Нет транзитивных зависимостей
   (неключевой атрибут не зависит от другого неключевого)

───────────────────────────────────────────────────

НЕ В 3NF:

┌────┬───────────┬─────────────────┬─────────────────────┐
│ id │ employee  │  department_id  │   department_name   │
├────┼───────────┼─────────────────┼─────────────────────┤
│ 1  │   Иван    │       10        │      "Sales"        │
│ 2  │   Мария   │       10        │      "Sales"        │
│ 3  │   Пётр    │       20        │      "IT"           │
└────┴───────────┴─────────────────┴─────────────────────┘

Транзитивная зависимость:
id → department_id → department_name

Проблема: department_name дублируется и зависит от department_id

───────────────────────────────────────────────────

3NF НОРМАЛИЗАЦИЯ:

employees:                   departments:
┌────┬───────────┬─────────┐ ┌────┬─────────────────────┐
│ id │ employee  │ dept_id │ │ id │   department_name   │
├────┼───────────┼─────────┤ ├────┼─────────────────────┤
│ 1  │   Иван    │   10    │ │ 10 │      "Sales"        │
│ 2  │   Мария   │   10    │ │ 20 │      "IT"           │
│ 3  │   Пётр    │   20    │ └────┴─────────────────────┘
└────┴───────────┴─────────┘
```

### Денормализация

```
ДЕНОРМАЛИЗАЦИЯ — намеренное нарушение NF для производительности.

КОГДА ПРИМЕНЯТЬ:
1. Read-heavy системы (много чтений, мало записей)
2. Часто нужны JOINы одних и тех же таблиц
3. Аналитика и отчёты

ПРИМЕР:

Нормализовано (3NF):
SELECT
    o.id,
    u.name,
    u.email,
    p.name as product,
    oi.quantity
FROM orders o
JOIN users u ON o.user_id = u.id
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id;

Денормализовано (для скорости):
┌──────────┬────────────┬─────────────────┬──────────────┬──────────┐
│ order_id │ user_name  │   user_email    │ product_name │ quantity │
├──────────┼────────────┼─────────────────┼──────────────┼──────────┤
│    1     │   Иван     │  ivan@mail.com  │   "iPhone"   │    2     │
└──────────┴────────────┴─────────────────┴──────────────┴──────────┘

Плюс: SELECT быстрый (нет JOINов)
Минус: Дублирование, сложность обновления
```

---

## CAP теорема

### Что такое CAP

```
CAP ТЕОРЕМА (Eric Brewer, 2000)

Распределённая система может гарантировать ТОЛЬКО 2 из 3:

┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│                        C — Consistency                              │
│                       /              \                              │
│                      /                \                             │
│                     /                  \                            │
│                    /                    \                           │
│                   /        CAP           \                          │
│                  /                        \                         │
│                 /                          \                        │
│                /                            \                       │
│     A — Availability ────────────────── P — Partition Tolerance     │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

C — CONSISTENCY (Согласованность)
   Все узлы видят одинаковые данные в одно время.
   Чтение всегда возвращает последнюю запись.

A — AVAILABILITY (Доступность)
   Каждый запрос получает ответ (не обязательно последние данные).
   Система всегда работает.

P — PARTITION TOLERANCE (Устойчивость к разделению)
   Система работает даже если связь между узлами потеряна.
   Критично для распределённых систем.
```

### CAP в реальных системах

```
В реальности P обязательно (сеть ненадёжна), выбираем между C и A:

┌─────────────────────────────────────────────────────────────────────┐
│                    CP vs AP СИСТЕМЫ                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  CP (Consistency + Partition Tolerance)                             │
│  ─────────────────────────────────────                              │
│  При разделении: жертвуем доступностью ради консистентности         │
│                                                                     │
│  Примеры:                                                           │
│  • MongoDB (default config)                                         │
│  • HBase                                                            │
│  • Redis Cluster                                                    │
│  • Zookeeper                                                        │
│                                                                     │
│  Use case: Финансы, inventory (нельзя продать больше, чем есть)     │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  AP (Availability + Partition Tolerance)                            │
│  ─────────────────────────────────────                              │
│  При разделении: жертвуем консистентностью ради доступности         │
│  Eventual Consistency — данные синхронизируются "со временем"       │
│                                                                     │
│  Примеры:                                                           │
│  • Cassandra                                                        │
│  • CouchDB                                                          │
│  • DynamoDB                                                         │
│  • Riak                                                             │
│                                                                     │
│  Use case: Social media (лайки, комменты — ок если чуть устарели)   │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  CA (Consistency + Availability) — теоретически                     │
│  ───────────────────────────────────────────────                    │
│  Только если нет сетевых разделений (single node).                  │
│  Традиционные RDBMS на одном сервере.                               │
│                                                                     │
│  Примеры:                                                           │
│  • PostgreSQL (single node)                                         │
│  • MySQL (single node)                                              │
│  • SQLite                                                           │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### PACELC

```
PACELC — расширение CAP (Daniel Abadi, 2010)

"Если есть Partition — выбираем A или C.
 Иначе (Else) — выбираем Latency или Consistency."

┌───────────────────────────────────────────────────────────────────┐
│                                                                   │
│  IF (Partition) THEN (A or C) ELSE (L or C)                       │
│                                                                   │
│  PA/EL — доступность важнее                                       │
│  • DynamoDB, Cassandra                                            │
│  • При partition: доступны, eventual consistency                  │
│  • Без partition: низкая latency, eventual consistency            │
│                                                                   │
│  PC/EC — консистентность важнее                                   │
│  • MongoDB, HBase                                                 │
│  • При partition: недоступны, ждём консистентности                │
│  • Без partition: высокая latency ради консистентности            │
│                                                                   │
│  PA/EC — гибрид                                                   │
│  • Некоторые конфигурации MongoDB                                 │
│  • При partition: доступны                                        │
│  • Без partition: консистентность важнее latency                  │
│                                                                   │
└───────────────────────────────────────────────────────────────────┘
```

---

## Типичные ошибки

### 10 главных ошибок новичков

```
┌─────────────────────────────────────────────────────────────────────┐
│              10 ГЛАВНЫХ ОШИБОК НОВИЧКОВ В БД                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. ИГНОРИРОВАНИЕ НОРМАЛИЗАЦИИ                                      │
│     ✗ Хранение всех данных в одной таблице                          │
│     ✗ Дублирование информации                                       │
│     ✓ Минимум 3NF для транзакционных данных                         │
│                                                                     │
│  2. НЕТ PRIMARY KEY                                                 │
│     ✗ Таблица без уникального идентификатора                        │
│     ✗ Использование бизнес-полей как PK (email, phone)              │
│     ✓ Всегда добавляй суррогатный id (SERIAL/AUTO_INCREMENT)        │
│                                                                     │
│  3. ОТСУТСТВИЕ FOREIGN KEYS                                         │
│     ✗ Связи только на уровне приложения                             │
│     ✗ "Сиротские" записи в базе                                     │
│     ✓ FK + ON DELETE CASCADE/RESTRICT                               │
│                                                                     │
│  4. НЕТ ИНДЕКСОВ НА ЧАСТО ИСПОЛЬЗУЕМЫХ ПОЛЯХ                        │
│     ✗ Full table scan на миллион строк                              │
│     ✗ Медленные JOIN операции                                       │
│     ✓ EXPLAIN ANALYZE → добавить индексы                            │
│                                                                     │
│  5. СЛИШКОМ МНОГО ИНДЕКСОВ                                          │
│     ✗ Индекс на каждую колонку                                      │
│     ✗ Медленные INSERT/UPDATE                                       │
│     ✓ Только для часто используемых в WHERE/JOIN                    │
│                                                                     │
│  6. ХРАНЕНИЕ НЕСКОЛЬКИХ ЗНАЧЕНИЙ В ОДНОМ ПОЛЕ                       │
│     ✗ phones = "+7..., +7..., +7..."                                │
│     ✗ tags = "tag1,tag2,tag3"                                       │
│     ✓ Отдельная таблица + JOIN                                      │
│                                                                     │
│  7. ПЛОХИЕ ИМЕНА                                                    │
│     ✗ t1, val_1, flag_a, data                                       │
│     ✗ Смешение snake_case и camelCase                               │
│     ✓ user_profiles, created_at, is_active                          │
│                                                                     │
│  8. НЕТ ВАЛИДАЦИИ НА УРОВНЕ БД                                      │
│     ✗ age = -5, price = 'abc', email без @                          │
│     ✗ "Приложение проверит"                                         │
│     ✓ CHECK constraints, NOT NULL, UNIQUE                           │
│                                                                     │
│  9. НЕТ БЭКАПОВ                                                     │
│     ✗ "Авось не упадёт"                                             │
│     ✗ pg_dump раз в месяц вручную                                   │
│     ✓ Автоматические daily backups + point-in-time recovery         │
│                                                                     │
│  10. SELECT * ВЕЗДЕ                                                 │
│     ✗ SELECT * FROM users — тянет все 50 колонок                    │
│     ✗ Лишний трафик, память, время                                  │
│     ✓ SELECT id, name, email FROM users                             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### SQL Injection (критическая ошибка безопасности)

```python
# ═══════════════════════════════════════════════════════════════
# АНТИПРИМЕР: SQL Injection vulnerability
# ═══════════════════════════════════════════════════════════════

# НИКОГДА ТАК НЕ ДЕЛАЙ!
def get_user_UNSAFE(email: str):
    query = f"SELECT * FROM users WHERE email = '{email}'"
    cursor.execute(query)
    return cursor.fetchone()

# Атака:
# email = "'; DROP TABLE users; --"
# query = "SELECT * FROM users WHERE email = ''; DROP TABLE users; --'"
# Результат: таблица удалена!

# Ещё атака:
# email = "' OR '1'='1"
# query = "SELECT * FROM users WHERE email = '' OR '1'='1'"
# Результат: возвращает ВСЕХ пользователей!


# ═══════════════════════════════════════════════════════════════
# ПРАВИЛЬНО: Параметризованные запросы
# ═══════════════════════════════════════════════════════════════

def get_user_SAFE(email: str):
    query = "SELECT * FROM users WHERE email = %s"
    cursor.execute(query, (email,))  # email как параметр, не строка
    return cursor.fetchone()

# Теперь:
# email = "'; DROP TABLE users; --"
# Будет искать буквально email = "'; DROP TABLE users; --"
# Таблица в безопасности!


# ═══════════════════════════════════════════════════════════════
# Или через ORM (ещё безопаснее)
# ═══════════════════════════════════════════════════════════════

# SQLAlchemy
user = session.query(User).filter(User.email == email).first()

# Django ORM
user = User.objects.get(email=email)

# WHY: ORM автоматически экранирует все параметры
```

---

## Практические задания

### Задание 1: Проектирование схемы

```
ЗАДАЧА: Спроектировать БД для книжного магазина

Требования:
- Книги (название, автор, ISBN, цена, количество)
- Авторы (имя, биография)
- Покупатели (имя, email, адрес)
- Заказы (покупатель, книги, количество, дата, статус)
- Книга может иметь нескольких авторов
- Автор может написать несколько книг

Задания:
1. Нарисуй ER-диаграмму
2. Создай таблицы в 3NF
3. Определи Primary и Foreign Keys
4. Добавь constraints (NOT NULL, CHECK)
5. Какие индексы нужны?
```

### Задание 2: CRUD операции

```sql
-- Используя схему из Задания 1, напиши:

-- 1. INSERT: Добавить нового автора и его книгу
-- 2. SELECT: Найти все книги автора "Толстой"
-- 3. SELECT: Топ-10 самых продаваемых книг
-- 4. UPDATE: Обновить цену книги на 10%
-- 5. DELETE: Удалить все заказы старше 1 года (soft delete)
-- 6. JOIN: Показать все заказы с именами покупателей и названиями книг
```

### Задание 3: Анализ производительности

```sql
-- 1. Включи EXPLAIN ANALYZE для этих запросов
-- 2. Определи, какие индексы помогут
-- 3. Создай индексы
-- 4. Сравни время выполнения до/после

-- Запрос 1: Поиск книг по автору
SELECT b.title, a.name
FROM books b
JOIN book_authors ba ON b.id = ba.book_id
JOIN authors a ON ba.author_id = a.id
WHERE a.name LIKE 'Толстой%';

-- Запрос 2: Статистика заказов по месяцам
SELECT
    DATE_TRUNC('month', created_at) as month,
    COUNT(*) as orders,
    SUM(total) as revenue
FROM orders
WHERE created_at > '2024-01-01'
GROUP BY DATE_TRUNC('month', created_at)
ORDER BY month;
```

---

## Заключение

### Чек-лист для начинающих

```
□ Понимаю, зачем нужны базы данных vs файлы
□ Знаю разницу между SQL и NoSQL
□ Могу объяснить ACID свойства
□ Понимаю Primary Key и Foreign Key
□ Знаю, что такое нормализация (1NF, 2NF, 3NF)
□ Понимаю, как работают индексы (B-Tree)
□ Знаю CRUD операции
□ Умею защищаться от SQL Injection
□ Понимаю CAP теорему для распределённых систем
```

### Путь обучения

```
1. НАЧАЛО (эта статья)
   └── Что такое БД, CRUD, ключи, типы

2. SQL ОСНОВЫ
   └── SELECT, JOIN, GROUP BY, подзапросы

3. ПРОЕКТИРОВАНИЕ
   └── ER-диаграммы, нормализация, схемы

4. ОПТИМИЗАЦИЯ
   └── Индексы, EXPLAIN, query tuning

5. АДМИНИСТРИРОВАНИЕ
   └── Backup, recovery, security, monitoring

6. РАСПРЕДЕЛЁННЫЕ СИСТЕМЫ
   └── Репликация, шардинг, CAP

7. СПЕЦИАЛИЗАЦИЯ
   └── PostgreSQL deep dive
   └── MongoDB для NoSQL
   └── Redis для кэширования
   └── Vector DB для AI
```

---

## Связь с другими темами

[[sql-databases-complete]] — SQL-базы данных (PostgreSQL, MySQL, SQLite) являются практической реализацией реляционной модели, описанной в этом документе. После освоения теории (таблицы, ключи, нормализация, ACID) следующий шаг — изучение конкретных СУБД, их различий в синтаксисе, производительности и возможностях. Рекомендуется как прямое продолжение данного материала.

[[nosql-databases-complete]] — NoSQL-базы данных (MongoDB, Redis, Cassandra, Neo4j) представляют альтернативный подход к хранению данных, жертвующий некоторыми ACID-гарантиями ради гибкости и масштабируемости. Понимание реляционных основ из этого документа (нормализация, JOIN, транзакции) помогает осознанно выбирать между SQL и NoSQL для конкретной задачи. Рекомендуется читать после этого материала.

[[architecture-distributed-systems]] — Распределённые системы расширяют концепции баз данных (CAP-теорема, eventual consistency, шардинг) до масштаба нескольких серверов и дата-центров. Фундамент из этого документа (транзакции, isolation levels, индексы) необходим для понимания сложностей distributed databases и выбора правильных trade-offs.

[[database-design-optimization]] — Практическая оптимизация запросов и проектирование схем строится на фундаменте из этого документа: индексы ускоряют WHERE и JOIN, нормализация устраняет аномалии, EXPLAIN ANALYZE показывает план выполнения. Рекомендуется как следующий шаг после освоения основ для перехода к production-уровню работы с БД.

## Источники и дальнейшее чтение

- Date C.J. (2003). *An Introduction to Database Systems*. — Классический учебник по реляционной теории: нормальные формы, реляционная алгебра, целостность данных. Лучшее академическое введение в фундамент баз данных.
- Ramakrishnan R., Gehrke J. (2002). *Database Management Systems*. — Полный университетский курс: от ER-моделирования и SQL до индексов, транзакций и query processing. Идеален для систематического изучения.
- Kleppmann M. (2017). *Designing Data-Intensive Applications*. — Современный взгляд на базы данных в контексте распределённых систем: репликация, партиционирование, stream processing. Необходим для перехода от основ к архитектурным решениям.

---

---

## Проверь себя

> [!question]- Почему база данных лучше обычных файлов для хранения данных приложения?
> Файлы не обеспечивают атомарность операций (сбой между записями приводит к повреждению данных), не поддерживают параллельный доступ без ручной реализации блокировок, требуют полного сканирования для поиска (O(n)), и не гарантируют целостность связей. СУБД решает все эти проблемы через транзакции, MVCC, индексы и foreign keys.

> [!question]- В e-commerce проекте нужно хранить заказы, пользователей и товары. Почему нельзя хранить все данные в одной таблице?
> Хранение всего в одной таблице приводит к аномалиям: дублирование данных (имя клиента в каждом заказе), аномалии обновления (смена email требует обновления всех заказов), аномалии удаления (удаление последнего заказа клиента удалит и самого клиента). Нормализация разделяет данные на связанные таблицы, устраняя эти проблемы.

> [!question]- Когда стоит выбрать NoSQL вместо SQL, и почему это решение не должно определяться масштабом?
> NoSQL выбирается по характеру данных, а не по нагрузке: документы с переменной структурой (MongoDB), кэш и сессии (Redis), временные ряды (InfluxDB), граф связей (Neo4j). PostgreSQL на одном сервере с правильными индексами справляется с 10,000+ RPS — масштаб не является причиной выбора NoSQL.

> [!question]- Что произойдет, если добавить индекс на каждую колонку таблицы?
> Каждый индекс ускоряет чтение (SELECT), но замедляет запись (INSERT/UPDATE/DELETE), потому что при каждом изменении данных СУБД должна обновить все затронутые индексы. Также индексы занимают дополнительное место на диске. Оптимальная стратегия — индексировать только колонки, используемые в WHERE, JOIN и ORDER BY, и проверять эффективность через EXPLAIN ANALYZE.

---

## Ключевые карточки

Что такое СУБД и чем она отличается от базы данных?
?
СУБД (DBMS) — это программа для управления базой данных (PostgreSQL, MySQL). База данных — это сами данные. СУБД — библиотекарь, база данных — библиотека.

Какие 4 свойства гарантирует ACID?
?
Atomicity (всё или ничего), Consistency (данные всегда валидны), Isolation (транзакции не мешают друг другу), Durability (сохранённое не потеряется даже при сбое).

Что такое Primary Key и Foreign Key?
?
Primary Key — уникальный идентификатор записи в таблице (например, user_id). Foreign Key — ссылка на Primary Key другой таблицы, обеспечивающая связь и целостность данных.

Что такое нормализация и зачем она нужна?
?
Нормализация — процесс устранения дублирования данных путём разделения на связанные таблицы. Устраняет аномалии вставки, обновления и удаления. Например, данные клиента хранятся один раз, а заказы ссылаются на них через FK.

Чем отличается B-Tree индекс от Hash индекса?
?
B-Tree поддерживает поиск по диапазону (>, <, BETWEEN), сортировку и поиск по префиксу. Hash работает только для точного совпадения (=), но быстрее для этого случая. B-Tree — универсальный выбор по умолчанию.

Что утверждает CAP-теорема?
?
В распределённой системе при сетевом сбое (Partition) нужно выбирать между Consistency (все узлы видят одинаковые данные) и Availability (система отвечает на запросы). Все три одновременно невозможны.

В чём разница между SQL и NoSQL?
?
SQL — реляционные БД со строгой схемой, ACID, мощными JOIN (PostgreSQL, MySQL). NoSQL — нереляционные БД с гибкой схемой, горизонтальным масштабированием, специализированные под задачу (MongoDB, Redis, Cassandra).

Какие 4 операции включает CRUD?
?
Create (INSERT), Read (SELECT), Update (UPDATE), Delete (DELETE) — четыре базовые операции с данными, которые поддерживает любая СУБД.

---

## Куда дальше

| Направление | Куда | Зачем |
|-------------|------|-------|
| Следующий шаг | [[databases-sql-fundamentals]] | Изучить SQL-синтаксис, JOIN, подзапросы, оконные функции |
| Следующий шаг | [[databases-nosql-comparison]] | Понять когда использовать разные типы NoSQL |
| Углубиться | [[sql-databases-complete]] | Детальное сравнение PostgreSQL, MySQL, SQLite |
| Углубиться | [[nosql-databases-complete]] | Глубокое погружение в MongoDB, Redis, Cassandra, Neo4j |
| Смежная тема | [[architecture-distributed-systems]] | CAP-теорема и распределённые системы на практике |
| Обзор | [[databases-overview]] | Вернуться к карте раздела |

---

*Создано: 2025-12-30*
*Обновлено: 2025-12-30*
*Источники: Oracle, MongoDB, PostgreSQL docs, GeeksforGeeks, PlanetScale, Stack Overflow, Reddit, HackerNews*
