---
title: "Databases: карта раздела"
created: 2025-12-22
modified: 2025-12-22
type: moc
status: published
area: databases
confidence: high
tags:
  - topic/databases
  - sql
  - nosql
  - type/moc
  - level/beginner
related:
  - "[[database-design-optimization]]"
  - "[[databases-sql-fundamentals]]"
  - "[[databases-nosql-comparison]]"
  - "[[databases-transactions-acid]]"
  - "[[databases-replication-sharding]]"
  - "[[databases-backup-recovery]]"
  - "[[databases-monitoring-security]]"
reading_time: 19
difficulty: 3
study_status: not_started
mastery: 0
last_reviewed:
next_review:
---

# Databases: карта раздела

> Базы данных — фундамент любого приложения. Правильный выбор БД и понимание её внутренностей определяют производительность, масштабируемость и надёжность системы.

---

## TL;DR

- **SQL (PostgreSQL, MySQL)** — транзакции, связи, сложные запросы, ACID
- **NoSQL (MongoDB, Redis, Cassandra)** — гибкая схема, горизонтальное масштабирование, специализированные задачи
- **Polyglot Persistence** — используй разные БД для разных задач в одном проекте
- **Знать обязательно:** индексы, транзакции, репликация, бэкапы

---

## Часть 1: Интуиция без кода

> Прежде чем погружаться в SQL и архитектуру — давайте поймём саму суть баз данных через знакомые образы.

### Аналогия 1: Библиотека — идеальная метафора базы данных

```
┌─────────────────────────────────────────────────────────────────┐
│                        БИБЛИОТЕКА (Database)                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│   │  ХУДОЖЕСТВЕННАЯ │  │     НАУЧНАЯ     │  │   СПРАВОЧНАЯ    │ │
│   │    ЛИТЕРАТУРА   │  │   ЛИТЕРАТУРА    │  │   ЛИТЕРАТУРА    │ │
│   │    (Table 1)    │  │    (Table 2)    │  │    (Table 3)    │ │
│   ├─────────────────┤  ├─────────────────┤  ├─────────────────┤ │
│   │ 📖 Книга 1      │  │ 📕 Книга А      │  │ 📘 Книга X      │ │
│   │ 📖 Книга 2      │  │ 📕 Книга Б      │  │ 📘 Книга Y      │ │
│   │ 📖 Книга 3      │  │ 📕 Книга В      │  │ 📘 Книга Z      │ │
│   │   (Records)     │  │   (Records)     │  │   (Records)     │ │
│   └─────────────────┘  └─────────────────┘  └─────────────────┘ │
│                                                                  │
│   Каждая книга имеет: Автор, Название, ISBN, Год                │
│                        ↑                                         │
│                    (Fields/Columns)                              │
│                                                                  │
│   ┌─────────────────────────────────────────────────────────────┤
│   │        БИБЛИОТЕКАРЬ (DBMS)                                  │
│   │   • Знает где какая книга                                   │
│   │   • Ведёт каталог (индексы)                                 │
│   │   • Следит за выдачей (транзакции)                          │
│   │   • Не даёт взять одну книгу двоим (блокировки)             │
│   └─────────────────────────────────────────────────────────────┘
└─────────────────────────────────────────────────────────────────┘
```

**Ключевой инсайт:** DBMS = библиотекарь. Вы не роетесь сами на полках — вы говорите "найди мне книги Толстого", и система знает, как это сделать максимально быстро.

### Аналогия 2: Банкомат — почему ACID критичен

```
Сценарий: У вас 1000₽, вы переводите 500₽ другу

БЕЗ ACID (катастрофа):
┌────────────┐     ┌────────────┐
│ Ваш счёт   │     │ Счёт друга │
│   1000₽    │     │    0₽      │
└─────┬──────┘     └────────────┘
      │
      ▼ Шаг 1: Списание 500₽
┌────────────┐     ┌────────────┐
│ Ваш счёт   │     │ Счёт друга │
│    500₽    │     │    0₽      │
└────────────┘     └────────────┘
      │
      ▼ 💥 СБОЙ СИСТЕМЫ! Шаг 2 не выполнен!

Результат: 500₽ исчезли из мира. Вы потеряли, друг не получил.

С ACID (безопасно):
┌────────────┐     ┌────────────┐
│ Ваш счёт   │     │ Счёт друга │
│   1000₽    │     │    0₽      │
└─────┬──────┘     └────────────┘
      │
      ▼ НАЧАЛО ТРАНЗАКЦИИ
      │ Шаг 1: Списание 500₽
      │ 💥 СБОЙ!
      │
      ▼ ROLLBACK — всё вернулось назад
┌────────────┐     ┌────────────┐
│ Ваш счёт   │     │ Счёт друга │
│   1000₽    │     │    0₽      │  ← Деньги на месте!
└────────────┘     └────────────┘
```

**Ключевой инсайт:** ACID — это гарантия "всё или ничего". Деньги либо переводятся полностью, либо не переводятся вообще. Середины нет.

### Аналогия 3: Картотечный шкаф vs Умная библиотека (DBMS vs RDBMS)

```
┌─────────────────────────────────────────────────────────────────┐
│              КАРТОТЕЧНЫЙ ШКАФ (простая DBMS)                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐          │
│   │ Папка А  │ │ Папка Б  │ │ Папка В  │ │ Папка Г  │          │
│   │ ────────── │ ────────── │ ────────── │ ────────── │          │
│   │ Документы │ │ Документы │ │ Документы │ │ Документы │          │
│   │ внутри    │ │ внутри    │ │ внутри    │ │ внутри    │          │
│   └──────────┘ └──────────┘ └──────────┘ └──────────┘          │
│                                                                  │
│   ❌ Папки не связаны между собой                               │
│   ❌ Нужно вручную искать связи                                 │
│   ❌ Дублирование данных                                        │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│              УМНАЯ БИБЛИОТЕКА (RDBMS)                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌──────────┐    FK    ┌──────────┐    FK    ┌──────────┐     │
│   │ Клиенты  │◄────────►│  Заказы  │◄────────►│ Товары   │     │
│   ├──────────┤          ├──────────┤          ├──────────┤     │
│   │ id: 1    │          │ client:1 │          │ id: 100  │     │
│   │ Иван     │          │ item:100 │          │ iPhone   │     │
│   └──────────┘          └──────────┘          └──────────┘     │
│                                                                  │
│   ✅ Связи через Foreign Keys                                   │
│   ✅ Один запрос = данные из всех таблиц                        │
│   ✅ Нет дублирования: клиент хранится один раз                 │
└─────────────────────────────────────────────────────────────────┘
```

### Аналогия 4: Ресторан с разной посудой — Polyglot Persistence

```
┌─────────────────────────────────────────────────────────────────┐
│                    РЕСТОРАН (Ваше приложение)                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   🍜 СУП подают в ТАРЕЛКЕ        →  PostgreSQL для заказов      │
│      (структурированные данные)     (транзакции, связи)         │
│                                                                  │
│   🍣 СУШИ на ДЕРЕВЯННОЙ ДОСКЕ    →  MongoDB для каталога        │
│      (гибкая презентация)           (гибкая схема товаров)      │
│                                                                  │
│   🥤 НАПИТКИ в СТАКАНАХ          →  Redis для сессий            │
│      (быстрый доступ)               (key-value, TTL)            │
│                                                                  │
│   🍰 ТОРТ на ЭТАЖЕРКЕ            →  Elasticsearch для поиска    │
│      (многоуровневая структура)     (full-text search)          │
│                                                                  │
│   🎂 МОРОЖЕНОЕ в КРЕМАНКЕ        →  ClickHouse для аналитики    │
│      (специальный формат)           (колоночное хранение)       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

Правило: "Не ешь суп вилкой, не режь стейк ложкой"
         = "Используй правильную БД для каждой задачи"
```

### Аналогия 5: CAP-теорема — Выбери два из трёх

```
Представьте распределённую сеть банкоматов в шторм:

┌─────────────────────────────────────────────────────────────────┐
│                         СЕТЬ БАНКОМАТОВ                          │
│                                                                  │
│   🏧 Банкомат А                     🏧 Банкомат Б               │
│   (Москва)                          (Питер)                      │
│       │                                 │                        │
│       │         ⚡ ШТОРМ! ⚡            │                        │
│       │      Связь оборвалась          │                        │
│       └─────────── ✗ ──────────────────┘                        │
│                                                                  │
│   Баланс: 1000₽        ?           Баланс: ???                  │
└─────────────────────────────────────────────────────────────────┘

ВЫБОР 1: Consistency (согласованность)
─────────────────────────────────────
"Извините, банкоматы временно не работают"
✅ Данные точные   ❌ Сервис недоступен

ВЫБОР 2: Availability (доступность)
─────────────────────────────────────
"Выдаём деньги, но баланс может быть неточным"
❌ Риск овердрафта  ✅ Сервис работает

В реальности: Банки выбирают доступность с лимитами
→ "Можете снять до 5000₽ без связи с центром"
```

**Ключевой инсайт:** В распределённых системах сетевые сбои неизбежны (Partition). Когда они случаются — выбирай между Consistency и Availability.

---

## Часть 2: Почему это сложно — типичные ошибки

### Ошибка 1: "NoSQL = Web Scale"

**СИМПТОМ:** "Мы растём, нужен MongoDB/Cassandra для масштабирования!"

```
Реальность большинства проектов:

┌─────────────────────────────────────────────────────────────────┐
│                    ВАШ "ВЫСОКОНАГРУЖЕННЫЙ" ПРОЕКТ               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Данные: ~1 GB              Google: ~15,000 PB                 │
│   Запросов: ~100/сек         Google: ~100,000,000/сек           │
│                                                                  │
│   ┌──────────────────────────────────────────────────────────┐  │
│   │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│  │
│   │░                                                        █│  │
│   │░  ← Вы                                          Google →█│  │
│   └──────────────────────────────────────────────────────────┘  │
│                                                                  │
│   PostgreSQL легко справляется с нагрузкой в 10,000+ RPS        │
│   на одном сервере с правильными индексами и пулом соединений   │
└─────────────────────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:**
- Для 95% приложений PostgreSQL + кэширование = оптимальный выбор
- NoSQL выбирай по характеру данных (граф? документы?), не по масштабу
- Помни: "Google проектирует БД для проблем, которых у тебя нет"

### Ошибка 2: Забытые индексы

**СИМПТОМ:** "Запрос работал быстро, а потом начал тормозить"

```
Таблица users: 1,000,000 строк

БЕЗ ИНДЕКСА:
SELECT * FROM users WHERE email = 'ivan@mail.ru'

┌────────────────────────────────────────────────────────────┐
│  Сканирование: 1,000,000 строк                             │
│  Время: 3-5 секунд 🐌                                      │
│                                                             │
│  [████████████████████████████████████████████████] 100%   │
│   Проверяем КАЖДУЮ строку... есть совпадение? нет? дальше  │
└────────────────────────────────────────────────────────────┘

С ИНДЕКСОМ (B-Tree):
CREATE INDEX idx_email ON users(email);

┌────────────────────────────────────────────────────────────┐
│  Поиск по индексу: ~20 операций (log₂ 1,000,000)          │
│  Время: 1-5 мс 🚀                                          │
│                                                             │
│  ivan@mail.ru → [индекс] → строка #847,291                 │
│  Прямой доступ без сканирования!                           │
└────────────────────────────────────────────────────────────┘

Разница: 1000x быстрее!
```

**РЕШЕНИЕ:**
- Индексы на колонки в WHERE, JOIN, ORDER BY
- Используй EXPLAIN ANALYZE для проверки
- Но не переусердствуй: каждый индекс замедляет INSERT/UPDATE

### Ошибка 3: Игнорирование Foreign Keys

**СИМПТОМ:** "Данные как-то рассинхронизировались..."

```
БЕЗ FOREIGN KEY:

orders:                          users:
┌────┬──────────┐               ┌────┬─────────┐
│ id │ user_id  │               │ id │ name    │
├────┼──────────┤               ├────┼─────────┤
│ 1  │ 100      │               │ 1  │ Иван    │
│ 2  │ 200      │  ← user 200   │ 2  │ Пётр    │
│ 3  │ 999      │  ← ПРИЗРАК!   └────┴─────────┘
└────┴──────────┘    не существует!

Результат: "битые" заказы, невалидные отчёты, баги

С FOREIGN KEY:

CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INT REFERENCES users(id) ON DELETE CASCADE
);

INSERT INTO orders (user_id) VALUES (999);
-- ERROR: foreign key constraint violation
-- БД не даст создать "сиротский" заказ!
```

**РЕШЕНИЕ:**
- Всегда добавляй FK для связей между таблицами
- ON DELETE CASCADE / SET NULL — определи поведение при удалении
- FK = самодокументирующаяся схема

### Ошибка 4: Выбор NoSQL "потому что модно"

**СИМПТОМ:** "Все говорят MongoDB хорош, возьмём его!"

```
Типичный e-commerce проект:

┌─────────────────────────────────────────────────────────────────┐
│   ТРЕБОВАНИЯ:                                                    │
│   • Заказы (транзакции, платежи) → нужен ACID                   │
│   • Связи: пользователь → заказы → товары → отзывы              │
│   • Сложные отчёты с агрегациями                                │
│   • Целостность данных критична                                 │
└─────────────────────────────────────────────────────────────────┘
                    │
                    ▼
┌──────────────────────────────────────┐
│         НЕПРАВИЛЬНЫЙ ВЫБОР:          │
│              MongoDB                 │
│                                      │
│  ❌ Нет настоящих транзакций*        │
│  ❌ JOIN через $lookup = медленно   │
│  ❌ Дублирование данных             │
│  ❌ Нет FK — риск рассинхронизации  │
└──────────────────────────────────────┘
                    │
                    ▼
┌──────────────────────────────────────┐
│         ПРАВИЛЬНЫЙ ВЫБОР:            │
│           PostgreSQL                 │
│                                      │
│  ✅ Полный ACID                      │
│  ✅ Мощные JOIN                      │
│  ✅ JSONB если нужна гибкость        │
│  ✅ 30+ лет проверенной надёжности   │
└──────────────────────────────────────┘

* MongoDB добавил транзакции в v4.0, но они медленнее и сложнее
```

**РЕШЕНИЕ:**
- Вопрос не "SQL или NoSQL?", а "Какие у меня данные?"
- Начинай с PostgreSQL — он покрывает 95% случаев
- NoSQL — когда PostgreSQL объективно не подходит

### Ошибка 5: Преждевременная оптимизация

**СИМПТОМ:** "Сразу сделаем шардинг на 10 серверов!"

```
День 1 проекта:

Архитектор: "Нам нужен кластер из 10 шардов,
            репликация master-master,
            отдельный сервер для аналитики..."

┌────────────────────────────────────────────────────────────────┐
│                      РЕАЛЬНОСТЬ                                 │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Через год:                                                    │
│   • Пользователей: 1,000                                        │
│   • Данных: 500 MB                                              │
│   • RPS: 10                                                     │
│                                                                 │
│   Всё это легко работает на:                                    │
│   • Один PostgreSQL                                             │
│   • 2 GB RAM                                                    │
│   • $20/месяц сервер                                            │
│                                                                 │
│   Потрачено на "архитектуру":                                   │
│   • 3 месяца разработки                                         │
│   • $500/месяц на инфраструктуру                                │
│   • Бесконечные баги синхронизации                              │
└────────────────────────────────────────────────────────────────┘
```

**РЕШЕНИЕ:**
- Проектируй для текущего масштаба + 10x запас
- Вертикальное масштабирование дешевле горизонтального
- Шардинг — когда один сервер объективно не справляется

### Ошибка 6: Неявное преобразование типов

**СИМПТОМ:** "Индекс есть, но запрос всё равно медленный"

```sql
-- Таблица с VARCHAR полем
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    phone VARCHAR(20)  -- строка!
);
CREATE INDEX idx_phone ON users(phone);

-- Ошибка: передаём число вместо строки
SELECT * FROM users WHERE phone = 79001234567;
                                   ↑
                              Число, не строка!

┌────────────────────────────────────────────────────────────────┐
│                   ЧТО ПРОИСХОДИТ:                               │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│   БД конвертирует ВСЕ значения phone в числа для сравнения     │
│   → Индекс становится бесполезен                               │
│   → Full Table Scan                                             │
│                                                                 │
│   EXPLAIN: Seq Scan on users (cost=0.00..2541.00 rows=1000000) │
│            ↑ Индекс не используется!                           │
└────────────────────────────────────────────────────────────────┘

ПРАВИЛЬНО:
SELECT * FROM users WHERE phone = '79001234567';
                                   ↑
                              Строка в кавычках!
```

**РЕШЕНИЕ:**
- Всегда передавай параметры правильного типа
- Используй prepared statements
- EXPLAIN ANALYZE — твой лучший друг

---

## Часть 3: Ментальные модели

### Модель 1: Три уровня проектирования БД

```
┌─────────────────────────────────────────────────────────────────┐
│                    УРОВНИ ДИЗАЙНА БАЗЫ ДАННЫХ                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   1. КОНЦЕПТУАЛЬНЫЙ (Что хранить?)                              │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  🎨 Художественный набросок                              │   │
│   │                                                          │   │
│   │  [Клиент] ──покупает──► [Товар]                         │   │
│   │      │                      │                            │   │
│   │      └──────┬───────────────┘                            │   │
│   │             ▼                                            │   │
│   │         [Заказ]                                          │   │
│   │                                                          │   │
│   │  • Сущности и связи                                      │   │
│   │  • Без технических деталей                               │   │
│   │  • Понятен бизнесу                                       │   │
│   └─────────────────────────────────────────────────────────┘   │
│                           │                                      │
│                           ▼                                      │
│   2. ЛОГИЧЕСКИЙ (Как структурировать?)                          │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  📐 Архитектурный чертёж                                │   │
│   │                                                          │   │
│   │  customers(id PK, name, email)                          │   │
│   │       │                                                  │   │
│   │       │ 1:N                                              │   │
│   │       ▼                                                  │   │
│   │  orders(id PK, customer_id FK, total, status)           │   │
│   │       │                                                  │   │
│   │       │ N:M                                              │   │
│   │       ▼                                                  │   │
│   │  order_items(order_id FK, product_id FK, qty)           │   │
│   │                                                          │   │
│   │  • Таблицы, колонки, типы                               │   │
│   │  • Primary/Foreign Keys                                  │   │
│   │  • Нормализация                                          │   │
│   └─────────────────────────────────────────────────────────┘   │
│                           │                                      │
│                           ▼                                      │
│   3. ФИЗИЧЕСКИЙ (Где и как хранить?)                            │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │  🔧 Строительство                                        │   │
│   │                                                          │   │
│   │  • Какой движок: PostgreSQL, MySQL?                     │   │
│   │  • Индексы: B-Tree, Hash, GIN?                          │   │
│   │  • Партиционирование по дате?                           │   │
│   │  • Tablespace на SSD?                                    │   │
│   │  • Репликация, шардинг?                                  │   │
│   └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### Модель 2: Дерево решений "SQL или NoSQL?"

```
                        ┌────────────────────────┐
                        │ Какие у тебя данные?   │
                        └───────────┬────────────┘
                                    │
              ┌─────────────────────┼─────────────────────┐
              │                     │                     │
              ▼                     ▼                     ▼
    ┌─────────────────┐   ┌─────────────────┐   ┌─────────────────┐
    │  Структуриро-   │   │  Полуструктури- │   │  Графовые       │
    │  ванные, связи  │   │  рованные/      │   │  (связи важнее  │
    │  между сущностями│   │  документы     │   │  данных)        │
    └────────┬────────┘   └────────┬────────┘   └────────┬────────┘
             │                     │                     │
             ▼                     ▼                     ▼
    ┌─────────────────┐   ┌─────────────────┐   ┌─────────────────┐
    │ Нужны транзакции│   │ Схема меняется  │   │    Neo4j        │
    │ и консистентность?│  │ часто?          │   │    ArangoDB     │
    └────────┬────────┘   └────────┬────────┘   └─────────────────┘
             │                     │
      ┌──────┴──────┐       ┌──────┴──────┐
      │ Да          │ Нет   │ Да          │ Нет
      ▼             ▼       ▼             ▼
┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐
│PostgreSQL│  │Может всё │  │ MongoDB  │  │PostgreSQL│
│  MySQL   │  │ ещё SQL? │  │ CouchDB  │  │  + JSONB │
│          │  │ (JSONB)  │  │          │  │          │
└──────────┘  └──────────┘  └──────────┘  └──────────┘

                    │
                    ▼
        ┌─────────────────────┐
        │ Нужен МАСШТАБ       │
        │ записи (100K+ WPS)? │
        └──────────┬──────────┘
                   │
            ┌──────┴──────┐
            │ Да          │ Нет
            ▼             ▼
      ┌──────────┐  ┌──────────────────┐
      │Cassandra │  │ Не усложняй,     │
      │ScyllaDB  │  │ PostgreSQL хватит│
      │DynamoDB  │  └──────────────────┘
      └──────────┘
```

### Модель 3: ACID vs BASE — спектр компромиссов

```
┌─────────────────────────────────────────────────────────────────┐
│                    СПЕКТР КОНСИСТЕНТНОСТИ                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ACID                                              BASE          │
│  ◄──────────────────────────────────────────────────────────►   │
│                                                                  │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐          │
│  │   Банки     │    │  E-commerce │    │   Соцсети   │          │
│  │   Биржи     │    │   Стримы    │    │   Метрики   │          │
│  │  Платежи    │    │   Игры      │    │    Логи     │          │
│  └─────────────┘    └─────────────┘    └─────────────┘          │
│        │                  │                  │                   │
│        ▼                  ▼                  ▼                   │
│  "Лучше недоступен,  "Баланс между"   "Лучше неточно,           │
│   чем неправильный"                   чем недоступно"           │
│                                                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ACID:                           BASE:                          │
│  • Atomicity   (всё или ничего)  • Basically Available          │
│  • Consistency (правила)         • Soft state                   │
│  • Isolation   (изоляция)        • Eventually consistent        │
│  • Durability  (сохранность)                                    │
│                                                                  │
│  Цена: производительность        Цена: сложность логики         │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Модель 4: Вопросы для выбора БД

```
┌─────────────────────────────────────────────────────────────────┐
│           5 ВОПРОСОВ ПЕРЕД ВЫБОРОМ БАЗЫ ДАННЫХ                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. ЧТО ХРАНИШЬ?                                                │
│     ├─ Структурированные данные со связями → SQL                │
│     ├─ Документы с переменной структурой → Document DB          │
│     ├─ Ключ-значение для кэша/сессий → Redis                    │
│     ├─ Временные ряды (метрики) → InfluxDB/TimescaleDB          │
│     └─ Связи между сущностями важнее данных → Graph DB          │
│                                                                  │
│  2. КАК ЗАПРАШИВАЕШЬ?                                           │
│     ├─ Сложные JOIN, агрегации, отчёты → SQL                    │
│     ├─ Поиск по ключу → Key-Value                               │
│     ├─ Полнотекстовый поиск → Elasticsearch                     │
│     └─ Обход графа (друзья друзей) → Graph DB                   │
│                                                                  │
│  3. СКОЛЬКО ДАННЫХ?                                             │
│     ├─ < 100 GB → Один сервер PostgreSQL хватит                 │
│     ├─ 100 GB - 1 TB → Репликация + партиционирование           │
│     └─ > 1 TB → Шардинг или специализированные БД               │
│                                                                  │
│  4. КАК ЧАСТО МЕНЯЮТСЯ?                                         │
│     ├─ Read-heavy (95% чтение) → Кэширование + реплики          │
│     ├─ Write-heavy (много записи) → Cassandra / ScyllaDB        │
│     └─ Balanced → PostgreSQL справится                          │
│                                                                  │
│  5. ЧТО КРИТИЧНО?                                               │
│     ├─ Консистентность (банки) → ACID, PostgreSQL               │
│     ├─ Доступность (соцсети) → BASE, репликация                 │
│     └─ Скорость (кэш) → Redis in-memory                         │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Модель 5: Пирамида масштабирования

```
┌─────────────────────────────────────────────────────────────────┐
│              ПИРАМИДА МАСШТАБИРОВАНИЯ БД                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│                          ▲                                       │
│                         ╱ ╲        Уровень 5: ШАРДИНГ           │
│                        ╱   ╲       • Горизонтальное разделение   │
│                       ╱     ╲      • Распределённые транзакции   │
│                      ╱ HARD  ╲     • CockroachDB, Vitess         │
│                     ╱─────────╲    💰💰💰💰💰 Очень дорого      │
│                    ╱           ╲                                 │
│                   ╱             ╲   Уровень 4: РЕПЛИКАЦИЯ        │
│                  ╱               ╲  • Master + Read Replicas     │
│                 ╱    MEDIUM       ╲ • Асинхронная репликация     │
│                ╱───────────────────╲ 💰💰💰 Средне               │
│               ╱                     ╲                            │
│              ╱                       ╲ Уровень 3: ПАРТИЦИИ       │
│             ╱                         ╲• По дате, региону        │
│            ╱          EASY             ╲• Архивирование старых   │
│           ╱─────────────────────────────╲ 💰💰 Недорого          │
│          ╱                               ╲                       │
│         ╱                                 ╲ Уровень 2: ОПТИМИЗАЦИЯ│
│        ╱                                   ╲• Индексы, EXPLAIN   │
│       ╱             FREE / EASY             ╲• Connection pool   │
│      ╱───────────────────────────────────────╲• Кэширование      │
│     ╱                                         ╲ 💰 Дёшево        │
│    ╱                                           ╲                 │
│   ╱                                             ╲Уровень 1:      │
│  ╱              НАЧНИ ЗДЕСЬ                      ╲ВЕРТИКАЛЬНОЕ   │
│ ╱─────────────────────────────────────────────────╲ МАСШТАБИРОВАНИЕ│
│╱  • Больше RAM, CPU, SSD на одном сервере          ╲💰 Почти бесплатно│
│                                                                  │
│  ПРАВИЛО: Поднимайся на следующий уровень только когда          │
│           текущий исчерпан. 95% проектов живут на уровнях 1-2.   │
└─────────────────────────────────────────────────────────────────┘
```

---

## Быстрая навигация

| Вопрос | Куда идти |
|--------|-----------|
| Как писать эффективные SQL запросы? | [[databases-sql-fundamentals]] |
| SQL или NoSQL — что выбрать? | [[databases-nosql-comparison]] |
| Как работают транзакции и блокировки? | [[databases-transactions-acid]] |
| Как масштабировать БД? | [[databases-replication-sharding]] |
| Как настроить бэкапы и DR? | [[databases-backup-recovery]] |
| Как мониторить и защищать БД? | [[databases-monitoring-security]] |
| Как оптимизировать запросы? | [[database-design-optimization]] |

---

## Путь обучения

```
                    ┌─────────────────────────┐
                    │   SQL Fundamentals      │
                    │   (синтаксис, JOIN,     │
                    │    подзапросы, CTE)     │
                    └───────────┬─────────────┘
                                │
                    ┌───────────▼─────────────┐
                    │   Design & Optimization │
                    │   (индексы, EXPLAIN,    │
                    │    N+1, нормализация)   │
                    └───────────┬─────────────┘
                                │
              ┌─────────────────┼─────────────────┐
              │                 │                 │
    ┌─────────▼───────┐ ┌───────▼───────┐ ┌───────▼───────┐
    │   Transactions  │ │  NoSQL Types  │ │   Security    │
    │   (ACID, locks, │ │  (документы,  │ │   (RLS, audit,│
    │   isolation)    │ │   KV, графы)  │ │   encryption) │
    └─────────┬───────┘ └───────┬───────┘ └───────┬───────┘
              │                 │                 │
              └─────────────────┼─────────────────┘
                                │
                    ┌───────────▼─────────────┐
                    │   Scaling & Operations  │
                    │   (репликация, шардинг, │
                    │    бэкапы, мониторинг)  │
                    └─────────────────────────┘
```

---

## Статьи по категориям

### Фундамент

| Статья | Описание | Связи |
|--------|----------|-------|
| [[databases-sql-fundamentals]] | SQL синтаксис, JOIN, подзапросы, CTE, оконные функции | → optimization |
| [[database-design-optimization]] | Индексы, EXPLAIN, N+1, нормализация, пагинация | → transactions |

### Типы баз данных

| Статья | Описание | Связи |
|--------|----------|-------|
| [[databases-nosql-comparison]] | MongoDB, Redis, DynamoDB, Cassandra — когда что | → architecture |

### Надёжность и консистентность

| Статья | Описание | Связи |
|--------|----------|-------|
| [[databases-transactions-acid]] | ACID, уровни изоляции, deadlocks, оптимистичные блокировки | → distributed |
| [[databases-backup-recovery]] | PITR, WAL, RTO/RPO, стратегии восстановления | → devops |

### Масштабирование

| Статья | Описание | Связи |
|--------|----------|-------|
| [[databases-replication-sharding]] | Master-slave, multi-master, шардинг, CAP теорема | → cloud |

### Операции

| Статья | Описание | Связи |
|--------|----------|-------|
| [[databases-monitoring-security]] | pg_stat_statements, slow queries, RLS, encryption | → security |

---

## Ключевые концепции

| Концепция | Что это | Почему важно |
|-----------|---------|--------------|
| **ACID** | Atomicity, Consistency, Isolation, Durability | Гарантии целостности данных в транзакциях |
| **CAP теорема** | Consistency, Availability, Partition tolerance — выбери 2 | Понимание компромиссов в распределённых системах |
| **Индексы** | Структуры для быстрого поиска O(log n) | Разница между 5 секунд и 5 мс на запрос |
| **Репликация** | Копирование данных на несколько серверов | Отказоустойчивость и масштабирование чтения |
| **Шардинг** | Горизонтальное разделение данных | Масштабирование записи и хранения |
| **WAL** | Write-Ahead Log — журнал изменений | Point-in-time recovery, репликация |

---

## Числа, которые нужно знать

| Метрика | Значение | Контекст |
|---------|----------|----------|
| Index lookup | 1-5 ms | B-Tree по 1M строк |
| Full table scan | 1-5 sec | Без индекса на 1M строк |
| Connection overhead | 20-50 ms | Создание нового соединения |
| Connection pool | 0.1-1 ms | Получение из пула (HikariCP) |
| SSD random read | 0.1 ms | Влияет на index scan |
| HDD random read | 10 ms | 100x медленнее SSD |
| Network latency (same DC) | 0.5-1 ms | БД в том же датацентре |
| Network latency (cross-region) | 50-150 ms | Geo-distributed setup |

---

## SQL vs NoSQL: быстрый выбор

```
┌─────────────────────────────────────────────────────────────────┐
│                     ВЫБОР ТИПА БД                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Нужны транзакции и связи? ──────────────────▶ SQL (PostgreSQL) │
│                                                                 │
│  Гибкая/меняющаяся схема? ───────────────────▶ Document (Mongo) │
│                                                                 │
│  Key-value + кэш + TTL? ─────────────────────▶ Redis            │
│                                                                 │
│  Огромные объёмы записи? ────────────────────▶ Cassandra        │
│                                                                 │
│  Поиск по связям (граф)? ────────────────────▶ Neo4j            │
│                                                                 │
│  Full-text search? ──────────────────────────▶ Elasticsearch    │
│                                                                 │
│  Serverless + AWS? ──────────────────────────▶ DynamoDB         │
│                                                                 │
│  Не знаешь — начни с ────────────────────────▶ PostgreSQL       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Связи с другими разделами

- [[architecture-overview]] — архитектурные паттерны с БД (CQRS, Event Sourcing)
- [[cloud-overview]] — managed databases (RDS, Cloud SQL, DynamoDB)
- [[devops-overview]] — деплой БД, бэкапы в K8s
- [[security-overview]] — защита данных, encryption, compliance

---

## Инструменты

### PostgreSQL экосистема
- **psql** — CLI клиент
- **pgAdmin** — GUI администрирование
- **pg_stat_statements** — статистика запросов
- **pgBouncer** — connection pooling
- **Patroni** — HA кластер

### Мониторинг
- **Grafana + Prometheus** — метрики
- **pganalyze** — анализ производительности
- **Datadog** — APM интеграция

### Миграции
- **Flyway** — Java/Kotlin стек
- **Liquibase** — enterprise
- **Alembic** — Python
- **golang-migrate** — Go

---

## Источники

- [PostgreSQL Documentation](https://www.postgresql.org/docs/) — официальная документация
- [Use The Index, Luke](https://use-the-index-luke.com/) — индексы от А до Я
- "Designing Data-Intensive Applications" by Martin Kleppmann — библия распределённых систем
- [High Performance MySQL](https://www.oreilly.com/library/view/high-performance-mysql/9781492080503/) — O'Reilly

---

## Статистика раздела

| Метрика | Значение |
|---------|----------|
| Всего статей | 8 |
| Категорий | 5 |
| Последнее обновление | 2025-12-22 |

---

## Проверь себя

> [!question]- Почему PostgreSQL с JSONB может заменить MongoDB в большинстве случаев? В каких сценариях MongoDB всё-таки лучше?
> PostgreSQL с JSONB даёт гибкую схему (как MongoDB) плюс ACID-транзакции, мощные JOIN и 30+ лет надёжности. Индексы GIN на JSONB обеспечивают быстрый поиск внутри JSON-документов. MongoDB лучше, когда: (1) схема действительно меняется очень часто и непредсказуемо, (2) нужна встроенная горизонтальная масштабируемость из коробки (шардинг в MongoDB проще настроить), (3) данные естественно представляются вложенными документами без связей между сущностями. Но для e-commerce, финтеха и большинства CRUD-приложений PostgreSQL — объективно лучший выбор.

> [!question]- Индекс ускоряет чтение в 1000 раз, но имеет цену. Почему нельзя создать индекс на каждую колонку?
> Каждый индекс — это отдельная структура данных (обычно B-Tree), которая обновляется при каждой INSERT, UPDATE и DELETE операции. Чем больше индексов — тем медленнее запись. Также индексы занимают место на диске и в RAM. Для таблицы с 10 колонками и индексом на каждую: INSERT замедлится в 5-10 раз, потому что БД должна обновить 10 деревьев. Правило: индексы на колонки из WHERE, JOIN, ORDER BY, и только те, которые реально используются. EXPLAIN ANALYZE покажет, какие индексы работают, а какие — балласт.

> [!question]- CAP-теорема утверждает "выбери два из трёх". Почему на практике выбор всегда между C и A (а не включает P)?
> Partition tolerance (P) — не опция, а факт жизни. В распределённой системе сетевые сбои неизбежны: кабели рвутся, маршрутизаторы падают, пакеты теряются. Если вы не выбираете P — у вас одна машина (не распределённая система). Поэтому реальный выбор: CP (при сбое сети — отказать в обслуживании, но данные точные, как банки) или AP (при сбое сети — продолжить работу, но данные могут быть устаревшими, как соцсети). Это напрямую связано с выбором БД: PostgreSQL — CP, Cassandra — AP. Подробнее в [[databases-replication-sharding]].

> [!question]- Как связана пирамида масштабирования БД с облачными managed-сервисами? На каком уровне пирамиды облако помогает больше всего?
> Облако (см. [[cloud-overview]]) упрощает все уровни, но наибольший эффект — на уровнях 1-3. Вертикальное масштабирование: в облаке за 5 минут увеличиваете RAM/CPU (вместо покупки нового сервера). Оптимизация: managed-сервисы (RDS, Cloud SQL) уже настроены с connection pooling и мониторингом. Партиционирование: автоматическое. Репликация: read replicas создаются в один клик. Шардинг: это единственный уровень, где облако не избавляет от сложности — CockroachDB, Vitess, DynamoDB решают это, но добавляют архитектурную сложность.

> [!question]- Почему неявное преобразование типов в SQL-запросе убивает производительность, даже если есть индекс?
> Когда тип параметра в WHERE не совпадает с типом колонки (например, число vs VARCHAR), БД вынуждена конвертировать каждое значение в колонке для сравнения. Это означает full table scan — индекс игнорируется, потому что B-Tree построен для оригинального типа данных. Prepared statements решают проблему, потому что драйвер БД автоматически передаёт параметры правильного типа. EXPLAIN ANALYZE покажет Seq Scan вместо Index Scan — это сигнал проблемы.

---

## Ключевые карточки

Что такое ACID и зачем он нужен?
?
ACID — гарантии транзакций: Atomicity (всё или ничего), Consistency (данные валидны), Isolation (транзакции не мешают друг другу), Durability (данные сохранены после commit). Критичен для финансовых операций, платежей — без ACID деньги могут "исчезнуть" при сбое.

Чем ACID отличается от BASE?
?
ACID — строгая консистентность, "лучше недоступен, чем неправильный" (банки, биржи). BASE — Basically Available, Soft state, Eventually consistent — "лучше неточно, чем недоступно" (соцсети, метрики). ACID жертвует производительностью, BASE — сложностью логики.

Что такое CAP-теорема?
?
В распределённой системе можно гарантировать только 2 из 3: Consistency (согласованность), Availability (доступность), Partition tolerance (устойчивость к сбоям сети). P неизбежна, поэтому реальный выбор — между C и A.

Как работает индекс B-Tree и какой прирост он даёт?
?
B-Tree — дерево поиска, где нахождение записи требует O(log n) операций. Для 1 миллиона строк: без индекса — полный перебор (1M операций, 3-5 сек), с индексом — ~20 операций (1-5 мс). Разница в 1000 раз.

Когда выбирать SQL, а когда NoSQL?
?
SQL (PostgreSQL): структурированные данные со связями, транзакции, сложные JOIN и отчёты. NoSQL: MongoDB — гибкая/частоменяющаяся схема, Redis — кэш/сессии (key-value), Cassandra — огромные объёмы записи, Neo4j — графовые данные. По умолчанию — начинай с PostgreSQL.

Что такое Polyglot Persistence?
?
Использование разных баз данных для разных задач в одном проекте. Пример: PostgreSQL для заказов (ACID), Redis для сессий (скорость), Elasticsearch для поиска (full-text), ClickHouse для аналитики (колоночное хранение). Правило: "используй правильную БД для каждой задачи".

Что такое Foreign Key и почему его нельзя игнорировать?
?
Foreign Key (FK) — ограничение, гарантирующее, что значение в колонке существует в связанной таблице. Без FK можно создать "сиротские" записи (заказ на несуществующего пользователя), что приводит к битым данным. FK = самодокументирующаяся схема + целостность данных.

Три уровня проектирования базы данных?
?
1) Концептуальный — сущности и связи (ER-диаграмма), понятен бизнесу. 2) Логический — таблицы, колонки, PK/FK, нормализация. 3) Физический — выбор движка, типы индексов, партиционирование, размещение на дисках.

Пирамида масштабирования — с чего начать?
?
Снизу вверх: 1) Вертикальное масштабирование (больше RAM/CPU). 2) Оптимизация (индексы, EXPLAIN, connection pool). 3) Партиционирование. 4) Репликация (master + read replicas). 5) Шардинг. 95% проектов живут на уровнях 1-2.

Почему "начни с PostgreSQL" — хороший совет?
?
PostgreSQL покрывает ~95% случаев: полный ACID, мощные JOIN, JSONB для гибкой схемы, 10,000+ RPS на одном сервере с правильными индексами. Выбирай NoSQL только когда PostgreSQL объективно не подходит (граф, 100K+ WPS, key-value кэш).

---

## Куда дальше

| Направление | Куда | Зачем |
|-------------|------|-------|
| Следующий шаг | [[databases-sql-fundamentals]] | Основы SQL: синтаксис, JOIN, подзапросы, CTE, оконные функции |
| Углубиться | [[database-design-optimization]] | Индексы, EXPLAIN, N+1, нормализация — оптимизация на практике |
| Углубиться | [[databases-transactions-acid]] | ACID, уровни изоляции, deadlocks — как работают транзакции изнутри |
| Смежная тема | [[cloud-overview]] | Managed databases в облаке: RDS, Cloud SQL, DynamoDB |
| Смежная тема | [[devops-overview]] | Деплой, бэкапы и мониторинг баз данных в production |
| Смежная тема | [[databases-replication-sharding]] | Масштабирование: репликация, шардинг, CAP-теорема на практике |
| Обзор | [[databases-nosql-comparison]] | MongoDB, Redis, Cassandra — когда SQL не подходит |

---

*Создано: 2025-12-22*
*Обновлено: 2026-01-09 — добавлены педагогические секции (5 аналогий: библиотека, банкомат/ACID, картотека vs RDBMS, ресторан/polyglot, CAP-банкоматы; 6 типичных ошибок с решениями; 5 ментальных моделей: три уровня дизайна, дерево решений SQL/NoSQL, ACID vs BASE спектр, 5 вопросов выбора, пирамида масштабирования)*
