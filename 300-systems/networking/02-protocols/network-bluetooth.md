---
title: "Bluetooth: от гарнитур до IoT mesh"
created: 2025-12-18
modified: 2026-02-13
type: concept
status: published
confidence: high
sources_verified: true
tags:
  - topic/networking
  - networking/wireless
  - networking/bluetooth
  - type/concept
  - level/intermediate
related:
  - "[[network-wireless-iot]]"
  - "[[network-physical-layer]]"
  - "[[android-networking]]"
prerequisites:
  - "[[network-physical-layer]]"
  - "[[network-fundamentals-for-developers]]"
reading_time: 135
difficulty: 6
study_status: not_started
mastery: 0
last_reviewed:
next_review:
---

# Bluetooth: от гарнитур до IoT mesh

## Prerequisites

Прежде чем изучать Bluetooth, рекомендуется понимать:

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **Радиочастоты 2.4 GHz** | Bluetooth работает в ISM band, понимание интерференции | Базовая физика |
| **Client-Server модель** | GATT использует client/server для BLE | [[networking-overview]] |
| **UUID** | Идентификаторы сервисов и характеристик | Общие концепции |
| **Android разрешения** | Runtime permissions для Bluetooth на Android 12+ | [[android-development]] |

### Для кого этот материал

| Уровень | Подходит? | Рекомендация |
|---------|-----------|--------------|
| **Новичок** | ✅ Да | Основы BLE |
| **Intermediate** | ✅ Да | Мобильная/IoT разработка |
| **Advanced** | ✅ Да | BLE Mesh, аудио кодеки |

### Терминология для новичков

> 💡 **Bluetooth** = беспроводная связь на короткие расстояния (до 100м). Наушники, клавиатуры, фитнес-браслеты — всё это Bluetooth.

| Термин | Значение | Аналогия для новичка |
|--------|----------|---------------------|
| **Bluetooth Classic** | Традиционный Bluetooth | **Рация** — постоянная связь для аудио |
| **BLE** | Bluetooth Low Energy | **Умная рация** — экономит батарею |
| **Pairing** | Сопряжение устройств | **Обменяться номерами** — познакомиться |
| **GATT** | Протокол обмена данными BLE | **Меню услуг** — что устройство умеет |
| **Service** | Группа характеристик | **Категория услуг** — например "пульсометр" |
| **Characteristic** | Одно значение (температура, пульс) | **Конкретная услуга** — измерить пульс |
| **Advertising** | Объявление о себе | **"Я здесь!"** — устройство ищет друзей |
| **Scanning** | Поиск устройств | **Слушать объявления** |
| **MTU** | Maximum Transfer Unit | **Размер письма** — сколько за раз |
| **BLE Mesh** | Mesh-сеть на BLE | **Эстафета BLE** — передаём по цепочке |

---

## Часть 1: Интуиция без кода

> 🎯 **Цель секции**: Понять Bluetooth через повседневные аналогии — без единой строки кода или технических спецификаций.

### Аналогия 1: Classic vs BLE как такси vs каршеринг

```
+------------------------------------------------------------------+
|           BLUETOOTH CLASSIC VS BLE: МОДЕЛИ ТРАНСПОРТА            |
+------------------------------------------------------------------+
|                                                                    |
|   🚖 BLUETOOTH CLASSIC = Личный водитель (такси)                 |
|   +----------------------------------------------------------+   |
|   |                                                          |   |
|   |   • Вызвал → водитель приехал → едет с тобой пока нужно |   |
|   |   • Машина ТВОЯ на всё время поездки                    |   |
|   |   • Постоянная связь (двигатель работает всегда)        |   |
|   |   • Идеально для долгих поездок (музыка в наушниках)    |   |
|   |   • Дорого: бензин тратится даже в пробке               |   |
|   |                                                          |   |
|   +----------------------------------------------------------+   |
|                                                                    |
|   🚗 BLE = Каршеринг (поминутная аренда)                        |
|   +----------------------------------------------------------+   |
|   |                                                          |   |
|   |   • Нашёл машину → открыл → доехал → закрыл → ушёл      |   |
|   |   • Машина "спит" пока не нужна                         |   |
|   |   • Короткие сессии: взял данные → отключился           |   |
|   |   • Батарейка-таблетка на ГОДЫ!                         |   |
|   |   • Идеально для датчиков: раз в минуту отправил данные |   |
|   |                                                          |   |
|   +----------------------------------------------------------+   |
|                                                                    |
|   КЛЮЧЕВОЙ ИНСАЙТ:                                                |
|   ┌────────────────────────────────────────────────────────┐     |
|   │ Classic: постоянное соединение, высокий throughput     │     |
|   │ BLE: спорадическое соединение, минимальное потребление │     |
|   └────────────────────────────────────────────────────────┘     |
|                                                                    |
|   Когда что использовать:                                         |
|   • Музыка 3 часа без перерыва → Classic (A2DP)                  |
|   • Пульс раз в секунду → BLE (Heart Rate Service)               |
|   • Умная лампочка → BLE (редкие команды)                        |
|   • Передача файла → Classic (SPP/FTP)                           |
|                                                                    |
+------------------------------------------------------------------+
```

---

### Аналогия 2: GATT как ресторанное меню

```
+------------------------------------------------------------------+
|              GATT = СТРУКТУРИРОВАННОЕ МЕНЮ РЕСТОРАНА             |
+------------------------------------------------------------------+
|                                                                    |
|   Представьте: вы пришли в ресторан и открыли меню.              |
|   Меню — это GATT Profile устройства.                            |
|                                                                    |
|   ┌─────────────────────────────────────────────────────────┐    |
|   │              🏪 МЕНЮ РЕСТОРАНА (GATT Profile)           │    |
|   │                                                          │    |
|   │  📂 РАЗДЕЛ "СУПЫ" ←─────────── SERVICE (UUID: 0x1809)   │    |
|   │  │                             Temperature Service       │    |
|   │  │                                                       │    |
|   │  ├── 🍜 Борщ                                             │    |
|   │  │   Цена: 250₽ ←────────── Characteristic (Value)      │    |
|   │  │   Калории: 180 ←──────── Descriptor (метаданные)     │    |
|   │  │   [Read-only]                                        │    |
|   │  │                                                       │    |
|   │  └── 🍜 Том Ям                                           │    |
|   │      Цена: 350₽                                          │    |
|   │      Острота: 🌶️🌶️🌶️ ←───── Descriptor                  │    |
|   │      [Read-only]                                        │    |
|   │                                                          │    |
|   │  📂 РАЗДЕЛ "НАПИТКИ" ←────── SERVICE (UUID: 0x180F)     │    |
|   │  │                            Battery Service            │    |
|   │  │                                                       │    |
|   │  └── 🍷 Вино                                             │    |
|   │      Уровень: 75% ←────────── Battery Level (0-100%)    │    |
|   │      [Read + Notify]                                    │    |
|   │                                                          │    |
|   └─────────────────────────────────────────────────────────┘    |
|                                                                    |
|   КАК ЭТО РАБОТАЕТ:                                               |
|   1. Клиент (Central) "открывает меню" → discoverServices()      |
|   2. Видит список разделов (Services) и блюд (Characteristics)   |
|   3. "Заказывает" (Read) или "подписывается" (Notify)            |
|   4. Официант (Peripheral) приносит данные или уведомляет        |
|                                                                    |
|   Properties (что можно делать с блюдом):                         |
|   • Read: посмотреть цену                                        |
|   • Write: заказать (изменить настройку)                         |
|   • Notify: "позвоните когда готово" (без подтверждения)         |
|   • Indicate: "позвоните и убедитесь что я услышал"              |
|                                                                    |
+------------------------------------------------------------------+
```

---

### Аналогия 3: Advertising как объявления на доске

```
+------------------------------------------------------------------+
|           BLE ADVERTISING = ДОСКА ОБЪЯВЛЕНИЙ В ПОДЪЕЗДЕ          |
+------------------------------------------------------------------+
|                                                                    |
|   📋 ДОСКА ОБЪЯВЛЕНИЙ (2.4 GHz эфир)                             |
|   ┌─────────────────────────────────────────────────────────┐    |
|   │                                                          │    |
|   │  ┌──────────────────┐  ┌──────────────────┐             │    |
|   │  │ 🏋️ ФИТНЕС-БРАСЛЕТ│  │ 💡 УМНАЯ ЛАМПА   │             │    |
|   │  │ "Я тут!"         │  │ "Я тут!"         │             │    |
|   │  │ UUID: Heart Rate │  │ UUID: Light Ctrl │             │    |
|   │  │ Имя: Mi Band 8   │  │ Имя: Yeelight    │             │    |
|   │  │ Обновл: каждые   │  │ Обновл: каждые   │             │    |
|   │  │ 100ms            │  │ 1000ms           │             │    |
|   │  └──────────────────┘  └──────────────────┘             │    |
|   │                                                          │    |
|   │  ┌──────────────────┐  ┌──────────────────┐             │    |
|   │  │ 🔑 BLUETOOTH     │  │ 🌡️ ТЕРМОМЕТР     │             │    |
|   │  │    BEACON        │  │ "Я тут!"         │             │    |
|   │  │ "Я тут!"         │  │ UUID: Thermo     │             │    |
|   │  │ iBeacon UUID     │  │ Темп: 23.5°C     │             │    |
|   │  │ Major/Minor      │  │ (в самом adv!)   │             │    |
|   │  └──────────────────┘  └──────────────────┘             │    |
|   │                                                          │    |
|   └─────────────────────────────────────────────────────────┘    |
|                                                                    |
|   📱 ТЕЛЕФОН (Central/Scanner):                                   |
|   "Смотрю на доску, вижу кто здесь рядом"                        |
|                                                                    |
|   ТИПЫ ОБЪЯВЛЕНИЙ:                                                |
|   ┌────────────────────────────────────────────────────────┐     |
|   │ Connectable: "Стучитесь, поговорим!" (большинство)     │     |
|   │ Non-connectable: "Только смотреть!" (beacons)          │     |
|   │ Scannable: "Спросите — расскажу больше" (scan response)│     |
|   └────────────────────────────────────────────────────────┘     |
|                                                                    |
|   ЭНЕРГИЯ:                                                        |
|   • Advertising interval 20ms = много энергии, быстро найдут     |
|   • Advertising interval 10s = мало энергии, долго искать        |
|   • Beacon на батарейке CR2032 → живёт 1-3 года!                 |
|                                                                    |
+------------------------------------------------------------------+
```

---

### Аналогия 4: Pairing как знакомство с паролем

```
+------------------------------------------------------------------+
|           BLUETOOTH PAIRING = ЗНАКОМСТВО С ОБМЕНОМ СЕКРЕТОМ      |
+------------------------------------------------------------------+
|                                                                    |
|   Представьте: вы хотите подружиться с новым соседом.            |
|   Но не с любым — только с тем, кому доверяете.                  |
|                                                                    |
|   УРОВНИ "ЗНАКОМСТВА" (Security Modes):                          |
|                                                                    |
|   Level 1: "Привет, сосед!" (Just Works)                         |
|   ┌────────────────────────────────────────────────────────┐     |
|   │ 👋 Просто пожали руки, никаких вопросов                │     |
|   │ ⚠️ Любой может притвориться "соседом"!                 │     |
|   │ ✅ Используется: наушники, колонки (удобство > секрет) │     |
|   └────────────────────────────────────────────────────────┘     |
|                                                                    |
|   Level 2: "Какой код на домофоне?" (Passkey Entry)              |
|   ┌────────────────────────────────────────────────────────┐     |
|   │ 🔢 Устройство показывает PIN: 847293                   │     |
|   │ 📱 Вы вводите этот PIN на телефоне                     │     |
|   │ ✅ Только тот, кто видит экран устройства              │     |
|   │ ✅ Используется: клавиатуры, сейфы                     │     |
|   └────────────────────────────────────────────────────────┘     |
|                                                                    |
|   Level 3: "Это точно ты?" (Numeric Comparison)                  |
|   ┌────────────────────────────────────────────────────────┐     |
|   │ 📱 Телефон: "Вижу код 583621. У вас такой же?"        │     |
|   │ ⌚ Часы: "Вижу код 583621"                             │     |
|   │ 👤 Вы: "Да, совпадает!" → Подтверждаете на обоих      │     |
|   │ ✅ MITM-защита (человек посередине не пройдёт)         │     |
|   └────────────────────────────────────────────────────────┘     |
|                                                                    |
|   Level 4: "Секретный рукопожатие" (Out-of-Band / NFC)           |
|   ┌────────────────────────────────────────────────────────┐     |
|   │ 📲 Коснулись телефонами (NFC обмен ключами)           │     |
|   │ 🔐 Ключи переданы физически, а не по воздуху          │     |
|   │ ✅ Максимальная безопасность                           │     |
|   └────────────────────────────────────────────────────────┘     |
|                                                                    |
|   ПОСЛЕ PAIRING:                                                  |
|   ┌────────────────────────────────────────────────────────┐     |
|   │ Устройства запомнили друг друга (Bonding)             │     |
|   │ Ключи сохранены → в следующий раз без PIN             │     |
|   │ Как "сохранить контакт" после знакомства              │     |
|   └────────────────────────────────────────────────────────┘     |
|                                                                    |
+------------------------------------------------------------------+
```

---

### Аналогия 5: Bluetooth Mesh как сеть соседей-передатчиков

```
+------------------------------------------------------------------+
|         BLUETOOTH MESH = ИСПОРЧЕННЫЙ ТЕЛЕФОН ПО ПОДЪЕЗДУ         |
+------------------------------------------------------------------+
|                                                                    |
|   Представьте длинный коридор общежития:                          |
|   Комната 1 хочет передать сообщение в Комнату 100.              |
|   Bluetooth достаёт только на 2-3 комнаты!                        |
|                                                                    |
|   БЕЗ MESH (обычный BLE):                                        |
|   ┌────┐                                              ┌────┐      |
|   │ К1 │ ══════════════════✕══════════════════════> │К100│      |
|   └────┘    ❌ Не достаёт! (50м max)                 └────┘      |
|                                                                    |
|   С MESH (ретрансляция):                                         |
|   ┌────┐   ┌────┐   ┌────┐   ┌────┐         ┌────┐              |
|   │ К1 │──>│ К2 │──>│ К3 │──>│ К4 │──> ... │К100│              |
|   └────┘   └────┘   └────┘   └────┘         └────┘              |
|      │        │        │        │              │                  |
|      └────────┴────────┴────────┴──────────────┘                  |
|            ✅ Каждый передаёт дальше!                             |
|                                                                    |
|   КАК РАБОТАЕТ:                                                   |
|   ┌────────────────────────────────────────────────────────┐     |
|   │                                                         │     |
|   │   1. Комната 1 кричит: "Включить свет в К100!"        │     |
|   │      (Managed Flood — все слышат)                      │     |
|   │                                                         │     |
|   │   2. Комнаты 2, 3, 4 услышали → повторяют             │     |
|   │      (Relay Nodes)                                     │     |
|   │                                                         │     |
|   │   3. Сообщение "прыгает" от комнаты к комнате         │     |
|   │      TTL=10 → 10 прыжков максимум                      │     |
|   │                                                         │     |
|   │   4. Комната 100 получила → включила свет             │     |
|   │                                                         │     |
|   │   5. Дубликаты фильтруются (каждый видел это msg)     │     |
|   │                                                         │     |
|   └────────────────────────────────────────────────────────┘     |
|                                                                    |
|   ТИПЫ ЖИЛЬЦОВ (Node Types):                                     |
|   • Relay Node: активный сосед, передаёт сообщения              |
|   • Low Power Node: спит, просыпается редко                      |
|   • Friend Node: хранит сообщения для спящих соседей            |
|   • Proxy Node: переводчик для обычных BLE устройств            |
|                                                                    |
|   ПРИМЕНЕНИЕ:                                                     |
|   • Умное освещение: 1000+ ламп в офисном здании                |
|   • Датчики: покрытие огромного склада                           |
|   • Метки: трекинг активов на заводе                             |
|                                                                    |
+------------------------------------------------------------------+
```

---

## Часть 2: Почему это сложно

> 🎯 **Цель секции**: Изучить 6 типичных ошибок, которые совершают при работе с Bluetooth, и как их избежать.

### Ошибка 1: Ожидание мгновенного соединения

**СИМПТОМ:**
```
Код:
gatt = device.connectGatt(context, false, callback)
// Сразу читаем characteristic
gatt.readCharacteristic(char)

Результат:
❌ Ничего не работает, callback не вызывается
```

**ПОЧЕМУ ПРОИСХОДИТ:**
- BLE соединение — асинхронный процесс
- connectGatt() возвращается сразу, но соединение ещё не установлено
- Нужно дождаться onConnectionStateChange → STATE_CONNECTED
- Затем discoverServices() → onServicesDiscovered
- И только потом можно читать/писать characteristics

**РЕШЕНИЕ:**
```kotlin
// ✅ Правильный порядок (state machine):
//
// connectGatt()
//     ↓
// onConnectionStateChange(STATE_CONNECTED)
//     ↓
// discoverServices()
//     ↓
// onServicesDiscovered()
//     ↓
// readCharacteristic() / writeCharacteristic()
//     ↓
// onCharacteristicRead() / onCharacteristicWrite()

// Используйте очередь операций или корутины для управления последовательностью
class GattOperationQueue {
    private val queue = ArrayDeque<suspend () -> Unit>()
    private var isProcessing = false

    suspend fun enqueue(operation: suspend () -> Unit) {
        queue.add(operation)
        if (!isProcessing) processNext()
    }

    private suspend fun processNext() {
        if (queue.isEmpty()) {
            isProcessing = false
            return
        }
        isProcessing = true
        val op = queue.removeFirst()
        op()
        // Ждём callback, потом processNext()
    }
}
```

---

### Ошибка 2: Игнорирование Android permissions на 12+

**СИМПТОМ:**
```
Приложение работало на Android 11, но на Android 12+ падает:
java.lang.SecurityException: Need BLUETOOTH_CONNECT permission

или: сканирование не находит устройства (silent fail)
```

**ПОЧЕМУ ПРОИСХОДИТ:**
- Android 12 (API 31) полностью изменил модель разрешений Bluetooth
- Старые BLUETOOTH и BLUETOOTH_ADMIN больше не работают
- Нужны новые runtime permissions: BLUETOOTH_SCAN, BLUETOOTH_CONNECT, BLUETOOTH_ADVERTISE
- Без них операции тихо фейлятся или бросают SecurityException

**РЕШЕНИЕ:**
```kotlin
// ✅ Проверяйте SDK версию и запрашивайте правильные permissions:

val permissions = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
    arrayOf(
        Manifest.permission.BLUETOOTH_SCAN,
        Manifest.permission.BLUETOOTH_CONNECT,
        Manifest.permission.BLUETOOTH_ADVERTISE  // если нужен advertising
    )
} else {
    arrayOf(
        Manifest.permission.BLUETOOTH,
        Manifest.permission.BLUETOOTH_ADMIN,
        Manifest.permission.ACCESS_FINE_LOCATION  // для сканирования
    )
}

// И в Manifest:
// android:maxSdkVersion="30" для старых permissions
// Новые permissions без maxSdkVersion
```

---

### Ошибка 3: Сканирование без остановки (battery drain)

**СИМПТОМ:**
```
Приложение сканирует BLE устройства.
Пользователь жалуется: "Батарея садится за 2 часа!"
Или: сканирование перестаёт работать через 30 минут.
```

**ПОЧЕМУ ПРОИСХОДИТ:**
- BLE сканирование — энергозатратная операция
- SCAN_MODE_LOW_LATENCY потребляет много энергии
- Android ограничивает длительное сканирование в background
- После 30 минут непрерывного сканирования — throttling

**РЕШЕНИЕ:**
```kotlin
// ✅ Правило: Scan → Find → Stop → Connect

// 1. Используйте правильный ScanMode:
val settings = ScanSettings.Builder()
    .setScanMode(ScanSettings.SCAN_MODE_BALANCED)  // или LOW_POWER
    .build()

// 2. Всегда останавливайте сканирование:
fun scanForDevice(targetName: String) {
    val callback = object : ScanCallback() {
        override fun onScanResult(callbackType: Int, result: ScanResult) {
            if (result.device.name == targetName) {
                stopScan()  // ← Нашли — остановили!
                connectToDevice(result.device)
            }
        }
    }

    scanner.startScan(callback)

    // 3. Timeout — остановить через N секунд даже если не нашли
    handler.postDelayed({ stopScan() }, 10_000)
}

// 4. Для background — используйте PendingIntent scan
```

---

### Ошибка 4: Путаница Classic vs BLE

**СИМПТОМ:**
```
Пытаюсь подключить BLE фитнес-браслет через createRfcommSocketToServiceRecord()
Результат: IOException: Connection refused

или наоборот: подключаю наушники через connectGatt()
Результат: Соединение есть, но звук не идёт
```

**ПОЧЕМУ ПРОИСХОДИТ:**
- Bluetooth Classic и BLE — разные технологии с разными API
- Classic: BluetoothSocket, RFCOMM, профили A2DP/HFP/SPP
- BLE: BluetoothGatt, GATT Services, Characteristics
- Одно устройство может поддерживать оба (Dual Mode), но API разные

**РЕШЕНИЕ:**
```kotlin
// ✅ Определите тип устройства перед подключением:

fun getDeviceType(device: BluetoothDevice): String {
    return when (device.type) {
        BluetoothDevice.DEVICE_TYPE_CLASSIC -> "Classic only"
        BluetoothDevice.DEVICE_TYPE_LE -> "BLE only"
        BluetoothDevice.DEVICE_TYPE_DUAL -> "Dual mode"
        else -> "Unknown"
    }
}

// Для Classic устройств (наушники, колонки):
val socket = device.createRfcommSocketToServiceRecord(SPP_UUID)
socket.connect()

// Для BLE устройств (датчики, фитнес-браслеты):
val gatt = device.connectGatt(context, false, gattCallback, TRANSPORT_LE)

// Для Dual mode — выбирайте transport явно:
device.connectGatt(context, false, callback, BluetoothDevice.TRANSPORT_LE)
device.connectGatt(context, false, callback, BluetoothDevice.TRANSPORT_BREDR)
```

---

### Ошибка 5: Забытое MTU согласование

**СИМПТОМ:**
```
Отправляю 100 байт через writeCharacteristic()
На устройство приходит только 20 байт, остальное теряется

Логи: Write successful!
Реальность: данные обрезаны
```

**ПОЧЕМУ ПРОИСХОДИТ:**
- Default MTU в BLE = 23 bytes (20 payload + 3 header)
- Если не запросить увеличение MTU — данные обрезаются
- writeCharacteristic() не проверяет размер vs MTU
- BLE 4.2+ поддерживает MTU до 517 bytes, но нужно запросить

**РЕШЕНИЕ:**
```kotlin
// ✅ После подключения — запросите MTU:

override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {
    if (newState == BluetoothProfile.STATE_CONNECTED) {
        gatt.requestMtu(512)  // Запрашиваем максимальный
    }
}

override fun onMtuChanged(gatt: BluetoothGatt, mtu: Int, status: Int) {
    if (status == BluetoothGatt.GATT_SUCCESS) {
        // Реальный MTU может быть меньше запрошенного
        val maxPayload = mtu - 3  // ATT header
        Log.d("BLE", "MTU: $mtu, max payload: $maxPayload bytes")
    }
}

// При записи — проверяйте размер:
fun writeData(data: ByteArray): Boolean {
    if (data.size > currentMtu - 3) {
        // Разбейте на чанки или используйте Write Long Characteristic
        return writeInChunks(data)
    }
    return gatt.writeCharacteristic(characteristic)
}
```

---

### Ошибка 6: Интерференция с Wi-Fi (2.4 GHz)

**СИМПТОМ:**
```
Bluetooth наушники "заикаются" когда:
- Включена микроволновка
- Активная загрузка по Wi-Fi
- Рядом много Wi-Fi сетей

BLE сканирование находит устройства через раз
```

**ПОЧЕМУ ПРОИСХОДИТ:**
- Bluetooth и Wi-Fi используют один диапазон 2.4 GHz
- Wi-Fi каналы 1-11 перекрываются с Bluetooth
- Микроволновки излучают в том же диапазоне
- Adaptive Frequency Hopping помогает, но не всегда

**РЕШЕНИЕ:**
```
✅ Аппаратные решения:
1. Переведите Wi-Fi на 5 GHz (если устройства поддерживают)
2. Уменьшите расстояние между Bluetooth устройствами
3. Избегайте физических препятствий (металл, вода)

✅ Программные решения:
1. Используйте Bluetooth 5.0+ (улучшенная coexistence)
2. Мониторьте RSSI и предупреждайте пользователя о плохом сигнале
3. Для критичных данных — реализуйте retry с backoff

// Мониторинг качества соединения:
override fun onReadRemoteRssi(gatt: BluetoothGatt, rssi: Int, status: Int) {
    when {
        rssi > -60 -> "Отличный сигнал"
        rssi > -70 -> "Хороший сигнал"
        rssi > -80 -> "Слабый сигнал — возможны проблемы"
        else -> "Критически слабый — переместите устройства ближе"
    }
}
```

---

## Часть 3: Ментальные модели

> 🎯 **Цель секции**: 5 способов думать о Bluetooth, которые упрощают понимание и принятие решений.

### Модель 1: Спектр энергопотребления

```
+------------------------------------------------------------------+
|                 BLUETOOTH: ОСЬ ЭНЕРГИИ                            |
+------------------------------------------------------------------+
|                                                                    |
|   Постоянное соединение ←──────────────────→ Спорадическое        |
|   (Classic)                                      (BLE)             |
|                                                                    |
|   Батарея: часы        ←──────────────────→ Батарея: годы         |
|                                                                    |
|   ┌─────────────────────────────────────────────────────────┐    |
|   │                                                          │    |
|   │  ◄── Высокое потребление          Низкое потребление ──►│    |
|   │                                                          │    |
|   │  🎧        📞        ⌨️        💓        🌡️        📍    │    |
|   │ A2DP     HFP      HID       HRS      Thermo   Beacon   │    |
|   │ Audio   Calls   Keyboard   Heart    Sensor    iBeacon  │    |
|   │                             Rate                        │    |
|   │                                                          │    |
|   │  ●────────●────────●────────●────────●────────●         │    |
|   │  │        │        │        │        │        │         │    |
|   │  │        │        │        │        │        │         │    |
|   │  └─Classic─┘        └─────────BLE──────────────┘         │    |
|   │                                                          │    |
|   └─────────────────────────────────────────────────────────┘    |
|                                                                    |
|   ПРАВИЛО ВЫБОРА:                                                 |
|   ┌────────────────────────────────────────────────────────┐     |
|   │ Вопрос: "Как часто устройство передаёт данные?"       │     |
|   │                                                         │     |
|   │ • Постоянный поток (музыка, звонки) → Classic          │     |
|   │ • Периодически (пульс раз в сек) → BLE                 │     |
|   │ • Редко (температура раз в минуту) → BLE Low Power     │     |
|   │ • Только когда спросят → BLE Advertising only          │     |
|   └────────────────────────────────────────────────────────┘     |
|                                                                    |
+------------------------------------------------------------------+
```

---

### Модель 2: Client-Server роли в BLE

```
+------------------------------------------------------------------+
|                 BLE: КТО КЛИЕНТ, КТО СЕРВЕР?                      |
+------------------------------------------------------------------+
|                                                                    |
|   ⚠️ ВНИМАНИЕ: Интуиция подводит!                                |
|                                                                    |
|   Кажется логичным:                                               |
|   "Телефон мощнее → он сервер"                                   |
|   "Датчик маленький → он клиент"                                 |
|                                                                    |
|   РЕАЛЬНОСТЬ (GATT):                                              |
|   ┌─────────────────────────────────────────────────────────┐    |
|   │                                                          │    |
|   │   📱 ТЕЛЕФОН = GATT CLIENT (Central)                    │    |
|   │   ┌───────────────────────────────────────────┐         │    |
|   │   │ • Инициирует подключение                   │         │    |
|   │   │ • Сканирует устройства                     │         │    |
|   │   │ • Запрашивает данные (Read)               │         │    |
|   │   │ • Подписывается на уведомления (Notify)   │         │    |
|   │   │ • Посылает команды (Write)                │         │    |
|   │   └───────────────────────────────────────────┘         │    |
|   │              │                                           │    |
|   │              │ "Какой у тебя пульс?"                     │    |
|   │              │ "Расскажи о своих сервисах"               │    |
|   │              ▼                                           │    |
|   │   💓 ДАТЧИК ПУЛЬСА = GATT SERVER (Peripheral)           │    |
|   │   ┌───────────────────────────────────────────┐         │    |
|   │   │ • Рекламирует себя (Advertising)          │         │    |
|   │   │ • Хранит данные (Characteristics)         │         │    |
|   │   │ • Отвечает на запросы                     │         │    |
|   │   │ • Уведомляет об изменениях                │         │    |
|   │   │ • "Меню услуг" = GATT Profile             │         │    |
|   │   └───────────────────────────────────────────┘         │    |
|   │                                                          │    |
|   └─────────────────────────────────────────────────────────┘    |
|                                                                    |
|   АНАЛОГИЯ:                                                       |
|   • Датчик = Ресторан (сервер) — имеет меню, обслуживает         |
|   • Телефон = Посетитель (клиент) — выбирает, заказывает         |
|                                                                    |
|   ПОЧЕМУ ТАК:                                                     |
|   Server = тот, кто ХРАНИТ данные и ПРЕДОСТАВЛЯЕТ услуги         |
|   Client = тот, кто ЗАПРАШИВАЕТ и ПОТРЕБЛЯЕТ услуги              |
|                                                                    |
+------------------------------------------------------------------+
```

---

### Модель 3: Дерево принятия решений по профилю

```
+------------------------------------------------------------------+
|           КАКОЙ BLUETOOTH ПРОФИЛЬ/СЕРВИС ИСПОЛЬЗОВАТЬ?           |
+------------------------------------------------------------------+
|                                                                    |
|   START: Что передаёте?                                           |
|      │                                                             |
|      ├─► Аудио (музыка, звонки)?                                 |
|      │      │                                                      |
|      │      ├─► Стерео музыка → A2DP (Classic)                   |
|      │      ├─► Телефонные звонки → HFP (Classic)                |
|      │      └─► Оба + низкая задержка → LE Audio (BLE 5.2+)      |
|      │                                                             |
|      ├─► Устройство ввода (клавиатура/мышь)?                     |
|      │      │                                                      |
|      │      └─► HID (Classic или BLE)                            |
|      │                                                             |
|      ├─► Данные с датчика?                                       |
|      │      │                                                      |
|      │      ├─► Пульс → Heart Rate Service (BLE)                 |
|      │      ├─► Температура → Health Thermometer (BLE)           |
|      │      ├─► Батарея → Battery Service (BLE)                  |
|      │      └─► Своё → Custom GATT Service (BLE)                 |
|      │                                                             |
|      ├─► Произвольные данные (как Serial Port)?                  |
|      │      │                                                      |
|      │      ├─► Много данных (Kbytes+) → SPP (Classic)           |
|      │      └─► Маленькие пакеты → Custom BLE или Nordic UART    |
|      │                                                             |
|      ├─► Маяк/локация?                                           |
|      │      │                                                      |
|      │      └─► iBeacon / Eddystone / AltBeacon (BLE Advertising)|
|      │                                                             |
|      └─► Mesh сеть (умное освещение)?                            |
|             │                                                      |
|             └─► Bluetooth Mesh (BLE)                              |
|                                                                    |
+------------------------------------------------------------------+
```

---

### Модель 4: Жизненный цикл BLE соединения

```
+------------------------------------------------------------------+
|              LIFECYCLE BLE СОЕДИНЕНИЯ (State Machine)            |
+------------------------------------------------------------------+
|                                                                    |
|   ┌──────────────────────────────────────────────────────────┐   |
|   │                                                           │   |
|   │   ┌─────────────┐                                        │   |
|   │   │   IDLE      │  Устройство "спит"                    │   |
|   │   │  (Standby)  │                                        │   |
|   │   └──────┬──────┘                                        │   |
|   │          │ startAdvertising()                            │   |
|   │          ▼                                               │   |
|   │   ┌─────────────┐                                        │   |
|   │   │ ADVERTISING │  "Я здесь!" каждые N ms               │   |
|   │   │  (Broadcast)│                                        │   |
|   │   └──────┬──────┘                                        │   |
|   │          │ Central connects                              │   |
|   │          ▼                                               │   |
|   │   ┌─────────────┐                                        │   |
|   │   │ CONNECTING  │  Handshake, параметры соединения      │   |
|   │   │             │                                        │   |
|   │   └──────┬──────┘                                        │   |
|   │          │ onConnectionStateChange(CONNECTED)            │   |
|   │          ▼                                               │   |
|   │   ┌─────────────┐                                        │   |
|   │   │ CONNECTED   │  Можно обмениваться данными           │   |
|   │   │             │                                        │   |
|   │   └──────┬──────┘                                        │   |
|   │          │ discoverServices()                            │   |
|   │          ▼                                               │   |
|   │   ┌─────────────┐                                        │   |
|   │   │ DISCOVERING │  Запрос списка Services               │   |
|   │   │  SERVICES   │                                        │   |
|   │   └──────┬──────┘                                        │   |
|   │          │ onServicesDiscovered()                        │   |
|   │          ▼                                               │   |
|   │   ┌─────────────┐                                        │   |
|   │   │   READY     │  Read/Write/Notify доступны           │   |
|   │   │  (Working)  │  ← ЗДЕСЬ РАБОТАЕМ                     │   |
|   │   └──────┬──────┘                                        │   |
|   │          │ disconnect() или потеря связи                 │   |
|   │          ▼                                               │   |
|   │   ┌─────────────┐                                        │   |
|   │   │DISCONNECTED │  Соединение разорвано                 │   |
|   │   │             │                                        │   |
|   │   └─────────────┘                                        │   |
|   │                                                           │   |
|   └──────────────────────────────────────────────────────────┘   |
|                                                                    |
|   ⚠️ ВАЖНО: Каждый переход = callback                            |
|   Нельзя "перепрыгивать" состояния!                               |
|                                                                    |
+------------------------------------------------------------------+
```

---

### Модель 5: Таблица совместимости версий

```
+------------------------------------------------------------------+
|        BLUETOOTH VERSIONS: ЧТО С ЧЕМ СОВМЕСТИМО                  |
+------------------------------------------------------------------+
|                                                                    |
|   ┌──────────────────────────────────────────────────────────┐   |
|   │                                                           │   |
|   │   Версия      Classic   BLE   Ключевые фичи              │   |
|   │   ─────────────────────────────────────────────────────  │   |
|   │   1.0-2.1     ✅        ❌    Базовый Bluetooth          │   |
|   │   3.0         ✅        ❌    High Speed (через Wi-Fi)   │   |
|   │   4.0         ✅        ✅    Появление BLE!             │   |
|   │   4.1         ✅        ✅    Улучшенный coexist с LTE   │   |
|   │   4.2         ✅        ✅    LE Data Packet Extension   │   |
|   │   5.0         ✅        ✅    2x скорость, 4x дальность  │   |
|   │   5.1         ✅        ✅    Direction Finding          │   |
|   │   5.2         ✅        ✅    LE Audio, LC3 codec        │   |
|   │   5.3         ✅        ✅    Enhanced ATT, субрейтинг   │   |
|   │   5.4         ✅        ✅    PAwR, Encrypted Advertising│   |
|   │                                                           │   |
|   └──────────────────────────────────────────────────────────┘   |
|                                                                    |
|   СОВМЕСТИМОСТЬ:                                                  |
|   ┌──────────────────────────────────────────────────────────┐   |
|   │                                                           │   |
|   │   Classic ↔ Classic: ✅ Совместимы (обратная совмест.)   │   |
|   │   BLE ↔ BLE: ✅ Совместимы (фичи версии min из двух)    │   |
|   │   Classic ↔ BLE: ❌ НЕ совместимы!                       │   |
|   │                                                           │   |
|   │   Dual Mode устройство:                                   │   |
|   │   • Может работать и как Classic, и как BLE              │   |
|   │   • Но не одновременно в одном соединении                │   |
|   │                                                           │   |
|   └──────────────────────────────────────────────────────────┘   |
|                                                                    |
|   ПРАКТИЧЕСКИЕ ВЫВОДЫ:                                            |
|   • Наушники 5.0 подключатся к телефону 4.0 (по Classic)         |
|   • Фитнес-браслет BLE 4.0 заработает с телефоном 5.4           |
|   • Но: новые фичи (LE Audio) требуют 5.2+ на ОБОИХ концах      |
|                                                                    |
+------------------------------------------------------------------+
```

---

## Аналогия: Bluetooth как рация в подъезде

Представьте многоквартирный дом, где жители общаются по рациям:

```
┌─────────────────────────────────────────────────────────────────────────┐
│              BLUETOOTH КАК РАЦИИ В ПОДЪЕЗДЕ                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  📻 BLUETOOTH CLASSIC = Обычная рация                                   │
│     Нажал кнопку — говоришь. Держишь канал занятым.                     │
│     Хорошо для долгих разговоров (аудио в наушниках).                   │
│     Батарея садится быстро, потому что рация всё время "слушает".       │
│                                                                          │
│  📟 BLE (Low Energy) = Рация с автоответчиком                           │
│     Большую часть времени ВЫКЛЮЧЕНА.                                    │
│     Раз в минуту: "Я тут!" (advertising) — и снова спит.                │
│     Если кто-то откликнулся — короткий разговор и опять спать.          │
│     Батарейка-таблетка служит ГОДАМИ!                                   │
│                                                                          │
│  🕸️ BLUETOOTH MESH = Сеть соседей-ретрансляторов                       │
│     Ваше сообщение передаётся от соседа к соседу.                       │
│     Квартира 1 → Квартира 2 → ... → Квартира 50.                        │
│     Даже если вы на 1-м этаже, дойдёт до 10-го!                         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘

КЛЮЧЕВОЙ ПРИНЦИП: ПРОФИЛИ = Типы разговоров

┌─────────────────────────────────────────────────────────────────────────┐
│                                                                          │
│  Bluetooth профили — это "языки" для разных целей:                      │
│                                                                          │
│  🎵 A2DP = "Язык музыки"                                                │
│     Высококачественная передача аудио для наушников                     │
│                                                                          │
│  📞 HFP = "Язык телефонных звонков"                                     │
│     Hands-free для автомобиля: можно говорить и слушать                 │
│                                                                          │
│  ⌨️ HID = "Язык устройств ввода"                                        │
│     Мышки, клавиатуры, геймпады — "нажал кнопку"                        │
│                                                                          │
│  💓 GATT = "Универсальный язык данных для BLE"                          │
│     Датчик пульса → "пульс 72"                                          │
│     Термометр → "температура 36.6"                                      │
│     Любые структурированные данные                                      │
│                                                                          │
│  Устройство должно "говорить на том же языке" (поддерживать профиль),   │
│  чтобы понять другое устройство.                                        │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## ПОЧЕМУ (15-20%)

### История и эволюция

Bluetooth - стандарт беспроводной связи ближнего радиуса действия, разработанный компанией Ericsson в 1994 году. Название происходит от датского короля Харальда I Синезубого (Harald Bluetooth), который объединил разрозненные датские племена в единое королевство - аналогично тому, как технология Bluetooth объединяет различные устройства.

**Ключевые вехи развития:**

- **1999** - Bluetooth 1.0: первая спецификация (скорость 721 kbps)
- **2004** - Bluetooth 2.0 + EDR: увеличение скорости до 3 Mbps
- **2009** - Bluetooth 3.0 + HS: теоретически до 24 Mbps через Wi-Fi
- **2010** - Bluetooth 4.0: появление BLE (Bluetooth Low Energy)
- **2014** - Bluetooth 4.2: улучшенная безопасность и IoT-функции
- **2016** - Bluetooth 5.0: увеличение дальности в 4 раза, скорости в 2 раза
- **2019** - Bluetooth 5.1: определение направления (direction finding)
- **2020** - Bluetooth 5.2: LE Audio и изохронные каналы
- **2021** - Bluetooth 5.3: улучшенное энергопотребление
- **2023** - Bluetooth 5.4: PAwR (Periodic Advertising with Responses), шифрование рекламных данных

### Какую проблему решает

**Основные проблемы:**

1. **Избавление от проводов** - замена кабелей для периферийных устройств (мышь, клавиатура, наушники)
2. **Низкое энергопотребление** - BLE позволяет устройствам работать годами от батарейки-таблетки
3. **Универсальность** - стандартизированный протокол, работающий на миллиардах устройств
4. **Персональная сеть** - создание PAN (Personal Area Network) без инфраструктуры
5. **Простота использования** - автоматическое сопряжение (pairing) и переподключение
6. **Масштабируемые сети** - Bluetooth Mesh для IoT-приложений с тысячами устройств

**Типичные сценарии:**

- Беспроводная аудио-передача (наушники, колонки, автомобильные системы)
- Периферийные устройства (клавиатуры, мыши, стилусы)
- Носимая электроника (фитнес-трекеры, смарт-часы)
- IoT-устройства (датчики температуры, умное освещение, замки)
- Медицинские устройства (тонометры, глюкометры, пульсометры)
- Промышленные приложения (мониторинг оборудования, логистика)
- Автомобильная индустрия (hands-free, диагностика, ключи)

### Альтернативы и сравнение

| Технология | Дальность | Скорость | Энергопотребление | Сценарии использования |
|------------|-----------|----------|-------------------|------------------------|
| **Bluetooth Classic** | 10-100m | 1-3 Mbps | Среднее | Аудио, hands-free, файлообмен |
| **Bluetooth LE** | 10-50m | 1-2 Mbps | Очень низкое | IoT, носимая электроника, маяки |
| **Bluetooth Mesh** | До 1 км (multi-hop) | 1 Mbps | Низкое | Умное освещение, автоматизация зданий |
| **Wi-Fi** | 50-100m | 54-1300+ Mbps | Высокое | Интернет, видео-стриминг, большие данные |
| **Zigbee** | 10-100m | 250 kbps | Очень низкое | IoT-сети, домашняя автоматизация |
| **NFC** | <10 см | 424 kbps | Очень низкое | Бесконтактные платежи, сопряжение |
| **LoRa** | До 15 км | 0.3-50 kbps | Очень низкое | Дальняя IoT-связь, сельское хозяйство |
| **Thread** | 10-30m | 250 kbps | Низкое | Умный дом (Matter/HomeKit) |

**Преимущества Bluetooth:**
- Универсальная поддержка в смартфонах, ноутбуках, автомобилях
- Зрелая экосистема с множеством профилей для различных применений
- Низкая стоимость чипов и модулей
- Простота разработки и сертификации
- Баланс между энергопотреблением, дальностью и скоростью

**Недостатки:**
- Ограниченная дальность по сравнению с Wi-Fi и LoRa
- Меньшая пропускная способность по сравнению с Wi-Fi
- Проблемы с interference в диапазоне 2.4 GHz
- Сложность отладки проблем с подключением
- Вопросы безопасности при некорректной реализации

---

## ЧТО (25-35%)

### Как работает Bluetooth

**Радио-характеристики:**
- Частотный диапазон: 2.400-2.4835 GHz (ISM band)
- Модуляция: GFSK (Gaussian Frequency Shift Keying)
- Мощность передачи: Class 1 (100 mW, ~100m), Class 2 (2.5 mW, ~10m), Class 3 (1 mW, ~1m)
- Адаптивная frequency hopping для снижения интерференции

### Bluetooth Classic vs BLE vs Mesh

#### Сравнительная таблица

| Параметр | Bluetooth Classic | Bluetooth LE (BLE) | Bluetooth Mesh |
|----------|-------------------|--------------------|--------------------|
| **Введение** | Bluetooth 1.0 (1999) | Bluetooth 4.0 (2010) | Bluetooth 5.0 (2017) |
| **Частоты** | 79 каналов по 1 MHz | 40 каналов по 2 MHz | 40 каналов по 2 MHz |
| **Скорость передачи** | 1-3 Mbps | 1-2 Mbps | 1 Mbps |
| **Задержка** | ~100 ms | ~6 ms | Зависит от hop count |
| **Дальность** | До 100m | До 50m | До 1 км (multi-hop) |
| **Энергопотребление** | 1 Wh (постоянное соединение) | 0.01-0.5 Wh (периодическое) | 0.01-0.3 Wh |
| **Топология** | Point-to-point, piconet (1:7) | Star (1:многие), broadcasting | Many-to-many mesh |
| **Время сопряжения** | ~6 секунд | <1 секунды | <1 секунды |
| **Батарея (CR2032)** | Несколько часов | Несколько лет | Несколько лет |
| **Основные профили** | A2DP, HFP, SPP, PBAP | GATT-based (HRS, BAS, etc.) | Mesh models |
| **Применение** | Аудио, hands-free, файлообмен | IoT, носимая электроника | Умное освещение, автоматизация |

#### Bluetooth Classic

**Архитектура:**
- **BR (Basic Rate)**: 1 Mbps
- **EDR (Enhanced Data Rate)**: 2-3 Mbps
- **AMP (Alternate MAC/PHY)**: использование Wi-Fi для высокоскоростной передачи

**Особенности:**
- Постоянное подключение с высокой пропускной способностью
- Идеален для аудио-стриминга (A2DP), телефонных звонков (HFP)
- Поддержка до 7 активных устройств в piconet (один master, несколько slaves)
- Frequency hopping: 1600 переключений в секунду для снижения интерференции

#### Bluetooth Low Energy (BLE)

**Архитектура:**
- Оптимизирован для коротких всплесков передачи данных
- Большую часть времени находится в спящем режиме
- Быстрое установление соединения (<3 мс)

**Режимы работы:**
1. **Advertising mode** - устройство периодически отправляет beacon-пакеты (можно без подключения)
2. **Connection mode** - установление GATT-соединения для обмена данными
3. **Scanning mode** - сканирование advertising-пакетов от других устройств

**Роли устройств:**
- **Peripheral** (GATT Server) - устройство, которое рекламирует себя (датчики, фитнес-трекеры)
- **Central** (GATT Client) - устройство, которое сканирует и подключается (смартфоны)
- **Broadcaster** - только отправляет advertising-пакеты (beacons)
- **Observer** - только сканирует advertising-пакеты

#### Bluetooth Mesh

**Архитектура:**
- Построен поверх BLE
- Decentralized managed flood mesh с pub/sub моделью
- Каждый узел может быть relay, proxy, friend, low power node

**Типы узлов:**
- **Relay nodes** - ретранслируют сообщения для расширения покрытия
- **Proxy nodes** - позволяют BLE-устройствам взаимодействовать с mesh-сетью
- **Friend nodes** - хранят сообщения для low power nodes
- **Low Power Nodes (LPN)** - энергоэффективные устройства, пробуждаются периодически

**Механизмы передачи сообщений:**
1. **Managed Flood** - надежная многопутевая передача с TTL (Time To Live)
2. **Directed Forwarding** (Bluetooth 5.4+) - оптимизированная маршрутизация для крупных сетей

**Безопасность:**
- Двухуровневое шифрование: Network Key (для всей сети) и Application Key (для приложений)
- AES-128 шифрование каждого сообщения
- Защита от replay-атак

**Применение:**
- Умное освещение в коммерческих зданиях (до 30,000 устройств)
- Системы автоматизации зданий (HVAC, датчики, сигнализация)
- Промышленный IoT (мониторинг оборудования, логистика)

### Bluetooth Profiles

Bluetooth профили - это спецификации, определяющие как устройства взаимодействуют для конкретных применений.

#### Основные Classic Bluetooth Profiles

| Профиль | Название | Назначение | Примеры использования |
|---------|----------|------------|----------------------|
| **A2DP** | Advanced Audio Distribution Profile | Передача стерео-аудио высокого качества | Беспроводные наушники, колонки |
| **HFP** | Hands-Free Profile | Hands-free телефония в автомобилях | Автомобильные системы, гарнитуры |
| **HSP** | Headset Profile | Моно-аудио для гарнитур | Простые Bluetooth-гарнитуры |
| **AVRCP** | Audio/Video Remote Control Profile | Дистанционное управление медиа | Управление воспроизведением на наушниках |
| **SPP** | Serial Port Profile | Эмуляция последовательного порта | Arduino, GPS, промышленные устройства |
| **HID** | Human Interface Device Profile | Устройства ввода | Клавиатуры, мыши, геймпады |
| **PBAP** | Phone Book Access Profile | Доступ к контактам телефона | Автомобильные системы |
| **MAP** | Message Access Profile | Доступ к SMS/Email | Автомобильные системы |
| **OPP** | Object Push Profile | Передача файлов | Обмен файлами между телефонами |

**A2DP кодеки:**
- **SBC** (SubBand Codec) - базовый кодек, обязательный для всех устройств
- **AAC** (Advanced Audio Coding) - более качественный кодек, популярен в Apple-устройствах
- **aptX** / **aptX HD** - проприетарные кодеки Qualcomm с низкой задержкой
- **LDAC** - Sony кодек с высоким битрейтом (до 990 kbps)
- **LC3** (Bluetooth 5.2+) - новый кодек для LE Audio

**HFP возможности:**
- Прием/отклонение вызовов
- Voice recognition (голосовые команды)
- Call waiting (ожидание вызова)
- Three-way calling (конференц-связь)
- Wide Band Speech (mSBC codec) - улучшенное качество речи
- LC3-SWB codec (HFP 1.9+)

#### BLE GATT Profiles

GATT (Generic Attribute Profile) - основа для всех BLE-профилей.

**Структура GATT:**
```
Service (UUID)
├── Characteristic 1 (UUID)
│   ├── Value (данные)
│   ├── Descriptor 1 (метаданные)
│   └── Descriptor 2
├── Characteristic 2
└── Characteristic 3
```

**Популярные GATT Services:**

| Service | UUID | Назначение | Characteristics |
|---------|------|------------|-----------------|
| **HRS** | 0x180D | Heart Rate Service | Heart Rate Measurement, Body Sensor Location |
| **BAS** | 0x180F | Battery Service | Battery Level (0-100%) |
| **DIS** | 0x180A | Device Information Service | Manufacturer Name, Model Number, Serial Number |
| **HTS** | 0x1809 | Health Thermometer | Temperature Measurement, Temperature Type |
| **BLS** | 0x1810 | Blood Pressure Service | Blood Pressure Measurement |
| **GLS** | 0x1808 | Glucose Service | Glucose Measurement |
| **CSC** | 0x1816 | Cycling Speed and Cadence | CSC Measurement, CSC Feature |
| **FMP** | 0x1802 | Find Me Profile | Alert Level (для поиска устройств) |

**GATT операции:**
- **Read** - чтение значения characteristic
- **Write** - запись значения (с подтверждением)
- **Write Without Response** - запись без подтверждения (быстрее)
- **Notify** - уведомления об изменениях (без подтверждения)
- **Indicate** - уведомления с подтверждением получения

### Стек протоколов Bluetooth

```
┌─────────────────────────────────────────────────────────┐
│              Application Layer                           │
│  (Bluetooth Profiles: A2DP, HFP, GATT Services, etc.)   │
├─────────────────────────────────────────────────────────┤
│              Host Layer                                  │
│                                                           │
│  ┌──────────────────────────────────────────────┐       │
│  │  GAP (Generic Access Profile)                 │       │
│  │  - Device discovery, connection management    │       │
│  └──────────────────────────────────────────────┘       │
│                                                           │
│  ┌──────────────────────────────────────────────┐       │
│  │  GATT (Generic Attribute Profile) - BLE only │       │
│  │  - Data exchange structure                    │       │
│  └──────────────────────────────────────────────┘       │
│                                                           │
│  ┌──────────────────────────────────────────────┐       │
│  │  ATT (Attribute Protocol) - BLE only         │       │
│  │  - Client/Server data transfer                │       │
│  └──────────────────────────────────────────────┘       │
│                                                           │
│  ┌──────────────────────────────────────────────┐       │
│  │  SMP (Security Manager Protocol)             │       │
│  │  - Pairing, encryption, key generation        │       │
│  └──────────────────────────────────────────────┘       │
│                                                           │
│  ┌──────────────────────────────────────────────┐       │
│  │  L2CAP (Logical Link Control & Adaptation)   │       │
│  │  - Protocol multiplexing, segmentation        │       │
│  └──────────────────────────────────────────────┘       │
│                                                           │
│  ┌──────────────────────────────────────────────┐       │
│  │  HCI (Host Controller Interface)             │       │
│  │  - Interface between host and controller     │       │
│  └──────────────────────────────────────────────┘       │
├─────────────────────────────────────────────────────────┤
│              Controller Layer                            │
│                                                           │
│  ┌──────────────────────────────────────────────┐       │
│  │  Link Manager Protocol (LMP/LL)              │       │
│  │  - Link setup, authentication, encryption     │       │
│  └──────────────────────────────────────────────┘       │
│                                                           │
│  ┌──────────────────────────────────────────────┐       │
│  │  Baseband / Link Controller                  │       │
│  │  - Physical channel management                │       │
│  └──────────────────────────────────────────────┘       │
│                                                           │
│  ┌──────────────────────────────────────────────┐       │
│  │  Radio / Physical Layer                       │       │
│  │  - RF transmission (2.4 GHz ISM band)         │       │
│  └──────────────────────────────────────────────┘       │
└─────────────────────────────────────────────────────────┘
```

**Ключевые компоненты:**

- **GAP (Generic Access Profile)** - управление обнаружением устройств, подключением, рекламой
- **GATT (Generic Attribute Profile)** - структура для обмена данными в BLE
- **ATT (Attribute Protocol)** - протокол для доступа к данным (client/server модель)
- **SMP (Security Manager Protocol)** - управление сопряжением и шифрованием
- **L2CAP** - сегментация и reassembly пакетов, QoS
- **HCI (Host Controller Interface)** - стандартный интерфейс между host и controller (UART, USB, SDIO)
- **Link Manager/Link Layer** - управление соединениями, шифрованием, frequency hopping
- **Baseband** - управление физическими каналами, синхронизация, коррекция ошибок
- **RF Layer** - физическая передача данных в эфире

### Новые возможности Bluetooth 5.4 (2023)

**1. Periodic Advertising with Responses (PAwR)**
- Двунаправленная connectionless-коммуникация
- Поддержка тысяч устройств в star-топологии
- Детерминированные временные слоты для ответов
- Идеально для Electronic Shelf Labels (ESL)

**2. Encrypted Advertising Data (EAD)**
- Шифрование advertising-пакетов с AES-128
- Только устройства с shared session key могут расшифровать данные
- Улучшенная конфиденциальность в публичных пространствах

**3. LE GATT Security Levels Characteristic (SLC)**
- Позволяет узнать требования безопасности до попытки доступа к GATT
- Предотвращает прерывания из-за недостаточного уровня безопасности
- Улучшенный UX при работе с защищенными характеристиками

**4. Advertising Coding Selection**
- Контроль error correction через S-параметры
- Увеличение дальности за счет снижения скорости (125 kbps до 240 метров)

---

## КАК (35-45%)

### Android Bluetooth API - Kotlin примеры

#### Проверка поддержки и разрешений

**Манифест (AndroidManifest.xml):**
```xml
<manifest>
    <!-- Bluetooth permissions -->
    <uses-permission android:name="android.permission.BLUETOOTH"
                     android:maxSdkVersion="30" />
    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN"
                     android:maxSdkVersion="30" />

    <!-- Android 12+ (API 31+) permissions -->
    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
    <uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
    <uses-permission android:name="android.permission.BLUETOOTH_ADVERTISE" />

    <!-- Location required for BLE scanning on Android 10+ -->
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />

    <!-- Feature declarations -->
    <uses-feature android:name="android.hardware.bluetooth" android:required="true" />
    <uses-feature android:name="android.hardware.bluetooth_le" android:required="true" />
</manifest>
```

**Запрос runtime permissions (Android 12+):**
```kotlin
class BluetoothActivity : AppCompatActivity() {

    private val bluetoothPermissions = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
        arrayOf(
            Manifest.permission.BLUETOOTH_SCAN,
            Manifest.permission.BLUETOOTH_CONNECT,
            Manifest.permission.BLUETOOTH_ADVERTISE
        )
    } else {
        arrayOf(
            Manifest.permission.BLUETOOTH,
            Manifest.permission.BLUETOOTH_ADMIN,
            Manifest.permission.ACCESS_FINE_LOCATION
        )
    }

    private val requestPermissionLauncher = registerForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) { permissions ->
        val allGranted = permissions.entries.all { it.value }
        if (allGranted) {
            initializeBluetooth()
        } else {
            Toast.makeText(this, "Bluetooth permissions required", Toast.LENGTH_LONG).show()
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        requestPermissionLauncher.launch(bluetoothPermissions)
    }

    private fun initializeBluetooth() {
        val bluetoothManager = getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager
        val bluetoothAdapter = bluetoothManager.adapter

        if (bluetoothAdapter == null) {
            Toast.makeText(this, "Bluetooth not supported", Toast.LENGTH_LONG).show()
            return
        }

        if (!bluetoothAdapter.isEnabled) {
            val enableBtIntent = Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE)
            startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT)
        }
    }

    companion object {
        const val REQUEST_ENABLE_BT = 1
    }
}
```

#### Bluetooth Classic - Device Discovery и Pairing

**Device Discovery:**
```kotlin
class BluetoothClassicManager(private val context: Context) {

    private val bluetoothAdapter: BluetoothAdapter? = BluetoothAdapter.getDefaultAdapter()
    private val discoveredDevices = mutableListOf<BluetoothDevice>()

    private val discoveryReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            when (intent.action) {
                BluetoothDevice.ACTION_FOUND -> {
                    val device: BluetoothDevice? =
                        intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)
                    device?.let {
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
                            ActivityCompat.checkSelfPermission(
                                context,
                                Manifest.permission.BLUETOOTH_CONNECT
                            ) != PackageManager.PERMISSION_GRANTED
                        ) {
                            return
                        }

                        discoveredDevices.add(it)
                        Log.d("BT", "Found device: ${it.name} - ${it.address}")
                    }
                }
                BluetoothAdapter.ACTION_DISCOVERY_STARTED -> {
                    Log.d("BT", "Discovery started")
                    discoveredDevices.clear()
                }
                BluetoothAdapter.ACTION_DISCOVERY_FINISHED -> {
                    Log.d("BT", "Discovery finished. Found ${discoveredDevices.size} devices")
                }
            }
        }
    }

    fun startDiscovery() {
        val filter = IntentFilter().apply {
            addAction(BluetoothDevice.ACTION_FOUND)
            addAction(BluetoothAdapter.ACTION_DISCOVERY_STARTED)
            addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)
        }
        context.registerReceiver(discoveryReceiver, filter)

        if (bluetoothAdapter?.isDiscovering == true) {
            bluetoothAdapter.cancelDiscovery()
        }

        bluetoothAdapter?.startDiscovery()
    }

    fun stopDiscovery() {
        bluetoothAdapter?.cancelDiscovery()
        try {
            context.unregisterReceiver(discoveryReceiver)
        } catch (e: IllegalArgumentException) {
            // Receiver not registered
        }
    }

    fun getPairedDevices(): Set<BluetoothDevice> {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
            ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.BLUETOOTH_CONNECT
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return emptySet()
        }
        return bluetoothAdapter?.bondedDevices ?: emptySet()
    }
}
```

**Pairing (Bonding):**
```kotlin
class BluetoothPairingManager(private val context: Context) {

    private val pairingReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            when (intent.action) {
                BluetoothDevice.ACTION_BOND_STATE_CHANGED -> {
                    val device: BluetoothDevice? =
                        intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)
                    val bondState = intent.getIntExtra(
                        BluetoothDevice.EXTRA_BOND_STATE,
                        BluetoothDevice.BOND_NONE
                    )
                    val previousBondState = intent.getIntExtra(
                        BluetoothDevice.EXTRA_PREVIOUS_BOND_STATE,
                        BluetoothDevice.BOND_NONE
                    )

                    when (bondState) {
                        BluetoothDevice.BOND_BONDING -> {
                            Log.d("BT", "Bonding started with ${device?.address}")
                        }
                        BluetoothDevice.BOND_BONDED -> {
                            Log.d("BT", "Bonding successful with ${device?.address}")
                        }
                        BluetoothDevice.BOND_NONE -> {
                            if (previousBondState == BluetoothDevice.BOND_BONDING) {
                                Log.e("BT", "Bonding failed with ${device?.address}")
                            }
                        }
                    }
                }
                BluetoothDevice.ACTION_PAIRING_REQUEST -> {
                    val device: BluetoothDevice? =
                        intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)
                    val pairingVariant = intent.getIntExtra(
                        BluetoothDevice.EXTRA_PAIRING_VARIANT,
                        BluetoothDevice.ERROR
                    )

                    when (pairingVariant) {
                        BluetoothDevice.PAIRING_VARIANT_PIN -> {
                            Log.d("BT", "PIN required for ${device?.address}")
                        }
                        BluetoothDevice.PAIRING_VARIANT_PASSKEY_CONFIRMATION -> {
                            val passkey = intent.getIntExtra(
                                BluetoothDevice.EXTRA_PAIRING_KEY,
                                BluetoothDevice.ERROR
                            )
                            Log.d("BT", "Confirm passkey: $passkey")
                        }
                        BluetoothDevice.PAIRING_VARIANT_CONSENT -> {
                            Log.d("BT", "Confirm pairing with ${device?.address}")
                        }
                    }
                }
            }
        }
    }

    fun registerPairingReceiver() {
        val filter = IntentFilter().apply {
            addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED)
            addAction(BluetoothDevice.ACTION_PAIRING_REQUEST)
        }
        context.registerReceiver(pairingReceiver, filter)
    }

    fun unregisterPairingReceiver() {
        try {
            context.unregisterReceiver(pairingReceiver)
        } catch (e: IllegalArgumentException) {
            // Receiver not registered
        }
    }

    fun pairDevice(device: BluetoothDevice): Boolean {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
            ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.BLUETOOTH_CONNECT
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return false
        }

        return when (device.bondState) {
            BluetoothDevice.BOND_NONE -> {
                device.createBond()
            }
            BluetoothDevice.BOND_BONDED -> {
                Log.d("BT", "Device already paired")
                true
            }
            BluetoothDevice.BOND_BONDING -> {
                Log.d("BT", "Bonding in progress")
                false
            }
            else -> false
        }
    }

    fun unpairDevice(device: BluetoothDevice): Boolean {
        if (device.bondState != BluetoothDevice.BOND_BONDED) {
            return false
        }

        return try {
            val method = device.javaClass.getMethod("removeBond")
            method.invoke(device) as Boolean
        } catch (e: Exception) {
            Log.e("BT", "Unpair failed", e)
            false
        }
    }
}
```

**RFCOMM Socket Connection (SPP):**
```kotlin
class BluetoothSocketManager(private val device: BluetoothDevice) {

    private var socket: BluetoothSocket? = null
    private var inputStream: InputStream? = null
    private var outputStream: OutputStream? = null
    private var receiveThread: Thread? = null

    companion object {
        private val SPP_UUID = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB")
    }

    fun connect(context: Context): Boolean {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
            ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.BLUETOOTH_CONNECT
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return false
        }

        return try {
            socket = device.createRfcommSocketToServiceRecord(SPP_UUID)
            BluetoothAdapter.getDefaultAdapter()?.cancelDiscovery()
            socket?.connect()
            inputStream = socket?.inputStream
            outputStream = socket?.outputStream
            startReceiveThread()
            Log.d("BT", "Connected to ${device.name}")
            true
        } catch (e: IOException) {
            Log.e("BT", "Connection failed", e)
            close()
            false
        }
    }

    fun sendData(data: ByteArray): Boolean {
        return try {
            outputStream?.write(data)
            outputStream?.flush()
            true
        } catch (e: IOException) {
            Log.e("BT", "Send failed", e)
            false
        }
    }

    private fun startReceiveThread() {
        receiveThread = Thread {
            val buffer = ByteArray(1024)
            while (true) {
                try {
                    val bytesRead = inputStream?.read(buffer) ?: -1
                    if (bytesRead > 0) {
                        val data = buffer.copyOfRange(0, bytesRead)
                        onDataReceived(data)
                    }
                } catch (e: IOException) {
                    Log.e("BT", "Receive failed", e)
                    break
                }
            }
        }.apply { start() }
    }

    private fun onDataReceived(data: ByteArray) {
        Log.d("BT", "Received: ${data.size} bytes")
    }

    fun close() {
        try {
            receiveThread?.interrupt()
            inputStream?.close()
            outputStream?.close()
            socket?.close()
        } catch (e: IOException) {
            Log.e("BT", "Close failed", e)
        }
    }
}
```

#### Bluetooth Low Energy (BLE) - Scanning и GATT

**BLE Scanning:**
```kotlin
class BleScanner(private val context: Context) {

    private val bluetoothAdapter: BluetoothAdapter? = BluetoothAdapter.getDefaultAdapter()
    private val bleScanner: BluetoothLeScanner? = bluetoothAdapter?.bluetoothLeScanner
    private val scanResults = mutableMapOf<String, BluetoothDevice>()
    private var isScanning = false

    private val scanCallback = object : ScanCallback() {
        override fun onScanResult(callbackType: Int, result: ScanResult) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
                ActivityCompat.checkSelfPermission(
                    context,
                    Manifest.permission.BLUETOOTH_CONNECT
                ) != PackageManager.PERMISSION_GRANTED
            ) {
                return
            }

            val device = result.device
            scanResults[device.address] = device

            val scanRecord = result.scanRecord
            val deviceName = scanRecord?.deviceName ?: device.name ?: "Unknown"
            val rssi = result.rssi
            val txPower = scanRecord?.txPowerLevel ?: 0

            Log.d("BLE", "Found: $deviceName (${device.address}) RSSI: $rssi dBm")

            scanRecord?.serviceUuids?.forEach { uuid ->
                Log.d("BLE", "  Service: $uuid")
            }
        }

        override fun onBatchScanResults(results: MutableList<ScanResult>) {
            results.forEach { onScanResult(ScanSettings.CALLBACK_TYPE_ALL_MATCHES, it) }
        }

        override fun onScanFailed(errorCode: Int) {
            val error = when (errorCode) {
                SCAN_FAILED_ALREADY_STARTED -> "Already started"
                SCAN_FAILED_APPLICATION_REGISTRATION_FAILED -> "App registration failed"
                SCAN_FAILED_FEATURE_UNSUPPORTED -> "Feature unsupported"
                SCAN_FAILED_INTERNAL_ERROR -> "Internal error"
                else -> "Unknown error: $errorCode"
            }
            Log.e("BLE", "Scan failed: $error")
        }
    }

    fun startScan(serviceUuid: UUID? = null) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
            ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.BLUETOOTH_SCAN
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return
        }

        if (isScanning) {
            Log.w("BLE", "Already scanning")
            return
        }

        val filters = mutableListOf<ScanFilter>()
        serviceUuid?.let {
            filters.add(
                ScanFilter.Builder()
                    .setServiceUuid(ParcelUuid(it))
                    .build()
            )
        }

        val settings = ScanSettings.Builder()
            .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)
            .setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES)
            .setMatchMode(ScanSettings.MATCH_MODE_AGGRESSIVE)
            .setNumOfMatches(ScanSettings.MATCH_NUM_MAX_ADVERTISEMENT)
            .setReportDelay(0)
            .build()

        scanResults.clear()
        bleScanner?.startScan(filters, settings, scanCallback)
        isScanning = true

        Log.d("BLE", "Scan started")
    }

    fun stopScan() {
        if (!isScanning) return

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
            ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.BLUETOOTH_SCAN
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return
        }

        bleScanner?.stopScan(scanCallback)
        isScanning = false

        Log.d("BLE", "Scan stopped. Found ${scanResults.size} devices")
    }

    fun getScanResults(): List<BluetoothDevice> = scanResults.values.toList()
}
```

**GATT Connection и Data Exchange:**
```kotlin
class BleGattManager(
    private val context: Context,
    private val device: BluetoothDevice
) {

    private var bluetoothGatt: BluetoothGatt? = null
    private var connectionState = STATE_DISCONNECTED

    companion object {
        const val STATE_DISCONNECTED = 0
        const val STATE_CONNECTING = 1
        const val STATE_CONNECTED = 2

        val HEART_RATE_SERVICE_UUID = UUID.fromString("0000180D-0000-1000-8000-00805F9B34FB")
        val HEART_RATE_MEASUREMENT_UUID = UUID.fromString("00002A37-0000-1000-8000-00805F9B34FB")
        val CCCD_UUID = UUID.fromString("00002902-0000-1000-8000-00805F9B34FB")
    }

    private val gattCallback = object : BluetoothGattCallback() {

        override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
                ActivityCompat.checkSelfPermission(
                    context,
                    Manifest.permission.BLUETOOTH_CONNECT
                ) != PackageManager.PERMISSION_GRANTED
            ) {
                return
            }

            when (newState) {
                BluetoothProfile.STATE_CONNECTED -> {
                    connectionState = STATE_CONNECTED
                    Log.d("BLE", "Connected to GATT server")
                    gatt.discoverServices()
                }
                BluetoothProfile.STATE_DISCONNECTED -> {
                    connectionState = STATE_DISCONNECTED
                    Log.d("BLE", "Disconnected from GATT server")
                }
            }
        }

        override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {
            if (status == BluetoothGatt.GATT_SUCCESS) {
                Log.d("BLE", "Services discovered")

                gatt.services.forEach { service ->
                    Log.d("BLE", "Service: ${service.uuid}")
                    service.characteristics.forEach { characteristic ->
                        Log.d("BLE", "  Characteristic: ${characteristic.uuid}")
                        Log.d("BLE", "    Properties: ${characteristicPropertiesToString(characteristic)}")
                    }
                }

                enableHeartRateNotifications(gatt)
            } else {
                Log.e("BLE", "Service discovery failed: $status")
            }
        }

        override fun onCharacteristicRead(
            gatt: BluetoothGatt,
            characteristic: BluetoothGattCharacteristic,
            status: Int
        ) {
            if (status == BluetoothGatt.GATT_SUCCESS) {
                val value = characteristic.value
                Log.d("BLE", "Characteristic read: ${characteristic.uuid}")
                Log.d("BLE", "  Value: ${value.contentToString()}")
            }
        }

        override fun onCharacteristicWrite(
            gatt: BluetoothGatt,
            characteristic: BluetoothGattCharacteristic,
            status: Int
        ) {
            if (status == BluetoothGatt.GATT_SUCCESS) {
                Log.d("BLE", "Characteristic written: ${characteristic.uuid}")
            } else {
                Log.e("BLE", "Characteristic write failed: $status")
            }
        }

        override fun onCharacteristicChanged(
            gatt: BluetoothGatt,
            characteristic: BluetoothGattCharacteristic
        ) {
            when (characteristic.uuid) {
                HEART_RATE_MEASUREMENT_UUID -> {
                    val heartRate = parseHeartRate(characteristic.value)
                    Log.d("BLE", "Heart Rate: $heartRate bpm")
                }
            }
        }

        override fun onDescriptorWrite(
            gatt: BluetoothGatt,
            descriptor: BluetoothGattDescriptor,
            status: Int
        ) {
            if (status == BluetoothGatt.GATT_SUCCESS) {
                Log.d("BLE", "Descriptor written: ${descriptor.uuid}")
            }
        }
    }

    fun connect(): Boolean {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
            ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.BLUETOOTH_CONNECT
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return false
        }

        bluetoothGatt = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            device.connectGatt(
                context,
                false,
                gattCallback,
                BluetoothDevice.TRANSPORT_LE
            )
        } else {
            device.connectGatt(context, false, gattCallback)
        }

        connectionState = STATE_CONNECTING
        return true
    }

    fun disconnect() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
            ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.BLUETOOTH_CONNECT
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return
        }

        bluetoothGatt?.disconnect()
    }

    fun close() {
        bluetoothGatt?.close()
        bluetoothGatt = null
    }

    fun readCharacteristic(serviceUuid: UUID, characteristicUuid: UUID): Boolean {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
            ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.BLUETOOTH_CONNECT
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return false
        }

        val characteristic = bluetoothGatt
            ?.getService(serviceUuid)
            ?.getCharacteristic(characteristicUuid)
            ?: return false

        return bluetoothGatt?.readCharacteristic(characteristic) ?: false
    }

    fun writeCharacteristic(
        serviceUuid: UUID,
        characteristicUuid: UUID,
        value: ByteArray
    ): Boolean {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
            ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.BLUETOOTH_CONNECT
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return false
        }

        val characteristic = bluetoothGatt
            ?.getService(serviceUuid)
            ?.getCharacteristic(characteristicUuid)
            ?: return false

        characteristic.value = value
        return bluetoothGatt?.writeCharacteristic(characteristic) ?: false
    }

    private fun enableHeartRateNotifications(gatt: BluetoothGatt) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
            ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.BLUETOOTH_CONNECT
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return
        }

        val service = gatt.getService(HEART_RATE_SERVICE_UUID) ?: return
        val characteristic = service.getCharacteristic(HEART_RATE_MEASUREMENT_UUID) ?: return

        gatt.setCharacteristicNotification(characteristic, true)

        val descriptor = characteristic.getDescriptor(CCCD_UUID)
        descriptor?.value = BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE
        gatt.writeDescriptor(descriptor)
    }

    private fun parseHeartRate(value: ByteArray): Int {
        val flag = value[0].toInt()
        val format = flag and 0x01
        return if (format == 0) {
            value[1].toInt() and 0xFF
        } else {
            (value[1].toInt() and 0xFF) or ((value[2].toInt() and 0xFF) shl 8)
        }
    }

    private fun characteristicPropertiesToString(characteristic: BluetoothGattCharacteristic): String {
        val properties = mutableListOf<String>()
        val prop = characteristic.properties

        if (prop and BluetoothGattCharacteristic.PROPERTY_READ != 0) properties.add("READ")
        if (prop and BluetoothGattCharacteristic.PROPERTY_WRITE != 0) properties.add("WRITE")
        if (prop and BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE != 0) properties.add("WRITE_NO_RESPONSE")
        if (prop and BluetoothGattCharacteristic.PROPERTY_NOTIFY != 0) properties.add("NOTIFY")
        if (prop and BluetoothGattCharacteristic.PROPERTY_INDICATE != 0) properties.add("INDICATE")

        return properties.joinToString(", ")
    }
}
```

### Практические примеры использования

#### 1. Беспроводные наушники (A2DP + AVRCP)

```kotlin
fun isA2dpSupported(device: BluetoothDevice, context: Context): Boolean {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
        ActivityCompat.checkSelfPermission(
            context,
            Manifest.permission.BLUETOOTH_CONNECT
        ) != PackageManager.PERMISSION_GRANTED
    ) {
        return false
    }

    val uuids = device.uuids
    val a2dpUuid = ParcelUuid.fromString("0000110D-0000-1000-8000-00805F9B34FB")
    return uuids?.contains(a2dpUuid) == true
}

fun controlMediaPlayback(context: Context) {
    val audioManager = context.getSystemService(Context.AUDIO_SERVICE) as AudioManager
    val keyEvent = KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE)
    audioManager.dispatchMediaKeyEvent(keyEvent)
}
```

#### 2. Фитнес-трекер (BLE Heart Rate Monitor)

```kotlin
class HeartRateMonitor(context: Context, device: BluetoothDevice) {
    private val gattManager = BleGattManager(context, device)

    fun start() {
        gattManager.connect()
    }

    fun stop() {
        gattManager.disconnect()
        gattManager.close()
    }
}
```

#### 3. Arduino Serial Communication (SPP)

```kotlin
class ArduinoController(private val device: BluetoothDevice) {
    private val socketManager = BluetoothSocketManager(device)

    fun connect(context: Context) {
        socketManager.connect(context)
    }

    fun sendCommand(command: String) {
        val data = "$command\n".toByteArray(Charsets.UTF_8)
        socketManager.sendData(data)
    }

    fun turnOnLED() {
        sendCommand("LED_ON")
    }

    fun turnOffLED() {
        sendCommand("LED_OFF")
    }

    fun disconnect() {
        socketManager.close()
    }
}
```

---

## ПОДВОДНЫЕ КАМНИ (10-15%)

### 1. Проблемы с Interference (интерференция)

**Проблема:**
Bluetooth работает в диапазоне 2.4 GHz ISM band, который также используется Wi-Fi (каналы 1-11), микроволновыми печами, беспроводными телефонами, и другими устройствами.

**Симптомы:**
- Прерывистое аудио в наушниках
- Низкая скорость передачи данных
- Частые разрывы соединения
- Увеличенная задержка

**Решения:**
```kotlin
fun monitorConnectionQuality(gatt: BluetoothGatt, context: Context) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
        ActivityCompat.checkSelfPermission(
            context,
            Manifest.permission.BLUETOOTH_CONNECT
        ) != PackageManager.PERMISSION_GRANTED
    ) {
        return
    }

    val handler = Handler(Looper.getMainLooper())
    val runnable = object : Runnable {
        override fun run() {
            gatt.readRemoteRssi()
            handler.postDelayed(this, 1000)
        }
    }
    handler.post(runnable)
}

// In gattCallback:
override fun onReadRemoteRssi(gatt: BluetoothGatt, rssi: Int, status: Int) {
    if (status == BluetoothGatt.GATT_SUCCESS) {
        when {
            rssi > -60 -> Log.d("BLE", "Excellent signal: $rssi dBm")
            rssi > -70 -> Log.d("BLE", "Good signal: $rssi dBm")
            rssi > -80 -> Log.d("BLE", "Fair signal: $rssi dBm")
            else -> Log.w("BLE", "Poor signal: $rssi dBm")
        }
    }
}
```

**Best practices:**
- Держите устройства на расстоянии не более 5-10 метров
- Избегайте физических препятствий (стены, металлические поверности)
- Используйте Bluetooth 5.0+ для улучшенной coexistence с Wi-Fi
- Для критичных приложений рассмотрите 5 GHz Wi-Fi или проводные соединения

### 2. Проблемы с Pairing (сопряжение)

**Pairing Failures:**
```kotlin
class RobustPairingManager(private val context: Context) {

    fun pairWithRetry(device: BluetoothDevice, maxRetries: Int = 3): Boolean {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
            ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.BLUETOOTH_CONNECT
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return false
        }

        var attempts = 0
        while (attempts < maxRetries) {
            attempts++
            Log.d("BT", "Pairing attempt $attempts of $maxRetries")

            when (device.bondState) {
                BluetoothDevice.BOND_BONDED -> {
                    Log.d("BT", "Already paired")
                    return true
                }
                BluetoothDevice.BOND_BONDING -> {
                    Thread.sleep(2000)
                    continue
                }
                BluetoothDevice.BOND_NONE -> {
                    if (device.createBond()) {
                        Thread.sleep(5000)
                    } else {
                        Log.e("BT", "createBond() returned false")
                    }
                }
            }
        }

        return device.bondState == BluetoothDevice.BOND_BONDED
    }

    fun clearPairingCache(device: BluetoothDevice) {
        try {
            val method = device.javaClass.getMethod("removeBond")
            method.invoke(device)
            Thread.sleep(1000)
        } catch (e: Exception) {
            Log.e("BT", "Failed to clear pairing cache", e)
        }
    }
}
```

### 3. Security Vulnerabilities (уязвимости безопасности)

**Актуальные уязвимости 2025:**

#### A. PerfektBlue (CVE-2024-45431 to -45434)
- Затрагивает автомобильные системы с OpenSynergy BlueSDK
- Remote Code Execution через Bluetooth-сопряжение
- Требуется физическая близость (5-7 метров)
- Эксплуатация возможна только в режиме pairing

**Защита:**
```kotlin
fun disableBluetoothWhenNotInUse(context: Context) {
    val bluetoothAdapter = BluetoothAdapter.getDefaultAdapter()

    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
        ActivityCompat.checkSelfPermission(
            context,
            Manifest.permission.BLUETOOTH_CONNECT
        ) != PackageManager.PERMISSION_GRANTED
    ) {
        return
    }

    if (bluetoothAdapter?.isEnabled == true) {
        bluetoothAdapter.disable()
    }
}

fun setDiscoverableTemporarily(activity: Activity, durationSeconds: Int = 120) {
    val discoverableIntent = Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE).apply {
        putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, durationSeconds)
    }
    activity.startActivityForResult(discoverableIntent, REQUEST_DISCOVERABLE)
}
```

#### B. Airoha Bluetooth Vulnerabilities (CVE-2025-20700/701/702)
- Полный захват наушников без аутентификации
- Не требуется pairing
- Уязвимы популярные наушники и микрофоны

**Best practices:**
- Всегда используйте encryption для чувствительных данных
- Реализуйте mutual authentication
- Используйте application-level encryption поверх Bluetooth encryption
- Регулярно обновляйте Bluetooth stack ОС
- Для IoT-устройств используйте certificate-based authentication

### 4. Android-специфичные проблемы

**Permissions на Android 12+:**
```kotlin
class BluetoothPermissionManager(private val activity: AppCompatActivity) {

    private val permissionLauncher = activity.registerForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) { permissions ->
        val bluetoothScan = permissions[Manifest.permission.BLUETOOTH_SCAN] ?: false
        val bluetoothConnect = permissions[Manifest.permission.BLUETOOTH_CONNECT] ?: false
        val location = permissions[Manifest.permission.ACCESS_FINE_LOCATION] ?: false

        when {
            bluetoothScan && bluetoothConnect -> {
                onPermissionsGranted()
            }
            !bluetoothScan || !bluetoothConnect -> {
                showPermissionRationale()
            }
        }
    }

    fun requestPermissions() {
        val permissions = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            arrayOf(
                Manifest.permission.BLUETOOTH_SCAN,
                Manifest.permission.BLUETOOTH_CONNECT,
                Manifest.permission.ACCESS_FINE_LOCATION
            )
        } else {
            arrayOf(
                Manifest.permission.BLUETOOTH,
                Manifest.permission.BLUETOOTH_ADMIN,
                Manifest.permission.ACCESS_FINE_LOCATION
            )
        }

        permissionLauncher.launch(permissions)
    }

    private fun showPermissionRationale() {
        AlertDialog.Builder(activity)
            .setTitle("Bluetooth Permissions Required")
            .setMessage("This app needs Bluetooth permissions to discover and connect to devices.")
            .setPositiveButton("Grant") { _, _ ->
                requestPermissions()
            }
            .setNegativeButton("Deny") { dialog, _ ->
                dialog.dismiss()
            }
            .show()
    }

    private fun onPermissionsGranted() {
        // Initialize Bluetooth functionality
    }
}
```

**Background Limitations (Android 8+):**
```kotlin
class BleBackgroundService : Service() {

    private lateinit var bleScanner: BleScanner

    override fun onCreate() {
        super.onCreate()

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                "BLE_SCAN_CHANNEL",
                "BLE Scanning",
                NotificationManager.IMPORTANCE_LOW
            )
            val notificationManager = getSystemService(NotificationManager::class.java)
            notificationManager.createNotificationChannel(channel)
        }

        val notification = NotificationCompat.Builder(this, "BLE_SCAN_CHANNEL")
            .setContentTitle("BLE Scanning Active")
            .setContentText("Scanning for Bluetooth devices...")
            .setSmallIcon(R.drawable.ic_bluetooth)
            .build()

        startForeground(1, notification)

        bleScanner = BleScanner(this)
        bleScanner.startScan()
    }

    override fun onBind(intent: Intent?): IBinder? = null

    override fun onDestroy() {
        super.onDestroy()
        bleScanner.stopScan()
    }
}
```

### 5. Performance и Battery Life

**Оптимизация:**
```kotlin
class OptimizedBleManager(private val context: Context) {

    fun startBatchScan() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
            ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.BLUETOOTH_SCAN
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return
        }

        val settings = ScanSettings.Builder()
            .setScanMode(ScanSettings.SCAN_MODE_LOW_POWER)
            .setReportDelay(5000)
            .build()

        val bleScanner = BluetoothAdapter.getDefaultAdapter()?.bluetoothLeScanner
        bleScanner?.startScan(emptyList(), settings, scanCallback)
    }

    private val serviceCache = mutableMapOf<String, List<BluetoothGattService>>()

    fun cacheServices(deviceAddress: String, services: List<BluetoothGattService>) {
        serviceCache[deviceAddress] = services
    }

    fun requestConnectionPriority(gatt: BluetoothGatt, priority: Int) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
            ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.BLUETOOTH_CONNECT
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return
        }

        gatt.requestConnectionPriority(priority)
    }
}
```

### 6. Debugging Challenges

**Инструменты для отладки:**
```bash
# Android HCI snoop log (capture Bluetooth packets)
adb pull /data/misc/bluetooth/logs/btsnoop_hci.log

# Check Bluetooth state
adb shell dumpsys bluetooth_manager

# Monitor Bluetooth logs
adb logcat | grep -i bluetooth
```

**Логирование в приложении:**
```kotlin
class BluetoothDebugLogger {

    companion object {
        private const val TAG = "BT_DEBUG"

        fun logConnectionState(device: BluetoothDevice, state: String) {
            Log.d(TAG, """
                Connection State Changed:
                  Device: ${device.name} (${device.address})
                  State: $state
                  Time: ${System.currentTimeMillis()}
            """.trimIndent())
        }

        fun logGattOperation(operation: String, characteristic: BluetoothGattCharacteristic) {
            Log.d(TAG, """
                GATT Operation:
                  Operation: $operation
                  Service: ${characteristic.service.uuid}
                  Characteristic: ${characteristic.uuid}
                  Properties: ${characteristic.properties}
            """.trimIndent())
        }

        fun logError(message: String, throwable: Throwable? = null) {
            Log.e(TAG, message, throwable)
        }
    }
}
```

---

## Терминология

| Термин | Определение |
|--------|-------------|
| **Advertising** | Процесс BLE-устройства, при котором оно периодически отправляет пакеты для обнаружения |
| **Bonding** | Процесс создания долгосрочного доверенного соединения (сопряжение с сохранением ключей) |
| **BR/EDR** | Basic Rate/Enhanced Data Rate - классический Bluetooth |
| **CCCD** | Client Characteristic Configuration Descriptor - дескриптор для включения notifications/indications |
| **Central** | BLE-устройство, которое инициирует соединение (обычно смартфон) |
| **Characteristic** | Единица данных в GATT (содержит value, properties, descriptors) |
| **Discoverable** | Режим, когда устройство видимо для других Bluetooth-устройств |
| **GATT** | Generic Attribute Profile - профиль для структурированного обмена данными в BLE |
| **GAP** | Generic Access Profile - управление обнаружением и подключением |
| **HCI** | Host Controller Interface - интерфейс между host и controller |
| **L2CAP** | Logical Link Control and Adaptation Protocol - мультиплексирование протоколов |
| **LE** | Low Energy - энергоэффективная версия Bluetooth |
| **MTU** | Maximum Transmission Unit - максимальный размер пакета (default 23 bytes для BLE) |
| **Pairing** | Процесс аутентификации и обмена ключами между устройствами |
| **Peripheral** | BLE-устройство, которое рекламирует себя (датчики, фитнес-трекеры) |
| **Piconet** | Сеть из одного master и до 7 активных slave-устройств в Classic Bluetooth |
| **Profile** | Спецификация для конкретного применения (A2DP, HFP, HRS, etc.) |
| **RSSI** | Received Signal Strength Indicator - индикатор силы сигнала (dBm) |
| **Service** | Коллекция связанных characteristics в GATT |
| **SPP** | Serial Port Profile - эмуляция последовательного порта |
| **UUID** | Universally Unique Identifier - идентификатор service/characteristic |

---

## Источники

**Официальная документация (проверено 2025-12-18):**
- [Bluetooth SIG - Core Specification 5.4](https://www.bluetooth.com/specifications/specs/core54-html/)
- [Bluetooth SIG - What's new in Bluetooth 5.4](https://www.bluetooth.com/bluetooth-resources/whats-new-in-bluetooth-core-5-4-an-overview/)
- [Android Developers - Bluetooth Overview](https://developer.android.com/guide/topics/connectivity/bluetooth)
- [Android Developers - Bluetooth LE](https://developer.android.com/guide/topics/connectivity/bluetooth/ble-overview)

**Технические ресурсы (проверено 2025-12-18):**
- [Nordic Semiconductor - Bluetooth 5.4 Overview](https://devzone.nordicsemi.com/nordic/nordic-blog/b/blog/posts/whats-new-in-bluetooth-v5-4-an-overview)
- [Silicon Labs - Bluetooth 5.4 Features](https://www.silabs.com/blog/the-new-bluetooth-5-4-what-you-should-know-first)
- [Ezurio - Bluetooth Classic vs BLE](https://www.ezurio.com/resources/blog/bluetooth-low-energy-vs-bluetooth-classic-what-s-the-difference)
- [MokoSmart - Bluetooth vs BLE Comparison 2025](https://www.mokosmart.com/bluetooth-vs-bluetooth-low-energy-a-detailed-comparison/)

**Bluetooth Mesh (проверено 2025-12-18):**
- [Bluetooth SIG - Mesh Networking](https://www.bluetooth.com/learn-about-bluetooth/feature-enhancements/mesh/)
- [Silicon Labs - Bluetooth Mesh Whitepaper](https://www.silabs.com/whitepapers/enabling-ubiquitous-iot-connectivity-with-bluetooth-mesh-networking)
- [Sidekick Interactive - Bluetooth Mesh IoT Guide 2025](https://www.sidekickinteractive.com/bluetooth-mesh/bluetooth-mesh-iot-integration-ultimate-guide-2025/)

**Android Development (проверено 2025-12-18):**
- [Reintech - Kotlin and Bluetooth](https://reintech.io/blog/kotlin-bluetooth-building-connected-android-app)
- [Punch Through - Android BLE Guide](https://punchthrough.com/android-ble-guide/)
- [CloudDevs - Bluetooth with Kotlin](https://clouddevs.com/kotlin/bluetooth/)

**Security (проверено 2025-12-18):**
- [Keysight - PerfektBlue Vulnerabilities](https://www.keysight.com/blogs/en/tech/nwvs/2025/07/22/perfektblue-bluetooth-vulnerabilities-in-millions-of-vehicles)
- [Insinuator - Airoha Bluetooth Vulnerabilities](https://insinuator.net/2025/06/airoha-bluetooth-security-vulnerabilities/)
- [The Hacker News - PerfektBlue RCE](https://thehackernews.com/2025/07/perfektblue-bluetooth-vulnerabilities.html)
- [CSO Online - Bluetooth Vulnerability 2025](https://www.csoonline.com/article/1291144/magic-keyboard-vulnerability-allows-takeover-of-ios-android-linux-and-macos-devices.html)
- [Stack Watch - Bluetooth Security 2025](https://stack.watch/product/bluetooth/)

**Profiles и Protocols (проверено 2025-12-18):**
- [Wikipedia - List of Bluetooth Profiles](https://en.wikipedia.org/wiki/List_of_Bluetooth_profiles)
- [RF Wireless World - Bluetooth Profiles](https://www.rfwireless-world.com/Terminology/Bluetooth-profiles-list.html)
- [Philips - Bluetooth Profiles Explained](https://www.usa.philips.com/c-f/XC000008687/what-is-a-bluetooth-profile-hsp-hsp-a2dp-avrcp)

---

## Связь с другими темами

[[network-wireless-iot]] — Bluetooth (особенно BLE) часто сравнивается с другими IoT-протоколами: Zigbee, Thread, Matter, LoRa. Понимание Bluetooth помогает оценить его место в экосистеме беспроводных технологий — когда BLE достаточно, а когда нужен mesh-протокол вроде Thread или дальнобойный LoRa. Рекомендуется изучить оба материала для формирования целостной картины IoT-коммуникаций.

[[network-physical-layer]] — Bluetooth работает в ISM-диапазоне 2.4 GHz и использует frequency hopping spread spectrum (FHSS) для борьбы с интерференцией. Понимание физического уровня — радиочастот, модуляции, помех — объясняет ограничения дальности Bluetooth, проблемы сосуществования с Wi-Fi и причины потери пакетов в зашумлённой среде. Физический уровень рекомендуется изучить первым.

[[android-networking]] — Android является одной из основных платформ для BLE-разработки, и Android BLE API имеет множество нюансов: runtime permissions с Android 12+, GATT callback threading, MTU negotiation. Понимание Bluetooth-протокола на концептуальном уровне критически важно перед работой с Android BLE API, иначе ошибки в state machine и callback hell неизбежны. Рекомендуется сначала изучить протокол, затем платформенные API.

---

## Источники и дальнейшее чтение

- **Townsend K. (2014). Getting Started with Bluetooth Low Energy.** — Практическое введение в BLE с точки зрения разработчика: GATT, Services, Characteristics, Advertising. Книга объясняет архитектуру BLE через примеры на реальных устройствах и помогает избежать типичных ошибок при работе с BLE-стеком.

- **Gupta N. (2013). Inside Bluetooth Low Energy.** — Глубокий технический разбор BLE-стека: Link Layer, Security Manager, ATT/GATT. Книга подходит для разработчиков, которые хотят понять «под капотом» — как работает pairing, почему MTU ограничен и как оптимизировать энергопотребление.

- **Tanenbaum A., Wetherall D. (2011). Computer Networks, 5th Edition.** — Академический учебник с разделом о беспроводных сетях, включая Bluetooth Classic и его место среди других беспроводных технологий. Даёт широкий контекст для понимания протоколов ближнего действия.

---

**Последнее обновление:** 2026-01-09
**Статус проверки источников:** Verified
**Уровень уверенности:** High

---

## Проверь себя

> [!question]- Почему BLE не подходит для передачи аудио, хотя Bluetooth Classic справляется?
> BLE оптимизирован для коротких пакетов данных с низким энергопотреблением (IoT-сенсоры, фитнес-трекеры). Пропускная способность BLE ограничена (~125 Kbps реальная), а аудио требует стабильного потока ~200+ Kbps. Classic использует профиль A2DP со специальными кодеками (SBC, AAC, aptX). LE Audio (Bluetooth 5.2+) решает это через LC3 кодек.

> [!question]- Android-приложение сканирует BLE-устройства, и через 30 минут батарея садится на 20%. Что не так?
> Сканирование BLE --- энергоёмкая операция. Типичная ошибка: не останавливать сканирование после нахождения устройства или использовать aggressive scan mode без перерывов. Решение: устанавливать таймаут (10-30 сек), использовать фильтры по UUID сервиса, переключаться на low power scan mode, останавливать сканирование при уходе в фон.

> [!question]- Чем GATT-клиент отличается от GATT-сервера и почему телефон обычно клиент?
> GATT-сервер хранит данные (характеристики, сервисы) и предоставляет к ним доступ. GATT-клиент запрашивает и получает данные. Телефон --- клиент, потому что он читает данные с периферии (фитнес-браслет, датчик). Периферийное устройство --- сервер, потому что хранит показания и раздаёт их.

---

## Ключевые карточки

Чем отличается Bluetooth Classic от BLE?
?
Classic --- высокая пропускная способность (до 3 Mbps), постоянное соединение, для аудио/файлов. BLE --- низкое энергопотребление, короткие пакеты, для сенсоров и IoT. Classic быстрее разряжает батарею. BLE может работать месяцы на батарейке-таблетке.

Что такое GATT и из чего он состоит?
?
GATT (Generic Attribute Profile) --- протокол обмена данными в BLE. Структура: Profile -> Service (UUID, группа характеристик) -> Characteristic (значение + дескрипторы). Пример: Heart Rate Service содержит Heart Rate Measurement Characteristic.

Что такое Advertising в BLE?
?
Advertising --- механизм обнаружения BLE-устройств. Периферия рассылает advertising-пакеты (до 31 байт) каждые 20-10000ms. Центральное устройство сканирует эфир и обнаруживает устройства. Можно передавать данные без соединения (iBeacon, Eddystone).

Что такое MTU negotiation в BLE?
?
MTU (Maximum Transmission Unit) --- максимальный размер пакета. По умолчанию 23 байта (20 полезных). Можно запросить увеличение до 512 байт. Без MTU negotiation данные больше 20 байт разбиваются на множество пакетов, снижая скорость.

Что такое Bluetooth Mesh?
?
Bluetooth Mesh --- расширение BLE для создания mesh-сетей из сотен устройств. Данные передаются через промежуточные узлы (relay). Применение: умное освещение, промышленные датчики. Топология managed flood: сообщение пересылается всеми, но с TTL и кэшем для избежания петель.

---

## Куда дальше

| Направление | Куда | Зачем |
|-------------|------|-------|
| Следующий шаг | [[network-wireless-iot]] | Zigbee, Thread, Matter --- альтернативы BLE для IoT |
| Углубиться | [[android-networking]] | BLE API в Android: сканирование, GATT, permissions |
| Смежная тема | [[network-cellular]] | Сотовые сети как другой тип беспроводной связи |
| Обзор | [[networking-overview]] | Вернуться к карте раздела |

---

*Добавлены педагогические секции: 5 аналогий (Classic vs BLE как такси vs каршеринг, GATT как ресторанное меню с разделами и блюдами, Advertising как доска объявлений в подъезде, Pairing как знакомство с обменом секретом, Bluetooth Mesh как сеть соседей-передатчиков), 6 типичных ошибок с СИМПТОМ/РЕШЕНИЕ, 5 ментальных моделей*
