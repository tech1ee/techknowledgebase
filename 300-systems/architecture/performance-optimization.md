---
title: "Performance: от 3s до 300ms"
created: 2025-11-24
modified: 2026-01-02
type: concept
status: published
confidence: high
sources_verified: true
tags:
  - topic/architecture
  - architecture/performance
  - programming/optimization
  - best-practices
  - type/concept
  - level/advanced
related:
  - "[[caching-strategies]]"
  - "[[database-design-optimization]]"
  - "[[observability]]"
prerequisites:
  - "[[caching-strategies]]"
  - "[[api-design]]"
  - "[[microservices-vs-monolith]]"
reading_time: 55
difficulty: 7
study_status: not_started
mastery: 0
last_reviewed:
next_review:
---

# Performance: от 3s до 300ms

> +100ms задержки = -1% продаж Amazon = **-$1.6B/год**. 53% уходят если сайт грузится > 3 секунд. Measure first — профилирование > интуиция. Преждевременная оптимизация — зло.

---

## Prerequisites (Что нужно знать заранее)

Прежде чем погружаться в оптимизацию, убедись, что понимаешь:

| Тема | Зачем нужна | Где изучить |
|------|------------|-------------|
| JavaScript основы | Понимание примеров кода | MDN JavaScript Guide |
| HTTP основы | Понимание запросов/ответов | [[network-http-evolution]] |
| Базы данных основы | SQL запросы, индексы | [[database-design-optimization]] |
| Кэширование | Ускорение повторных запросов | [[caching-strategies]] |

---

## Зачем нужна производительность? (ПОЧЕМУ)

### Главная аналогия: Ресторан быстрого обслуживания vs Медленный ресторан

```
БЫСТРЫЙ РЕСТОРАН (Performance < 1s)
┌──────────────────────────────────────────────────────────────┐
│  👨 Клиент входит                                              │
│  📋 Меню сразу на экране (0.2s)                                │
│  🍔 Заказ принят мгновенно (0.3s)                              │
│  💵 Оплата за секунду (0.5s)                                   │
│  🎉 Клиент доволен, придёт снова!                              │
└──────────────────────────────────────────────────────────────┘

МЕДЛЕННЫЙ РЕСТОРАН (Performance > 3s)
┌──────────────────────────────────────────────────────────────┐
│  👨 Клиент входит                                              │
│  ⏳ Ждёт меню... 2 секунды...                                  │
│  ⏳ Меню грузится... кнопки не работают...                     │
│  😤 "Ну его, пойду в другое место!"                           │
│  🚶 Клиент ушёл к конкуренту                                   │
└──────────────────────────────────────────────────────────────┘
```

### История: Когда деньги начали считать миллисекундами

#### Amazon: Открытие 2007 года

В **2007 году** команда Amazon провела эксперимент и обнаружила шокирующую зависимость:

```
┌─────────────────────────────────────────────────────────────┐
│           AMAZON: КАЖДЫЕ 100ms = -1% ПРОДАЖ                  │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   Задержка    →    Потеря продаж    →    Потеря денег       │
│   ─────────        ───────────────        ─────────────     │
│   +100ms      →         -1%         →     -$1.6B/год        │
│   +200ms      →         -2%         →     -$3.2B/год        │
│   +500ms      →         -5%         →     -$8B/год          │
│                                                              │
│   При годовой выручке ~$160 миллиардов!                      │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**Почему так происходит?**

1. Пользователь ждёт → начинает сомневаться
2. Сомневается → возвращается к поиску
3. Возвращается к поиску → уходит к конкуренту
4. Конкурент отвечает быстрее → продажа потеряна

#### Google: Открытие 2006 года

Google обнаружил **долгосрочный эффект** медленной страницы:

```
Эксперимент Google Search:

Группа A: Показывали страницу с задержкой 400ms
Группа B: Обычная страница

Результаты:
┌───────────────────────────────────────────────────────────┐
│  Период          │  Группа A (медленная)  │  Разница     │
├───────────────────────────────────────────────────────────┤
│  Первые 3 недели │  -0.44% поисков       │  Привыкают   │
│  Вторые 3 недели │  -0.76% поисков       │  Уходят!     │
│  После отмены    │  -0.21% поисков       │  Помнят!     │
└───────────────────────────────────────────────────────────┘

ВАЖНО: Даже после возврата к быстрой версии,
пользователи продолжали искать МЕНЬШЕ!
Они "запомнили" что Google медленный.
```

**Вывод:** Медленный сайт не просто теряет клиентов сейчас — он **портит репутацию** на будущее.

#### Bing (Microsoft): Velocity 2009

На конференции O'Reilly Velocity 2009 Bing представил данные:

| Задержка | Влияние на запросы | Влияние на выручку |
|----------|-------------------|-------------------|
| +1 секунда | -0.9% | -2.2% |
| +2 секунды | -1.8% | -4.3% |

#### Современные данные (2024-2025)

| Исследование | Результат |
|--------------|-----------|
| Google | +100ms задержки = **-0.6% конверсии** |
| Trainline | -0.3s задержки = **+$11.5M/год** выручки |
| Rakuten 24 | Улучшение Core Web Vitals = **+53% revenue per visitor** |
| Общая статистика | 53% уходят если страница грузится > 3 секунд |

### Почему миллисекунды так важны?

**Человеческое восприятие времени:**

```
┌─────────────────────────────────────────────────────────────────┐
│                   ВОСПРИЯТИЕ ЧЕЛОВЕКА                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   0-100ms     🚀 МГНОВЕННО                                      │
│               Мозг не успевает осознать задержку               │
│               Это как щёлкнуть выключателем                    │
│                                                                 │
│   100-300ms   ⚡ БЫСТРО                                          │
│               Заметная пауза, но комфортно                      │
│               Это как отклик сенсорного экрана                  │
│                                                                 │
│   300-1000ms  ⏳ ОЩУТИМО                                         │
│               "Что-то загружается..."                           │
│               Фокус внимания начинает уходить                   │
│                                                                 │
│   1-3s        😐 МЕДЛЕННО                                        │
│               Пользователь думает о другом                      │
│               "Может обновить страницу?"                        │
│                                                                 │
│   3s+         😤 РАЗДРАЖЕНИЕ                                     │
│               "Это не работает!"                                │
│               53% уходят на этом этапе                          │
│                                                                 │
│   10s+        🚶 УХОД                                            │
│               Пользователь ушёл к конкуренту                    │
│               Может не вернуться никогда                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Терминология с аналогиями

| Термин | Аналогия | Значение |
|--------|----------|----------|
| **Latency** (задержка) | Время от заказа до получения блюда | Время от запроса до ответа сервера |
| **Throughput** (пропускная способность) | Сколько клиентов ресторан может обслужить в час | Количество запросов в секунду (RPS/QPS) |
| **P50** (медиана) | "Обычный" клиент ждёт столько | 50% запросов быстрее этого значения |
| **P99** (99-й перцентиль) | "Невезучий" клиент ждёт столько | 99% запросов быстрее этого (1% медленнее) |
| **Bottleneck** (узкое место) | Один медленный кассир тормозит всю очередь | Компонент, ограничивающий производительность |
| **FCP** (First Contentful Paint) | Появилось меню на экране | Первый контент появился на странице |
| **LCP** (Largest Contentful Paint) | Главное блюдо на столе | Главный контент загрузился |
| **CLS** (Cumulative Layout Shift) | Тарелки двигаются по столу | Элементы "прыгают" при загрузке |
| **INP** (Interaction to Next Paint) | Как быстро официант реагирует на просьбы | Отзывчивость на действия пользователя |
| **TTFB** (Time to First Byte) | Первый знак внимания от официанта | Первый байт ответа от сервера |
| **Tree Shaking** | Выбросить листья, которые не на дереве | Удалить неиспользуемый код из bundle |
| **Code Splitting** | Не приносить всё меню сразу, только нужную страницу | Загружать код по частям, а не всё сразу |
| **Flame Graph** | Рентген показывает что болит | Визуализация где код тратит время |

---

## Core Web Vitals: Что измеряет Google

### Аналогия: Оценка ресторана по трём критериям

```
CORE WEB VITALS = Оценка Google для сайтов

Как ресторан оценивают по:
1. Скорость обслуживания (LCP)
2. Отзывчивость персонала (INP)
3. Стабильность сервиса (CLS)

Так Google оценивает сайты и учитывает это в поисковой выдаче!
```

### LCP (Largest Contentful Paint) — Скорость загрузки

**Аналогия: Как быстро главное блюдо появляется на столе**

```
LCP измеряет: через сколько секунд появится ГЛАВНЫЙ контент

Хронология загрузки страницы:
0s ─────────────────────────────────────────────→ время
   │
   ├─ [0.2s] Белый экран
   │
   ├─ [0.5s] Появился header (это FCP)
   │
   ├─ [1.2s] Текст статьи появился (маленький элемент)
   │
   └─ [2.1s] ★ Главная картинка загрузилась ★ = LCP
            (самый большой элемент на экране)

┌────────────────────────────────────────┐
│         ОЦЕНКИ LCP                      │
├────────────────────────────────────────┤
│  ≤ 2.5s   →  🟢 Хорошо (Good)          │
│  2.5-4s   →  🟡 Нужно улучшить         │
│  > 4s     →  🔴 Плохо (Poor)           │
└────────────────────────────────────────┘
```

**Что влияет на LCP:**
- Размер изображений (большие = медленно)
- Скорость сервера (TTFB)
- Блокирующие ресурсы (CSS, JS)
- Сторонние скрипты (аналитика, реклама)

### INP (Interaction to Next Paint) — Отзывчивость

**Аналогия: Как быстро официант реагирует КАЖДЫЙ раз**

```
INP измеряет: отзывчивость на ВСЕ взаимодействия за сессию

До марта 2024: измерялся FID (только ПЕРВОЕ взаимодействие)
После марта 2024: INP (ВСЕ взаимодействия)

Пример сессии пользователя:
┌─────────────────────────────────────────────────────────────┐
│ Взаимодействие    │ Время отклика │ Ощущение               │
├─────────────────────────────────────────────────────────────┤
│ Клик по меню      │     50ms      │ Мгновенно              │
│ Ввод в поиск      │     80ms      │ Быстро                 │
│ Клик "Купить"     │    350ms      │ ← Заметная задержка!   │
│ Скролл страницы   │     30ms      │ Плавно                 │
│ Открыть фильтр    │    120ms      │ Нормально              │
└─────────────────────────────────────────────────────────────┘

INP = 350ms (худшее взаимодействие за сессию)

┌────────────────────────────────────────┐
│         ОЦЕНКИ INP                      │
├────────────────────────────────────────┤
│  ≤ 200ms  →  🟢 Хорошо (Good)          │
│  200-500ms→  🟡 Нужно улучшить         │
│  > 500ms  →  🔴 Плохо (Poor)           │
└────────────────────────────────────────┘
```

**Что влияет на INP:**
- Тяжёлый JavaScript (блокирует main thread)
- Long Tasks (> 50ms)
- Большой DOM (много элементов)
- Неоптимизированные обработчики событий

### CLS (Cumulative Layout Shift) — Визуальная стабильность

**Аналогия: Тарелки не должны двигаться по столу**

```
CLS измеряет: насколько контент "прыгает" при загрузке

Представь: ты собираешься нажать кнопку "Отмена",
но в последний момент сверху появляется баннер,
страница сдвигается, и ты нажимаешь "Удалить аккаунт"! 😱

Это и есть CLS — неожиданные сдвиги layout.

Визуализация проблемы:
┌──────────────────────┐      ┌──────────────────────┐
│ [Header]             │      │ [Header]             │
│                      │      │ [Внезапный баннер!]  │ ← Появился!
│ [Текст статьи]       │  →   │ [Текст статьи]       │ ← Сдвинулся!
│                      │      │                      │
│ [Кнопка "Купить"] ← │      │ [Кнопка "Купить"] ← │ ← Сдвинулась!
│     👆 Палец тут     │      │     👆 Промах!       │
└──────────────────────┘      └──────────────────────┘

Пользователь нажал не туда!

┌────────────────────────────────────────┐
│         ОЦЕНКИ CLS                      │
├────────────────────────────────────────┤
│  ≤ 0.1    →  🟢 Хорошо (Good)          │
│  0.1-0.25 →  🟡 Нужно улучшить         │
│  > 0.25   →  🔴 Плохо (Poor)           │
└────────────────────────────────────────┘

Формула: CLS = impact fraction × distance fraction
         (какая часть экрана) × (на сколько сдвинулось)
```

**Что вызывает CLS:**
- Изображения без размеров (width/height)
- Реклама, динамически появляющаяся
- Шрифты загружаются и меняют layout
- Контент добавляется JavaScript'ом сверху

---

## Measure First: Профилирование

### Золотое правило оптимизации

```
"Программисты тратят огромное количество времени,
 думая о или беспокоясь о скорости некритических
 частей своих программ"
                                    — Donald Knuth

ПРАВИЛО:
1. ИЗМЕРЬ (profiler) — найди реальную проблему
2. НАЙДИ узкое место (80/20: 20% кода = 80% времени)
3. ОПТИМИЗИРУЙ ТОЛЬКО узкое место
4. ИЗМЕРЬ СНОВА — подтверди улучшение

❌ ПЛОХО: "Мне кажется этот цикл медленный, перепишу"
✅ ХОРОШО: "Profiler показал что 80% времени в функции X"
```

### Flame Graphs: Рентген для кода

**Аналогия: Как рентген показывает где болит**

```
Flame Graph — визуализация где код проводит время.
Изобретены Brendan Gregg для решения проблемы MySQL.

КАК ЧИТАТЬ FLAME GRAPH:

         ▲ Ось Y: глубина стека (кто кого вызвал)
         │
         │    ┌─────────────────────────────────────┐
         │    │           main()                     │  ← Точка входа
         │    └─────────────────────────────────────┘
         │              │
         │    ┌─────────┴─────────┐
         │    │   processUsers()   │  ← Вызвана из main
         │    └───────────────────┘
         │          │         │
         │    ┌─────┴────┐ ┌──┴───────────────────┐
         │    │getUser() │ │    sendEmail()        │
         │    └──────────┘ └───────────────────────┘
         │                          │
         │                 ┌────────┴────────────────┐
         │                 │  ★ formatHTML() ★       │ ← ШИРОКАЯ = МНОГО ВРЕМЕНИ
         │                 └─────────────────────────┘
         │
         └──────────────────────────────────────────────→ Ось X: время CPU
           (ширина = сколько времени функция на CPU)

ПРАВИЛА ЧТЕНИЯ:
• Ширина блока = сколько времени занимает
• Высота = глубина вызовов
• ★ ШИРОКИЕ блоки наверху = проблема! ★
• Узкие блоки — не трогать, не важно

В примере выше: formatHTML() широкая → её нужно оптимизировать
```

### Browser DevTools: Performance Tab

```javascript
// Chrome DevTools → Performance Tab

/*
Шаг 1: Открой DevTools (F12)
Шаг 2: Вкладка Performance
Шаг 3: Нажми Record (●)
Шаг 4: Выполни действие на сайте
Шаг 5: Нажми Stop
Шаг 6: Анализируй!

Что смотреть:

Timeline (временная шкала):
─────────────────────────────────────────────────────
░░░░[HTML Parse]░░░░
    ▓▓▓[JS Execution]▓▓▓▓▓▓▓▓▓▓▓  ← Если много — проблема!
              [Layout]
                [Paint]
                      [Composite]

Summary (внизу):
┌──────────────────────────────────────┐
│ Loading:       50ms    (2%)          │
│ Scripting:   2300ms   (75%) ← !!!    │  ← ПРОБЛЕМА ЗДЕСЬ
│ Rendering:    450ms   (15%)          │
│ Painting:     200ms    (7%)          │
│ Other:         50ms    (1%)          │
└──────────────────────────────────────┘

Bottom-Up (какие функции самые медленные):
┌──────────────────────────────────────┐
│ Function           │ Self Time       │
├──────────────────────────────────────┤
│ getUserData()      │  1850ms ← FIX!  │
│ renderList()       │   380ms         │
│ parseJSON()        │   120ms         │
└──────────────────────────────────────┘
*/
```

### Backend профилирование (Node.js)

```javascript
// ═══════════════════════════════════════════════════════════════════
// СПОСОБ 1: Встроенный V8 профайлер
// ═══════════════════════════════════════════════════════════════════

// Шаг 1: Запусти с флагом --prof
// node --prof app.js

// Шаг 2: Сгенерируется файл isolate-*-v8.log

// Шаг 3: Обработай лог
// node --prof-process isolate-*-v8.log > profile.txt

// Шаг 4: Читай результат:
/*
[Summary]:                          ← Общая картина
  ticks  total  nonlib   name
  1234   41.2%   45.1%   JavaScript  ← 45% времени в JS
   567   18.9%   20.7%   C++         ← 21% в нативном коде

[JavaScript]:                        ← Детализация по функциям
  ticks  total  nonlib   name
   800   26.7%   29.2%   LazyCompile: *processUsers /app/users.js:45  ← HOTSPOT!
   234    7.8%    8.5%   LazyCompile: *formatDate /app/utils.js:12
*/


// ═══════════════════════════════════════════════════════════════════
// СПОСОБ 2: Clinic.js — автоматический анализ (рекомендуется)
// ═══════════════════════════════════════════════════════════════════

// Установка:
// npm install -g clinic

// Запуск с flame graph:
// clinic flame -- node app.js

// Запуск с обнаружением проблем:
// clinic doctor -- node app.js

// Результат: открывается HTML с визуализацией и рекомендациями


// ═══════════════════════════════════════════════════════════════════
// СПОСОБ 3: Ручное измерение времени (для конкретных функций)
// ═══════════════════════════════════════════════════════════════════

const { performance } = require('perf_hooks');

/**
 * Обёртка для измерения времени выполнения функции.
 *
 * Как работает:
 * 1. Запоминаем время ДО выполнения
 * 2. Выполняем функцию
 * 3. Считаем разницу ПОСЛЕ выполнения
 * 4. Если медленно — логируем предупреждение
 *
 * @param fn - функция для измерения
 * @param name - название для логов
 * @returns результат функции
 */
async function measurePerformance(fn, name) {
  // Запоминаем время старта (в миллисекундах, высокая точность)
  const startTime = performance.now();

  try {
    // Выполняем функцию (await для async)
    const result = await fn();
    return result;
  } finally {
    // Считаем сколько времени прошло
    const duration = performance.now() - startTime;

    // Логируем результат
    console.log(`[PERF] ${name}: ${duration.toFixed(2)}ms`);

    // Предупреждение если медленно (> 1 секунды)
    if (duration > 1000) {
      console.warn(`⚠️ SLOW: ${name} took ${duration.toFixed(0)}ms!`);
    }
  }
}

// Использование:
const user = await measurePerformance(
  () => getUserById(123),  // Что измеряем
  'getUserById'            // Название в логах
);

// Вывод: [PERF] getUserById: 45.23ms
// Или:   ⚠️ SLOW: getUserById took 2341ms!
```

---

## Frontend: Quick Wins

### 1. Code Splitting & Lazy Loading

**Аналогия: Не грузи всё меню — только нужную страницу**

```javascript
// ═══════════════════════════════════════════════════════════════════
// ПРОБЛЕМА: Всё в одном bundle
// ═══════════════════════════════════════════════════════════════════

// ❌ ПЛОХО: загружаем всё сразу
import HeavyChart from './HeavyChart';       // 500KB
import RarelyUsedModal from './RarelyUsedModal'; // 200KB
import AdminPanel from './AdminPanel';       // 800KB (только для админов!)

function App() {
  return (
    <div>
      <HeavyChart />
      {user.isAdmin && <AdminPanel />}
    </div>
  );
}

// Результат: КАЖДЫЙ пользователь скачивает 1.5MB
// Даже если он не админ и никогда не увидит AdminPanel!


// ═══════════════════════════════════════════════════════════════════
// РЕШЕНИЕ: Dynamic imports (lazy loading)
// ═══════════════════════════════════════════════════════════════════

import { lazy, Suspense } from 'react';

// lazy() говорит React: "Не загружай сейчас, только когда понадобится"
// import() — динамический импорт, возвращает Promise
const HeavyChart = lazy(() => import('./HeavyChart'));
const AdminPanel = lazy(() => import('./AdminPanel'));

function App() {
  return (
    <div>
      {/* Suspense показывает fallback пока компонент загружается */}
      <Suspense fallback={<Spinner />}>
        <HeavyChart />
        {/* AdminPanel загрузится ТОЛЬКО для админов */}
        {user.isAdmin && <AdminPanel />}
      </Suspense>
    </div>
  );
}

// Результат:
// Initial bundle: 300KB (основное приложение)
// HeavyChart: 500KB (загружается при рендере)
// AdminPanel: 800KB (загружается ТОЛЬКО для админов)

// Обычный пользователь скачивает: 300KB + 500KB = 800KB (было 1.5MB!)


// ═══════════════════════════════════════════════════════════════════
// Route-based code splitting (по страницам)
// ═══════════════════════════════════════════════════════════════════

import { lazy, Suspense } from 'react';
import { Routes, Route } from 'react-router-dom';

// Каждая страница = отдельный chunk (файл)
const Home = lazy(() => import('./pages/Home'));           // chunk: home.js
const Dashboard = lazy(() => import('./pages/Dashboard')); // chunk: dashboard.js
const Settings = lazy(() => import('./pages/Settings'));   // chunk: settings.js
const AdminPanel = lazy(() => import('./pages/AdminPanel')); // chunk: admin.js

function App() {
  return (
    <Suspense fallback={<PageLoader />}>
      <Routes>
        {/* Пользователь заходит на /  → загружается ТОЛЬКО home.js */}
        <Route path="/" element={<Home />} />

        {/* Переходит на /dashboard → загружается dashboard.js */}
        <Route path="/dashboard" element={<Dashboard />} />

        {/* И так далее... */}
        <Route path="/settings" element={<Settings />} />
        <Route path="/admin" element={<AdminPanel />} />
      </Routes>
    </Suspense>
  );
}

// Результат: пользователь загружает только те страницы, которые посещает
```

### 2. Tree Shaking: Убираем неиспользуемый код

**Аналогия: Дерево с мёртвыми листьями**

```javascript
/*
Tree Shaking = "Встряхни дерево, мёртвые листья упадут"

Твоё приложение — это дерево:
• Живые листья (🌿) = код, который используется
• Мёртвые листья (🍂) = код, который импортирован, но не используется

Tree shaking удаляет мёртвые листья из bundle.
*/

// ═══════════════════════════════════════════════════════════════════
// ПРОБЛЕМА: Lodash и подобные библиотеки
// ═══════════════════════════════════════════════════════════════════

// ❌ ПЛОХО: импортируем ВСЮ библиотеку ради одной функции
import _ from 'lodash';      // 72KB minified!
_.debounce(handleSearch, 300);

// Что попадает в bundle:
// - debounce ← нужно
// - map, filter, reduce ← НЕ нужно
// - merge, clone, cloneDeep ← НЕ нужно
// - ещё 300+ функций ← НЕ нужно

// Результат: 72KB в bundle ради 1KB кода


// ✅ ХОРОШО: импортируем только нужное
import debounce from 'lodash/debounce';  // ~2KB
debounce(handleSearch, 300);

// Или с ES modules (если библиотека поддерживает):
import { debounce } from 'lodash-es';    // Tree-shakeable!


// ═══════════════════════════════════════════════════════════════════
// ПРИМЕР: Date formatting
// ═══════════════════════════════════════════════════════════════════

// ❌ ПЛОХО: moment.js для простого форматирования
import moment from 'moment';  // 67KB minified + 300KB locales!
const formatted = moment(date).format('YYYY-MM-DD');

// ✅ ХОРОШО: нативный Intl API (0KB — встроен в браузер!)
const formatted = new Intl.DateTimeFormat('en-CA').format(date);
// 'en-CA' format даёт YYYY-MM-DD

// ✅ ИЛИ: легковесная библиотека
import { format } from 'date-fns';  // 2KB (tree-shakeable!)
const formatted = format(date, 'yyyy-MM-dd');


// ═══════════════════════════════════════════════════════════════════
// КАК ВКЛЮЧИТЬ TREE SHAKING
// ═══════════════════════════════════════════════════════════════════

// Webpack: включен по умолчанию в production mode
// webpack.config.js
module.exports = {
  mode: 'production',  // ← Автоматически включает tree shaking
  optimization: {
    usedExports: true,  // Помечает неиспользуемые экспорты
  }
};

// package.json (для своих библиотек):
{
  "sideEffects": false  // ← "Мой код не имеет побочных эффектов"
                        // Webpack может безопасно удалять неиспользуемое
}


// ═══════════════════════════════════════════════════════════════════
// КАК ПРОВЕРИТЬ ЧТО ПОПАЛО В BUNDLE
// ═══════════════════════════════════════════════════════════════════

// Установи webpack-bundle-analyzer:
// npm install --save-dev webpack-bundle-analyzer

// Запусти:
// npx webpack-bundle-analyzer dist/stats.json

// Результат: интерактивная карта bundle
// Сразу видно какие библиотеки занимают много места
```

### 3. Image Optimization

```html
<!-- ═══════════════════════════════════════════════════════════════════ -->
<!-- ПРОБЛЕМА: Огромные изображения                                      -->
<!-- ═══════════════════════════════════════════════════════════════════ -->

<!-- ❌ ПЛОХО: огромный файл для маленького места -->
<img src="photo.jpg" width="300" />
<!-- photo.jpg = 4000x3000px, 8MB! Но отображается 300px! -->


<!-- ═══════════════════════════════════════════════════════════════════ -->
<!-- РЕШЕНИЕ 1: Responsive images (разные размеры для разных экранов)    -->
<!-- ═══════════════════════════════════════════════════════════════════ -->

<!-- ✅ ХОРОШО: браузер выбирает подходящий размер -->
<img
  srcset="
    photo-300w.jpg 300w,     <!-- Для экранов до 300px -->
    photo-600w.jpg 600w,     <!-- Для экранов до 600px -->
    photo-1200w.jpg 1200w    <!-- Для больших экранов -->
  "
  sizes="
    (max-width: 600px) 300px,   <!-- На мобильных: 300px -->
    (max-width: 1200px) 600px,  <!-- На планшетах: 600px -->
    1200px                       <!-- На десктопах: 1200px -->
  "
  src="photo-600w.jpg"           <!-- Fallback для старых браузеров -->
  alt="Photo description"
  loading="lazy"                 <!-- Загружать только когда видно -->
  decoding="async"               <!-- Декодировать асинхронно -->
/>

<!--
Что происходит:
1. Браузер смотрит на размер экрана
2. Выбирает подходящий файл из srcset
3. Мобильный телефон скачает 300w (50KB), не 1200w (500KB)!
-->


<!-- ═══════════════════════════════════════════════════════════════════ -->
<!-- РЕШЕНИЕ 2: Modern formats (WebP, AVIF)                              -->
<!-- ═══════════════════════════════════════════════════════════════════ -->

<picture>
  <!-- AVIF: лучшее сжатие, новые браузеры -->
  <source srcset="photo.avif" type="image/avif" />

  <!-- WebP: хорошее сжатие, большинство браузеров -->
  <source srcset="photo.webp" type="image/webp" />

  <!-- JPEG: fallback для старых браузеров -->
  <img
    src="photo.jpg"
    alt="Photo description"
    loading="lazy"
  />
</picture>

<!--
Сравнение размеров (одинаковое качество):
• JPEG: 500KB
• WebP: 200KB (-60%!)
• AVIF: 150KB (-70%!)
-->


<!-- ═══════════════════════════════════════════════════════════════════ -->
<!-- РЕШЕНИЕ 3: Next.js Image (автоматическая оптимизация)               -->
<!-- ═══════════════════════════════════════════════════════════════════ -->

import Image from 'next/image';

<Image
  src="/photo.jpg"
  width={600}
  height={400}
  alt="Photo"
  loading="lazy"           // Ленивая загрузка
  placeholder="blur"       // Размытый placeholder пока грузится
  blurDataURL="..."        // Base64 превью (10 байт)
/>

<!--
Next.js Image автоматически:
• Конвертирует в WebP/AVIF
• Генерирует разные размеры
• Оптимизирует качество
• Добавляет lazy loading
• Предотвращает CLS (layout shift)
-->
```

### 4. Virtualization для длинных списков

**Аналогия: Показывай только видимую часть книги, не всю книгу сразу**

```javascript
// ═══════════════════════════════════════════════════════════════════
// ПРОБЛЕМА: Рендер 10,000 элементов
// ═══════════════════════════════════════════════════════════════════

// ❌ ПЛОХО: создаём 10,000 DOM элементов
function UserList({ users }) {
  return (
    <div>
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
}

// Что происходит:
// 1. React создаёт 10,000 virtual DOM элементов
// 2. Браузер создаёт 10,000 реальных DOM элементов
// 3. Браузер тормозит: scroll лагает, память растёт
//
// DOM = Самая медленная часть браузера!


// ═══════════════════════════════════════════════════════════════════
// РЕШЕНИЕ: Virtualization (react-window)
// ═══════════════════════════════════════════════════════════════════

import { FixedSizeList } from 'react-window';

function VirtualUserList({ users }) {
  return (
    <FixedSizeList
      height={600}           // Высота видимой области
      itemCount={users.length} // Всего элементов
      itemSize={80}          // Высота одного элемента (px)
      width="100%"
    >
      {({ index, style }) => (
        // style содержит position: absolute и top: ...
        // React-window позиционирует только видимые элементы!
        <div style={style}>
          <UserCard user={users[index]} />
        </div>
      )}
    </FixedSizeList>
  );
}

// Что происходит:
// 1. Видимая область = 600px
// 2. Высота элемента = 80px
// 3. Видимых элементов = 600 / 80 = ~8 элементов + буфер
// 4. React рендерит только ~10-15 элементов вместо 10,000!
//
// Результат:
// • DOM: 10,000 → ~15 элементов (-99.85%!)
// • Scroll: плавный
// • Память: константная

// Схема работы:
/*
┌───────────────────────────────────────────────────┐
│         Весь список (10,000 элементов)            │
│                                                    │
│  [User 1]      ← вне экрана, НЕ создан            │
│  [User 2]      ← вне экрана, НЕ создан            │
│  ...                                              │
│  [User 997]    ← вне экрана, НЕ создан            │
│  ┌──────────────────────────────────────────┐     │
│  │ ВИДИМАЯ ОБЛАСТЬ (viewport)               │     │
│  ├──────────────────────────────────────────┤     │
│  │ [User 998]  ← СОЗДАН в DOM               │     │
│  │ [User 999]  ← СОЗДАН в DOM               │     │
│  │ [User 1000] ← СОЗДАН в DOM               │     │
│  │ [User 1001] ← СОЗДАН в DOM               │     │
│  │ [User 1002] ← СОЗДАН в DOM               │     │
│  │ [User 1003] ← СОЗДАН в DOM               │     │
│  │ [User 1004] ← СОЗДАН в DOM               │     │
│  │ [User 1005] ← СОЗДАН в DOM (буфер)       │     │
│  └──────────────────────────────────────────┘     │
│  [User 1006]   ← вне экрана, НЕ создан            │
│  ...                                              │
│  [User 10000]  ← вне экрана, НЕ создан            │
└───────────────────────────────────────────────────┘

При скролле: старые элементы удаляются, новые создаются
*/
```

---

## Backend: Quick Wins

### 1. N+1 Query Problem

**Аналогия: Официант ходит на кухню за каждым ингредиентом отдельно**

```javascript
// ═══════════════════════════════════════════════════════════════════
// ПРОБЛЕМА: N+1 запросов
// ═══════════════════════════════════════════════════════════════════

// ❌ ПЛОХО: 1 + N запросов к базе
async function getPostsWithAuthors() {
  // 1 запрос: получить все посты
  const posts = await db.query('SELECT * FROM posts LIMIT 100');
  // SQL: SELECT * FROM posts LIMIT 100

  // N запросов: для КАЖДОГО поста получить автора
  for (const post of posts) {
    post.author = await db.query(
      'SELECT * FROM users WHERE id = ?',
      [post.user_id]
    );
  }
  // SQL (100 раз!):
  // SELECT * FROM users WHERE id = 1
  // SELECT * FROM users WHERE id = 2
  // SELECT * FROM users WHERE id = 3
  // ... (ещё 97 раз)

  return posts;
}

// Итого: 1 + 100 = 101 запрос к базе!
// Время: ~500ms (каждый запрос ~5ms)


// ═══════════════════════════════════════════════════════════════════
// РЕШЕНИЕ 1: JOIN (один запрос)
// ═══════════════════════════════════════════════════════════════════

// ✅ ХОРОШО: 1 запрос с JOIN
async function getPostsWithAuthors() {
  const result = await db.query(`
    SELECT
      posts.*,
      users.name as author_name,
      users.email as author_email
    FROM posts
    JOIN users ON posts.user_id = users.id
    LIMIT 100
  `);
  // 1 запрос вместо 101!
  // Время: ~10ms

  return result;
}


// ═══════════════════════════════════════════════════════════════════
// РЕШЕНИЕ 2: DataLoader (для GraphQL)
// ═══════════════════════════════════════════════════════════════════

/*
DataLoader решает N+1 проблему через батчинг:
1. Собирает все запросы за один "tick" event loop
2. Объединяет их в один batch запрос
3. Распределяет результаты обратно

Было: 100 запросов SELECT * FROM users WHERE id = ?
Стало: 1 запрос SELECT * FROM users WHERE id IN (1, 2, 3, ...)
*/

const DataLoader = require('dataloader');

// Функция для batch загрузки (вызывается ОДИН раз)
async function batchLoadUsers(userIds) {
  console.log(`Loading users: ${userIds.join(', ')}`);

  // Один запрос за всеми пользователями
  const users = await db.query(
    'SELECT * FROM users WHERE id IN (?)',
    [userIds]
  );

  // ВАЖНО: вернуть в том же порядке, что и userIds!
  const userMap = new Map(users.map(u => [u.id, u]));
  return userIds.map(id => userMap.get(id));
}

// Создаём DataLoader (один на запрос!)
const userLoader = new DataLoader(batchLoadUsers);

// Использование в resolver'ах
const resolvers = {
  Post: {
    // Этот resolver вызывается 100 раз (для каждого поста)
    // Но DataLoader соберёт все .load() в один batch!
    author: (post) => userLoader.load(post.user_id)
  }
};

// Результат в логах:
// Loading users: 1, 2, 3, 5, 7, 12, ...  (один вызов!)

// Вместо:
// Loading users: 1
// Loading users: 2
// Loading users: 3
// ... (100 раз)
```

### 2. Parallel Operations (Promise.all)

```javascript
// ═══════════════════════════════════════════════════════════════════
// ПРОБЛЕМА: Последовательные независимые операции
// ═══════════════════════════════════════════════════════════════════

// ❌ ПЛОХО: последовательно (waterfall)
async function getDashboard(userId) {
  // Ждём user... (500ms)
  const user = await getUser(userId);

  // Ждём posts... (500ms)
  const posts = await getPosts(userId);

  // Ждём analytics... (500ms)
  const analytics = await getAnalytics(userId);

  return { user, posts, analytics };
}
// Общее время: 500 + 500 + 500 = 1500ms
//
// Timeline:
// |--- getUser ---|--- getPosts ---|--- getAnalytics ---|
// 0ms           500ms            1000ms              1500ms


// ═══════════════════════════════════════════════════════════════════
// РЕШЕНИЕ: Promise.all (параллельно)
// ═══════════════════════════════════════════════════════════════════

// ✅ ХОРОШО: параллельно
async function getDashboard(userId) {
  // Все три запроса стартуют ОДНОВРЕМЕННО!
  const [user, posts, analytics] = await Promise.all([
    getUser(userId),      // Старт в 0ms, готово в 500ms
    getPosts(userId),     // Старт в 0ms, готово в 500ms
    getAnalytics(userId)  // Старт в 0ms, готово в 500ms
  ]);

  return { user, posts, analytics };
}
// Общее время: max(500, 500, 500) = 500ms (3x быстрее!)
//
// Timeline:
// |--- getUser -------|
// |--- getPosts ------|
// |--- getAnalytics --|
// 0ms              500ms


// ═══════════════════════════════════════════════════════════════════
// УЛУЧШЕНИЕ: Promise.allSettled (с обработкой ошибок)
// ═══════════════════════════════════════════════════════════════════

// ✅ ЕЩЁ ЛУЧШЕ: graceful degradation
async function getDashboard(userId) {
  // allSettled не бросает ошибку если один promise rejected
  const results = await Promise.allSettled([
    withTimeout(getUser(userId), 2000),      // Таймаут 2 секунды
    withTimeout(getPosts(userId), 2000),
    withTimeout(getAnalytics(userId), 2000)
  ]);

  // Обрабатываем результаты
  return {
    // Если fulfilled — берём значение, иначе null
    user: results[0].status === 'fulfilled' ? results[0].value : null,
    posts: results[1].status === 'fulfilled' ? results[1].value : [],
    analytics: results[2].status === 'fulfilled' ? results[2].value : {}
  };
}

// Вспомогательная функция для таймаута
function withTimeout(promise, ms) {
  const timeout = new Promise((_, reject) =>
    setTimeout(() => reject(new Error('Timeout')), ms)
  );
  return Promise.race([promise, timeout]);
}

// Результат:
// • Если analytics тормозит 10 секунд — не ждём, возвращаем {}
// • User и posts вернутся за 500ms
// • Пользователь видит страницу (хоть и неполную) за 500ms, не 10s
```

### 3. Response Compression

```javascript
// ═══════════════════════════════════════════════════════════════════
// ПРОБЛЕМА: Большие JSON ответы
// ═══════════════════════════════════════════════════════════════════

// API возвращает список пользователей
// Без сжатия: 250KB
// С gzip: 45KB (-82%!)
// С brotli: 35KB (-86%!)


// ═══════════════════════════════════════════════════════════════════
// РЕШЕНИЕ: Middleware для сжатия (Express.js)
// ═══════════════════════════════════════════════════════════════════

const express = require('express');
const compression = require('compression');

const app = express();

// Добавляем middleware для сжатия
app.use(compression({
  // Уровень сжатия: 1-9
  // 1 = быстрое сжатие, большой размер
  // 9 = медленное сжатие, маленький размер
  // 6 = хороший баланс (default)
  level: 6,

  // Минимальный размер для сжатия
  // Не сжимаем мелкие ответы (overhead > выигрыш)
  threshold: 1024,  // 1KB

  // Какие content-types сжимать
  filter: (req, res) => {
    // Сжимаем JSON, HTML, CSS, JS
    // Не сжимаем уже сжатые (images, videos)
    if (req.headers['x-no-compression']) {
      return false;
    }
    return compression.filter(req, res);
  }
}));

// Теперь все ответы автоматически сжимаются!
app.get('/api/users', async (req, res) => {
  const users = await db.getUsers();
  res.json(users);  // Автоматически gzip если браузер поддерживает
});


// ═══════════════════════════════════════════════════════════════════
// КАК ЭТО РАБОТАЕТ
// ═══════════════════════════════════════════════════════════════════

/*
1. Браузер в запросе говорит: "Я умею gzip и brotli"
   Accept-Encoding: gzip, br

2. Сервер сжимает ответ и добавляет заголовок:
   Content-Encoding: gzip

3. Браузер автоматически разжимает

До:  Content-Length: 250000 (250KB)
После: Content-Length: 45000 (45KB)

Пользователь скачивает в 5x меньше данных!
*/
```

### 4. Streaming Responses (для больших данных)

```javascript
// ═══════════════════════════════════════════════════════════════════
// ПРОБЛЕМА: Экспорт миллиона записей
// ═══════════════════════════════════════════════════════════════════

// ❌ ПЛОХО: всё в память
app.get('/export/users', async (req, res) => {
  // Загружаем ВСЁ в память
  const users = await db.query('SELECT * FROM users');
  // 1,000,000 записей × 500 байт = 500MB в памяти!

  // Конвертируем ВСЁ
  const csv = users.map(u => `${u.id},${u.name},${u.email}`).join('\n');
  // Ещё 500MB для строки!

  // Отправляем
  res.send(csv);
});

// Проблемы:
// 1. Память: 1GB+ на один запрос
// 2. Таймаут: пользователь ждёт пока ВСЁ загрузится
// 3. Один такой запрос может убить сервер


// ═══════════════════════════════════════════════════════════════════
// РЕШЕНИЕ: Streaming (потоковая передача)
// ═══════════════════════════════════════════════════════════════════

// ✅ ХОРОШО: streaming
app.get('/export/users', async (req, res) => {
  // Устанавливаем заголовки ДО начала отправки
  res.setHeader('Content-Type', 'text/csv');
  res.setHeader('Content-Disposition', 'attachment; filename=users.csv');

  // Заголовок CSV
  res.write('id,name,email\n');

  // Получаем поток данных из базы
  const stream = db.query('SELECT * FROM users').stream();

  // Обрабатываем по одной записи
  stream.on('data', (user) => {
    // Сразу отправляем клиенту, не храним в памяти!
    res.write(`${user.id},${user.name},${user.email}\n`);
  });

  // Когда все данные отправлены
  stream.on('end', () => {
    res.end();
  });

  // Обработка ошибок
  stream.on('error', (err) => {
    console.error('Stream error:', err);
    res.end();
  });
});

// Результат:
// • Память: константная (~10MB буфер)
// • Первые данные: через 100ms (не через 30 секунд!)
// • Сервер: может обрабатывать много таких запросов

/*
Сравнение:

БЕЗ STREAMING:
[Загрузка 30s]────────────[Конвертация 5s]────[Отправка 5s]
Пользователь ждёт: 40s до начала скачивания

С STREAMING:
[Первый байт 100ms]──[Данные текут]──[Данные текут]──[Готово]
Пользователь видит прогресс: скачивание начинается сразу
*/
```

---

## Memory Leaks: Как находить и исправлять

### Аналогия: Забытые вещи в комнатах

```
Memory Leak = "Утечка памяти"

Представь: ты переезжаешь из комнаты в комнату,
но забываешь вещи в каждой комнате.

Комната 1: забыл книгу
Комната 2: забыл кружку
Комната 3: забыл ноутбук
...

Через 100 комнат: все твои вещи разбросаны,
новые вещи не помещаются, дом переполнен!

В JavaScript:
• Комнаты = вызовы функций, компоненты, страницы
• Вещи = объекты в памяти
• "Забыл" = не убрал ссылку, GC не может удалить
```

### Распространённые причины memory leaks

```javascript
// ═══════════════════════════════════════════════════════════════════
// ПРИЧИНА 1: Забытые event listeners
// ═══════════════════════════════════════════════════════════════════

// ❌ ПЛОХО: listener остаётся после unmount
function BadComponent() {
  useEffect(() => {
    window.addEventListener('resize', handleResize);
    // Нет cleanup! При каждом mount добавляем listener.
    // После 10 перерендеров = 10 listeners!
  }, []);

  return <div>...</div>;
}

// ✅ ХОРОШО: cleanup в useEffect
function GoodComponent() {
  useEffect(() => {
    window.addEventListener('resize', handleResize);

    // Return cleanup function!
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return <div>...</div>;
}


// ═══════════════════════════════════════════════════════════════════
// ПРИЧИНА 2: Detached DOM nodes
// ═══════════════════════════════════════════════════════════════════

// ❌ ПЛОХО: ссылка на удалённый DOM элемент
let cachedElement = null;

function cacheButton() {
  cachedElement = document.getElementById('myButton');
}

function removeButton() {
  document.getElementById('myButton').remove();
  // DOM элемент удалён, но cachedElement всё ещё ссылается на него!
  // GC не может его удалить → memory leak
}

// ✅ ХОРОШО: очищаем ссылку
function removeButton() {
  document.getElementById('myButton').remove();
  cachedElement = null;  // Теперь GC может удалить
}


// ═══════════════════════════════════════════════════════════════════
// ПРИЧИНА 3: Closures держат большие объекты
// ═══════════════════════════════════════════════════════════════════

// ❌ ПЛОХО: closure держит весь bigData
function processData() {
  const bigData = new Array(1000000).fill('x');  // 1MB данных

  return function printLength() {
    // Closure захватывает bigData, даже если нужна только длина!
    console.log(bigData.length);
  };
}

const fn = processData();  // bigData остаётся в памяти!

// ✅ ХОРОШО: сохраняем только нужное
function processData() {
  const bigData = new Array(1000000).fill('x');
  const length = bigData.length;  // Сохраняем только длину

  return function printLength() {
    console.log(length);  // Closure захватывает только number
  };
}
// bigData будет удалён GC после выхода из processData()


// ═══════════════════════════════════════════════════════════════════
// ПРИЧИНА 4: Не отменённые таймеры и интервалы
// ═══════════════════════════════════════════════════════════════════

// ❌ ПЛОХО: интервал продолжает работать
function BadPolling() {
  useEffect(() => {
    setInterval(() => {
      fetchData();  // Продолжает вызываться после unmount!
    }, 5000);
  }, []);
}

// ✅ ХОРОШО: очищаем интервал
function GoodPolling() {
  useEffect(() => {
    const intervalId = setInterval(() => {
      fetchData();
    }, 5000);

    return () => {
      clearInterval(intervalId);  // Останавливаем при unmount
    };
  }, []);
}
```

### Как найти memory leaks в Chrome DevTools

```
Шаг 1: Открой DevTools → Memory

Шаг 2: Сделай Heap Snapshot ПЕРЕД действием
       (нажми "Take snapshot")

Шаг 3: Выполни подозрительное действие
       (например: открой/закрой модальное окно 10 раз)

Шаг 4: Сделай Heap Snapshot ПОСЛЕ действия

Шаг 5: Выбери "Comparison" view

Шаг 6: Смотри что добавилось (+):
       ┌────────────────────────────────────────┐
       │ Constructor        │ # New │ Shallow  │
       ├────────────────────────────────────────┤
       │ (closure)          │  +100 │  +50KB   │ ← Подозрительно!
       │ HTMLDivElement     │  +500 │ +200KB   │ ← Detached nodes?
       │ EventListener      │  +100 │  +10KB   │ ← Не очищенные!
       └────────────────────────────────────────┘

Шаг 7: Кликни на строку → увидишь стек где создан объект

Ключевые слова для поиска:
• "Detached" — отсоединённые DOM ноды
• "EventListener" — не очищенные listeners
• "(closure)" — замыкания, держащие данные
```

---

## Performance Budget: Установи лимиты заранее

```
КОНЦЕПЦИЯ:
Как бюджет для расходов — если потратил на одно,
сэкономь на другом. Общий "бюджет" фиксирован.

┌─────────────────────────────────────────────────────────────────┐
│                     PERFORMANCE BUDGET                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  РАЗМЕР ФАЙЛОВ (gzipped):                                       │
│  ─────────────────────────                                      │
│  JavaScript:      max 200KB    ← Добавляешь библиотеку?        │
│  CSS:             max 50KB       Удали что-то другое!          │
│  Images:          max 500KB                                     │
│  Fonts:           max 100KB                                     │
│                                                                 │
│  МЕТРИКИ:                                                       │
│  ─────────                                                      │
│  LCP:             < 2.5s       (mobile 4G)                      │
│  INP:             < 200ms                                       │
│  CLS:             < 0.1                                         │
│  TTFB:            < 600ms                                       │
│                                                                 │
│  LIGHTHOUSE:                                                    │
│  ───────────                                                    │
│  Performance:     ≥ 90                                          │
│  Accessibility:   ≥ 90                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

CI/CD: Build fails если бюджет превышен!
```

### Автоматическая проверка в CI

```javascript
// ═══════════════════════════════════════════════════════════════════
// Webpack: Ограничение размера bundle
// ═══════════════════════════════════════════════════════════════════

// webpack.config.js
module.exports = {
  mode: 'production',
  performance: {
    // Максимальный размер одного файла (bytes)
    maxAssetSize: 200 * 1024,  // 200KB

    // Максимальный размер точки входа (bytes)
    maxEntrypointSize: 300 * 1024,  // 300KB

    // Что делать при превышении
    hints: 'error'  // 'warning' | 'error' | false

    // error = build fails! PR не мержится.
  }
};

// Результат в CI:
// ERROR: asset main.js (350KB) exceeds the limit (200KB)


// ═══════════════════════════════════════════════════════════════════
// Lighthouse CI: Проверка метрик
// ═══════════════════════════════════════════════════════════════════

// .lighthouserc.js
module.exports = {
  ci: {
    collect: {
      url: ['http://localhost:3000'],  // Какие страницы проверять
      numberOfRuns: 3  // Запустить 3 раза, взять медиану
    },
    assert: {
      assertions: {
        // Performance score >= 90
        'categories:performance': ['error', { minScore: 0.9 }],

        // LCP < 2500ms
        'largest-contentful-paint': ['error', { maxNumericValue: 2500 }],

        // TTI < 3800ms
        'interactive': ['error', { maxNumericValue: 3800 }],

        // CLS < 0.1
        'cumulative-layout-shift': ['error', { maxNumericValue: 0.1 }]
      }
    },
    upload: {
      // Загружать результаты в Lighthouse CI Server (опционально)
      target: 'temporary-public-storage'
    }
  }
};

// В GitHub Actions:
// .github/workflows/lighthouse.yml
/*
name: Lighthouse CI
on: [push]
jobs:
  lighthouse:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm ci && npm run build
      - run: npm run start &  # Запустить сервер
      - run: npx lhci autorun  # Запустить Lighthouse
*/
```

---

## Actionable Checklist

### Frontend Checklist

```
□ Code splitting по роутам (lazy loading)
□ Image optimization:
  □ WebP/AVIF форматы
  □ Responsive images (srcset)
  □ loading="lazy"
  □ Указаны width/height (предотвращает CLS)
□ Tree shaking:
  □ import только нужное из библиотек
  □ Проверить bundle size (webpack-bundle-analyzer)
□ Virtualization для списков > 100 элементов
□ CDN для статики (JS, CSS, images)
□ Performance budget в CI
□ Web Vitals monitoring
```

### Backend Checklist

```
□ N+1 queries исправлены (JOIN или DataLoader)
□ Connection pooling для БД
□ Response compression (gzip/brotli)
□ Кэш для частых запросов (Redis)
□ Streaming для больших ответов
□ Async/parallel для независимых операций
□ Индексы на WHERE/JOIN колонки
□ Rate limiting
□ APM tool (Datadog, New Relic, OpenTelemetry)
□ Slow query logging
```

### Monitoring Checklist

```
□ Core Web Vitals tracking (web-vitals library)
□ Real User Monitoring (RUM)
□ P50/P95/P99 latency dashboards
□ Alerting на:
  □ P95 > threshold
  □ Error rate > threshold
  □ Memory growth (potential leak)
□ Flame graphs для hotspot analysis
```

---

## Типичные ошибки

| Ошибка | Почему плохо | Как правильно |
|--------|-------------|---------------|
| Оптимизация без измерений | Тратишь время на некритичное | Сначала profiler, потом оптимизация |
| Преждевременная оптимизация | Сложный код без выгоды | Keep it simple, оптимизируй когда нужно |
| Синхронные операции в event loop | Блокирует все запросы | Использовать async версии |
| Загрузка всего bundle сразу | Медленный initial load | Code splitting по роутам |
| N+1 queries | 100+ запросов вместо 1 | JOIN или DataLoader |
| Огромные изображения | Медленная загрузка | WebP, srcset, lazy loading |
| Нет performance budget | Незаметная деградация | Автоматические проверки в CI |
| Memory leaks | Растущее потребление памяти | Cleanup в useEffect, remove listeners |

---

## Связи

- [[caching-strategies]] — Кэширование для ускорения
- [[database-design-optimization]] — Оптимизация БД
- [[observability]] — Мониторинг и метрики
- [[architecture-resilience-patterns]] — Resilience patterns (timeouts, fallbacks)

---

## Источники

| # | Источник | Тип | Credibility | Ключевой вклад |
|---|----------|-----|-------------|----------------|
| 1 | [Google Web Vitals](https://web.dev/articles/vitals) | Official | 0.95 | Core Web Vitals определения |
| 2 | [Amazon Latency Study](https://www.gigaspaces.com/blog/amazon-found-every-100ms-of-latency-cost-them-1-in-sales) | Research | 0.90 | 100ms = -1% sales |
| 3 | [Google Speed Research](https://research.google/blog/speed-matters/) | Research | 0.95 | Долгосрочный эффект задержки |
| 4 | [Webpack Tree Shaking](https://webpack.js.org/guides/tree-shaking/) | Official | 0.95 | Как работает tree shaking |
| 5 | [Chrome DevTools Memory](https://developer.chrome.com/docs/devtools/memory-problems) | Official | 0.95 | Отладка memory leaks |
| 6 | [GraphQL DataLoader](https://www.apollographql.com/docs/graphos/schema-design/guides/handling-n-plus-one) | Official | 0.90 | Решение N+1 проблемы |
| 7 | [Node.js Flame Graphs](https://nodejs.org/en/learn/diagnostics/flame-graphs) | Official | 0.95 | Профилирование Node.js |
| 8 | [WPO Stats](https://wpostats.com/tags/revenue/) | Research | 0.85 | Исследования влияния скорости на revenue |
| 9 | [Brendan Gregg Flame Graphs](https://www.brendangregg.com/flamegraphs.html) | Technical | 0.90 | Изобретатель Flame Graphs |
| 10 | [DebugBear Memory Leaks](https://www.debugbear.com/blog/debugging-javascript-memory-leaks) | Technical Blog | 0.85 | Практические примеры утечек |

---

*Проверено: 2026-01-09. Обновлено с исследованием 2024-2025.*

---

## Проверь себя

> [!question]- Сервис отвечает за 200ms (P50), но пользователи жалуются на тормоза. P99 = 4.5s. Почему P50 может быть обманчивой метрикой и какие шаги ты предпримешь для диагностики?
> P50 показывает «типичного» пользователя, но 1% запросов (P99) может быть катастрофически медленным. При 1M запросов в день — это 10 000 пользователей с задержкой 4.5s. Шаги: (1) построить flame graph для медленных запросов, (2) проверить N+1 queries и slow query log, (3) проанализировать tail latency — возможно, проблема в GC паузах, cold cache или connection pool exhaustion. Именно поэтому monitoring должен отслеживать P95/P99, а не только P50.

> [!question]- Команда добавила React-библиотеку графиков (500KB gzipped) для одной страницы dashboard. LCP на главной странице упал с 2.1s до 3.8s. Как такое возможно, если графики только на dashboard, и как это связано с принципами tree shaking и code splitting?
> Если библиотека импортирована через обычный `import` (не `lazy()`), она попадает в основной bundle и загружается на КАЖДОЙ странице, включая главную. Tree shaking не поможет, если библиотека не поддерживает ES modules или имеет side effects. Решение: (1) dynamic import через `lazy()` — библиотека загрузится только на dashboard, (2) проверить `sideEffects` в package.json библиотеки, (3) использовать `webpack-bundle-analyzer` чтобы убедиться, что chunk изолирован. Это пример нарушения performance budget — CI должен был заблокировать PR.

> [!question]- В мобильном приложении (Android/iOS) после 30 минут активного использования приложение начинает лагать, а потом крашится с OOM. Какие паттерны memory leaks из этой статьи применимы к мобильной разработке и чем отличается диагностика?
> Паттерны идентичны: забытые listeners (аналог — не отписанные observers), detached views (аналог — утечки через Context/Activity в Android), closures с большими объектами. Отличия в диагностике: вместо Chrome DevTools Memory используются Android Profiler / LeakCanary (Android) или Instruments / Memory Graph Debugger (iOS). Принцип тот же — snapshot до и после действия, поиск retained objects. Связь с [[android-memory-leaks]] и [[android-performance-profiling]].

> [!question]- Интернет-магазин решил добавить A/B тест: группа A видит страницу с CLS 0.05, группа B — с CLS 0.3 (из-за динамической рекламы). Оцени влияние на конверсию и объясни, почему CLS влияет на бизнес-метрики сильнее, чем кажется.
> CLS 0.3 — это «красная зона» по Google. Пользователи группы B будут промахиваться по кнопкам (классический пример: нажал «Отмена» вместо «Купить»), что вызывает раздражение и потерю доверия. Исследования Google (Bing 2009) показали, что даже небольшие ухудшения UX имеют долгосрочный эффект — пользователи «запоминают» негативный опыт и возвращаются реже даже после исправления. Кроме того, Google учитывает CLS в поисковом ранжировании — плохой CLS ухудшает SEO позиции, что снижает органический трафик.

---

## Ключевые карточки

Что такое правило «Measure First» и почему оно критически важно для оптимизации?
?
Перед любой оптимизацией нужно измерить профайлером, где реальное узкое место (80/20: 20% кода = 80% времени). Без измерений разработчик оптимизирует интуитивно и тратит время на некритичные участки — это «преждевременная оптимизация» по Кнуту.

Какие три метрики входят в Core Web Vitals и каковы их пороги для оценки «Good»?
?
LCP (Largest Contentful Paint) <= 2.5s — скорость загрузки главного контента. INP (Interaction to Next Paint) <= 200ms — отзывчивость на взаимодействия. CLS (Cumulative Layout Shift) <= 0.1 — визуальная стабильность без «прыжков» элементов.

Что такое N+1 Query Problem и какие два основных способа её решения?
?
N+1 — это когда для N элементов делается 1 запрос на список + N отдельных запросов на связанные данные. Решение 1: SQL JOIN — объединить в один запрос. Решение 2: DataLoader (батчинг) — собрать все ID и сделать один WHERE IN запрос.

Чем Promise.all отличается от Promise.allSettled и когда какой использовать?
?
`Promise.all` завершается ошибкой, если хоть один promise rejected — подходит когда нужны все результаты. `Promise.allSettled` возвращает статус каждого promise (fulfilled/rejected) — подходит для graceful degradation, когда страница может отобразиться с неполными данными.

Как виртуализация списков (react-window) снижает нагрузку на браузер?
?
Вместо создания DOM-элементов для всех записей (например, 10 000), виртуализация рендерит только видимые элементы + небольшой буфер (~15 штук). При скролле старые элементы удаляются, новые создаются. Это снижает количество DOM-нод на 99%+.

Что такое Performance Budget и как его автоматизировать в CI?
?
Performance Budget — заранее установленные лимиты на размер файлов (JS <= 200KB gzip) и метрики (LCP < 2.5s). Автоматизация: webpack `performance.hints: 'error'` для размера bundle, Lighthouse CI для метрик — build падает при превышении бюджета.

Как читать Flame Graph: что означают ширина и высота блоков?
?
Ширина блока = сколько CPU-времени функция занимает (чем шире — тем дольше). Высота = глубина стека вызовов (кто кого вызвал). Оптимизировать нужно широкие блоки наверху стека — это реальные hotspot'ы.

Почему streaming responses лучше буферизации при экспорте больших данных?
?
Буферизация загружает все данные в память (1M записей = ~500MB RAM), пользователь ждёт пока всё обработается. Streaming отправляет данные по частям: память константная (~10MB), первые данные уходят через 100ms, сервер может обрабатывать параллельные запросы.

---

## Куда дальше

| Направление | Куда | Зачем |
|-------------|------|-------|
| Обзор области | [[architecture-overview]] | Общая карта архитектурных тем и как performance вписывается в контекст |
| Следующий шаг | [[caching-strategies]] | Кэширование — главный инструмент ускорения после устранения базовых проблем |
| Глубже в тему | [[database-design-optimization]] | Индексы, query optimization, партиционирование — backend bottleneck #1 |
| Мониторинг | [[observability]] | Как собирать метрики P50/P95/P99, настроить alerting и dashboards |
| Устойчивость | [[architecture-resilience-patterns]] | Timeouts, circuit breakers, fallbacks — что делать когда performance деградирует |
| Кросс-домен: сеть | [[network-latency-optimization]] | Оптимизация на сетевом уровне: TCP tuning, CDN, HTTP/2 multiplexing |
| Кросс-домен: мобильные | [[android-performance-profiling]] | Профилирование в Android: systrace, Android Profiler, baseline profiles |
