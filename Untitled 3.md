ARTWORKOUT - ะะะะะซะ ะะะะ ะะะฏ ะะะขะะะะฌะฎ

ะะพะผะฟะปะตะบัะฝะพะต ััะบะพะฒะพะดััะฒะพ: ะะปะณะพัะธัะผั, ะัะฐัะธะบะฐ, ะัะพะธะทะฒะพะดะธัะตะปัะฝะพััั

ะะฒัะพั: Arman Aralbayevะะพะทะธัะธั: Lead Android Developer @ ArtWorkoutะะฐัะฐ: January 2026

  

๐ ะกะะะะะะะะะ

ะงะะกะขะฌ 1: ะะะะะะะขะะซ ะะฆะะะะ ะจะขะะะฅะะ

1.1 ะะฒะตะดะตะฝะธะต: ะะฐัะตะผ ะฝัะถะฝะฐ ะฐะฒัะพะผะฐัะธัะตัะบะฐั ะพัะตะฝะบะฐ  
1.2 Hausdorff Distance - ะณะตะพะผะตััะธัะตัะบะฐั ะฑะปะธะทะพััั  
1.3 Frรฉchet Distance - ััะตั ะฟะพัะปะตะดะพะฒะฐัะตะปัะฝะพััะธ  
1.4 Coverage - ะฟะพะปะฝะพัะฐ ัััะธัะฐ  
1.5 Smoothness - ะฟะปะฐะฒะฝะพััั ะดะฒะธะถะตะฝะธะน  
1.6 Direction - ัะตัะฝะธะบะฐ ัะธัะพะฒะฐะฝะธั  
1.7 Weighted Scoring - ะบะพะผะฑะธะฝะธัะพะฒะฐะฝะฝะฐั ะพัะตะฝะบะฐ

ะงะะกะขะฌ 2: ANDROID CANVAS API

2.1 Canvas basics - ะบะพะพัะดะธะฝะฐัั, ััะฐะฝััะพัะผะฐัะธะธ  
2.2 Path API - ะบัะธะฒัะต ะะตะทัะต, ะพะฟะตัะฐัะธะธ  
2.3 Paint - ััะธะปะธ, ัััะตะบัั, ะฐะฟะฟะฐัะฐัะฝะพะต ััะบะพัะตะฝะธะต  
2.4 Custom View - ะถะธะทะฝะตะฝะฝัะน ัะธะบะป, onDraw  
2.5 Dirty Rectangles - ะพะฟัะธะผะธะทะฐัะธั ะฟะตัะตัะธัะพะฒะบะธ  
2.6 Hardware Acceleration - GPU rendering

ะงะะกะขะฌ 3: OPENGL ES ะ VULKAN

3.1 OpenGL ES basics - pipeline, shaders  
3.2 Texture mapping - ะทะฐะณััะทะบะฐ, ัะธะปัััะฐัะธั  
3.3 Vulkan overview - low-level API  
3.4 ะะพะณะดะฐ ะธัะฟะพะปัะทะพะฒะฐัั Canvas vs OpenGL vs Vulkan

ะงะะกะขะฌ 4: TOUCH EVENTS ะ ะะะกะขะซ

4.1 Touch Event ัะธััะตะผะฐ Android  
4.2 MotionEvent - ะบะพะพัะดะธะฝะฐัั, pressure, timestamp  
4.3 Gesture Detection - ัะฒะฐะนะฟั, pinch, rotate  
4.4 Multi-touch ะพะฑัะฐะฑะพัะบะฐ  
4.5 Palm rejection - ะธะณะฝะพัะธัะพะฒะฐะฝะธะต ะปะฐะดะพะฝะธ  
4.6 Stylus support - ะดะฐะฒะปะตะฝะธะต, ะฝะฐะบะปะพะฝ

ะงะะกะขะฌ 5: ะะะะะะะะะะขะะะฌะะะกะขะฌ ะ ะะะขะะะะะะฆะะฏ

5.1 Frame Budget - 60fps = 16ms  
5.2 Profiling Tools - Systrace, GPU Inspector  
5.3 Bottleneck Detection - CPU vs GPU  
5.4 Background Threading - Coroutines, WorkManager  
5.5 Memory Management - bitmap pools, caching  
5.6 Battery Optimization - reducing wake locks

ะงะะกะขะฌ 6: ะะะฅะะขะะะขะฃะะ ะ DATA MODELS

6.1 Data Models ะดะปั ArtWorkout  
6.2 Normalized Coordinates (0-1)  
6.3 JSON Schema ะธ ะบะพะฝะฒะตััะฐัะธั  
6.4 Lesson Creation Pipeline  
6.5 CDN ะธ asset delivery

ะงะะกะขะฌ 7: ะะะขะะะะฌะฎ - TALKING POINTS

7.1 ะขะฒะพะธ ะพัะฒะตัั ะธะท application  
7.2 ะะฐะบ ะทะฐัะธัะฐัั ะบะฐะถะดัะน ะพัะฒะตั  
7.3 ะกะฒัะทั AR/3D ะพะฟััะฐ ั 2D drawing  
7.4 ะะพะฟัะพัั ะดะปั ะธะฝัะตัะฒััะตัะฐ  
7.5 Red flags ัะตะณะพ ะธะทะฑะตะณะฐัั

  

ะงะะกะขะฌ 1: ะะะะะะะขะะซ ะะฆะะะะ ะจะขะะะฅะะ

1.1 ะะะะะะะะ: ะะะงะะ ะะฃะะะ ะะะขะะะะขะะงะะกะะะฏ ะะฆะะะะ

ะัะพะฑะปะตะผะฐ ััะฐะดะธัะธะพะฝะฝะพะณะพ ะพะฑััะตะฝะธั

ะะปะฐััะธัะตัะบะฐั ะผะพะดะตะปั:

ะฃัะตะฝะธะบ โ ะะธััะตั โ ะะดะตั ััะธัะตะปั โ ะะพะปััะฐะตั feedback ัะตัะตะท ัะฐัั/ะดะฝะธ

ะัะพะฑะปะตะผั:

1. ะะตmะฐัััะฐะฑะธััะตะผะพััั: 1 ััะธัะตะปั ะฝะฐ 30 ััะตะฝะธะบะพะฒ
2. ะะฐะดะตัะถะบะฐ feedback: ะฃะทะฝะฐะตัั ะพะฑ ะพัะธะฑะบะต ะบะพะณะดะฐ ะทะฐะฑัะป ััะพ ะดะตะปะฐะป
3. ะกัะฑัะตะบัะธะฒะฝะพััั: ะะฐะทะฝัะต ััะธัะตะปั - ัะฐะทะฝัะต ะบัะธัะตัะธะธ
4. ะะตะดะพัััะฟะฝะพััั: ะัะถะฝั ะดะตะฝัะณะธ, ะฒัะตะผั, ัะธะทะธัะตัะบะพะต ะฟัะธัััััะฒะธะต

ะะตัะตะฝะธะต ArtWorkout:

ะฃัะตะฝะธะบ โ ะะธััะตั โ ะะะะะะะะะซะ feedback (< 100ms)

ยย ย ย ย โ___________________|

ยย ย ย ย Immediate correction loop

ะะฐััะฝะพะต ะพะฑะพัะฝะพะฒะฐะฝะธะต

Motor Learning Theory (Schmidt & Lee, 2011):

Immediate feedback ััะบะพััะตั learning rate ะฝะฐ 40-60%  
Knowledge of Results (KR) ะดะพะปะถะตะฝ ะฑััั: immediate, specific, actionable

ะขัะธ ัะธะฟะฐ feedback:

1. Knowledge of Performance (KP): ะะฐะบ ัั ะฒัะฟะพะปะฝะธะป ะดะฒะธะถะตะฝะธะต
2. Knowledge of Results (KR): ะะฐะบะพะฒ ัะตะทัะปััะฐั ะดะฒะธะถะตะฝะธั
3. Error Detection: ะะฐะบะธะต ะบะพะฝะบัะตัะฝะพ ะพัะธะฑะบะธ

ArtWorkout ัะตะฐะปะธะทัะตั ะฒัะต ััะธ:

data class StrokeFeedback(

ย ย // KP: ะะฐะบ ัะธัะพะฒะฐะป

ย ย val smoothness: Float,ย ย ย ย // ะะปะฐะฒะฝะพััั ะดะฒะธะถะตะฝะธั

ย ย val consistency: Float, ย ย ย // ะะพะฝัะธััะตะฝัะฝะพััั ัะบะพัะพััะธ

ย ย // KR: ะะตะทัะปััะฐั

ย ย val accuracy: Float,ย ย ย ย ย // ะขะพัะฝะพััั ัะพัะผั

ย ย val completion: Float,ย ย ย ย // ะะพะปะฝะพัะฐ ัััะธัะฐ

ย ย // Error Detection: ะะพะฝะบัะตัะฝัะต ะพัะธะฑะบะธ

ย ย val incorrectSegments: List<Int>,ย // ะะฐะบะธะต ัะฐััะธ ะฝะตะฟัะฐะฒะธะปัะฝัะต

ย ย val deviation: Float,ย ย ย ย ย ย ย // ะะฐัะบะพะปัะบะพ ะพัะบะปะพะฝะธะปัั

ย ย val diagnosis: Stringย ย ย ย ย ย ย // ะงัะพ ะบะพะฝะบัะตัะฝะพ ะธัะฟัะฐะฒะธัั

)

ะะตะดะฐะณะพะณะธัะตัะบะธะน ะดะธะทะฐะนะฝ

Zone of Proximal Development (Vygotsky):

ะกะปะธัะบะพะผ ะปะตะณะบะพ โ ะกะบััะฝะพ โ Quit

ะะฟัะธะผะฐะปัะฝะพย ย โ Flow state โ Learning

ะกะปะธัะบะพะผ ัะปะพะถะฝะพ โ Frustration โ Quit

ะะตะฐะปะธะทะฐัะธั ัะตัะตะท ะฐะดะฐะฟัะธะฒะฝัะต ะฟะพัะพะณะธ:

fun calculateThreshold(

ย ย userSkillLevel: Float, ย ย // 0-1 ะพั ะธััะพัะธะธ

ย ย lessonDifficulty: Floatย ย // 0-1 ะบะพะฝัะธะณััะธััะตะผะพ

): Float {

ย ย // ะะพะฒะธัะบะฐะผ - ัะตะดััะน ะฟะพัะพะณ (30px)

ย ย // ะญะบัะฟะตััะฐะผ - ัััะพะณะธะน ะฟะพัะพะณ (10px)

ย ย return lerp(30f, 10f, userSkillLevel * lessonDifficulty)

}

  

1.2 HAUSDORFF DISTANCE - ะะะะะะขะะะงะะกะะะฏ ะะะะะะกะขะฌ

ะะฝััะธัะธะฒะฝะพะต ะฟะพะฝะธะผะฐะฝะธะต

ะะฝะฐะปะพะณะธั ั ัะตะฝัั:

ะะพะปะพะถะธ ะดะฒะต ะฒะตัะตะฒะบะธ ะฝะฐ ััะพะป. ะะบะปััะธ ะปะฐะผะฟั ัะฒะตััั - ะบะฐะถะดะฐั ะพัะฑัะฐััะฒะฐะตั ัะตะฝั. Hausdorff distance = "ะฝะฐัะบะพะปัะบะพ ะฝัะถะฝะพ ัะฐััะธัะธัั ะพะดะฝั ัะตะฝั, ััะพะฑั ะพะฝะฐ ะะะะะะกะขะฌะฎ ะฝะฐะบััะปะฐ ะดััะณัั ัะตะฝั".

ะะตัะตะฒะบะฐ A (reference):ย โโโโโโโโโโโโโโโ

ะะตัะตะฒะบะฐ B (user): ย ย ย \/\/\/\/\/\/\/\/

  

Hausdorff = ะผะฐะบัะธะผะฐะปัะฝะพะต ัะฐัััะพัะฝะธะต

ะะปััะตัะฝะฐัะธะฒะฝะฐั ะฐะฝะฐะปะพะณะธั - ะทะฐะฑะพั:

ะฃ ัะตะฑั ะตััั ััะฐััะพะบ (reference path). ะกััะพะธัั ะทะฐะฑะพั ะฒะพะบััะณ ะฝะตะณะพ. Hausdorff distance = ะผะธะฝะธะผะฐะปัะฝะฐั ะฒััะพัะฐ ะทะฐะฑะพัะฐ, ััะพะฑั ะพะฝ ะฝะฐะบััะป ะะกะ ัะพัะบะธ ะพะฑะพะธั ะฟััะตะน.

ะะฐัะตะผะฐัะธัะตัะบะพะต ะพะฟัะตะดะตะปะตะฝะธะต

ะะฐะฟัะฐะฒะปะตะฝะฝะพะต ัะฐัััะพัะฝะธะต (ะพะดะฝะพััะพัะพะฝะฝะตะต):

h(A, B) = max { min { d(a, b) } }

ย ย ย ย ย aโA ย bโB

  

ะงะธัะฐะตััั:

"ะะปั ะบะฐะถะดะพะน ัะพัะบะธ a ะฒ ะผะฝะพะถะตััะฒะต A,

ยะฝะฐะนะดะธ ะฑะปะธะถะฐะนััั ัะพัะบั b ะฒ B,

ยะทะฐัะตะผ ะฒะพะทัะผะธ ะะะะกะะะฃะ ััะธั ะผะธะฝะธะผะฐะปัะฝัั ัะฐัััะพัะฝะธะน"

ะกะธะผะผะตััะธัะฝะพะต ัะฐัััะพัะฝะธะต (ะดะฒัััะพัะพะฝะฝะตะต):

H(A, B) = max( h(A,B), h(B,A) )

  

ะะฐัะตะผ ะพะฑะฐ ะฝะฐะฟัะฐะฒะปะตะฝะธั?

- h(AโB): ะะฐัะบะพะปัะบะพ A "ัะพััะธั" ะทะฐ ะฟัะตะดะตะปั B

- h(BโA): ะะฐัะบะพะปัะบะพ B "ัะพััะธั" ะทะฐ ะฟัะตะดะตะปั A

ะะพัะฐะณะพะฒัะน ะฟัะธะผะตั ะฒััะธัะปะตะฝะธั

Reference path A: [(0,0), (1,0), (2,0), (3,0)]ย // ะััะผะฐั ะปะธะฝะธั

User path B:ย ย ย [(0,0.5), (1,0.5), (2,0.5), (3,0.5)]ย // ะะฐัะฐะปะปะตะปัะฝะพ ะฒััะต

  

ะจะะ 1: ะััะธัะปะธัั h(A โ B)

โโโโโโโโโโโโโโโโโโโโโโโโโ

aโ = (0,0)

ย ะัะพะฒะตััะตะผ ะฒัะต ัะพัะบะธ B:

ย - d(aโ, bโ) = d((0,0), (0,0.5)) = 0.5

ย - d(aโ, bโ) = d((0,0), (1,0.5)) = 1.12

ย - d(aโ, bโ) = d((0,0), (2,0.5)) = 2.06

ย - d(aโ, bโ) = d((0,0), (3,0.5)) = 3.04

ย โ min = 0.5 โ

  

aโ = (1,0)

ย โ min ัะฐัััะพัะฝะธะต ะดะพ B = 0.5

  

aโ = (2,0)

ย โ min ัะฐัััะพัะฝะธะต ะดะพ B = 0.5

  

aโ = (3,0)

ย โ min ัะฐัััะพัะฝะธะต ะดะพ B = 0.5

  

h(AโB) = max(0.5, 0.5, 0.5, 0.5) = 0.5

  

ะจะะ 2: ะััะธัะปะธัั h(B โ A)

โโโโโโโโโโโโโโโโโโโโโโโโโ

ะะฝะฐะปะพะณะธัะฝะพ ะดะปั ะฒัะตั ัะพัะตะบ B:

h(BโA) = 0.5

  

ะจะะ 3: ะคะธะฝะฐะปัะฝะพะต ัะฐัััะพัะฝะธะต

โโโโโโโโโโโโโโโโโโโโโโโโโโโโ

H(A, B) = max(0.5, 0.5) = 0.5

  

ะะะขะะะะะะขะะฆะะฏ:

ะััะธ ะฟะฐัะฐะปะปะตะปัะฝั ะฝะฐ ัะฐัััะพัะฝะธะธ 0.5 ะตะดะธะฝะธั ะดััะณ ะพั ะดััะณะฐ.

Kotlin ัะตะฐะปะธะทะฐัะธั ั ะดะตัะฐะปัะฝัะผะธ ะบะพะผะผะตะฝัะฐัะธัะผะธ

import android.graphics.Path

import android.graphics.PathMeasure

import android.graphics.PointF

import kotlin.math.max

import kotlin.math.sqrt

  

/**

ย* ะััะธัะปะตะฝะธะต ัะฐัััะพัะฝะธั ะฅะฐััะดะพััะฐ ะผะตะถะดั ะดะฒัะผั Path ะพะฑัะตะบัะฐะผะธ

ย*ย

ย* ะะะะะะะะะะ:

ย* ะะทะผะตััะตั "ะผะฐะบัะธะผะฐะปัะฝะพะต ะพัะบะปะพะฝะตะฝะธะต" ะผะตะถะดั ะดะฒัะผั ะบัะธะฒัะผะธ.

ย* ะะปั ArtWorkout: ะฟะพะบะฐะทัะฒะฐะตั ะฝะฐัะบะพะปัะบะพ ะดะฐะปะตะบะพ user ััะตะป ะพั reference.

ย*ย

ย* COMPLEXITY: O(n ร m) ะณะดะต n, m - ะบะพะปะธัะตััะฒะพ ัะพัะตะบ

ย* ะะปั 50 ัะพัะตะบ: 50 ร 50 = 2,500 ะพะฟะตัะฐัะธะน (~0.25ms ะฝะฐ ะผะพะฑะธะปัะฝะพะผ) โ

ย*ย

ย* @param pathA Reference path (ะฟัะฐะฒะธะปัะฝัะน ัััะธั)

ย* @param pathB User path (ะฝะฐัะธัะพะฒะฐะฝะฝัะน ัััะธั)

ย* @param sampleCount ะะพะปะธัะตััะฒะพ ัะพัะตะบ ะดะปั ะดะธัะบัะตัะธะทะฐัะธะธ

ย*ย ย ย ย ย ย ย ย ย ย ะะพะปััะต = ัะพัะฝะตะต, ะฝะพ ะผะตะดะปะตะฝะฝะตะต

ย* @return ะะฐัััะพัะฝะธะต ะฒ ะฟะธะบัะตะปัั (0 = ะธะดะตะฐะปัะฝะพะต ัะพะฒะฟะฐะดะตะฝะธะต)

ย*/

fun hausdorffDistance(

ย ย pathA: Path,

ย ย pathB: Path,

ย ย sampleCount: Int = 50

): Float {

ย ย // ะจะะ 1: ะะธัะบัะตัะธะทะฐัะธั ะฟััะตะน

ย ย // Path ะฒ Android - ััะพ ะผะฐัะตะผะฐัะธัะตัะบะฐั ะบัะธะฒะฐั (Bezier splines)

ย ย // ะัะถะฝะพ ะฟัะตะฒัะฐัะธัั ะฒ ัะฟะธัะพะบ ะบะพะฝะบัะตัะฝัั ัะพัะตะบ

ย ย val pointsA = samplePathUniformly(pathA, sampleCount)

ย ย val pointsB = samplePathUniformly(pathB, sampleCount)

ย ย // ะัะพะฒะตัะบะฐ edge cases

ย ย if (pointsA.isEmpty() || pointsB.isEmpty()) {

ย ย ย ย return Float.MAX_VALUEย // Infinite distance ะดะปั ะฟััััั ะฟััะตะน

ย ย }

ย ย // ะจะะ 2: ะััะธัะปะธัั h(A โ B)

ย ย // "ะะปั ะบะฐะถะดะพะน ัะพัะบะธ A ะฝะฐะนัะธ ะฑะปะธะถะฐะนััั ะฒ B"

ย ย val maxDistAtoB = pointsA.maxOf { pointA ->

ย ย ย ย // ะะปั ะญะขะะ ัะพัะบะธ A ะธัะตะผ ะฑะปะธะถะฐะนััั ะฒะพ ะะกะะ B

ย ย ย ย val minDistToB = pointsB.minOf { pointB ->

ย ย ย ย ย ย euclideanDistance(pointA, pointB)

ย ย ย ย }

ย ย ย ย // ะญัะพ ะผะธะฝะธะผะฐะปัะฝะพะต ัะฐัััะพัะฝะธะต ะพั pointA ะดะพ B

ย ย ย ย minDistToB

ย ย }

ย ย // maxOf ะฑะตัะตั ะผะฐะบัะธะผัะผ ััะตะดะธ ะฒัะตั ััะธั ะผะธะฝะธะผะฐะปัะฝัั ัะฐัััะพัะฝะธะน

ย ย // ะจะะ 3: ะััะธัะปะธัั h(B โ A)

ย ย // ะกะธะผะผะตััะธัะฝะพ - ะดะปั ะบะฐะถะดะพะน ัะพัะบะธ B ะฝะฐะนัะธ ะฑะปะธะถะฐะนััั ะฒ A

ย ย val maxDistBtoA = pointsB.maxOf { pointB ->

ย ย ย ย val minDistToA = pointsA.minOf { pointA ->

ย ย ย ย ย ย euclideanDistance(pointA, pointB)

ย ย ย ย }

ย ย ย ย minDistToA

ย ย }

ย ย // ะจะะ 4: ะกะธะผะผะตััะธัะฝะพะต ัะฐัััะพัะฝะธะต

ย ย // ะะตัะตะผ ะผะฐะบัะธะผัะผ ะธะท ะดะฒัั ะฝะฐะฟัะฐะฒะปะตะฝะธะน

ย ย return max(maxDistAtoB, maxDistBtoA)

}

  

/**

ย* ะะฐะฒะฝะพะผะตัะฝะฐั ะดะธัะบัะตัะธะทะฐัะธั ะฟััะธ

ย*ย

ย* ะะะงะะ:

ย* Path - ััะพ ะฝะตะฟัะตััะฒะฝะฐั ะผะฐัะตะผะฐัะธัะตัะบะฐั ััะฝะบัะธั (ะบัะธะฒัะต ะะตะทัะต).

ย* ะะฐะผ ะฝัะถะฝั ะบะพะฝะบัะตัะฝัะต ัะพัะบะธ ะดะปั ััะฐะฒะฝะตะฝะธั.

ย* "ะัะพะฑัะตะผ" ะฟััั ัะตัะตะท ัะฐะฒะฝัะต ะธะฝัะตัะฒะฐะปั.

ย*ย

ย* ะะะะะ: ะัะฟะพะปัะทัะตะผ PathMeasure ะดะปั ัะฐะฒะฝะพะผะตัะฝะพะณะพ ัะฐัะฟัะตะดะตะปะตะฝะธั

ย* ะฟะพ ะะะะะ ะฟััะธ, ะฐ ะฝะต ะฟะพ ะฟะฐัะฐะผะตััั t (ะธะฝะฐัะต ะฑัััััะต ัะฐััะธ

ย* ะฑัะดัั ะธะผะตัั ะผะตะฝััะต ัะพัะตะบ ัะตะผ ะผะตะดะปะตะฝะฝัะต)

ย*ย

ย* @param path Path ะดะปั ะดะธัะบัะตัะธะทะฐัะธะธ

ย* @param numSamples ะะพะปะธัะตััะฒะพ ัะพัะตะบ (ัะตะบะพะผะตะฝะดัะตััั 30-100)

ย* @return List ัะพัะตะบ ัะฐะฒะฝะพะผะตัะฝะพ ัะฐัะฟัะตะดะตะปะตะฝะฝัั ะฟะพ ะดะปะธะฝะต ะฟััะธ

ย*/

fun samplePathUniformly(path: Path, numSamples: Int): List<PointF> {

ย ย val measure = PathMeasure(path, false)

ย ย val totalLength = measure.length

ย ย // ะัะพะฒะตัะบะฐ ะฝะฐ ะฒััะพะถะดะตะฝะฝัะน ัะปััะฐะน

ย ย if (totalLength < 0.001f) {

ย ย ย ย return emptyList()

ย ย }

ย ย val points = mutableListOf<PointF>()

ย ย val pos = FloatArray(2)ย // ะััะตั ะดะปั getPosTan: [x, y]

ย ย val tan = FloatArray(2)ย // ะััะตั ะดะปั tangent (ะฝะต ะธัะฟะพะปัะทัะตะผ, ะฝะพ ะฝัะถะตะฝ ะดะปั API)

ย ย for (i in 0 until numSamples) {

ย ย ย ย // ะััะธัะปะธัั ัะฐัััะพัะฝะธะต ะฒะดะพะปั ะฟััะธ (ะพั 0 ะดะพ totalLength)

ย ย ย ย // ะะฐัะฟัะตะดะตะปัะตะผ ัะฐะฒะฝะพะผะตัะฝะพ: 0%, 2%, 4%, ..., 98%, 100%

ย ย ย ย val distance = (i.toFloat() / (numSamples - 1)) * totalLength

ย ย ย ย // ะะพะปััะธัั ะบะพะพัะดะธะฝะฐัั ัะพัะบะธ ะฝะฐ ะฟััะธ ะฝะฐ ััะพะผ ัะฐัััะพัะฝะธะธ

ย ย ย ย val success = measure.getPosTan(distance, pos, tan)

ย ย ย ย if (success) {

ย ย ย ย ย ย points.add(PointF(pos[0], pos[1]))

ย ย ย ย }

ย ย }

ย ย return points

}

  

/**

ย* ะะฒะบะปะธะดะพะฒะพ ัะฐัััะพัะฝะธะต ะผะตะถะดั ะดะฒัะผั ัะพัะบะฐะผะธ ะฝะฐ ะฟะปะพัะบะพััะธ

ย*ย

ย* ะขะตะพัะตะผะฐ ะะธัะฐะณะพัะฐ: d = โ((xโ-xโ)ยฒ + (yโ-yโ)ยฒ)

ย*ย

ย* @param p1 ะะตัะฒะฐั ัะพัะบะฐ

ย* @param p2 ะัะพัะฐั ัะพัะบะฐ ย

ย* @return ะะฐัััะพัะฝะธะต ะฒ ัะตั ะถะต ะตะดะธะฝะธัะฐั ััะพ ะบะพะพัะดะธะฝะฐัั (ะพะฑััะฝะพ ะฟะธะบัะตะปะธ)

ย*/

fun euclideanDistance(p1: PointF, p2: PointF): Float {

ย ย val dx = p1.x - p2.x

ย ย val dy = p1.y - p2.y

ย ย return sqrt(dx * dx + dy * dy)

}

Computational Complexity - ะฐะฝะฐะปะธะท ะฟัะพะธะทะฒะพะดะธัะตะปัะฝะพััะธ

Naive ะฐะปะณะพัะธัะผ:

ะะฐะฝะพ:

- n ัะพัะตะบ ะฒ pathA

- m ัะพัะตะบ ะฒ pathB

  

ะะปั h(A, B):

ย ะะปั ะบะฐะถะดะพะน ะธะท n ัะพัะตะบ ะฒ A:ย ย ย ย ย ย ย โ ะฒะฝะตัะฝะธะน ัะธะบะป O(n)

ย ย ะัะพะฒะตัะธัั ะฒัะต m ัะพัะตะบ ะฒ B:ย ย ย ย ย ย โ ะฒะฝัััะตะฝะฝะธะน ัะธะบะป O(m)

ย ย ย ะััะธัะปะธัั distanceย ย ย ย ย ย ย ย ย โ O(1)

ย ย ะะทััั minimumย ย ย ย ย ย ย ย ย ย ย ย ย โ O(m)

ย ะะทััั maximumย ย ย ย ย ย ย ย ย ย ย ย ย ย โ O(n)

ย ะัะพะณะพ: O(n ร m) ะพะฟะตัะฐัะธะน

  

ะะปั h(B, A): ะฐะฝะฐะปะพะณะธัะฝะพ O(m ร n)

  

ะะะฉะะฏ ะกะะะะะะกะขะฌ: O(n ร m) + O(m ร n) = O(n ร m)

ะัะฐะบัะธัะตัะบะธะน ัะฐััะตั:

n = m = 50 ัะพัะตะบ (ัะธะฟะธัะฝะพะต ะทะฝะฐัะตะฝะธะต)

ะะฟะตัะฐัะธะน: 50 ร 50 = 2,500 distance ะฒััะธัะปะตะฝะธะน

  

ะะฐ ัะพะฒัะตะผะตะฝะฝะพะผ Android ััััะพะนััะฒะต:

- ะะดะฝะพ distance ะฒััะธัะปะตะฝะธะต: ~100 nanoseconds

- ะัะตะณะพ: 2,500 ร 100ns = 0.25 milliseconds โ

  

Frame budget @ 60fps: 16.67ms

Hausdorff ะทะฐะฝะธะผะฐะตั: 0.25ms (1.5% ะฑัะดะถะตัะฐ)

โ ะะขะะะงะะ, ะดะพััะฐัะพัะฝะพ ะฑััััะพ!

ะะฟัะธะผะธะทะฐัะธะธ ะตัะปะธ ะฝัะถะฝะพ ะตัะต ะฑััััะตะต:

1. ะฃะผะตะฝััะธัั ะบะพะปะธัะตััะฒะพ ัะพัะตะบ:

// Real-time ะฒะพ ะฒัะตะผั ัะธัะพะฒะฐะฝะธั: 20 ัะพัะตะบ

val quickDistance = hausdorffDistance(pathA, pathB, sampleCount = 20)

// 20 ร 20 = 400 ะพะฟะตัะฐัะธะน โ ~0.04ms

  

// ะคะธะฝะฐะปัะฝะฐั ะพัะตะฝะบะฐ ะฟะพัะปะต ะทะฐะฒะตััะตะฝะธั: 100 ัะพัะตะบ

val preciseDistance = hausdorffDistance(pathA, pathB, sampleCount = 100)

// 100 ร 100 = 10,000 ะพะฟะตัะฐัะธะน โ ~1ms (still OK!)

2. Early termination:

fun hausdorffDistanceWithThreshold(

ย ย pathA: Path,

ย ย pathB: Path,

ย ย threshold: Float,ย // ะัะปะธ distance > threshold, ะผะพะถะฝะพ ะพััะฐะฝะพะฒะธัััั

ย ย sampleCount: Int = 50

): Float {

ย ย val pointsA = samplePathUniformly(pathA, sampleCount)

ย ย val pointsB = samplePathUniformly(pathB, sampleCount)

ย ย var maxDistAtoB = 0f

ย ย for (pointA in pointsA) {

ย ย ย ย val minDistToB = pointsB.minOf { pointB ->

ย ย ย ย ย ย euclideanDistance(pointA, pointB)

ย ย ย ย }

ย ย ย ย maxDistAtoB = max(maxDistAtoB, minDistToB)

ย ย ย ย // Early exit: ัะถะต ะฟัะตะฒััะธะปะธ ะฟะพัะพะณ

ย ย ย ย if (maxDistAtoB > threshold) {

ย ย ย ย ย ย return Float.MAX_VALUEย // ะขะพัะฝะพะต ะทะฝะฐัะตะฝะธะต ะฝะต ะฒะฐะถะฝะพ

ย ย ย ย }

ย ย }

ย ย // ะะฝะฐะปะพะณะธัะฝะพ ะดะปั BโA...

ย ย // ...

}

3. Spatial indexing (ะดะปั ะฟัะพะดะฒะธะฝัััั ัะปััะฐะตะฒ):

/**

ย* K-D Tree ะดะปั fast nearest neighbor search

ย*ย

ย* ะะผะตััะพ O(m) ะดะปั ะฟะพะธัะบะฐ ะฑะปะธะถะฐะนัะตะน ัะพัะบะธ โ O(log m)

ย* ะะฑัะฐั ัะปะพะถะฝะพััั: O(n log m) ะฒะผะตััะพ O(n ร m)

ย*/

class KDTree(points: List<PointF>) {

ย ย // ะะพัััะพะตะฝะธะต ะดะตัะตะฒะฐ: O(m log m)

ย ย // ะะพะธัะบ ะฑะปะธะถะฐะนัะตะณะพ: O(log m)

ย ย // ะะตัะฐะปะธ ัะตะฐะปะธะทะฐัะธะธ ะพะฟััะตะฝั ะดะปั ะบัะฐัะบะพััะธ

}

  

fun hausdorffDistanceOptimized(

ย ย pathA: Path,

ย ย pathB: Path,

ย ย sampleCount: Int = 50

): Float {

ย ย val pointsA = samplePathUniformly(pathA, sampleCount)

ย ย val pointsB = samplePathUniformly(pathB, sampleCount)

ย ย // ะะพัััะพะธัั KD-tree ะดะปั B (O(m log m))

ย ย val kdTreeB = KDTree(pointsB)

ย ย // h(AโB) ัะตะฟะตัั O(n log m) ะฒะผะตััะพ O(n ร m)

ย ย val maxDistAtoB = pointsA.maxOf { pointA ->

ย ย ย ย kdTreeB.nearestNeighbor(pointA).distance

ย ย }

ย ย // ะะฝะฐะปะพะณะธัะฝะพ ะดะปั BโA

ย ย // ...

}

ะัะตะธะผััะตััะฒะฐ ะธ ะฝะตะดะพััะฐัะบะธ Hausdorff

โ ะะะะะะฃะฉะะกะขะะ:

1. ะะตััะธัะตัะบะฐั ะธะฝะฒะฐัะธะฐะฝัะฝะพััั

- ะะต ะทะฐะฒะธัะธั ะพั ะบะพะปะธัะตััะฒะฐ ัะพัะตะบ
- ะัััััะน ัััะธั (10 ัะพัะตะบ) vs ะผะตะดะปะตะฝะฝัะน (100 ัะพัะตะบ) - ััะฐะฒะฝะธะผะพ

3. ะะฝััะธัะธะฒะฝะฐั ะธะฝัะตัะฟัะตัะฐัะธั

- ะะตะทัะปััะฐั ะฒ ะฟะธะบัะตะปัั: "ะผะฐะบัะธะผะฐะปัะฝะพะต ะพัะบะปะพะฝะตะฝะธะต 15px"
- ะะตะณะบะพ ัััะฐะฝะพะฒะธัั ะฟะพัะพะณ: "ะดะพะฟัััะธะผะพ ะดะพ 20px"

5. ะััะธัะปะธัะตะปัะฝะฐั ัััะตะบัะธะฒะฝะพััั

- O(n ร m) ะฒะฟะพะปะฝะต ะฟัะธะตะผะปะตะผะพ ะดะปั ะผะพะฑะธะปัะฝัั
- ะะพะถะฝะพ ัะฐัะฟะฐัะฐะปะปะตะปะธัั ะฝะฐ ะฝะตัะบะพะปัะบะพ ะฟะพัะพะบะพะฒ

7. Robustness ะบ ััะผั

- ะะพะบะฐะปัะฝัะต ะฒัะฑัะพัั (outliers) ะฝะต ะบัะธัะธัะฝั
- ะกะผะพััะธั ะฝะฐ worst-case, ััะพ ะฒะฐะถะฝะพ ะดะปั ะพะฑััะตะฝะธั

โ ะะะะะกะขะะขะะ:

1. ะะต ััะธััะฒะฐะตั ะฟะพััะดะพะบ ัะพัะตะบ

ะััั A: 0 โ 1 โ 2 โ 3 (ะฟัะฐะฒะธะปัะฝะพะต ะฝะฐะฟัะฐะฒะปะตะฝะธะต)

ะััั B: 0 โ 3 โ 2 โ 1 (ะทะฐะดะพะผ ะฝะฐะฟะตัะตะด!)

  

Hausdorff ะผะพะถะตั ะฟะพะบะฐะทะฐัั ะผะฐะปะพะต ัะฐัััะพัะฝะธะต! โ

  

ะะะจะะะะ: ะะพะฑะฐะฒะธัั direction validation (ัะผ. ัะตะบัะธั 1.6)

2. ะงัะฒััะฒะธัะตะปะตะฝ ะบ ะดะปะธะฝะต ะฟััะธ

ะััั A: โโโโโโโโโโโโโโโโโโ (ะดะปะธะฝะฝะฐั ะปะธะฝะธั)

ะััั B: โโโโโโโโ ย ย ย ย ย (ะบะพัะพัะบะฐั, ะฝะพ ัะพัะฝะฐั)

  

Hausdorff ะฟะพะบะฐะถะตั ะะะะฌะจะะ ัะฐัััะพัะฝะธะต! โ

(ะะพัะพะผั ััะพ ะบะพะฝะตั A ะดะฐะปะตะบะพ ะพั ะปัะฑะพะน ัะพัะบะธ B)

  

ะะะจะะะะ: ะะพะฑะฐะฒะธัั coverage metric (ัะผ. ัะตะบัะธั 1.4)

3. ะกะธะผะผะตััะธั ะผะพะถะตั ะฑััั ะธะทะฑััะพัะฝะพะน

h(A, B) ะธ h(B, A) ัะฐััะพ ะฟัะธะผะตัะฝะพ ะพะดะธะฝะฐะบะพะฒั

ะะพะถะฝะพ ะพะฟัะธะผะธะทะธัะพะฒะฐัั ะฒััะธัะปะธะฒ ัะพะปัะบะพ ะพะดะฝะพ ะฝะฐะฟัะฐะฒะปะตะฝะธะต

  

ะะพะณะดะฐ ะดะพะฟัััะธะผะพ:

- User path ะฟัะธะผะตัะฝะพ ัะพะน ะถะต ะดะปะธะฝั ััะพ reference

- ะะฑะฐ ะฟััะธ ัะพัะพัะพ covering ะดััะณ ะดััะณะฐ

ะัะฐะบัะธัะตัะบะธะต ะฟัะธะผะตัั

ะัะธะผะตั 1: Circle drawing

// Reference: ะธะดะตะฐะปัะฝัะน ะบััะณ

val referenceCircle = createCirclePath(

ย ย center = PointF(500f, 500f),

ย ย radius = 200f,

ย ย points = 50

)

  

// User attempt 1: ัะพัะพัะธะน ะบััะณ, ะฝะตะผะฝะพะณะพ ัะผะตัะตะฝ

val userAttempt1 = createCirclePath(

ย ย center = PointF(510f, 505f),ย // +10px right, +5px down

ย ย radius = 198f, ย ย ย ย ย ย ย ย // ะงััั ะผะตะฝััะต

ย ย points = 50

)

val distance1 = hausdorffDistance(referenceCircle, userAttempt1)

// Result: ~12px

// ะะฆะะะะ: ACCEPTABLE โ (ะฟะพัะพะณ 20px)

  

// User attempt 2: ะพะฒะฐะป ะฒะผะตััะพ ะบััะณะฐ

val userAttempt2 = createOvalPath(

ย ย center = PointF(500f, 500f),

ย ย radiusX = 250f,ย // ะะฐัััะฝัั ะณะพัะธะทะพะฝัะฐะปัะฝะพ

ย ย radiusY = 200f,

ย ย points = 50

)

val distance2 = hausdorffDistance(referenceCircle, userAttempt2)

// Result: ~50px

// ะะฆะะะะ: REJECTED โ (ัะปะธัะบะพะผ ะดะฐะปะตะบะพ)

  

// User attempt 3: ะฟะพะปะพะฒะธะฝะฐ ะบััะณะฐ

val userAttempt3 = createArcPath(

ย ย center = PointF(500f, 500f),

ย ย radius = 200f,

ย ย startAngle = 0f,

ย ย sweepAngle = 180f,ย // ะขะพะปัะบะพ ะฟะพะปะพะฒะธะฝะฐ!

ย ย points = 25

)

val distance3 = hausdorffDistance(referenceCircle, userAttempt3)

// Result: ~280px

// ะะฆะะะะ: REJECTED โ

// Hausdorff ะพะฑะฝะฐััะถะธะป ััะพ ะฟะพะปะพะฒะธะฝะฐ reference ะฝะต ะฟะพะบัััะฐ!

ะะธะทัะฐะปะธะทะฐัะธั:

Reference (ัะตััะน): ย ย โ

User good (ะทะตะปะตะฝัะน):ย ย โญย (ัััั ัะผะตัะตะฝ, ะฝะพ ะฑะปะธะทะบะพ)

User oval (ะถะตะปััะน): ย ย โฌญย (ัะพัะผะฐ ะฝะตะฟัะฐะฒะธะปัะฝะฐั)

User half (ะบัะฐัะฝัะน):ย ย โย (incomplete)

  

Hausdorff distances:

โ vs โญย โย 12px ย โ PASS

โ vs โฌญย โย 50px ย โ๏ธ MARGINAL

โ vs โย โ 280px ย โ FAIL

ะัะธะผะตั 2: Line drawing

// Reference: ะฟััะผะฐั ะปะธะฝะธั

val referenceLine = Path().apply {

ย ย moveTo(100f, 100f)

ย ย lineTo(500f, 100f)ย // ะะพัะธะทะพะฝัะฐะปัะฝะฐั

}

  

// User 1: ะฟะฐัะฐะปะปะตะปัะฝะฐั ะปะธะฝะธั (offset ะฒะฒะตัั)

val userLine1 = Path().apply {

ย ย moveTo(100f, 90f) ย // -10px ะฟะพ Y

ย ย lineTo(500f, 90f)

}

val dist1 = hausdorffDistance(referenceLine, userLine1)

// Result: 10px (ะฟะพััะพัะฝะฝัะน offset)

// ะะะขะะะะะะขะะฆะะฏ: ะขะพัะฝะฐั ะฟะฐัะฐะปะปะตะปั โ

  

// User 2: ะฒะพะปะฝะธััะฐั ะปะธะฝะธั

val userLine2 = Path().apply {

ย ย moveTo(100f, 100f)

ย ย // ะะพะฑะฐะฒะธะผ ัะธะฝััะพะธะดั

ย ย for (x in 100..500 step 10) {

ย ย ย ย val y = 100f + 20f * sin((x - 100f) / 50f)

ย ย ย ย lineTo(x.toFloat(), y)

ย ย }

}

val dist2 = hausdorffDistance(referenceLine, userLine2)

// Result: ~20px (ะฐะผะฟะปะธััะดะฐ ัะธะฝััะพะธะดั)

// ะะะขะะะะะะขะะฆะะฏ: ะัะพะถะฐัะฐั ััะบะฐ โ๏ธ

  

1.3 FRรCHET DISTANCE - "ะกะะะะะ ะะ ะะะะะะะ"

ะะฝััะธัะธะฒะฝะพะต ะฟะพะฝะธะผะฐะฝะธะต

ะะปะฐััะธัะตัะบะฐั ะฐะฝะฐะปะพะณะธั:

ะขั ะณัะปัะตัั ั ัะพะฑะฐะบะพะน ะฒ ะฟะฐัะบะต.

- ะขั ะธะดะตัั ะฟะพ ะพะดะฝะพะผั ะฟััะธ (reference path)
- ะกะพะฑะฐะบะฐ ะธะดะตั ะฟะพ ะดััะณะพะผั (user path)
- ะั ะพะฑะฐ ะฝะฐ ะฟะพะฒะพะดะบะต

ะัะฐะฒะธะปะฐ ะฟัะพะณัะปะบะธ:

1. ะั ะพะฑะฐ ะฝะฐัะธะฝะฐะตัะต ะฒ ะฝะฐัะฐะปะต ัะฒะพะธั ะฟััะตะน
2. ะั ะพะฑะฐ ะทะฐะบะฐะฝัะธะฒะฐะตัะต ะฒ ะบะพะฝัะต
3. ะะธะบัะพ ะฝะต ะผะพะถะตั ะธะดัะธ ะฝะฐะทะฐะด (ะผะพะฝะพัะพะฝะฝะพััั)
4. ะั ะผะพะถะตัะต ะบะพะฝััะพะปะธัะพะฒะฐัั ัะบะพัะพััั (ััะบะพัััััั/ะทะฐะผะตะดะปััััั)

Frรฉchet distance = ะผะธะฝะธะผะฐะปัะฝะฐั ะดะปะธะฝะฐ ะฟะพะฒะพะดะบะฐ, ะบะพัะพัะฐั ะฟะพะทะฒะพะปะธั ะฒะฐะผ ะพะฑะพะธะผ ะฟัะพะนัะธ ะฒะตัั ะฟััั ะพั ะฝะฐัะฐะปะฐ ะดะพ ะบะพะฝัะฐ.

ะะธะทัะฐะปะธะทะฐัะธั:

  

ะขั: ย ย A โโโโโโ B โโโโโโ C โโโโโโ D

ยย ย ย ย โ ย ย ย โย ย ย ย โย ย ย ย โ

ะะพะฒะพะดะพะบ: โ ย ย ย โย ย ย ย โย ย ย ย โย โ ะะพะปะถะตะฝ ะดะพััะฐัั

ยย ย ย ย โ ย ย ย โย ย ย ย โย ย ย ย โ

ะกะพะฑะฐะบะฐ:ย a โโโโโ b โโโโโโ c โโโโโโ d

  

Frรฉchet = max(ะดะปะธะฝะฐ ะฟะพะฒะพะดะบะฐ ะฒะพ ะฒัะตั ะผะพะผะตะฝัะฐั ะฒัะตะผะตะฝะธ)

ะะพัะตะผั ััะพ ะปัััะต ัะตะผ Hausdorff ะดะปั ัะธัะพะฒะฐะฝะธั?

ะะปััะตะฒะพะต ัะฐะทะปะธัะธะต: ะะพััะดะพะบ ะธะผะตะตั ะทะฝะฐัะตะฝะธะต!

ะกัะตะฝะฐัะธะน: ะะธัะพะฒะฐะฝะธะต ะฑัะบะฒั "S"

Reference (ะฟัะฐะฒะธะปัะฝะฐั S):

ย ย โญโโโฎย ย ย โ ะะตััะฝัั ะดัะณะฐ (ัะธััะตะผ ะะะะะะ)

ย ย โย โ

ย ย โฐโโโค

ยย ย ย โ

ย ย โญโโโฏย ย ย โ ะะธะถะฝัั ะดัะณะฐ (ัะธััะตะผ ะะขะะะะ)

ย ย โย โ

ย ย โฐโโโฏ

  

User (ะะะะะะะะะฌะะะฏ ัะตัะฝะธะบะฐ - ะพะฑัะฐัะฝัะน ะฟะพััะดะพะบ):

ย ย โญโโโฎย ย ย โ ะะฐัะธัะพะฒะฐะป ะะขะะะะ โ

ย ย โย โ

ย ย โฐโโโค

ยย ย ย โ

ย ย โญโโโฏย ย ย โ ะะฐัะธัะพะฒะฐะป ะะะะะซะ โ

ย ย โย โ

ย ย โฐโโโฏ

ะะตะทัะปััะฐัั ะฐะปะณะพัะธัะผะพะฒ:

// Hausdorff: "ะคะพัะผะฐ ัะพะฒะฟะฐะดะฐะตั - ะฒัะต ัะพัะบะธ ะฑะปะธะทะบะพ!"

val hausdorff = hausdorffDistance(correctS, userS)

// Result: ~5px โ ACCEPTED

// ะะะะะะะะ: ะะปะณะพัะธัะผ ะะ ะะะะะขะะ ััะพ ะฟะพััะดะพะบ ะฝะตะฟัะฐะฒะธะปัะฝัะน! โ

  

// Frรฉchet: "ะะพััะดะพะบ ะฝะฐัััะตะฝ - ะฟะพะฒะพะดะพะบ ะดะพะปะถะตะฝ ะฑััั ะพัะตะฝั ะดะปะธะฝะฝัะผ!"

val frechet = frechetDistance(correctS, userS)

// Result: ~150px โ REJECTED

// ะะขะะะงะะ: ะะปะณะพัะธัะผ ะะะะะะฃะะะ ะฝะฐัััะตะฝะธะต ะฟะพััะดะบะฐ! โ

ะะตะดะฐะณะพะณะธัะตัะบะพะต ะทะฝะฐัะตะฝะธะต:

ะ ะฟัะพัะตััะธะพะฝะฐะปัะฝะพะผ ัะธัะพะฒะฐะฝะธะธ/ะบะฐะปะปะธะณัะฐัะธะธ ะฟะพััะดะพะบ ัััะธัะพะฒ ะะะะขะะงะะ:

1. ะะธัะฐะนัะบะธะต ะธะตัะพะณะปะธัั: ะกััะพะณะธะน ะฟะพััะดะพะบ (ไพ: ๆฐธ "ะฒะตัะฝะพััั" - 8 ัััะธัะพะฒ ะฒ ะพะฟัะตะดะตะปะตะฝะฝะพะน ะฟะพัะปะตะดะพะฒะฐัะตะปัะฝะพััะธ)
2. ะัะฐะฑัะบะฐั ะบะฐะปะปะธะณัะฐัะธั: ะะฐะฟัะฐะฒะปะตะฝะธะต ัะฟัะฐะฒะฐ ะฝะฐะปะตะฒะพ ะพะฑัะทะฐัะตะปัะฝะพ
3. ะฅัะดะพะถะตััะฒะตะฝะฝะพะต ัะธัะพะฒะฐะฝะธะต: ะััะตัะฝะฐั ะฟะฐะผััั ัััะพะธััั ะฝะฐ ะฟัะฐะฒะธะปัะฝะพะน ะฟะพัะปะตะดะพะฒะฐัะตะปัะฝะพััะธ
4. ะะฐะปะปะธะณัะฐัะธั: ะัะฐะฒะธะปัะฝัะน ะฟะพััะดะพะบ = ะบัะฐัะธะฒัะต ัะพะตะดะธะฝะตะฝะธั

Frรฉchet ััะพ ะพะฑะตัะฟะตัะธะฒะฐะตั! โ

ะะฐัะตะผะฐัะธัะตัะบะพะต ะพะฟัะตะดะตะปะตะฝะธะต

ะะฐัะฐะผะตััะธะทะฐัะธั ะฟััะตะน:

ะััั ฮฑ (reference): ฮฑ(t), ะณะดะต t โ [0, 1]

ะััั ฮฒ (user):ย ย ย ฮฒ(s), ะณะดะต s โ [0, 1]

  

ฮฑ(0) = ะฝะฐัะฐะปะพ reference path

ฮฑ(1) = ะบะพะฝะตั reference path

  

ะะฝะฐะปะพะณะธัะฝะพ ะดะปั ฮฒ(s)

Frรฉchet distance (continuous version):

F(ฮฑ, ฮฒ) = infย supย d(ฮฑ(t), ฮฒ(ฯ(t)))

ย ย ย ย ย ฯย tโ[0,1]

  

ะะดะต:

- ฯ(t): [0,1] โ [0,1] - ััะฝะบัะธั "ะฟะตัะตะฟะฐัะฐะผะตััะธะทะฐัะธะธ"

- ฯ ะดะพะปะถะฝะฐ ะฑััั:

ย * ะะตะฟัะตััะฒะฝะพะน

ย * ะะพะฝะพัะพะฝะฝะพ ะฒะพะทัะฐััะฐััะตะน

ย * ฯ(0) = 0, ฯ(1) = 1

  

- inf ฯ = ะธะฝัะธะผัะผ ะฟะพ ะฒัะตะผ ะฒะพะทะผะพะถะฝัะผ ะฟะตัะตะฟะฐัะฐะผะตััะธะทะฐัะธัะผ

- sup t = ััะฟัะตะผัะผ ะฟะพ ะฒัะตะผ ะผะพะผะตะฝัะฐะผ ะฒัะตะผะตะฝะธ

ะัะพัััะผะธ ัะปะพะฒะฐะผะธ:

ะั ะธัะตะผ ะะฃะงะจะะ ัะฟะพัะพะฑ ะฟัะพะนัะธ ะพะฑะฐ ะฟััะธ ะพะดะฝะพะฒัะตะผะตะฝะฝะพ (ั ะฒะพะทะผะพะถะฝะพะน ัะฐะทะฝะพะน ัะบะพัะพัััั), ััะพะฑั ะผะธะฝะธะผะธะทะธัะพะฒะฐัั ะผะฐะบัะธะผะฐะปัะฝะพะต ัะฐัััะพัะฝะธะต ะผะตะถะดั ะฝะฐัะธะผะธ ะฟะพะทะธัะธัะผะธ.

Discrete Frรฉchet Distance (ะฟัะฐะบัะธัะตัะบะฐั ะฒะตััะธั)

Continuous Frรฉchet ัะตะพัะตัะธัะตัะบะธ ะบัะฐัะธะฒ, ะฝะพ ะฒััะธัะปะธัะตะปัะฝะพ ัะปะพะถะตะฝ. ะะฐ ะฟัะฐะบัะธะบะต ะธัะฟะพะปัะทัะตะผ Discrete Frรฉchet Distance ั ะดะธะฝะฐะผะธัะตัะบะธะผ ะฟัะพะณัะฐะผะผะธัะพะฒะฐะฝะธะตะผ.

ะะฐะฝะพ:

P = [pโ, pโ, ..., pโ]ย (reference path points)

Q = [qโ, qโ, ..., qโ]ย (user path points)

DP ัะพัะผัะปะฐ:

ะะฐะทะพะฒัะน ัะปััะฐะน:

CA[1,1] = d(pโ, qโ)

  

ะะตะบัััะธะฒะฝัะน ัะปััะฐะน:

CA[i,j] = max(

ย ย d(pแตข, qโฑผ), ย ย ย ย ย ย ย ย // ะะฐัััะพัะฝะธะต ะฒ ัะตะบััะตะน ะฟะฐัะต ัะพัะตะบ

ย ย min(ย ย ย ย ย ย ย ย ย ย ย ย // ะัััะธะน ะฟััั ะธะท ะฟัะตะดัะดััะธั ัะฐะณะพะฒ

ย ย ย ย CA[i-1, j],ย ย // ะะฒะธะณะฐะตะผ ัะพะปัะบะพ P (ัะพะฑะฐะบะฐ ะถะดะตั)

ย ย ย ย CA[i, j-1],ย ย // ะะฒะธะณะฐะตะผ ัะพะปัะบะพ Q (ัั ะถะดะตัั)

ย ย ย ย CA[i-1, j-1] ย // ะะฒะธะณะฐะตะผ ะพะฑะฐ (ะพะฑะฐ ะธะดัั ะฒะผะตััะต)

ย ย )

)

  

ะัะฒะตั:

F(P, Q) = CA[n, m]

ะะฝัะตัะฟัะตัะฐัะธั DP ัะฐะณะพะฒ:

CA[i-1, j]:ย ย ะขั ัะดะตะปะฐะป ัะฐะณ, ัะพะฑะฐะบะฐ ััะพะธั ะฝะฐ ะผะตััะต

ยย ย ย ย ย ย ย โ ะะพะฒะพะดะพะบ ัะฐัััะณะธะฒะฐะตััั

  

CA[i, j-1]:ย ย ะกะพะฑะฐะบะฐ ัะดะตะปะฐะปะฐ ัะฐะณ, ัั ััะพะธัั

ยย ย ย ย ย ย ย โ ะะพะฒะพะดะพะบ ัะฐัััะณะธะฒะฐะตััั

  

CA[i-1, j-1]:ย ะะฑะฐ ะดะตะปะฐัั ัะฐะณ ะพะดะฝะพะฒัะตะผะตะฝะฝะพ

ยย ย ย ย ย ย ย โ ะะพะฒะพะดะพะบ ะผะพะถะตั ัะพะบัะฐัะธัััั ะธะปะธ ะพััะฐัััั ัะฐะบะธะผ ะถะต

  

min(...):ย ย ย ะัะฑะธัะฐะตะผ ะปัััะธะน ะฒะฐัะธะฐะฝั (ะผะธะฝะธะผะฐะปัะฝัะน ะฟะพะฒะพะดะพะบ)

max(...):ย ย ย ะะพ ััะธััะฒะฐะตะผ ัะตะบััะตะต ัะฐัััะพัะฝะธะต (ะผะพะถะตั ะฑััั ะฑะพะปััะต)

ะะพะดัะพะฑะฝัะน ะฟัะธะผะตั ะฒััะธัะปะตะฝะธั

Reference P: [(0,0), (1,0), (2,0)]ย // ะััะผะฐั ะปะธะฝะธั 3 ัะพัะบะธ

User Q:ย ย ย [(0,0), (0,1), (1,1)]ย // L-ะพะฑัะฐะทะฝะฐั ะปะธะฝะธั 3 ัะพัะบะธ

  

ะจะะ 1: ะะพัััะพะธัั ะผะฐััะธัั ัะฐัััะพัะฝะธะน d(pแตข, qโฑผ)

โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

ย ย ย ย ย qโ(0,0) ย qโ(0,1) ย qโ(1,1)

pโ(0,0) ย ย 0.0 ย ย ย 1.0 ย ย ย 1.41

pโ(1,0) ย ย 1.0 ย ย ย 1.41ย ย ย 1.0

pโ(2,0) ย ย 2.0 ย ย ย 2.24ย ย ย 1.41

  

ะจะะ 2: ะะฐะฟะพะปะฝะธัั DP ัะฐะฑะปะธัั CA[i,j]

โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

  

CA[1,1] = d(pโ,qโ) = 0.0ย โ ะะฐะทะพะฒัะน ัะปััะฐะน

  

CA[2,1] = max(

ย ย d(pโ,qโ) = 1.0,

ย ย CA[1,1] = 0.0

) = 1.0

  

CA[1,2] = max(

ย ย d(pโ,qโ) = 1.0,

ย ย CA[1,1] = 0.0

) = 1.0

  

CA[2,2] = max(

ย ย d(pโ,qโ) = 1.41,

ย ย min(

ย ย ย ย CA[1,2] = 1.0, ย // ะะฒะธะณะฐะตะผ ัะพะปัะบะพ P

ย ย ย ย CA[2,1] = 1.0, ย // ะะฒะธะณะฐะตะผ ัะพะปัะบะพ Q

ย ย ย ย CA[1,1] = 0.0ย ย // ะะฒะธะณะฐะตะผ ะพะฑะฐ

ย ย ) = 0.0

) = 1.41

  

CA[3,1] = max(

ย ย d(pโ,qโ) = 2.0,

ย ย CA[2,1] = 1.0

) = 2.0

  

CA[1,3] = max(

ย ย d(pโ,qโ) = 1.41,

ย ย CA[1,2] = 1.0

) = 1.41

  

CA[2,3] = max(

ย ย d(pโ,qโ) = 1.0,

ย ย min(

ย ย ย ย CA[1,3] = 1.41,

ย ย ย ย CA[2,2] = 1.41,

ย ย ย ย CA[1,2] = 1.0

ย ย ) = 1.0

) = 1.0

  

CA[3,2] = max(

ย ย d(pโ,qโ) = 2.24,

ย ย min(

ย ย ย ย CA[2,2] = 1.41,

ย ย ย ย CA[3,1] = 2.0,

ย ย ย ย CA[2,1] = 1.0

ย ย ) = 1.0

) = 2.24

  

CA[3,3] = max(

ย ย d(pโ,qโ) = 1.41,

ย ย min(

ย ย ย ย CA[2,3] = 1.0,

ย ย ย ย CA[3,2] = 2.24,

ย ย ย ย CA[2,2] = 1.41

ย ย ) = 1.0

) = 1.41

  

ะะะะฃะะฌะขะะข:

F(P, Q) = CA[3,3] = 1.41

  

ะะะขะะะะะะขะะฆะะฏ:

ะะธะฝะธะผะฐะปัะฝะฐั ะดะปะธะฝะฐ ะฟะพะฒะพะดะบะฐ = 1.41 ะฟะธะบัะตะปั (โ2)

ะญัะพ ะฟัะพะธััะพะดะธั ะบะพะณะดะฐ ะพะฑะฐ ะฝะฐัะพะดัััั ะฒ ะดะธะฐะณะพะฝะฐะปัะฝะพ ะฟัะพัะธะฒะพะฟะพะปะพะถะฝัั ัะพัะบะฐั.

ะะธะทัะฐะปะธะทะฐัะธั ะพะฟัะธะผะฐะปัะฝะพะณะพ ะฒััะฐะฒะฝะธะฒะฐะฝะธั:

ะะฟัะธะผะฐะปัะฝัะน ะฟััั ัะตัะตะท DP ัะฐะฑะปะธัั:

  

ยย ย ย qโย ย qโย ย qโ

ย ย โโโโโโโโโโโโโโโโโโโ

pโย โ 0.0โ 1.0ย 1.41 โ

ย ย โย โย ย โย ย โย ย โ

pโย โ 1.0ย 1.41โ1.0ย โ

ย ย โย โย ย ย ย โย ย ย โ

pโย โ 2.0ย 2.24ย 1.41 โ

ย ย โโโโโโโโโโโโโโโโโโโ

  

ะััั: (1,1)โ(1,2)โ(2,2)โ(2,3)โ(3,3)

ะกะพะพัะฒะตัััะฒะธั:

- pโ matched ั qโย (distance 0.0)

- pโ matched ั qโย (distance 1.0)ย โ ะกะพะฑะฐะบะฐ ััะปะฐ ะฒะฟะตัะตะด

- pโ matched ั qโย (distance 1.41)

- pโ matched ั qโย (distance 1.0)ย โ ะกะพะฑะฐะบะฐ ัะฝะพะฒะฐ ััะปะฐ ะฒะฟะตัะตะด

- pโ matched ั qโย (distance 1.41)

Kotlin ัะตะฐะปะธะทะฐัะธั ั ะผะตะผะพะธะทะฐัะธะตะน

/**

ย* Discrete Frรฉchet Distance ั ะดะธะฝะฐะผะธัะตัะบะธะผ ะฟัะพะณัะฐะผะผะธัะพะฒะฐะฝะธะตะผ

ย*ย

ย* COMPLEXITY:

ย* - Time: O(n ร m)

ย* - Space: O(n ร m) ะดะปั DP ัะฐะฑะปะธัั

ย*ย

ย* ะะปั 50 ัะพัะตะบ: 50ร50 = 2,500 ะบะปะตัะพะบ ัะฐะฑะปะธัั

ย* Memory: 2,500 ร 4 bytes (Float) = 10 KB โ ะัะธะตะผะปะตะผะพ

ย*ย

ย* @param pathA Reference path

ย* @param pathB User path

ย* @param sampleCount ะะพะปะธัะตััะฒะพ ัะพัะตะบ (ะผะตะฝััะต ัะตะผ Hausdorff ะธะท-ะทะฐ O(nรm) memory)

ย* @return Frรฉchet distance ะฒ ะฟะธะบัะตะปัั

ย*/

fun frechetDistance(

ย ย pathA: Path,

ย ย pathB: Path,

ย ย sampleCount: Int = 30ย // ะะตะฝััะต ัะตะผ ะดะปั Hausdorff

): Float {

ย ย val pointsA = samplePathUniformly(pathA, sampleCount)

ย ย val pointsB = samplePathUniformly(pathB, sampleCount)

ย ย if (pointsA.isEmpty() || pointsB.isEmpty()) {

ย ย ย ย return Float.MAX_VALUE

ย ย }

ย ย val n = pointsA.size

ย ย val m = pointsB.size

ย ย // DP ัะฐะฑะปะธัะฐ: dp[i][j] = Frรฉchet distance ะดะปั ะฟะพะดะฟััะตะน [0..i] ะธ [0..j]

ย ย // ะะฝะธัะธะฐะปะธะทะธััะตะผ ั -1 ะดะปั ะพะฑะพะทะฝะฐัะตะฝะธั "ะฝะต ะฒััะธัะปะตะฝะพ"

ย ย val dp = Array(n) { FloatArray(m) { -1f } }

ย ย // ะะฐะฟััะบะฐะตะผ ัะตะบัััะธะฒะฝะพะต ะฒััะธัะปะตะฝะธะต ั ะผะตะผะพะธะทะฐัะธะตะน

ย ย return computeFrechetDP(pointsA, pointsB, n - 1, m - 1, dp)

}

  

/**

ย* ะะตะบัััะธะฒะฝะฐั ััะฝะบัะธั ั ะผะตะผะพะธะทะฐัะธะตะน

ย*ย

ย* ะััะธัะปัะตั Frรฉchet distance ะดะปั ะฟะพะดะฟััะตะน A[0..i] ะธ B[0..j]

ย*ย

ย* ะะะะะะะะฆะะฏ: ะะตะทัะปััะฐัั ะบััะธัััััั ะฒ dp[][] ััะพะฑั ะธะทะฑะตะถะฐัั

ย* ะฟะพะฒัะพัะฝัั ะฒััะธัะปะตะฝะธะน ะพะดะฝะธั ะธ ัะตั ะถะต ะฟะพะดะทะฐะดะฐั

ย*/

private fun computeFrechetDP(

ย ย A: List<PointF>,

ย ย B: List<PointF>,

ย ย i: Int,

ย ย j: Int,

ย ย dp: Array<FloatArray>

): Float {

ย ย // ะะะะะะซะ ะกะะฃะงะะ: ะฟะตัะฒัะต ัะพัะบะธ ะพะฑะพะธั ะฟััะตะน

ย ย if (i == 0 && j == 0) {

ย ย ย ย return euclideanDistance(A[0], B[0])

ย ย }

ย ย // ะะะะะะะะฆะะฏ: ะฟัะพะฒะตัะบะฐ ะบััะฐ

ย ย if (dp[i][j] > -0.5f) {

ย ย ย ย return dp[i][j]ย // ะฃะถะต ะฒััะธัะปะตะฝะพ ัะฐะฝะตะต

ย ย }

ย ย // ะะฐัััะพัะฝะธะต ะผะตะถะดั ัะตะบััะธะผะธ ัะพัะบะฐะผะธ

ย ย val currentDist = euclideanDistance(A[i], B[j])

ย ย // ะััะธัะปะธัั ัะตะทัะปััะฐั ะฝะฐ ะพัะฝะพะฒะต ะณัะฐะฝะธัะฝัั ััะปะพะฒะธะน ะธ ัะตะบัััะธะธ

ย ย val result = when {

ย ย ย ย // ะะะะะะฆะ: i > 0, j = 0

ย ย ย ย // ะะพะถะตะผ ะดะฒะธะณะฐัั ัะพะปัะบะพ A (P)

ย ย ย ย i > 0 && j == 0 -> {

ย ย ย ย ย ย max(

ย ย ย ย ย ย ย ย computeFrechetDP(A, B, i - 1, 0, dp),ย // ะัะตะดัะดััะฐั ัะพัะบะฐ A

ย ย ย ย ย ย ย ย currentDist ย ย ย ย ย ย ย ย ย ย ย ย ย ย // ะขะตะบััะตะต ัะฐัััะพัะฝะธะต

ย ย ย ย ย ย )

ย ย ย ย }

ย ย ย ย // ะะะะะะฆะ: i = 0, j > 0

ย ย ย ย // ะะพะถะตะผ ะดะฒะธะณะฐัั ัะพะปัะบะพ B (Q)

ย ย ย ย i == 0 && j > 0 -> {

ย ย ย ย ย ย max(

ย ย ย ย ย ย ย ย computeFrechetDP(A, B, 0, j - 1, dp),ย // ะัะตะดัะดััะฐั ัะพัะบะฐ B

ย ย ย ย ย ย ย ย currentDist

ย ย ย ย ย ย )

ย ย ย ย }

ย ย ย ย // ะะะฉะะ ะกะะฃะงะะ: i > 0, j > 0

ย ย ย ย // ะขัะธ ะฒะฐัะธะฐะฝัะฐ ะดะฒะธะถะตะฝะธั

ย ย ย ย else -> {

ย ย ย ย ย ย val d1 = computeFrechetDP(A, B, i - 1, j, dp)ย ย ย // A ะดะฒะธะถะตััั, B ััะพะธั

ย ย ย ย ย ย val d2 = computeFrechetDP(A, B, i, j - 1, dp)ย ย ย // B ะดะฒะธะถะตััั, A ััะพะธั

ย ย ย ย ย ย val d3 = computeFrechetDP(A, B, i - 1, j - 1, dp)ย // ะะฑะฐ ะดะฒะธะถัััั

ย ย ย ย ย ย // ะัะฑะธัะฐะตะผ ะปัััะธะน ะฟััั (min), ะฝะพ ััะธััะฒะฐะตะผ ัะตะบััะตะต ัะฐัััะพัะฝะธะต (max)

ย ย ย ย ย ย max(

ย ย ย ย ย ย ย ย min(d1, d2, d3),ย // ะัััะธะน ะธะท ะฟัะตะดัะดััะธั ะฟััะตะน

ย ย ย ย ย ย ย ย currentDistย ย ย ย // ะขะตะบััะตะต ัะฐัััะพัะฝะธะต ะฝะต ะผะพะถะตั ะฑััั ะผะตะฝััะต

ย ย ย ย ย ย )

ย ย ย ย }

ย ย }

ย ย // ะกะะฅะะะะะขะฌ ะฒ ะบัั

ย ย dp[i][j] = result

ย ย return result

}

Space-optimized ะฒะตััะธั (O(min(n,m)) ะฟะฐะผััั)

ะัะพะฑะปะตะผะฐ: ะะปั ะฑะพะปััะธั ะฟััะตะน (100+ ัะพัะตะบ) ัะฐะฑะปะธัะฐ O(nรm) ะผะพะถะตั ะฑััั ะฑะพะปััะพะน

n = m = 100 ัะพัะตะบ

Memory: 100 ร 100 ร 4 bytes = 40 KBย โ๏ธ ะะฐัะธะฝะฐะตั ะฑััั ะผะฝะพะณะพ ะดะปั ัะฐัััั ะฒััะธัะปะตะฝะธะน

ะะตัะตะฝะธะต: Rolling array - ััะฐะฝะธะผ ัะพะปัะบะพ ะดะฒะต ัััะพะบะธ ะฒะผะตััะพ ะฒัะตะน ัะฐะฑะปะธัั

ะะฐะฑะปัะดะตะฝะธะต: ะะปั ะฒััะธัะปะตะฝะธั CA[i,j] ะฝัะถะฝั ัะพะปัะบะพ:

- CA[i-1, j-1] (ะดะธะฐะณะพะฝะฐะปั ัะฒะตััั-ัะปะตะฒะฐ)
- CA[i-1, j] (ัะฒะตััั)
- CA[i, j-1] (ัะปะตะฒะฐ)

ะขะพ ะตััั ะฝัะถะฝะฐ ัะพะปัะบะพ ะฟัะตะดัะดััะฐั ัััะพะบะฐ ะธ ัะตะบััะฐั ัััะพะบะฐ ะฒ ะฟัะพัะตััะต ะฟะพัััะพะตะฝะธั!

/**

ย* Space-optimized Frรฉchet Distance

ย*ย

ย* COMPLEXITY:

ย* - Time: O(n ร m) - ะฝะต ะธะทะผะตะฝะธะปะฐัั

ย* - Space: O(min(n,m)) - ัะพะปัะบะพ ะดะฒะต ัััะพะบะธ! โ

ย*ย

ย* ะะปั 100 ัะพัะตะบ:

ย* Old: 100 ร 100 ร 4 = 40 KB

ย* New: 2 ร 100 ร 4 = 800 bytesย ๐ 50x ะผะตะฝััะต!

ย*/

fun frechetDistanceOptimized(

ย ย pathA: Path,

ย ย pathB: Path,

ย ย sampleCount: Int = 50ย // ะขะตะฟะตัั ะผะพะถะตะผ ะฑะพะปััะต ัะพัะตะบ

): Float {

ย ย val pointsA = samplePathUniformly(pathA, sampleCount)

ย ย val pointsB = samplePathUniformly(pathB, sampleCount)

ย ย val n = pointsA.size

ย ย val m = pointsB.size

ย ย // ะขะพะปัะบะพ ะะะ ัััะพะบะธ ะฒะผะตััะพ ะฟะพะปะฝะพะน ะผะฐััะธัั nรm

ย ย var prevRow = FloatArray(m)ย // ะัะตะดัะดััะฐั ัััะพะบะฐ

ย ย var currRow = FloatArray(m)ย // ะขะตะบััะฐั ัััะพะบะฐ

ย ย // ะะะะฆะะะะะะะฆะะฏ: ะะตัะฒะฐั ัััะพะบะฐ (i = 0)

ย ย prevRow[0] = euclideanDistance(pointsA[0], pointsB[0])

ย ย for (j in 1 until m) {

ย ย ย ย // CA[0,j] = max(d(pโ,qโฑผ), CA[0,j-1])

ย ย ย ย prevRow[j] = max(

ย ย ย ย ย ย euclideanDistance(pointsA[0], pointsB[j]),

ย ย ย ย ย ย prevRow[j - 1]

ย ย ย ย )

ย ย }

ย ย // ะะะะะะะะะะ: ะััะฐะปัะฝัะต ัััะพะบะธ

ย ย for (i in 1 until n) {

ย ย ย ย // ะะตัะฒัะน ััะพะปะฑะตั ัะตะบััะตะน ัััะพะบะธ

ย ย ย ย currRow[0] = max(

ย ย ย ย ย ย euclideanDistance(pointsA[i], pointsB[0]),

ย ย ย ย ย ย prevRow[0]

ย ย ย ย )

ย ย ย ย // ะััะฐะปัะฝัะต ััะพะปะฑัั

ย ย ย ย for (j in 1 until m) {

ย ย ย ย ย ย val dist = euclideanDistance(pointsA[i], pointsB[j])

ย ย ย ย ย ย currRow[j] = max(

ย ย ย ย ย ย ย ย dist,

ย ย ย ย ย ย ย ย min(

ย ย ย ย ย ย ย ย ย ย prevRow[j],ย ย ย // ะกะฒะตััั: CA[i-1, j]

ย ย ย ย ย ย ย ย ย ย currRow[j - 1],ย // ะกะปะตะฒะฐ: CA[i, j-1]

ย ย ย ย ย ย ย ย ย ย prevRow[j - 1] ย // ะะธะฐะณะพะฝะฐะปั: CA[i-1, j-1]

ย ย ย ย ย ย ย ย )

ย ย ย ย ย ย )

ย ย ย ย }

ย ย ย ย // SWAP ัััะพะบ ะดะปั ัะปะตะดัััะตะน ะธัะตัะฐัะธะธ

ย ย ย ย val temp = prevRow

ย ย ย ย prevRow = currRow

ย ย ย ย currRow = temp

ย ย }

ย ย // ะะตะทัะปััะฐั ะฒ ะฟะพัะปะตะดะฝะตะน ะบะปะตัะบะต ะฟะพัะปะตะดะฝะตะน ัััะพะบะธ

ย ย return prevRow[m - 1]

}

Memory saving:

ะะปั 200 ัะพัะตะบ:

Old approach: 200 ร 200 ร 4 bytes = 160 KB

New approach: 2 ร 200 ร 4 bytes = 1.6 KBย ๐ 100x reduction!

  

1.4 COVERAGE - ะะะะะะขะ ะจะขะะะฅะ

ะงัะพ ะธะทะผะตััะตั coverage?

ะะฟัะตะดะตะปะตะฝะธะต: Coverage = ะฟัะพัะตะฝั reference path, ะบะพัะพััะน "ะฟะพะบััั" user stroke ะฒ ะฟัะตะดะตะปะฐั tolerance radius.

ะัะพััะฐั ะฐะฝะฐะปะพะณะธั - ะดะพัะพะณะฐ:

ะัะตะดััะฐะฒั reference path ะบะฐะบ ะดะพัะพะณั ัะธัะธะฝะพะน 40 ะฟะธะบัะตะปะตะน (tolerance = 20px ั ะบะฐะถะดะพะน ััะพัะพะฝั). User ัะธััะตั ะผะฐัะธะฝะพะน. Coverage = ะบะฐะบะพะน ะฟัะพัะตะฝั ะดะพัะพะณะธ ะฟัะพะตัะฐะปะฐ ะผะฐัะธะฝะฐ?

Reference road (100%):ย โโโโโโโโโโโโโโโโโโโโโโโโ

User drove (60%): ย ย ย โโโโโโโโโโโโ

  

Coverage = 60%ย โ INCOMPLETE

ะะฐัะตะผะฐัะธัะตัะบะพะต ะพะฟัะตะดะตะปะตะฝะธะต

ะะฐะฝั:

- R = {rโ, rโ, ..., rโ} - ัะพัะบะธ reference path

- U = {uโ, uโ, ..., uโ} - ัะพัะบะธ user path ย

- ฯ (tau) = tolerance radius (ะฝะฐะฟัะธะผะตั, 20px)

  

Coverage:

C(R, U, ฯ) = |{rแตข โ R : โuโฑผ โ U, d(rแตข, uโฑผ) < ฯ}| / n

  

ะัะพัััะผะธ ัะปะพะฒะฐะผะธ:

ะะพะดััะธัะฐะน ัะบะพะปัะบะพ ัะพัะตะบ reference ะธะผะตัั ัะพัั ะฑั ะะะะฃ ัะพัะบั user

ะฑะปะธะถะต ัะตะผ ฯ, ัะฐะทะดะตะปะธ ะฝะฐ ะพะฑัะตะต ะบะพะปะธัะตััะฒะพ ัะพัะตะบ reference.

ะัะธะผะตั:

Reference: 10 ัะพัะตะบ

User ะฟะพะบััะป: 7 ัะพัะตะบ (ะฒ ะฟัะตะดะตะปะฐั 20px tolerance)

  

Coverage = 7/10 = 0.7 = 70%

Kotlin ัะตะฐะปะธะทะฐัะธั

/**

ย* Coverage calculator ั ะดะตัะฐะปัะฝะพะน ะธะฝัะพัะผะฐัะธะตะน

ย*ย

ย* @param tolerance ะะฐะดะธัั "ะฟะพะฟะฐะดะฐะฝะธั" ะฒ ะฟะธะบัะตะปัั (default: 20px)

ย* @return CoverageResult ั ะฟะพะดัะพะฑะฝะพะน ะธะฝัะพัะผะฐัะธะตะน

ย*/

data class CoverageResult(

ย ย val coveragePercent: Float, ย ย ย ย ย // 0-100

ย ย val coveredPoints: Int, ย ย ย ย ย ย ย // ะะพะปะธัะตััะฒะพ ะฟะพะบััััั ัะพัะตะบ

ย ย val totalPoints: Int, ย ย ย ย ย ย ย ย // ะัะตะณะพ ัะพัะตะบ ะฒ reference

ย ย val uncoveredSegments: List<IntRange> // ะะฐะบะธะต ัะฐััะธ ะะ ะฟะพะบัััั

)

  

fun calculateDetailedCoverage(

ย ย referencePath: Path,

ย ย userPath: Path,

ย ย tolerance: Float = 20f,

ย ย sampleCount: Int = 50

): CoverageResult {

ย ย val refPoints = samplePathUniformly(referencePath, sampleCount)

ย ย val userPoints = samplePathUniformly(userPath, sampleCount)

ย ย if (refPoints.isEmpty()) {

ย ย ย ย return CoverageResult(0f, 0, 0, emptyList())

ย ย }

ย ย // ะะปั ะบะฐะถะดะพะน reference ัะพัะบะธ ะฟัะพะฒะตัะธัั coverage

ย ย val coverageStatus = BooleanArray(refPoints.size)

ย ย var coveredCount = 0

ย ย for (i in refPoints.indices) {

ย ย ย ย val refPoint = refPoints[i]

ย ย ย ย // ะัะพะฒะตัะธัั ะตััั ะปะธ ัะพัั ะะะะ user ัะพัะบะฐ ะฒ ะฟัะตะดะตะปะฐั tolerance

ย ย ย ย val isCovered = userPoints.any { userPoint ->

ย ย ย ย ย ย euclideanDistance(refPoint, userPoint) < tolerance

ย ย ย ย }

ย ย ย ย if (isCovered) {

ย ย ย ย ย ย coverageStatus[i] = true

ย ย ย ย ย ย coveredCount++

ย ย ย ย }

ย ย }

ย ย // ะะฐะนัะธ ะฝะตะฟะพะบััััะต ัะตะณะผะตะฝัั

ย ย val uncoveredSegments = findUncoveredSegments(coverageStatus)

ย ย val coveragePercent = (coveredCount.toFloat() / refPoints.size) * 100f

ย ย return CoverageResult(

ย ย ย ย coveragePercent = coveragePercent,

ย ย ย ย coveredPoints = coveredCount,

ย ย ย ย totalPoints = refPoints.size,

ย ย ย ย uncoveredSegments = uncoveredSegments

ย ย )

}

  

/**

ย* ะะฐะนัะธ ะฝะตะฟัะตััะฒะฝัะต ัะตะณะผะตะฝัั ะฝะตะฟะพะบััััั ัะพัะตะบ

ย*ย

ย* ะัะธะผะตั: [T,T,F,F,F,T,T,F,T] โ [(2..4), (7..7)]

ย* ย ย ย ย ะะพะบัััะพ: ะธะฝะดะตะบัั 0,1,5,6,8

ย* ย ย ย ย ะะ ะฟะพะบัััะพ: ะธะฝะดะตะบัั 2,3,4 ะธ 7

ย*/

fun findUncoveredSegments(coverage: BooleanArray): List<IntRange> {

ย ย val segments = mutableListOf<IntRange>()

ย ย var segmentStart: Int? = null

ย ย for (i in coverage.indices) {

ย ย ย ย if (!coverage[i]) {

ย ย ย ย ย ย // ะะฐัะฐะปะพ ะฝะตะฟะพะบัััะพะณะพ ัะตะณะผะตะฝัะฐ

ย ย ย ย ย ย if (segmentStart == null) {

ย ย ย ย ย ย ย ย segmentStart = i

ย ย ย ย ย ย }

ย ย ย ย } else {

ย ย ย ย ย ย // ะะพะฝะตั ะฝะตะฟะพะบัััะพะณะพ ัะตะณะผะตะฝัะฐ

ย ย ย ย ย ย if (segmentStart != null) {

ย ย ย ย ย ย ย ย segments.add(segmentStart until i)

ย ย ย ย ย ย ย ย segmentStart = null

ย ย ย ย ย ย }

ย ย ย ย }

ย ย }

ย ย // ะะฐะบัััั ะฟะพัะปะตะดะฝะธะน ัะตะณะผะตะฝั ะตัะปะธ ะพะฝ ะดะพ ะบะพะฝัะฐ

ย ย if (segmentStart != null) {

ย ย ย ย segments.add(segmentStart until coverage.size)

ย ย }

ย ย return segments

}

ะะฐะบ ะฒัะฑัะฐัั tolerance radius?

ะะฝะพะถะตััะฒะพ ัะฐะบัะพัะพะฒ ะฒะปะธััั ะฝะฐ ะพะฟัะธะผะฐะปัะฝัะน tolerance:

1. ะะฐะทะผะตั ัะบัะฐะฝะฐ:

fun getToleranceForScreenSize(screenWidthPx: Int): Float {

ย ย return when {

ย ย ย ย screenWidthPx < 720ย -> 15fย // Small phone (480p)

ย ย ย ย screenWidthPx < 1080 -> 20fย // Normal phone (720p)

ย ย ย ย screenWidthPx < 1440 -> 25fย // Large phone (1080p)

ย ย ย ย else ย ย ย ย ย ย ย ย -> 30fย // Tablet (1440p+)

ย ย }

}

  

// ะะฑัััะฝะตะฝะธะต: ะะฐ ะฑะพะปััะธั ัะบัะฐะฝะฐั ัะพัะฝะพััั ะฟะฐะปััะฐ ััะถะต

// (ัะธะทะธัะตัะบะธะน ะฟะฐะปะตั ะพะดะธะฝะฐะบะพะฒัะน, ะฝะพ ัะบัะฐะฝ ะฑะพะปััะต)

2. ะกะปะพะถะฝะพััั ััะพะบะฐ:

fun getToleranceForDifficulty(difficulty: Float): Float {

ย ย // ะะธะฝะตะนะฝะฐั ะธะฝัะตัะฟะพะปััะธั

ย ย // Beginner (0.0) โ 30px (ัะตะดััะน)

ย ย // Expert (1.0) โ 10px (ัััะพะณะธะน)

ย ย return 30f - (difficulty * 20f)

}

3. ะะฐะทะผะตั ัััะธัะฐ:

fun getToleranceForStrokeWidth(strokeWidth: Float): Float {

ย ย // Tolerance ะฟัะพะฟะพััะธะพะฝะฐะปะตะฝ ัะธัะธะฝะต ะบะธััะธ

ย ย // ะจะธัะพะบะฐั ะบะธััั = ะฑะพะปััะต tolerance

ย ย return strokeWidth * 2.5f

}

4. ะขะธะฟ ะฒะฒะพะดะฐ (ะฟะฐะปะตั vs stylus):

enum class InputType {

ย ย FINGER,ย // ะะตะฝะตะต ัะพัะฝัะน

ย ย STYLUS,ย // ะะพะปะตะต ัะพัะฝัะน

ย ย MOUSEย ย // ะกัะตะดะฝัั ัะพัะฝะพััั

}

  

fun getToleranceForInputType(inputType: InputType): Float {

ย ย return when (inputType) {

ย ย ย ย InputType.FINGER -> 25fย // ะะฐะปะตั ัะพะปัััะน

ย ย ย ย InputType.STYLUS -> 15fย // ะกัะธะปัั ัะพะฝะบะธะน

ย ย ย ย InputType.MOUSEย -> 20fย // ะััั ััะตะดะฝัั

ย ย }

}

ะะพะผะฑะธะฝะธัะพะฒะฐะฝะฝัะน ัะฐััะตั:

fun calculateOptimalTolerance(

ย ย screenWidth: Int,

ย ย difficulty: Float,

ย ย strokeWidth: Float,

ย ย inputType: InputType

): Float {

ย ย val factors = listOf(

ย ย ย ย getToleranceForScreenSize(screenWidth),

ย ย ย ย getToleranceForDifficulty(difficulty),

ย ย ย ย getToleranceForStrokeWidth(strokeWidth),

ย ย ย ย getToleranceForInputType(inputType)

ย ย )

ย ย // ะกัะตะดะฝะตะฒะทะฒะตัะตะฝะฝะพะต (ะธะปะธ ะฟัะพััะพ ััะตะดะฝะตะต)

ย ย return factors.average().toFloat()

}

Coverage vs Hausdorff: ะะพะผะฟะปะตะผะตะฝัะฐัะฝัะต ะผะตััะธะบะธ

Coverage ะพัะฒะตัะฐะตั: "ะะพะปะฝัะน ะปะธ ัััะธั?"Hausdorff ะพัะฒะตัะฐะตั: "ะะฐัะบะพะปัะบะพ ัะพัะฝัะน ัััะธั?"

ะะฑะฐ ะฝัะถะฝั!

fun evaluateStroke(

ย ย referencePath: Path,

ย ย userPath: Path

): StrokeEvaluation {

ย ย val coverage = calculateCoverage(referencePath, userPath)

ย ย val hausdorff = hausdorffDistance(referencePath, userPath)

ย ย val passedCoverage = coverage.coveragePercent >= 70fย // ะะธะฝะธะผัะผ 70%

ย ย val passedAccuracy = hausdorff < 20fย ย ย ย ย ย ย ย ย // ะะฐะบัะธะผัะผ 20px

ย ย return when {

ย ย ย ย passedCoverage && passedAccuracy ->ย

ย ย ย ย ย ย StrokeEvaluation.EXCELLENT

ย ย ย ย passedCoverage && !passedAccuracy ->ย

ย ย ย ย ย ย StrokeEvaluation.COMPLETE_BUT_INACCURATEย // ะัะพัะตะป ะฒะตัั ะฟััั, ะฝะพ ะบัะธะฒะพ

ย ย ย ย !passedCoverage && passedAccuracy ->ย

ย ย ย ย ย ย StrokeEvaluation.ACCURATE_BUT_INCOMPLETEย // ะขะพัะฝะพ, ะฝะพ ะฝะต ะทะฐะบะพะฝัะธะป

ย ย ย ย else ->ย

ย ย ย ย ย ย StrokeEvaluation.FAILED

ย ย }

}

ะัะธะผะตัั:

Scenario 1: ะฅะพัะพัะธะน ัััะธั

โโโโโโโโโโโโโโโโโโโโโโโโโ

Reference: โโโโโโโโโโโโโโ

User:ย ย ย โโโโโโโโโโโโโโย (ะฑะปะธะทะบะพ ะธ ะฟะพะปะฝะพัััั)

  

Coverage: 95%ย โ

Hausdorff: 5px โ

โ EXCELLENT

  

Scenario 2: ะะพะปะฝัะน ะฝะพ ะบัะธะฒะพะน

โโโโโโโโโโโโโโโโโโโโโโโโโโโโ

Reference: โโโโโโโโโโโโโโ

User:ย ย ย \/\/\/\/\/\/\/ (ะฒะพะปะฝะธัััะน, ะฝะพ ะฒะตัั ะฟััั)

  

Coverage: 90%ย โ

Hausdorff: 25px โ

โ COMPLETE_BUT_INACCURATE

  

Scenario 3: ะขะพัะฝัะน ะฝะพ ะบะพัะพัะบะธะน

โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

Reference: โโโโโโโโโโโโโโ

User:ย ย ย โโโโโโ ย ย ย ย (ัะพัะฝะพ, ะฝะพ ะฟะพะปะพะฒะธะฝะฐ)

  

Coverage: 50%ย โ

Hausdorff: 3px โ

โ ACCURATE_BUT_INCOMPLETE

  

Scenario 4: ะัะพะฒะฐะป

โโโโโโโโโโโโโโโโโโ

Reference: โโโโโโโโโโโโโโ

User:ย ย ย \/\/\/ ย ย ย ย (ะบัะธะฒะพะน ะธ ะบะพัะพัะบะธะน)

  

Coverage: 40%ย โ

Hausdorff: 30px โ

โ FAILED

  

1.5 SMOOTHNESS - ะะะะะะะกะขะฌ ะะะะะะะะ

ะะฐัะตะผ ะธะทะผะตัััั smoothness?

ะขัะธ ะฟะตะดะฐะณะพะณะธัะตัะบะธะต ะฟัะธัะธะฝั:

1. ะฃะฒะตัะตะฝะฝะพััั vs ะฝะตัะฒะตัะตะฝะฝะพััั:

ะัะพัะตััะธะพะฝะฐะปัะฝัะน ััะดะพะถะฝะธะบ:ย โโโโโโโโย (smooth, confident stroke)

ะะพะฒะธัะพะบ:ย ย ย ย ย ย ย ย ย ย \/\/\/\/ย (hesitant, jittery)

2. ะัะตะดะพัะฒัะฐัะตะฝะธะต ะพะฑะผะฐะฝะฐ:

User ะผะพะถะตั ะผะตะดะปะตะฝะฝะพ "ะพะฑะฒะพะดะธัั" reference ะผะฝะพะณะพ ัะฐะท

ะบัะพัะตัะฝัะผะธ ะดะฒะธะถะตะฝะธัะผะธ โ ัะตัะฝะธัะตัะบะธ coverage 100%

ะะ ััะพ ะะ ััะธั ะฟัะฐะฒะธะปัะฝะพะน ัะตัะฝะธะบะต!

  

Smoothness ะพะฑะฝะฐััะถะธะฒะฐะตั ัะฐะบะพะต ะฟะพะฒะตะดะตะฝะธะต โ

3. ะััะตัะฝะฐั ะฟะฐะผััั:

ะัะพัะตััะธะพะฝะฐะปัะฝะพะต ัะธัะพะฒะฐะฝะธะต ััะตะฑัะตั confident, flowing strokes

Smoothness metric ะฟะพะพัััะตั ัะฐะทะฒะธัะธะต ะฟัะฐะฒะธะปัะฝะพะน muscle memory

ะขัะธ ะผะตัะพะดะฐ ะธะทะผะตัะตะฝะธั smoothness

ะะตัะพะด 1: Velocity Variance (ะดะธัะฟะตััะธั ัะบะพัะพััะธ)

ะะดะตั: ะะปะฐะฒะฝัะน ัััะธั = ัะฐะฒะฝะพะผะตัะฝะฐั ัะบะพัะพััั

ะะฐัะตะผะฐัะธะบะฐ:

Velocity ะผะตะถะดั ัะพัะตะดะฝะธะผะธ ัะพัะบะฐะผะธ:

vแตข = distance(pแตขโโ, pแตข) / ฮtแตข

  

ะะดะต ฮtแตข = timestamp[i] - timestamp[i-1]

  

Mean velocity:

vฬ = (ฮฃ vแตข) / n

  

Variance:

ฯยฒ = ฮฃ(vแตข - vฬ)ยฒ / n

  

Smoothness score:

S = 1 / (1 + ฯยฒ)ย โ ะััะพะบะฐั variance = ะฝะธะทะบะฐั smoothness

Kotlin ัะตะฐะปะธะทะฐัะธั:

/**

ย* Smoothness ัะตัะตะท velocity variance

ย*ย

ย* @param timestamps ะัะตะผะตะฝะฝัะต ะผะตัะบะธ ะดะปั ะบะฐะถะดะพะน ัะพัะบะธ (milliseconds)

ย* @return Score 0-1 (1 = ะธะดะตะฐะปัะฝะพ ะฟะปะฐะฒะฝะพ)

ย*/

fun smoothnessVelocityVariance(

ย ย userPath: Path,

ย ย timestamps: List<Long>? = null,

ย ย sampleCount: Int = 50

): Float {

ย ย val points = samplePathUniformly(userPath, sampleCount)

ย ย if (points.size < 3) {

ย ย ย ย return 1.0fย // ะกะปะธัะบะพะผ ะผะฐะปะพ ัะพัะตะบ ะดะปั ะพัะตะฝะบะธ

ย ย }

ย ย // ะััะธัะปะธัั velocities

ย ย val velocities = mutableListOf<Float>()

ย ย for (i in 1 until points.size) {

ย ย ย ย val distance = euclideanDistance(points[i - 1], points[i])

ย ย ย ย val deltaTime = if (timestamps != null && i < timestamps.size) {

ย ย ย ย ย ย // ะัะฟะพะปัะทัะตะผ ัะตะฐะปัะฝะพะต ะฒัะตะผั

ย ย ย ย ย ย (timestamps[i] - timestamps[i - 1]).toFloat() / 1000fย // ms to seconds

ย ย ย ย } else {

ย ย ย ย ย ย // ะัะตะดะฟะพะปะฐะณะฐะตะผ uniform timing

ย ย ย ย ย ย 1.0f

ย ย ย ย }

ย ย ย ย // ะกะบะพัะพััั = ัะฐัััะพัะฝะธะต / ะฒัะตะผั

ย ย ย ย val velocity = if (deltaTime > 0.001f) distance / deltaTime else 0f

ย ย ย ย velocities.add(velocity)

ย ย }

ย ย // ะััะธัะปะธัั variance

ย ย val meanVelocity = velocities.average().toFloat()

ย ย val variance = velocities.map { v ->

ย ย ย ย val diff = v - meanVelocity

ย ย ย ย diff * diff

ย ย }.average().toFloat()

ย ย // ะะพัะผะฐะปะธะทะพะฒะฐัั: ะฒััะพะบะฐั variance = ะฝะธะทะบะฐั smoothness

ย ย // Exponential decay ะดะปั mapping variance โ score

ย ย val smoothness = exp(-variance / 1000f)

ย ย return smoothness.coerceIn(0f, 1f)

}

ะะตัะพะด 2: Curvature Variance (ะดะธัะฟะตััะธั ะบัะธะฒะธะทะฝั)

ะะดะตั: ะะปะฐะฒะฝะฐั ะบัะธะฒะฐั = ะฟะพััะตะฟะตะฝะฝะพะต ะธะทะผะตะฝะตะฝะธะต ะบัะธะฒะธะทะฝั (ะฑะตะท ัะตะทะบะธั ะฟะพะฒะพัะพัะพะฒ)

ะัะธะฒะธะทะฝะฐ (curvature):

ะะปั ััะตั ะฟะพัะปะตะดะพะฒะฐัะตะปัะฝัั ัะพัะตะบ pโ, pโ, pโ ะบัะธะฒะธะทะฝะฐ ะธะทะผะตััะตั "ะฝะฐัะบะพะปัะบะพ ัะตะทะบะพ" ะฟะพะฒะพัะฐัะธะฒะฐะตั ะปะธะฝะธั.

Menger curvature formula:

ฮบ = 4 ร Area(triangle pโpโpโ) / (|pโpโ| ร |pโpโ| ร |pโpโ|)

  

Area ะฒััะธัะปัะตััั ัะตัะตะท cross product:

Area = |(xโ-xโ)(yโ-yโ) - (xโ-xโ)(yโ-yโ)| / 2

ะะธะทัะฐะปะธะทะฐัะธั:

ะะปะฐะฒะฝะฐั ะบัะธะฒะฐั:ย ย ย โญโโโโฎ

ยย ย ย ย ย ย ย ย ย ย โ ย โ

ะัะธะฒะธะทะฝะฐ:ย ย ย ย ย ย โโโโโโโโโย โ ะะพััะตะฟะตะฝะฝะพะต ะธะทะผะตะฝะตะฝะธะต

  

ะะตะทะบะฐั ะบัะธะฒะฐั: ย ย ย โโโ

ยย ย ย ย ย ย ย ย ย ย โ โโโ

ะัะธะฒะธะทะฝะฐ:ย ย ย ย ย ย โโโโโโโโโย โ ะะตะทะบะธะน spike

Kotlin ัะตะฐะปะธะทะฐัะธั:

/**

ย* Smoothness ัะตัะตะท curvature variance

ย*/

fun smoothnessCurvature(

ย ย userPath: Path,

ย ย sampleCount: Int = 50

): Float {

ย ย val points = samplePathUniformly(userPath, sampleCount)

ย ย if (points.size < 3) return 1.0f

ย ย val curvatures = mutableListOf<Float>()

ย ย // ะััะธัะปะธัั ะบัะธะฒะธะทะฝั ะฒ ะบะฐะถะดะพะน ัะพัะบะต

ย ย for (i in 1 until points.size - 1) {

ย ย ย ย val p0 = points[i - 1]

ย ย ย ย val p1 = points[i]

ย ย ย ย val p2 = points[i + 1]

ย ย ย ย // ะะปะพัะฐะดั ััะตัะณะพะปัะฝะธะบะฐ ัะตัะตะท cross product

ย ย ย ย val area = abs(

ย ย ย ย ย ย (p1.x - p0.x) * (p2.y - p0.y) -ย

ย ย ย ย ย ย (p2.x - p0.x) * (p1.y - p0.y)

ย ย ย ย ) / 2f

ย ย ย ย // ะะปะธะฝั ััะพัะพะฝ

ย ย ย ย val a = euclideanDistance(p0, p1)

ย ย ย ย val b = euclideanDistance(p1, p2)

ย ย ย ย val c = euclideanDistance(p0, p2)

ย ย ย ย // Menger curvature

ย ย ย ย val curvature = if (a * b * c > 0.001f) {

ย ย ย ย ย ย 4f * area / (a * b * c)

ย ย ย ย } else {

ย ย ย ย ย ย 0fย // ะััะผะฐั ะปะธะฝะธั (ะดะตะปะตะฝะธะต ะฝะฐ ะฝะพะปั)

ย ย ย ย }

ย ย ย ย curvatures.add(curvature)

ย ย }

ย ย // ะััะธัะปะธัั variance ะบัะธะฒะธะทะฝั

ย ย val meanCurvature = curvatures.average().toFloat()

ย ย val variance = curvatures.map { k ->

ย ย ย ย val diff = k - meanCurvature

ย ย ย ย diff * diff

ย ย }.average().toFloat()

ย ย // ะะธะทะบะฐั variance = ะฟะปะฐะฒะฝะฐั ะบัะธะฒะฐั

ย ย val smoothness = exp(-variance * 10f)

ย ย return smoothness.coerceIn(0f, 1f)

}

ะะตัะพะด 3: Direction Change Detection (ัะตะทะบะธะต ะฟะพะฒะพัะพัั)

ะะดะตั: ะะพะดััะธัะฐัั ะบะพะปะธัะตััะฒะพ ัะตะทะบะธั ะธะทะผะตะฝะตะฝะธะน ะฝะฐะฟัะฐะฒะปะตะฝะธั

Kotlin ัะตะฐะปะธะทะฐัะธั:

/**

ย* Smoothness ัะตัะตะท ะฟะพะดััะตั ัะตะทะบะธั ะฟะพะฒะพัะพัะพะฒ

ย*ย

ย* @param angleThreshold ะฃะณะพะป ะฒ ะณัะฐะดััะฐั ััะธัะฐััะธะนัั "ัะตะทะบะธะผ" (default: 30ยฐ)

ย*/

fun smoothnessDirectionChanges(

ย ย userPath: Path,

ย ย angleThreshold: Float = 30f,

ย ย sampleCount: Int = 50

): Float {

ย ย val points = samplePathUniformly(userPath, sampleCount)

ย ย if (points.size < 3) return 1.0f

ย ย var sharpTurns = 0

ย ย for (i in 2 until points.size) {

ย ย ย ย // ะะตะบัะพั ะพั ัะพัะบะธ i-2 ะดะพ i-1

ย ย ย ย val v1 = Vector2(

ย ย ย ย ย ย points[i - 1].x - points[i - 2].x,

ย ย ย ย ย ย points[i - 1].y - points[i - 2].y

ย ย ย ย )

ย ย ย ย // ะะตะบัะพั ะพั ัะพัะบะธ i-1 ะดะพ i

ย ย ย ย val v2 = Vector2(

ย ย ย ย ย ย points[i].x - points[i - 1].x,

ย ย ย ย ย ย points[i].y - points[i - 1].y

ย ย ย ย )

ย ย ย ย // ะฃะณะพะป ะผะตะถะดั ะฒะตะบัะพัะฐะผะธ

ย ย ย ย val angle = angleBetweenVectors(v1, v2)

ย ย ย ย if (angle > angleThreshold) {

ย ย ย ย ย ย sharpTurns++

ย ย ย ย }

ย ย }

ย ย // Normalize: ะผะตะฝััะต ะฟะพะฒะพัะพัะพะฒ = ะฒััะต smoothness

ย ย val turnRate = sharpTurns.toFloat() / points.size

ย ย val smoothness = 1f - turnRate

ย ย return smoothness.coerceIn(0f, 1f)

}

  

/**

ย* ะฃะณะพะป ะผะตะถะดั ะดะฒัะผั ะฒะตะบัะพัะฐะผะธ ะฒ ะณัะฐะดััะฐั

ย*ย

ย* ะัะฟะพะปัะทัะตั dot product: a ยท b = |a| |b| cos(ฮธ)

ย*/

fun angleBetweenVectors(v1: Vector2, v2: Vector2): Float {

ย ย val dotProduct = v1.x * v2.x + v1.y * v2.y

ย ย val magnitudes = v1.length() * v2.length()

ย ย if (magnitudes < 0.001f) return 0f

ย ย val cosTheta = (dotProduct / magnitudes).coerceIn(-1f, 1f)

ย ย val angleRad = acos(cosTheta)

ย ย return Math.toDegrees(angleRad.toDouble()).toFloat()

}

  

data class Vector2(val x: Float, val y: Float) {

ย ย fun length() = sqrt(x * x + y * y)

}

ะะพะผะฑะธะฝะธัะพะฒะฐะฝะฝะฐั ะพัะตะฝะบะฐ smoothness

/**

ย* Comprehensive smoothness evaluation

ย*/

data class SmoothnessAnalysis(

ย ย val velocityScore: Float,ย ย ย // 0-1

ย ย val curvatureScore: Float, ย ย // 0-1

ย ย val directionScore: Float, ย ย // 0-1

ย ย val combinedScore: Float,ย ย ย // 0-1

ย ย val diagnosis: Stringย ย ย ย ย // Feedback ะดะปั ะฟะพะปัะทะพะฒะฐัะตะปั

)

  

fun analyzeSmoothnessComprehensive(

ย ย userPath: Path,

ย ย timestamps: List<Long>? = null

): SmoothnessAnalysis {

ย ย val velocity = smoothnessVelocityVariance(userPath, timestamps)

ย ย val curvature = smoothnessCurvature(userPath)

ย ย val direction = smoothnessDirectionChanges(userPath)

ย ย // ะะทะฒะตัะตะฝะฝะฐั ะบะพะผะฑะธะฝะฐัะธั

ย ย val combined = (

ย ย ย ย velocity * 0.4f +ย ย ย // Velocity variance ะฝะฐะธะฑะพะปะตะต ะฒะฐะถะฝะฐ

ย ย ย ย curvature * 0.3f + ย ย // Curvature ะฟะพะบะฐะทัะฒะฐะตั ะฟะปะฐะฒะฝะพััั ะดัะณ

ย ย ย ย direction * 0.3f ย ย ย // Direction changes ะปะพะฒะธั jitter

ย ย )

ย ย // ะะธะฐะณะฝะพััะธะบะฐ ะฝะฐ ะพัะฝะพะฒะต ัะปะฐะฑะตะนัะตะณะพ ะฟะพะบะฐะทะฐัะตะปั

ย ย val diagnosis = when {

ย ย ย ย combined >= 0.9f ->ย

ย ย ย ย ย ย "ะัะปะธัะฝะฐั ะฟะปะฐะฒะฝะพััั! ะฃะฒะตัะตะฝะฝัะน ัััะธั โญ"

ย ย ย ย velocity < 0.6f ->ย

ย ย ย ย ย ย "ะะตัะฐะฒะฝะพะผะตัะฝะฐั ัะบะพัะพััั - ััะฐัะฐะนัั ะดะฒะธะณะฐัััั ะฟะปะฐะฒะฝะพ"

ย ย ย ย curvature < 0.6f ->ย

ย ย ย ย ย ย "ะะตะทะบะธะต ะธะทะผะตะฝะตะฝะธั ะบัะธะฒะธะทะฝั - ะฑะพะปะตะต ะฟะปะฐะฒะฝัะต ะดัะณะธ"

ย ย ย ย direction < 0.6f ->ย

ย ย ย ย ย ย "ะะฝะพะณะพ ัะตะทะบะธั ะฟะพะฒะพัะพัะพะฒ - ัะธััะน ัะฒะตัะตะฝะฝะตะต"

ย ย ย ย else ->ย

ย ย ย ย ย ย "ะฅะพัะพัะฐั ะฟะปะฐะฒะฝะพััั, ะฝะตะฑะพะปััะธะต ะบะพะปะตะฑะฐะฝะธั"

ย ย }

ย ย return SmoothnessAnalysis(

ย ย ย ย velocityScore = velocity,

ย ย ย ย curvatureScore = curvature,

ย ย ย ย directionScore = direction,

ย ย ย ย combinedScore = combined,

ย ย ย ย diagnosis = diagnosis

ย ย )

}

  

1.6 DIRECTION - ะขะะฅะะะะ ะะะกะะะะะะฏ

ะะฐัะตะผ ะฟัะพะฒะตัััั ะฝะฐะฟัะฐะฒะปะตะฝะธะต?

1. ะััะตัะฝะฐั ะฟะฐะผััั:

Circle clockwise โป: ย ย ย ย ะะดะฝะฐ ะผััะตัะฝะฐั ะฟะฐะผััั

Circle counter-clockwise โบ: ะััะณะฐั ะผััะตัะฝะฐั ะฟะฐะผััั

  

ะะฐะถะฝะพ ััะธัั ะะะะะะะฌะะะะฃ ะฝะฐะฟัะฐะฒะปะตะฝะธั ั ะฝะฐัะฐะปะฐ!

2. ะะฐะปะปะธะณัะฐัะธั:

ะะธัะฐะนัะบะธะต ะธะตัะพะณะปะธัั: ะกะขะะะะะ ะฟะพััะดะพะบ ัััะธัะพะฒ

ๆฐธ (ะฒะตัะฝะพััั): 8 ัััะธัะพะฒ ะฒ ัะธะบัะธัะพะฒะฐะฝะฝะพะน ะฟะพัะปะตะดะพะฒะฐัะตะปัะฝะพััะธ

  

ะัะฐะฑัะบะฐั ะบะฐะปะปะธะณัะฐัะธั: ัะฟัะฐะฒะฐ ะฝะฐะปะตะฒะพ ะบัะธัะธัะฝะพ

3. ะฅัะดะพะถะตััะฒะตะฝะฝะฐั ัะตัะฝะธะบะฐ:

Shading (ัััะธัะพะฒะบะฐ): ะฝะฐะฟัะฐะฒะปะตะฝะธะต ะฒะปะธัะตั ะฝะฐ ัััะตะบั

โ ะะตััะธะบะฐะปัะฝัะต: ะฒััะพัะฐ

โ ะะพัะธะทะพะฝัะฐะปัะฝัะต: ัะธัะธะฝะฐ ย

โ ะะธะฐะณะพะฝะฐะปัะฝัะต: ะดะฒะธะถะตะฝะธะต

ะะตัะพะดั ะฟัะพะฒะตัะบะธ direction

ะะตัะพะด 1: Start/End Point Matching

fun validateDirectionSimple(

ย ย referencePath: Path,

ย ย userPath: Path,

ย ย threshold: Float = 50f

): Boolean {

ย ย val refPoints = samplePathUniformly(referencePath, 50)

ย ย val userPoints = samplePathUniformly(userPath, 50)

ย ย val startDist = euclideanDistance(refPoints.first(), userPoints.first())

ย ย val endDist = euclideanDistance(refPoints.last(), userPoints.last())

ย ย return startDist < threshold && endDist < threshold

}

ะัะพะฑะปะตะผะฐ: ะะต ะปะพะฒะธั ะพัะธะฑะบะธ ะฒ ัะตัะตะดะธะฝะต ะฟััะธ!

ะะตัะพะด 2: Segment-by-Segment (ัะตะบะพะผะตะฝะดัะตััั)

data class DirectionAnalysis(

ย ย val overallScore: Float,

ย ย val incorrectSegments: List<Int>,

ย ย val diagnosis: String

)

  

fun analyzeDirectionDetailed(

ย ย referencePath: Path,

ย ย userPath: Path,

ย ย numSegments: Int = 10

): DirectionAnalysis {

ย ย val refPoints = samplePathUniformly(referencePath, numSegments + 1)

ย ย val userPoints = samplePathUniformly(userPath, numSegments + 1)

ย ย val segmentScores = mutableListOf<Float>()

ย ย val incorrectSegments = mutableListOf<Int>()

ย ย for (i in 0 until numSegments) {

ย ย ย ย // ะะตะบัะพัะฐ ัะตะณะผะตะฝัะพะฒ

ย ย ย ย val refVector = Vector2(

ย ย ย ย ย ย refPoints[i + 1].x - refPoints[i].x,

ย ย ย ย ย ย refPoints[i + 1].y - refPoints[i].y

ย ย ย ย )

ย ย ย ย val userVector = Vector2(

ย ย ย ย ย ย userPoints[i + 1].x - userPoints[i].x,

ย ย ย ย ย ย userPoints[i + 1].y - userPoints[i].y

ย ย ย ย )

ย ย ย ย val angle = angleBetweenVectors(refVector, userVector)

ย ย ย ย val score = (1f - angle / 180f).coerceIn(0f, 1f)

ย ย ย ย segmentScores.add(score)

ย ย ย ย if (angle > 60f) {ย // Threshold

ย ย ย ย ย ย incorrectSegments.add(i)

ย ย ย ย }

ย ย }

ย ย val overallScore = segmentScores.average().toFloat()

ย ย val diagnosis = when {

ย ย ย ย overallScore >= 0.9f -> "ะัะปะธัะฝะพะต ะฝะฐะฟัะฐะฒะปะตะฝะธะต!"

ย ย ย ย incorrectSegments.isEmpty() -> "ะฅะพัะพัะตะต ะฝะฐะฟัะฐะฒะปะตะฝะธะต"

ย ย ย ย else -> "ะัะพะฑะปะตะผั ะฒ ัะตะณะผะตะฝัะฐั: ${incorrectSegments.joinToString()}"

ย ย }

ย ย return DirectionAnalysis(overallScore, incorrectSegments, diagnosis)

}

  

1.7 WEIGHTED SCORING - ะะะะะะะะะะะะะะะฏ ะะฆะะะะ

ะะพัะตะผั ะบะพะผะฑะธะฝะฐัะธั ะผะตััะธะบ?

ะัะฑะฐั ะะะะ ะผะตััะธะบะฐ ะธะผะตะตั ัะปะตะฟัะต ะทะพะฝั:

Situationย ย ย ย ย ย ย ย ย ย Coverageย Hausdorffย Smoothnessย Direction

โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ

Incomplete stroke (50%)ย ย ย ย โย ย ย ย โย ย ย ย ย โย ย ย ย ย โ

Wrong direction (backwards)ย ย โย ย ย ย โย ย ย ย ย โย ย ย ย ย โ

Shaky hand (jitter)ย ย ย ย ย ย โย ย ย ย โย ย ย ย ย โย ย ย ย ย โ

Wrong shapeย ย ย ย ย ย ย ย ย ย โย ย ย ย โย ย ย ย ย โย ย ย ย ย โ

  

ะะซะะะ: ะัะถะฝั ะะกะ ะผะตััะธะบะธ ััะพะฑั ะฟะพะนะผะฐัั ะฒัะต ะฒะธะดั ะพัะธะฑะพะบ!

Weighted Formula

Final Score = wโรCoverage + wโรDeviation + wโรDirection + wโรSmoothness

  

ะะดะต:

- wแตข = ะฒะตัะฐ (importance)

- ฮฃwแตข = 1 (ะฒะตัะฐ ััะผะผะธัััััั ะฒ 1)

- ะะฐะถะดะฐั ะผะตััะธะบะฐ normalized to 0-1

ะัะฑะพั ะฒะตัะพะฒ

ะะตัะพะด 1: ะะตะดะฐะณะพะณะธัะตัะบะธะน (ะดะปั ArtWorkout):

Coverage: ย 40%ย - ะะฐะฒะตััะตะฝะธะต = ะะะะขะะงะะ

Deviation:ย 30%ย - ะขะพัะฝะพััั = ะะงะะะฌ ะะะะะ

Direction:ย 20%ย - ะขะตัะฝะธะบะฐ = ะะะะะ

Smoothness: 10%ย - ะะปะฐะฒะฝะพััั = NICE TO HAVE

ะะฑะพัะฝะพะฒะฐะฝะธะต:

- ะะตะทะฐะบะพะฝัะตะฝะฝัะน ัััะธั = ะพัะตะฒะธะดะฝัะน ะฟัะพะฒะฐะป โ ะฒััะพะบะธะน ะฒะตั
- ะขะพัะฝะพััั - core skill ะพะฑััะตะฝะธั โ ะฒััะพะบะธะน ะฒะตั
- Direction ะฒะฐะถะตะฝ ะดะปั ัะตัะฝะธะบะธ, ะฝะพ ะฝะต ะฒัะตะณะดะฐ (ะทะฐะฒะธัะธั ะพั ัะธะฟะฐ ััะพะบะฐ)
- Smoothness - refinement, ะฝะต fundamental

Kotlin ัะตะฐะปะธะทะฐัะธั:

data class EvaluationWeights(

ย ย val coverage: Float = 0.4f,

ย ย val deviation: Float = 0.3f,

ย ย val direction: Float = 0.2f,

ย ย val smoothness: Float = 0.1f

) {

ย ย init {

ย ย ย ย val sum = coverage + deviation + direction + smoothness

ย ย ย ย require(abs(sum - 1.0f) < 0.001f) {

ย ย ย ย ย ย "ะะตัะฐ ะดะพะปะถะฝั ััะผะผะธัะพะฒะฐัััั ะฒ 1.0, actual: $sum"

ย ย ย ย }

ย ย }

ย ย companion object {

ย ย ย ย // Preset ะดะปั ัะฐะทะฝัั ัะธะฟะพะฒ ััะพะบะพะฒ

ย ย ย ย fun forBasicShapes() = EvaluationWeights(

ย ย ย ย ย ย coverage = 0.45f,

ย ย ย ย ย ย deviation = 0.35f,

ย ย ย ย ย ย direction = 0.10f,ย // ะะต ะฒะฐะถะฝะพ ะดะปั ะฟัะพัััั ัะธะณัั

ย ย ย ย ย ย smoothness = 0.10f

ย ย ย ย )

ย ย ย ย fun forCalligraphy() = EvaluationWeights(

ย ย ย ย ย ย coverage = 0.30f,

ย ย ย ย ย ย deviation = 0.25f,

ย ย ย ย ย ย direction = 0.35f,ย // ะะะะขะะงะะ ะดะปั ะบะฐะปะปะธะณัะฐัะธะธ!

ย ย ย ย ย ย smoothness = 0.10f

ย ย ย ย )

ย ย ย ย fun forArtistic() = EvaluationWeights(

ย ย ย ย ย ย coverage = 0.35f,

ย ย ย ย ย ย deviation = 0.30f,

ย ย ย ย ย ย direction = 0.10f,

ย ย ย ย ย ย smoothness = 0.25fย // ะะฐะถะฝะพ ะดะปั ััะดะพะถะตััะฒะตะฝะฝะพะณะพ ัะธัะพะฒะฐะฝะธั

ย ย ย ย )

ย ย }

}

  

/**

ย* Comprehensive stroke evaluator

ย*/

class MultiMetricStrokeEvaluator(

ย ย private val weights: EvaluationWeights = EvaluationWeights()

) {

ย ย fun evaluate(

ย ย ย ย referencePath: Path,

ย ย ย ย userPath: Path,

ย ย ย ย timestamps: List<Long>? = null

ย ย ): ComprehensiveEvaluation {

ย ย ย ย // ะััะธัะปะธัั ะฒัะต ะผะตััะธะบะธ

ย ย ย ย val coverageResult = calculateDetailedCoverage(referencePath, userPath)

ย ย ย ย val hausdorff = hausdorffDistance(referencePath, userPath)

ย ย ย ย val directionResult = analyzeDirectionDetailed(referencePath, userPath)

ย ย ย ย val smoothnessResult = analyzeSmoothnessComprehensive(userPath, timestamps)

ย ย ย ย // Normalize ะผะตััะธะบะธ to 0-1

ย ย ย ย val coverageScore = coverageResult.coveragePercent / 100f

ย ย ย ย val deviationScore = normalizeDeviation(hausdorff, maxAcceptable = 50f)

ย ย ย ย val directionScore = directionResult.overallScore

ย ย ย ย val smoothnessScore = smoothnessResult.combinedScore

ย ย ย ย // Weighted combination

ย ย ย ย val finalScore = (

ย ย ย ย ย ย coverageScore * weights.coverage +

ย ย ย ย ย ย deviationScore * weights.deviation +

ย ย ย ย ย ย directionScore * weights.direction +

ย ย ย ย ย ย smoothnessScore * weights.smoothness

ย ย ย ย )

ย ย ย ย return ComprehensiveEvaluation(

ย ย ย ย ย ย finalScore = finalScore,

ย ย ย ย ย ย coverage = coverageScore,

ย ย ย ย ย ย deviation = deviationScore,

ย ย ย ย ย ย direction = directionScore,

ย ย ย ย ย ย smoothness = smoothnessScore,

ย ย ย ย ย ย passed = finalScore >= 0.75f,ย // Threshold 75%

ย ย ย ย ย ย feedback = generateFeedback(finalScore, coverageScore,ย

ย ย ย ย ย ย ย ย deviationScore, directionScore, smoothnessScore)

ย ย ย ย )

ย ย }

ย ย private fun normalizeDeviation(hausdorff: Float, maxAcceptable: Float): Float {

ย ย ย ย // ะงะตะผ ะผะตะฝััะต Hausdorff, ัะตะผ ะฒััะต score

ย ย ย ย return (1f - (hausdorff / maxAcceptable)).coerceIn(0f, 1f)

ย ย }

ย ย private fun generateFeedback(

ย ย ย ย final: Float,

ย ย ย ย coverage: Float,

ย ย ย ย deviation: Float,

ย ย ย ย direction: Float,

ย ย ย ย smoothness: Float

ย ย ): String {

ย ย ย ย // ะะฐะนัะธ ัะปะฐะฑะตะนััั ะผะตััะธะบั

ย ย ย ย val weakest = mapOf(

ย ย ย ย ย ย "coverage" to coverage,

ย ย ย ย ย ย "deviation" to deviation,

ย ย ย ย ย ย "direction" to direction,

ย ย ย ย ย ย "smoothness" to smoothness

ย ย ย ย ).minByOrNull { it.value }!!

ย ย ย ย return when {

ย ย ย ย ย ย final >= 0.95f -> "ะัะปะธัะฝะพ! ะะดะตะฐะปัะฝะฐั ัะตัะฝะธะบะฐ! โญโญโญ"

ย ย ย ย ย ย final >= 0.85f -> "ะัะตะฝั ัะพัะพัะพ! ะะตะฑะพะปััะธะต ะฝะตัะพัะฝะพััะธ ะฒ ${weakest.key}"

ย ย ย ย ย ย final >= 0.75f -> "ะฅะพัะพัะพ! ${improvementHint(weakest.key)}"

ย ย ย ย ย ย final >= 0.5f -> "ะะพะฟัะพะฑัะน ะตัะต ัะฐะท. ${improvementHint(weakest.key)}"

ย ย ย ย ย ย else -> "ะะฐัะฝะธ ะทะฐะฝะพะฒะพ. ${improvementHint(weakest.key)}"

ย ย ย ย }

ย ย }

ย ย private fun improvementHint(weakMetric: String): String {

ย ย ย ย return when (weakMetric) {

ย ย ย ย ย ย "coverage" -> "ะัะพะนะดะธ ะฒะตัั ะฟััั ะดะพ ะบะพะฝัะฐ"

ย ย ย ย ย ย "deviation" -> "ะะตัะถะธัั ะฑะปะธะถะต ะบ ะพะฑัะฐะทัั"

ย ย ย ย ย ย "direction" -> "ะัะพะฒะตัั ะฝะฐะฟัะฐะฒะปะตะฝะธะต ัััะธัะฐ"

ย ย ย ย ย ย "smoothness" -> "ะะธััะน ัะฒะตัะตะฝะฝะตะต, ะฑะตะท ะดัะพะถะฐะฝะธั"

ย ย ย ย ย ย else -> "ะัะพะดะพะปะถะฐะน ะฟัะฐะบัะธะบะพะฒะฐัััั"

ย ย ย ย }

ย ย }

}

  

data class ComprehensiveEvaluation(

ย ย val finalScore: Float,

ย ย val coverage: Float,

ย ย val deviation: Float,

ย ย val direction: Float,

ย ย val smoothness: Float,

ย ย val passed: Boolean,

ย ย val feedback: String

)

  

ะงะะกะขะฌ 2: ANDROID CANVAS API

2.1 CANVAS BASICS - ะะะะะะะะะขะซ ะ ะขะะะะกะคะะะะะฆะะ

ะกะธััะตะผะฐ ะบะพะพัะดะธะฝะฐั

Android Canvas coordinate system:

Origin (0,0) = ะะะะฅะะะ ะะะะซะ ัะณะพะป

  

ยย ย (0,0) โโโโโโโโโ +X

ยย ย ย โ

ยย ย ย โ

ยย ย ย โ

ยย ย ย โ

ย ย ย +Y

  

ะะะะะ: Y ัะฐััะตั ะะะะ (ะฝะต ะฒะฒะตัั ะบะฐะบ ะฒ ะผะฐัะตะผะฐัะธะบะต!)

ะัะฐะบัะธัะตัะบะธะน ะฟัะธะผะตั:

canvas.drawCircle(

ย ย 100f,ย // x = 100px ัะฟัะฐะฒะฐ ะพั ะปะตะฒะพะณะพ ะบัะฐั

ย ย 200f,ย // y = 200px ะฒะฝะธะท ะพั ะฒะตััะฝะตะณะพ ะบัะฐั

ย ย 50f, ย // radius

ย ย paint

)

Canvas transformations

ะขัะธ ะพัะฝะพะฒะฝัะต ััะฐะฝััะพัะผะฐัะธะธ:

1. translate() - ัะดะฒะธะณ:

canvas.save()ย // ะกะพััะฐะฝะธัั ัะตะบััะตะต ัะพััะพัะฝะธะต

canvas.translate(100f, 50f)ย // ะกะดะฒะธะฝััั origin ะฝะฐ (100, 50)

  

// ะขะตะฟะตัั (0,0) ะฝะฐัะพะดะธััั ะฒ (100, 50) ัะบัะฐะฝะฐ

canvas.drawCircle(0f, 0f, 20f, paint)ย // ะะฐัะธััะตััั ะฒ (100, 50)!

  

canvas.restore()ย // ะะพัััะฐะฝะพะฒะธัั

2. scale() - ะผะฐัััะฐะฑะธัะพะฒะฐะฝะธะต:

canvas.save()

canvas.scale(2f, 2f)ย // ะฃะฒะตะปะธัะธัั ะฒ 2 ัะฐะทะฐ

  

canvas.drawRect(0f, 0f, 100f, 100f, paint)

// ะะฐัะธััะตััั 200x200 ะบะฒะฐะดัะฐั!

  

canvas.restore()

3. rotate() - ะฒัะฐัะตะฝะธะต:

canvas.save()

canvas.rotate(45f)ย // ะะพะฒะตัะฝััั ะฝะฐ 45ยฐ ะฒะพะบััะณ origin

  

canvas.drawLine(0f, 0f, 100f, 0f, paint)

// ะะธะฝะธั ะฟะพะด ัะณะปะพะผ 45ยฐ!

  

canvas.restore()

ะะพะผะฑะธะฝะธัะพะฒะฐะฝะธะต ััะฐะฝััะพัะผะฐัะธะน:

canvas.save()

  

// ะะพััะดะพะบ ะะะะะ!

canvas.translate(200f, 200f)ย // 1. ะะตัะตะผะตััะธัั ะฒ ัะตะฝัั

canvas.rotate(45f) ย ย ย ย ย ย // 2. ะะพะฒะตัะฝััั

canvas.scale(2f, 1f) ย ย ย ย ย // 3. ะะฐัััะฝััั

  

canvas.drawRect(-50f, -50f, 50f, 50f, paint)

  

canvas.restore()

ะะฐัะตะผ save() ะธ restore()?

Canvas transformation stack:

ะะตะท save/restore:

canvas.translate(100, 0)

canvas.drawCircle(0, 0, 10, paint)ย // (100, 0)

canvas.drawCircle(0, 0, 10, paint)ย // (100, 0) - ะฒัะต ะตัะต shifted!

  

ะก save/restore:

canvas.save()

canvas.translate(100, 0)

canvas.drawCircle(0, 0, 10, paint)ย // (100, 0)

canvas.restore()

canvas.drawCircle(0, 0, 10, paint)ย // (0, 0) - ะฒะพัััะฐะฝะพะฒะปะตะฝะพ!

  

2.2 PATH API - ะะะะะซะ ะะะะฌะ

Path basics

Path - ััะพ ะบะพะฝัะตะนะฝะตั ะดะปั ะณะตะพะผะตััะธัะตัะบะธั ัะธะณัั:

val path = Path()

  

// ะะฐัะฐัั ะฝะพะฒัะน ะบะพะฝััั

path.moveTo(100f, 100f)

  

// ะััะผัะต ะปะธะฝะธะธ

path.lineTo(200f, 100f)

path.lineTo(200f, 200f)

  

// ะะฐะบัััั ะบะพะฝััั (ะฒะตัะฝััััั ะฒ ะฝะฐัะฐะปะพ)

path.close()

  

// ะะฐัะธัะพะฒะฐัั

canvas.drawPath(path, paint)

ะัะธะฒัะต ะะตะทัะต

Quadratic Bezier (ะบะฒะฐะดัะฐัะธัะฝะฐั) - 3 ัะพัะบะธ:

ะคะพัะผัะปะฐ: B(t) = (1-t)ยฒPโ + 2(1-t)tPโ + tยฒPโ

  

Pโ = start point

Pโ = control point (ัะพัะบะฐ ะฟัะธััะถะตะฝะธั)

Pโ = end point

t โ [0, 1]

Kotlin:

path.moveTo(100f, 200f)ย // Pโ start

path.quadTo(

ย ย 150f, 100f,ย // Pโ control (ะฒััะต ัะตัะตะดะธะฝั = ะดัะณะฐ ะฒะฒะตัั)

ย ย 200f, 200f ย // Pโ end

)

ะะธะทัะฐะปะธะทะฐัะธั:

Pโ (control)

ย ย โ

ยย โฑ โฒ

ย โฑ ย โฒ (ะบัะธะฒะฐั ะฟัะธััะณะธะฒะฐะตััั ะบ Pโ)

ยโฑ ย ย โฒ

โ ย ย ย โย

Pโย ย ย Pโ

Cubic Bezier (ะบัะฑะธัะตัะบะฐั) - 4 ัะพัะบะธ:

ะคะพัะผัะปะฐ: B(t) = (1-t)ยณPโ + 3(1-t)ยฒtPโ + 3(1-t)tยฒPโ + tยณPโ

  

Pโ = start

Pโ = first control point

Pโ = second control point

Pโ = end

Kotlin:

path.moveTo(100f, 200f)ย // Pโ

path.cubicTo(

ย ย 150f, 100f,ย // Pโ ะฟะตัะฒะฐั control

ย ย 250f, 100f,ย // Pโ ะฒัะพัะฐั control

ย ย 300f, 200f ย // Pโ end

)

ะะพัะตะผั Bezier ะดะปั drawing apps?

1. Smooth interpolation: ะัะธะฒัะต ะฐะฒัะพะผะฐัะธัะตัะบะธ smooth ะผะตะถะดั ัะพัะบะฐะผะธ
2. Touch input smoothing: Raw touch ัะปะธัะบะพะผ jittery
3. Efficient storage: ะะผะตััะพ 100 ัะพัะตะบ - 4 control points
4. Scalable: ะะพะถะฝะพ resample ะฒ ะปัะฑะพะผ ัะฐะทัะตัะตะฝะธะธ

Path smoothing ะดะปั touch input

ะัะพะฑะปะตะผะฐ:

Raw touch input: ย ย \/\/\/\/\/ย (jittery, 100+ points)

ะฅะพัะธะผ:ย ย ย ย ย ย ย โโโโโโโโโโโย (smooth curve)

ะะตัะตะฝะธะต: Quadratic Bezier ะผะตะถะดั ัะพัะบะฐะผะธ

class SmoothPathBuilder {

ย ย private val path = Path()

ย ย private val points = mutableListOf<PointF>()

ย ย fun addPoint(point: PointF) {

ย ย ย ย points.add(point)

ย ย ย ย if (points.size == 1) {

ย ย ย ย ย ย // ะะตัะฒะฐั ัะพัะบะฐ

ย ย ย ย ย ย path.moveTo(point.x, point.y)

ย ย ย ย } else if (points.size >= 3) {

ย ย ย ย ย ย // ะัะฟะพะปัะทัะตะผ quadratic Bezier ะดะปั smoothing

ย ย ย ย ย ย val p0 = points[points.size - 3]ย // Start

ย ย ย ย ย ย val p1 = points[points.size - 2]ย // Control

ย ย ย ย ย ย val p2 = points[points.size - 1]ย // End

ย ย ย ย ย ย // Control point = ะฟัะตะดัะดััะฐั ัะพัะบะฐ

ย ย ย ย ย ย // End point = midpoint ะผะตะถะดั p1 ะธ p2

ย ย ย ย ย ย val midX = (p1.x + p2.x) / 2f

ย ย ย ย ย ย val midY = (p1.y + p2.y) / 2f

ย ย ย ย ย ย path.quadTo(

ย ย ย ย ย ย ย ย p1.x, p1.y,ย ย // Control

ย ย ย ย ย ย ย ย midX, midY ย ย // End (midpoint)

ย ย ย ย ย ย )

ย ย ย ย }

ย ย }

ย ย fun getPath(): Path = path

}

PathMeasure - ะธะทะผะตัะตะฝะธะต ะฟััะตะน

PathMeasure ะฟะพะทะฒะพะปัะตั:

- ะะพะปััะธัั ะดะปะธะฝั ะฟััะธ
- ะะทะฒะปะตัั ัะพัะบะธ ะฒะดะพะปั ะฟััะธ
- ะะพะปััะธัั tangent (ะบะฐัะฐัะตะปัะฝัั) ะฒ ะปัะฑะพะน ัะพัะบะต

val pathMeasure = PathMeasure(path, false)

val length = pathMeasure.lengthย // ะะฑัะฐั ะดะปะธะฝะฐ ะฒ px

  

// ะะพะปััะธัั ัะพัะบั ะฝะฐ 50% ะดะปะธะฝั ะฟััะธ

val pos = FloatArray(2)ย // [x, y]

val tan = FloatArray(2)ย // [dx, dy] tangent

pathMeasure.getPosTan(length * 0.5f, pos, tan)

  

// pos[0], pos[1] = ะบะพะพัะดะธะฝะฐัั ะฒ ัะตัะตะดะธะฝะต ะฟััะธ

// tan[0], tan[1] = ะฝะฐะฟัะฐะฒะปะตะฝะธะต ะดะฒะธะถะตะฝะธั ะฒ ััะพะน ัะพัะบะต

ะัะฐะบัะธัะตัะบะพะต ะฟัะธะผะตะฝะตะฝะธะต - ัะฐะฒะฝะพะผะตัะฝะฐั ะดะธัะบัะตัะธะทะฐัะธั:

fun samplePathUniformly(path: Path, numSamples: Int): List<PointF> {

ย ย val measure = PathMeasure(path, false)

ย ย val length = measure.length

ย ย val points = mutableListOf<PointF>()

ย ย val pos = FloatArray(2)

ย ย for (i in 0 until numSamples) {

ย ย ย ย val distance = (i.toFloat() / (numSamples - 1)) * length

ย ย ย ย measure.getPosTan(distance, pos, null)

ย ย ย ย points.add(PointF(pos[0], pos[1]))

ย ย }

ย ย return points

}

  

2.3 PAINT - ะกะขะะะ ะ ะญะคะคะะะขะซ

Paint basics

Paint ััะฐะฝะธั ััะธะปะธ ัะธัะพะฒะฐะฝะธั:

val paint = Paint().apply {

ย ย color = Color.REDย ย ย ย ย ย ย // ะฆะฒะตั

ย ย strokeWidth = 5f ย ย ย ย ย ย ย // ะขะพะปัะธะฝะฐ ะปะธะฝะธะธ

ย ย style = Paint.Style.STROKE ย ย // ะขะธะฟ: STROKE, FILL, FILL_AND_STROKE

ย ย isAntiAlias = trueย ย ย ย ย ย // ะกะณะปะฐะถะธะฒะฐะฝะธะต

}

Paint.Style

// STROKE - ัะพะปัะบะพ ะบะพะฝััั

paint.style = Paint.Style.STROKE

paint.strokeWidth = 10f

canvas.drawCircle(100f, 100f, 50f, paint)ย // ะัััะพะน ะบััะณ

  

// FILL - ะทะฐะปะธะฒะบะฐ

paint.style = Paint.Style.FILL

canvas.drawCircle(250f, 100f, 50f, paint)ย // ะะฐะบัะฐัะตะฝะฝัะน ะบััะณ

  

// FILL_AND_STROKE - ะพะฑะฐ

paint.style = Paint.Style.FILL_AND_STROKE

canvas.drawCircle(400f, 100f, 50f, paint)ย // ะก ะบะพะฝัััะพะผ ะธ ะทะฐะปะธะฒะบะพะน

StrokeCap ะธ StrokeJoin

StrokeCap - ะบะพะฝัั ะปะธะฝะธะน:

// BUTT - ะบะฒะฐะดัะฐัะฝัะน ะพะฑัะตะท (default)

paint.strokeCap = Paint.Cap.BUTT

  

// ROUND - ัะบััะณะปะตะฝะฝัะน

paint.strokeCap = Paint.Cap.ROUND

  

// SQUARE - ะบะฒะฐะดัะฐัะฝัะน ั ะฒััััะฟะพะผ

paint.strokeCap = Paint.Cap.SQUARE

StrokeJoin - ัะพะตะดะธะฝะตะฝะธั:

// MITER - ะพััััะน ัะณะพะป (default)

paint.strokeJoin = Paint.Join.MITER

  

// ROUND - ัะบััะณะปะตะฝะฝัะน

paint.strokeJoin = Paint.Join.ROUND

  

// BEVEL - ัะบะพัะตะฝะฝัะน

paint.strokeJoin = Paint.Join.BEVEL

PathEffect - ัััะตะบัั ะฟััะธ

DashPathEffect - ะฟัะฝะบัะธัะฝะฐั ะปะธะฝะธั:

val dashEffect = DashPathEffect(

ย ย floatArrayOf(10f, 5f),ย // 10px dash, 5px gap

ย ย 0f ย ย ย ย ย ย ย ย ย ย ย // phase offset

)

paint.pathEffect = dashEffect

CornerPathEffect - ัะบััะณะปะตะฝะธะต ัะณะปะพะฒ:

paint.pathEffect = CornerPathEffect(20f)ย // radius 20px

ComposePathEffect - ะบะพะผะฑะธะฝะธัะพะฒะฐะฝะธะต:

val corner = CornerPathEffect(10f)

val dash = DashPathEffect(floatArrayOf(20f, 10f), 0f)

paint.pathEffect = ComposePathEffect(dash, corner)

Shader - ะณัะฐะดะธะตะฝัั ะธ ะฟะฐััะตัะฝั

LinearGradient:

val gradient = LinearGradient(

ย ย 0f, 0f,ย ย ย // start (x, y)

ย ย 200f, 200f,ย // end (x, y)

ย ย Color.RED, ย // start color

ย ย Color.BLUE,ย // end color

ย ย Shader.TileMode.CLAMP

)

paint.shader = gradient

RadialGradient:

val radial = RadialGradient(

ย ย 100f, 100f,ย // center

ย ย 50f, ย ย ย ย // radius

ย ย Color.WHITE, // center color

ย ย Color.BLACK, // edge color

ย ย Shader.TileMode.CLAMP

)

  

2.4 CUSTOM VIEW - ะะะะะะะะซะ ะฆะะะ

ะะฐะทะพะฒะฐั ััััะบัััะฐ

class DrawingView @JvmOverloads constructor(

ย ย context: Context,

ย ย attrs: AttributeSet? = null,

ย ย defStyleAttr: Int = 0

) : View(context, attrs, defStyleAttr) {

ย ย private val paint = Paint().apply {

ย ย ย ย color = Color.BLACK

ย ย ย ย strokeWidth = 5f

ย ย ย ย style = Paint.Style.STROKE

ย ย ย ย isAntiAlias = true

ย ย ย ย strokeCap = Paint.Cap.ROUND

ย ย ย ย strokeJoin = Paint.Join.ROUND

ย ย }

ย ย private val currentPath = Path()

ย ย private val paths = mutableListOf<Path>()

ย ย override fun onDraw(canvas: Canvas) {

ย ย ย ย super.onDraw(canvas)

ย ย ย ย // ะะฐัะธัะพะฒะฐัั ะฒัะต ะทะฐะฒะตััะตะฝะฝัะต ะฟััะธ

ย ย ย ย paths.forEach { path ->

ย ย ย ย ย ย canvas.drawPath(path, paint)

ย ย ย ย }

ย ย ย ย // ะะฐัะธัะพะฒะฐัั ัะตะบััะธะน ะฟััั

ย ย ย ย canvas.drawPath(currentPath, paint)

ย ย }

ย ย override fun onTouchEvent(event: MotionEvent): Boolean {

ย ย ย ย val x = event.x

ย ย ย ย val y = event.y

ย ย ย ย when (event.action) {

ย ย ย ย ย ย MotionEvent.ACTION_DOWN -> {

ย ย ย ย ย ย ย ย currentPath.moveTo(x, y)

ย ย ย ย ย ย ย ย return true

ย ย ย ย ย ย }

ย ย ย ย ย ย MotionEvent.ACTION_MOVE -> {

ย ย ย ย ย ย ย ย currentPath.lineTo(x, y)

ย ย ย ย ย ย ย ย invalidate()ย // ะะฐะฟัะพัะธัั ะฟะตัะตัะธัะพะฒะบั

ย ย ย ย ย ย ย ย return true

ย ย ย ย ย ย }

ย ย ย ย ย ย MotionEvent.ACTION_UP -> {

ย ย ย ย ย ย ย ย paths.add(Path(currentPath))ย // ะกะพััะฐะฝะธัั

ย ย ย ย ย ย ย ย currentPath.reset()

ย ย ย ย ย ย ย ย invalidate()

ย ย ย ย ย ย ย ย return true

ย ย ย ย ย ย }

ย ย ย ย }

ย ย ย ย return super.onTouchEvent(event)

ย ย }

}

ะะธะทะฝะตะฝะฝัะน ัะธะบะป View

1. Constructor

ยย โ

2. onAttachedToWindow()ย - View ะดะพะฑะฐะฒะปะตะฝะฐ ะฒ hierarchy

ยย โ

3. onMeasure() ย ย ย ย ย - ะะทะผะตัะธัั ัะฐะทะผะตัั

ยย โ

4. onLayout()ย ย ย ย ย ย - ะะพะทะธัะธะพะฝะธัะพะฒะฐัั ะดะตัะตะน

ยย โ

5. onDraw()ย ย ย ย ย ย ย - ะะะกะะะะะะ! ะัะทัะฒะฐะตััั ะฟัะธ invalidate()

ยย โ

6. onDetachedFromWindow() - View ัะฑัะฐะฝะฐ ะธะท hierarchy

invalidate() vs postInvalidate():

// invalidate() - ะธะท UI thread

override fun onTouchEvent(event: MotionEvent): Boolean {

ย ย // ...

ย ย invalidate()ย // ะกะธะฝััะพะฝะฝะพ

}

  

// postInvalidate() - ะธะท background thread

thread {

ย ย // Background calculation

ย ย postInvalidate()ย // ะัะธะฝััะพะฝะฝะพ ัะตัะตะท message queue

}

  

2.5 DIRTY RECTANGLES - ะะะขะะะะะะฆะะฏ

ะัะพะฑะปะตะผะฐ ะฟะพะปะฝะพะน ะฟะตัะตัะธัะพะฒะบะธ

Naive ะฟะพะดัะพะด:

override fun onTouchEvent(event: MotionEvent): Boolean {

ย ย when (event.action) {

ย ย ย ย MotionEvent.ACTION_MOVE -> {

ย ย ย ย ย ย currentPath.lineTo(event.x, event.y)

ย ย ย ย ย ย invalidate()ย // ะะตัะตัะธัะพะฒะฐัั ะะกะฎ View!

ย ย ย ย }

ย ย }

}

  

// ะัะพะฑะปะตะผะฐ: ะัะปะธ View 1080x1920px, ะฟะตัะตัะธัะพะฒัะฒะฐะตะผ 2 ะผะธะปะปะธะพะฝะฐ ะฟะธะบัะตะปะตะน

// ะดะฐะถะต ะตัะปะธ ะธะทะผะตะฝะธะปัั ัะพะปัะบะพ ะผะฐะปะตะฝัะบะธะน ััะฐััะพะบ!

ะะตัะตะฝะธะต: Dirty Rect

class OptimizedDrawingView : View {

ย ย private var lastX = 0f

ย ย private var lastY = 0f

ย ย override fun onTouchEvent(event: MotionEvent): Boolean {

ย ย ย ย val x = event.x

ย ย ย ย val y = event.y

ย ย ย ย when (event.action) {

ย ย ย ย ย ย MotionEvent.ACTION_DOWN -> {

ย ย ย ย ย ย ย ย lastX = x

ย ย ย ย ย ย ย ย lastY = y

ย ย ย ย ย ย ย ย currentPath.moveTo(x, y)

ย ย ย ย ย ย }

ย ย ย ย ย ย MotionEvent.ACTION_MOVE -> {

ย ย ย ย ย ย ย ย currentPath.lineTo(x, y)

ย ย ย ย ย ย ย ย // ะััะธัะปะธัั bounding box ะธะทะผะตะฝะตะฝะธั

ย ย ย ย ย ย ย ย val left = min(lastX, x) - strokeWidth

ย ย ย ย ย ย ย ย val top = min(lastY, y) - strokeWidth

ย ย ย ย ย ย ย ย val right = max(lastX, x) + strokeWidth

ย ย ย ย ย ย ย ย val bottom = max(lastY, y) + strokeWidth

ย ย ย ย ย ย ย ย // ะะตัะตัะธัะพะฒะฐัั ะขะะะฌะะ ััะพั ะฟััะผะพัะณะพะปัะฝะธะบ

ย ย ย ย ย ย ย ย invalidate(

ย ย ย ย ย ย ย ย ย ย left.toInt(),

ย ย ย ย ย ย ย ย ย ย top.toInt(),

ย ย ย ย ย ย ย ย ย ย right.toInt(),

ย ย ย ย ย ย ย ย ย ย bottom.toInt()

ย ย ย ย ย ย ย ย )

ย ย ย ย ย ย ย ย lastX = x

ย ย ย ย ย ย ย ย lastY = y

ย ย ย ย ย ย }

ย ย ย ย }

ย ย ย ย return true

ย ย }

}

Performance improvement:

ะะตะท dirty rect:

- ะะตัะตัะธัะพะฒะบะฐ: 1080ร1920 = 2,073,600 pixels

- Time: ~8ms @ 60fps budget of 16ms

  

ะก dirty rect (stroke 50x50px):

- ะะตัะตัะธัะพะฒะบะฐ: 50ร50 = 2,500 pixels

- Time: ~0.1msย

- Speedup: 80x! ๐

  

2.6 HARDWARE ACCELERATION

Hardware vs Software rendering

Software rendering (CPU):

CPU ะฒัะฟะพะปะฝัะตั ะฒัะต ะพะฟะตัะฐัะธะธ ัะธัะพะฒะฐะฝะธั

- ะะตะดะปะตะฝะฝะพ ะดะปั ัะปะพะถะฝะพะน ะณัะฐัะธะบะธ

- ะขะพัะฝัะน ัะตะทัะปััะฐั

- ะะพะดะดะตัะถะธะฒะฐะตั ะฒัะต Canvas ะพะฟะตัะฐัะธะธ

Hardware rendering (GPU):

GPU ััะบะพััะตั ัะธัะพะฒะฐะฝะธะต

- ะััััะพ ะดะปั ะฑะพะปััะธะฝััะฒะฐ ะพะฟะตัะฐัะธะน

- ะะตะบะพัะพััะต ะพะฟะตัะฐัะธะธ ะฝะต ะฟะพะดะดะตัะถะธะฒะฐัััั

- ะะพ ัะผะพะปัะฐะฝะธั ะฒะบะปััะตะฝะพ ั API 14+

ะะบะปััะตะฝะธะต/ะฒัะบะปััะตะฝะธะต

// ะะปั View

view.setLayerType(View.LAYER_TYPE_HARDWARE, null)ย // GPU

view.setLayerType(View.LAYER_TYPE_SOFTWARE, null)ย // CPU

  

// ะะปั Window (ะฒ Activity)

window.setFlags(

ย ย WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,

ย ย WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED

)

  

// ะ AndroidManifest.xml

<application android:hardwareAccelerated="true">

Unsupported operations (GPU ะฝะต ะฟะพะดะดะตัะถะธะฒะฐะตั)

// ะญัะธ ะพะฟะตัะฐัะธะธ ะะะะะะะะซะ ะฝะฐ GPU (fallback to CPU):

  

canvas.drawPicture() ย ย ย ย ย // โ

canvas.drawTextOnPath()ย ย ย ย // โ

canvas.drawVertices()ย ย ย ย ย // โ

paint.setRasterizer()ย ย ย ย ย // โ

paint.setMaskFilter()ย ย ย ย ย // โ (ะบัะพะผะต BlurMaskFilter)

  

// ะัะฟะพะปัะทัะน ะฐะปััะตัะฝะฐัะธะฒั:

// ะะผะตััะพ drawTextOnPath -> ัะฐะทะฑะตะน ะฝะฐ ัะตะณะผะตะฝัั

// ะะผะตััะพ setMaskFilter -> ะธัะฟะพะปัะทัะน BlurMaskFilter ะธะปะธ shader

View Layer ะพะฟัะธะผะธะทะฐัะธั

ะัะพะฑะปะตะผะฐ:

// ะะฐะถะดัะน frame ะฟะตัะตัะธัะพะฒัะฒะฐะตะผ ัะพะฝ

override fun onDraw(canvas: Canvas) {

ย ย drawComplexBackground(canvas)ย // ะะตะดะปะตะฝะฝะพ!

ย ย drawUserStroke(canvas)ย ย ย ย ย // ะััััะพ

}

ะะตัะตะฝะธะต: ะััะธัะพะฒะฐัั background ะฒ ะพัะดะตะปัะฝะพะผ layer

class LayeredDrawingView : View {

ย ย private val backgroundBitmap: Bitmap by lazy {

ย ย ย ย Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)

ย ย }

ย ย private val backgroundCanvas: Canvas by lazy {

ย ย ย ย Canvas(backgroundBitmap)

ย ย }

ย ย init {

ย ย ย ย // ะะบะปััะธัั hardware layer ะดะปั ััะพะน View

ย ย ย ย setLayerType(LAYER_TYPE_HARDWARE, null)

ย ย }

ย ย private fun drawComplexBackground() {

ย ย ย ย // ะะฐัะธัะพะฒะฐัั ะะะะ ะะะ ะฒ bitmap

ย ย ย ย backgroundCanvas.drawColor(Color.WHITE)

ย ย ย ย // ... ัะปะพะถะฝัะต ะพะฟะตัะฐัะธะธ ...

ย ย }

ย ย override fun onDraw(canvas: Canvas) {

ย ย ย ย // ะัะพััะพ draw cached bitmap (ะพัะตะฝั ะฑััััะพ!)

ย ย ย ย canvas.drawBitmap(backgroundBitmap, 0f, 0f, null)

ย ย ย ย // ะะพะฒะตัั - user stroke

ย ย ย ย canvas.drawPath(userPath, paint)

ย ย }

}

  

ะงะะกะขะฌ 3: TOUCH EVENTS ะ ะะะกะขะซ

3.1 TOUCH EVENT ะกะะกะขะะะ ANDROID

MotionEvent basics

MotionEvent ัะพะดะตัะถะธั:

event.actionย ย ย ย // ะขะธะฟ ัะพะฑััะธั (DOWN, MOVE, UP)

event.x ย ย ย ย ย ย // X ะบะพะพัะดะธะฝะฐัะฐ

event.y ย ย ย ย ย ย // Y ะบะพะพัะดะธะฝะฐัะฐ

event.pressureย ย ย // ะกะธะปะฐ ะฝะฐะถะฐัะธั (0-1)

event.sizeย ย ย ย ย // ะะฐะทะผะตั touch area

event.eventTime ย ย // Timestamp ัะพะฑััะธั

event.getHistorical*() // ะัะพะผะตะถััะพัะฝัะต ัะพัะบะธ

Action types

when (event.actionMasked) {

ย ย MotionEvent.ACTION_DOWN -> {

ย ย ย ย // ะะฐะปะตั ะบะพัะฝัะปัั ัะบัะฐะฝะฐ (ะฟะตัะฒัะน)

ย ย }

ย ย MotionEvent.ACTION_POINTER_DOWN -> {

ย ย ย ย // ะะพะฟะพะปะฝะธัะตะปัะฝัะน ะฟะฐะปะตั ะบะพัะฝัะปัั (multi-touch)

ย ย }

ย ย MotionEvent.ACTION_MOVE -> {

ย ย ย ย // ะะฐะปะตั ะดะฒะธะถะตััั

ย ย ย ย // ะะะะะ: ะัะทัะฒะฐะตััั ะะะะะ ัะฐะท ะฒ ัะตะบัะฝะดั (100-120 Hz)

ย ย }

ย ย MotionEvent.ACTION_UP -> {

ย ย ย ย // ะะพัะปะตะดะฝะธะน ะฟะฐะปะตั ะฟะพะดะฝัั

ย ย }

ย ย MotionEvent.ACTION_POINTER_UP -> {

ย ย ย ย // ะะดะธะฝ ะธะท ะฟะฐะปััะตะฒ ะฟะพะดะฝัั (ะฝะพ ะตััั ะตัะต)

ย ย }

ย ย MotionEvent.ACTION_CANCEL -> {

ย ย ย ย // ะะตัั ะพัะผะตะฝะตะฝ ัะธััะตะผะพะน (ะฝะฐะฟัะธะผะตั, incoming call)

ย ย }

}

Historical points - ัะณะปะฐะถะธะฒะฐะฝะธะต

ะัะพะฑะปะตะผะฐ:

onTouchEvent() ะฒัะทัะฒะฐะตััั @ 60fps (16ms intervals)

ะะพ ัะตะฝัะพั ะพะฑะฝะพะฒะปัะตััั @ 120fps (8ms intervals)

  

ะะตะถะดั ะดะฒัะผั onTouchEvent() ะตััั ะฟัะพะผะตะถััะพัะฝัะต ัะพัะบะธ!

ะะตัะตะฝะธะต:

override fun onTouchEvent(event: MotionEvent): Boolean {

ย ย when (event.action) {

ย ย ย ย MotionEvent.ACTION_MOVE -> {

ย ย ย ย ย ย // ะะพะปััะธัั ะฒัะต ะฟัะพะผะตะถััะพัะฝัะต ัะพัะบะธ

ย ย ย ย ย ย val historySize = event.historySize

ย ย ย ย ย ย for (i in 0 until historySize) {

ย ย ย ย ย ย ย ย val x = event.getHistoricalX(i)

ย ย ย ย ย ย ย ย val y = event.getHistoricalY(i)

ย ย ย ย ย ย ย ย val time = event.getHistoricalEventTime(i)

ย ย ย ย ย ย ย ย addPointToPath(x, y, time)

ย ย ย ย ย ย }

ย ย ย ย ย ย // ะะพะฑะฐะฒะธัั ัะตะบัััั ัะพัะบั

ย ย ย ย ย ย addPointToPath(event.x, event.y, event.eventTime)

ย ย ย ย ย ย invalidate()

ย ย ย ย }

ย ย }

}

ะะตะทัะปััะฐั:

ะะตะท historical: ย ย โข ย ย โข ย ย โข ย ย โขย (4 ัะพัะบะธ)

ะก historical: ย ย ย โข โข โข โข โข โข โข โขย (8 ัะพัะตะบ) - ะฑะพะปะตะต smooth!

  

3.2 MULTI-TOUCH ะะะะะะะขะะ

Pointer Index vs Pointer ID

ะะะะะะฏ ะบะพะฝัะตะฟัะธั:

// Pointer Index - ะฟะพะทะธัะธั ะฒ ะผะฐััะธะฒะต (ะผะพะถะตั ะผะตะฝััััั!)

// Pointer ID - ัะฝะธะบะฐะปัะฝัะน ะธะดะตะฝัะธัะธะบะฐัะพั (ะฝะต ะผะตะฝัะตััั!)

  

when (event.actionMasked) {

ย ย MotionEvent.ACTION_POINTER_DOWN -> {

ย ย ย ย val pointerIndex = event.actionIndexย // ะะฐะบะพะน ะฟะฐะปะตั (0, 1, 2...)

ย ย ย ย val pointerId = event.getPointerId(pointerIndex)ย // ะฃะฝะธะบะฐะปัะฝัะน ID

ย ย ย ย // ะกะพััะฐะฝะธัั pointerId ะดะปั tracking

ย ย ย ย activePointers[pointerId] = PointF(

ย ย ย ย ย ย event.getX(pointerIndex),

ย ย ย ย ย ย event.getY(pointerIndex)

ย ย ย ย )

ย ย }

ย ย MotionEvent.ACTION_MOVE -> {

ย ย ย ย // ะะฑัะฐะฑะพัะฐัั ะะกะ ะฐะบัะธะฒะฝัะต ะฟะฐะปััั

ย ย ย ย for (i in 0 until event.pointerCount) {

ย ย ย ย ย ย val pointerId = event.getPointerId(i)

ย ย ย ย ย ย val x = event.getX(i)

ย ย ย ย ย ย val y = event.getY(i)

ย ย ย ย ย ย activePointers[pointerId] = PointF(x, y)

ย ย ย ย }

ย ย }

}

Pinch-to-zoom gesture

class ZoomableView : View {

ย ย private val scaleGestureDetector = ScaleGestureDetector(

ย ย ย ย context,

ย ย ย ย object : ScaleGestureDetector.SimpleOnScaleGestureListener() {

ย ย ย ย ย ย override fun onScale(detector: ScaleGestureDetector): Boolean {

ย ย ย ย ย ย ย ย scaleFactor *= detector.scaleFactor

ย ย ย ย ย ย ย ย scaleFactor = scaleFactor.coerceIn(0.5f, 3.0f)ย // Limits

ย ย ย ย ย ย ย ย invalidate()

ย ย ย ย ย ย ย ย return true

ย ย ย ย ย ย }

ย ย ย ย }

ย ย )

ย ย private var scaleFactor = 1.0f

ย ย override fun onTouchEvent(event: MotionEvent): Boolean {

ย ย ย ย scaleGestureDetector.onTouchEvent(event)

ย ย ย ย return true

ย ย }

ย ย override fun onDraw(canvas: Canvas) {

ย ย ย ย canvas.save()

ย ย ย ย canvas.scale(scaleFactor, scaleFactor, width / 2f, height / 2f)

ย ย ย ย // Draw content...

ย ย ย ย canvas.restore()

ย ย }

}

  

3.3 STYLUS SUPPORT

Stylus-specific properties

override fun onTouchEvent(event: MotionEvent): Boolean {

ย ย // ะัะพะฒะตัะธัั ััะพ stylus ะธะปะธ ะฟะฐะปะตั

ย ย val toolType = event.getToolType(0)

ย ย when (toolType) {

ย ย ย ย MotionEvent.TOOL_TYPE_STYLUS -> {

ย ย ย ย ย ย // S Pen / Apple Pencil

ย ย ย ย ย ย val pressure = event.pressureย // 0-1

ย ย ย ย ย ย val tilt = event.getAxisValue(MotionEvent.AXIS_TILT)

ย ย ย ย ย ย val orientation = event.orientation

ย ย ย ย ย ย // Adjust stroke width based on pressure

ย ย ย ย ย ย paint.strokeWidth = baseWidth * pressure

ย ย ย ย }

ย ย ย ย MotionEvent.TOOL_TYPE_FINGER -> {

ย ย ย ย ย ย // ะะฑััะฝัะน ะฟะฐะปะตั

ย ย ย ย }

ย ย }

}

Palm rejection

ะัะพะฑะปะตะผะฐ: ะัะบะฐ ะบะฐัะฐะตััั ัะบัะฐะฝะฐ ะบะพะณะดะฐ ัะธััะตัั

ะะตัะตะฝะธะต 1: Tool Type

// ะะณะฝะพัะธัะพะฒะฐัั TOOL_TYPE_PALM

if (event.getToolType(0) == MotionEvent.TOOL_TYPE_PALM) {

ย ย return trueย // Ignore

}

ะะตัะตะฝะธะต 2: Size heuristic

// ะะฐะดะพะฝั ะพะฑััะฝะพ ะธะผะตะตั ะฑะพะปััะธะน touch size

val touchSize = event.getSize(0)

if (touchSize > 0.3f) {ย // Threshold

ย ย return trueย // Likely palm, ignore

}

ะะตัะตะฝะธะต 3: Samsung S Pen API

// Samsung specific - hover detection

override fun onHoverEvent(event: MotionEvent): Boolean {

ย ย if (event.action == MotionEvent.ACTION_HOVER_ENTER) {

ย ย ย ย // S Pen ะฟัะธะฑะปะธะถะฐะตััั - ะพัะบะปััะธัั touch

ย ย ย ย disableTouchInput = true

ย ย }

ย ย return super.onHoverEvent(event)

}

  

ะงะะกะขะฌ 4: ะะะะะะะะะะขะะะฌะะะกะขะฌ ะ ะะะขะะะะะะฆะะฏ

4.1 FRAME BUDGET - 60FPS = 16MS

ะะพัะตะผั 60fps?

Human perception:

24fpsย - ะะธะฝะพ (ะทะฐะผะตัะฝะพ ะดะตัะณะฐะตััั)

30fpsย - ะะธะฝะธะผัะผ ะดะปั smooth

60fpsย - ะะพะปะพัะพะน ััะฐะฝะดะฐัั (smooth, responsive)

120fps - High-end devices, ะผะฐะปะพ ะบัะพ ะทะฐะผะตัะธั ัะฐะทะฝะธัั

Frame budget:

60 fps = 1000ms / 60 = 16.67ms per frame

  

Breakdown:

- Android system overhead: ~2ms

- Your app: ~14ms MAXIMUM

- GPU rendering: ~2ms

  

ะัะปะธ ะฟัะตะฒััะธัั โ dropped frames โ jank!

Measuring performance

Systrace - ะณะปะฐะฒะฝัะน ะธะฝััััะผะตะฝั:

# ะะฐะฟะธัั trace

adb shell "atrace --async_start -b 8192 gfx input view"

# ะัะฟะพะปัะทะพะฒะฐัั app

adb shell "atrace --async_stop -z -o /data/local/tmp/trace.html"

adb pull /data/local/tmp/trace.html

Chrome DevTools: ะัะบัััั chrome://tracing ะธ ะทะฐะณััะทะธัั trace.html

ะงัะพ ะธัะบะฐัั:

- doFrame > 16ms โ ะฟัะพะฟััะตะฝะฝัะน frame
- draw ะดะปะธะฝะฝัะน โ ะฟัะพะฑะปะตะผั ะฒ onDraw()
- measure/layout ะดะปะธะฝะฝัะน โ ะฟัะพะฑะปะตะผั ั View hierarchy

  

4.2 PROFILING TOOLS

Android GPU Inspector

ะฃััะฐะฝะพะฒะบะฐ:

# Download from: developer.android.com/agi

# Install ะธ ะฟะพะดะบะปััะธัั device

ะงัะพ ะฟะพะบะฐะทัะฒะฐะตั:

- Frame timing (GPU vs CPU)
- Overdraw visualization
- Shader compilation time
- Texture memory usage

GPU Profiling ะฒ Android Studio

ะะบะปััะธัั:

Settings โ Developer Options โ Profile GPU Rendering โ On screen as bars

ะะฝัะตัะฟัะตัะฐัะธั:

ะะตะปะตะฝะฐั ะปะธะฝะธั = 16ms budget

  

ะัะปะธ bars ะฒััะต ะทะตะปะตะฝะพะน โ ะฟัะพะฑะปะตะผะฐ!

  

ะฆะฒะตัะฐ bars:

- ะกะธะฝะธะน: onDraw() ะฒัะตะผั

- ะัะฐัะฝัะน: GPU rendering

- ะัะฐะฝะถะตะฒัะน: Processing input/layout

  

4.3 COMMON BOTTLENECKS

1. Overdraw

ะัะพะฑะปะตะผะฐ:

ะะธัะพะฒะฐะฝะธะต ะพะดะฝะธั ะธ ัะตั ะถะต ะฟะธะบัะตะปะตะน ะะะะะ ัะฐะท

  

Example:

Background (white) โ Layer 1 (opaque) โ Layer 2 (opaque) โ Layer 3

  

GPU ัะธััะตั 4 ัะฐะทะฐ ัะต ะถะต ะฟะธะบัะตะปะธ! Waste!

ะะฑะฝะฐััะถะตะฝะธะต:

Settings โ Developer Options โ Debug GPU overdraw

  

ะฆะฒะตัะฐ:

- ะะตะท ัะฒะตัะฐ: 0x (ideal)

- ะกะธะฝะธะน: 1x (OK)

- ะะตะปะตะฝัะน: 2x (ะฟัะธะตะผะปะตะผะพ)

- ะะพะทะพะฒัะน: 3x (ะฟะปะพัะพ)

- ะัะฐัะฝัะน: 4x+ (ะะงะะะฌ ะฟะปะพัะพ)

ะะตัะตะฝะธะต:

// 1. ะฃะฑัะฐัั ะฝะตะฝัะถะฝัะต backgrounds

// ะัะปะธ parent ะธะผะตะตั white background, ะฝะต ะฝัะถะตะฝ ะฒ child

view.background = null

  

// 2. clipRect ะดะปั ะพะณัะฐะฝะธัะตะฝะธั drawing area

override fun onDraw(canvas: Canvas) {

ย ย canvas.clipRect(visibleArea)ย // ะะธัะพะฒะฐัั ัะพะปัะบะพ ะฒะธะดะธะผัั ัะฐััั

ย ย // ... drawing ...

}

  

// 3. canvas.quickReject() ะดะปั early exit

override fun onDraw(canvas: Canvas) {

ย ย if (canvas.quickReject(objectBounds, Canvas.EdgeType.BW)) {

ย ย ย ย returnย // ะะฑัะตะบั ะฒะฝะต ัะบัะฐะฝะฐ, skip

ย ย }

ย ย // ... draw object ...

}

2. Too many draw calls

ะัะพะฑะปะตะผะฐ:

ะะฐะถะดัะน drawX() = ะพัะดะตะปัะฝะฐั ะบะพะผะฐะฝะดะฐ GPU

  

1000 drawCircle() calls = 1000 GPU commands = ะะะะะะะะ!

ะะตัะตะฝะธะต: Batching

// ะะะะฅะ:

for (point in points) {

ย ย canvas.drawCircle(point.x, point.y, radius, paint)ย // 1000 calls!

}

  

// ะฅะะะะจะ:

val path = Path()

for (point in points) {

ย ย path.addCircle(point.x, point.y, radius, Path.Direction.CW)

}

canvas.drawPath(path, paint)ย // 1 call!

3. Allocation ะฒ onDraw()

ะัะพะฑะปะตะผะฐ:

override fun onDraw(canvas: Canvas) {

ย ย val paint = Paint()ย // โ Allocation ะบะฐะถะดัะน frame!

ย ย val path = Path() ย ย // โย

ย ย canvas.drawPath(path, paint)

}

  

// ะะตะทัะปััะฐั: Garbage Collection ะฟะฐัะทั โ jank

ะะตัะตะฝะธะต:

// ะกะพะทะดะฐัั ะะะะ ะะะ

private val paint = Paint()

private val path = Path()

  

override fun onDraw(canvas: Canvas) {

ย ย path.reset()ย // ะัะธััะธัั ะฒะผะตััะพ ัะพะทะดะฐะฝะธั ะฝะพะฒะพะณะพ

ย ย // ... use paint and path ...

}

4. Bitmap decoding

ะัะพะฑะปะตะผะฐ:

// ะะตะบะพะดะธัะพะฒะฐะฝะธะต ะฑะพะปััะพะณะพ image ะฒ UI thread

val bitmap = BitmapFactory.decodeResource(resources, R.drawable.huge_image)

// ะะปะพะบะธััะตั UI ะฝะฐ 100-500ms! โ

ะะตัะตะฝะธะต:

// Background thread

lifecycleScope.launch(Dispatchers.IO) {

ย ย val bitmap = BitmapFactory.decodeResource(resources, R.drawable.huge_image)

ย ย withContext(Dispatchers.Main) {

ย ย ย ย imageView.setImageBitmap(bitmap)

ย ย }

}

  

4.4 BACKGROUND THREADING

Coroutines ะดะปั stroke evaluation

class DrawingView : View {

ย ย private val scope = CoroutineScope(Dispatchers.Main + SupervisorJob())

ย ย override fun onTouchEvent(event: MotionEvent): Boolean {

ย ย ย ย when (event.action) {

ย ย ย ย ย ย MotionEvent.ACTION_MOVE -> {

ย ย ย ย ย ย ย ย // FAST evaluation ะดะปั real-time feedback

ย ย ย ย ย ย ย ย val quickScore = quickEvaluate()ย // < 1ms

ย ย ย ย ย ย ย ย updateStrokeColor(quickScore)

ย ย ย ย ย ย ย ย invalidate()

ย ย ย ย ย ย }

ย ย ย ย ย ย MotionEvent.ACTION_UP -> {

ย ย ย ย ย ย ย ย // FULL evaluation ะฝะฐ background thread

ย ย ย ย ย ย ย ย scope.launch(Dispatchers.Default) {

ย ย ย ย ย ย ย ย ย ย val fullScore = comprehensiveEvaluate()ย // 10-20ms OK

ย ย ย ย ย ย ย ย ย ย withContext(Dispatchers.Main) {

ย ย ย ย ย ย ย ย ย ย ย ย showFinalFeedback(fullScore)

ย ย ย ย ย ย ย ย ย ย }

ย ย ย ย ย ย ย ย }

ย ย ย ย ย ย }

ย ย ย ย }

ย ย ย ย return true

ย ย }

ย ย private fun quickEvaluate(): Float {

ย ย ย ย // Simplified: ัะพะปัะบะพ coverage ั 20 ัะพัะบะฐะผะธ

ย ย ย ย val coverage = calculateCoverage(

ย ย ย ย ย ย referencePath,ย

ย ย ย ย ย ย userPath,ย

ย ย ย ย ย ย sampleCount = 20

ย ย ย ย )

ย ย ย ย return coverage.coveragePercent / 100f

ย ย }

ย ย private suspend fun comprehensiveEvaluate(): ComprehensiveEvaluation =ย

ย ย ย ย withContext(Dispatchers.Default) {

ย ย ย ย ย ย // ะัะต ะผะตััะธะบะธ ั ะฟะพะปะฝัะผ sample count

ย ย ย ย ย ย evaluator.evaluate(referencePath, userPath, timestamps)

ย ย ย ย }

}

  

4.5 MEMORY MANAGEMENT

Bitmap pooling

ะัะพะฑะปะตะผะฐ:

// ะกะพะทะดะฐะฒะฐัั ะฝะพะฒัะน bitmap ะดะปั ะบะฐะถะดะพะณะพ frame

val bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888)

// Allocation + GC ะฟะฐัะทั

ะะตัะตะฝะธะต: Bitmap pool

class BitmapPool(private val maxPoolSize: Int = 10) {

ย ย private val pool = mutableListOf<Bitmap>()

ย ย fun getBitmap(width: Int, height: Int): Bitmap {

ย ย ย ย // ะะพะฟัะพะฑะพะฒะฐัั ะฒะทััั ะธะท pool

ย ย ย ย val reusable = pool.find {ย

ย ย ย ย ย ย it.width == width && it.height == height && !it.isRecycled

ย ย ย ย }

ย ย ย ย return if (reusable != null) {

ย ย ย ย ย ย pool.remove(reusable)

ย ย ย ย ย ย reusable.eraseColor(Color.TRANSPARENT)ย // Clear

ย ย ย ย ย ย reusable

ย ย ย ย } else {

ย ย ย ย ย ย Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)

ย ย ย ย }

ย ย }

ย ย fun returnBitmap(bitmap: Bitmap) {

ย ย ย ย if (pool.size < maxPoolSize && !bitmap.isRecycled) {

ย ย ย ย ย ย pool.add(bitmap)

ย ย ย ย } else {

ย ย ย ย ย ย bitmap.recycle()

ย ย ย ย }

ย ย }

ย ย fun clear() {

ย ย ย ย pool.forEach { it.recycle() }

ย ย ย ย pool.clear()

ย ย }

}

LRU Cache ะดะปั paths

class PathCache(maxSize: Int = 50) {

ย ย private val cache = object : LruCache<String, Path>(maxSize) {

ย ย ย ย override fun sizeOf(key: String, value: Path): Int = 1

ย ย ย ย override fun entryRemoved(

ย ย ย ย ย ย evicted: Boolean,

ย ย ย ย ย ย key: String,

ย ย ย ย ย ย oldValue: Path,

ย ย ย ย ย ย newValue: Path?

ย ย ย ย ) {

ย ย ย ย ย ย // Clean up ะตัะปะธ ะฝัะถะฝะพ

ย ย ย ย }

ย ย }

ย ย fun get(lessonId: String): Path? = cache.get(lessonId)

ย ย fun put(lessonId: String, path: Path) {

ย ย ย ย cache.put(lessonId, path)

ย ย }

}

  

ะงะะกะขะฌ 5: OPENGL ES BASICS

5.1 ะะะะะ ะะกะะะะฌะะะะะขะฌ OPENGL

Canvas ะฟะพะดัะพะดะธั ะดะปั:

- 2D drawing apps โ
- Simple graphics โ
- ะะดะฝะพะฒัะตะผะตะฝะฝะพ ะผะฐะปะพ ะพะฑัะตะบัะพะฒ (< 100) โ

OpenGL ะฝัะถะตะฝ ะดะปั:

- 3D graphics โ
- Particle systems (1000+ particles) โ
- Advanced shaders โ
- Maximum performance โ

ะะปั ArtWorkout: Canvas ะดะพััะฐัะพัะฝะพ! โ

  

5.2 OPENGL ES RENDERING PIPELINE

ะฃะฟัะพัะตะฝะฝะฐั ััะตะผะฐ:

Vertices (ัะพัะบะธ)ย

ยย โ

Vertex Shader (GPU ะฟัะพะณัะฐะผะผะฐ)

ยย โ

Rasterization (ะฟัะตะฒัะฐัะตะฝะธะต ะฒ ะฟะธะบัะตะปะธ)

ยย โ

Fragment Shader (GPU ะฟัะพะณัะฐะผะผะฐ ะดะปั ะบะฐะถะดะพะณะพ ะฟะธะบัะตะปั)

ยย โ

Frame Buffer (ะบะพะฝะตัะฝะฐั ะบะฐััะธะฝะบะฐ)

Vertex Shader example:

// ะัะตะพะฑัะฐะทะพะฒะฐะฝะธะต 3D ะบะพะพัะดะธะฝะฐั ะฒ 2D ัะบัะฐะฝะฝัะต

attribute vec4 vPosition;

uniform mat4 uMVPMatrix;ย // Model-View-Projection matrix

  

void main() {

ย ย gl_Position = uMVPMatrix * vPosition;

}

Fragment Shader example:

// ะฆะฒะตั ะบะฐะถะดะพะณะพ ะฟะธะบัะตะปั

precision mediump float;

uniform vec4 vColor;

  

void main() {

ย ย gl_FragColor = vColor;ย // Output color

}

  

ะงะะกะขะฌ 6: ะะะฅะะขะะะขะฃะะ ะ DATA MODELS

6.1 DATA MODELS ะะะฏ ARTWORKOUT

Core entities

/**

ย* User profile

ย*/

data class User(

ย ย val id: String,

ย ย val name: String,

ย ย val email: String,

ย ย val subscription: SubscriptionType,

ย ย val progress: UserProgress,

ย ย val achievements: List<Achievement>

)

  

enum class SubscriptionType {

ย ย FREE,

ย ย PREMIUM,

ย ย PREMIUM_PLUS

}

  

/**

ย* Course (ะบะพะปะปะตะบัะธั ััะพะบะพะฒ)

ย*/

data class Course(

ย ย val id: String,

ย ย val title: String,

ย ย val description: String,

ย ย val category: CourseCategory,

ย ย val difficulty: Float,ย // 0-1

ย ย val lessons: List<String>,ย // Lesson IDs

ย ย val thumbnailUrl: String,

ย ย val estimatedHours: Int

)

  

enum class CourseCategory {

ย ย BASIC_SHAPES,

ย ย CALLIGRAPHY,

ย ย PORTRAIT,

ย ย LANDSCAPE,

ย ย ABSTRACT

}

  

/**

ย* Lesson (ะพะดะธะฝ ััะพะบ)

ย*/

data class Lesson(

ย ย val id: String,

ย ย val courseId: String,

ย ย val title: String,

ย ย val steps: List<LessonStep>,

ย ย val scoringConfig: ScoringConfig

)

  

/**

ย* LessonStep (ะพะดะธะฝ ัััะธั ะฒ ััะพะบะต)

ย*/

data class LessonStep(

ย ย val stepNumber: Int,

ย ย val instructionText: String,

ย ย val referencePath: ReferencePath,

ย ย val strokeParameters: StrokeParameters,

ย ย val hints: List<String> = emptyList()

)

  

/**

ย* Reference path (normalized 0-1 coordinates)

ย*/

data class ReferencePath(

ย ย val points: List<Point>,ย // Normalized coordinates

ย ย val isClosed: Boolean = false

)

  

data class Point(

ย ย val x: Float,ย // 0.0 - 1.0

ย ย val y: Float ย // 0.0 - 1.0

)

  

/**

ย* Stroke parameters ะดะปั evaluation

ย*/

data class StrokeParameters(

ย ย val toleranceRadius: Float = 20f,

ย ย val minCoverage: Float = 0.7f,

ย ย val maxDeviation: Float = 50f,

ย ย val requiresCorrectDirection: Boolean = true,

ย ย val minSmoothness: Float = 0.6f

)

  

/**

ย* Scoring configuration

ย*/

data class ScoringConfig(

ย ย val weights: EvaluationWeights = EvaluationWeights(),

ย ย val passingThreshold: Float = 0.75f,

ย ย val starsThresholds: List<Float> = listOf(0.75f, 0.85f, 0.95f)

)

  

6.2 NORMALIZED COORDINATES (0-1)

ะะฐัะตะผ ะฝะพัะผะฐะปะธะทะฐัะธั?

ะัะพะฑะปะตะผะฐ: Device fragmentation

ะะฐะปะตะฝัะบะธะน ัะตะปะตัะพะฝ: 720x1280px

ะกัะตะดะฝะธะน ัะตะปะตัะพะฝ: ย 1080x1920px

ะะปะฐะฝัะตั: ย ย ย ย ย 1440x2560px

Foldable:ย ย ย ย ย 2208x1768px

  

ะะฑัะพะปััะฝัะต ะฟะธะบัะตะปะธ ะะ ะะะะะขะะฎะข ะฝะฐ ัะฐะทะฝัั ัะบัะฐะฝะฐั!

ะะตัะตะฝะธะต: Normalize to 0-1

Point (0.5, 0.5) = ะะกะะะะ ัะตะฝัั ัะบัะฐะฝะฐ

Point (0, 0) = ะะกะะะะ ะฒะตััะฝะธะน ะปะตะฒัะน ัะณะพะป

Point (1, 1) = ะะกะะะะ ะฝะธะถะฝะธะน ะฟัะฐะฒัะน ัะณะพะป

  

ะะตะทะฐะฒะธัะธะผะพ ะพั ัะฐะทัะตัะตะฝะธั!

Conversion functions

/**

ย* Normalized (0-1) โ Screen pixels

ย*/

fun normalizedToScreen(

ย ย normalized: Point,

ย ย screenWidth: Int,

ย ย screenHeight: Int

): PointF {

ย ย return PointF(

ย ย ย ย normalized.x * screenWidth,

ย ย ย ย normalized.y * screenHeight

ย ย )

}

  

/**

ย* Screen pixels โ Normalized (0-1)

ย*/

fun screenToNormalized(

ย ย screen: PointF,

ย ย screenWidth: Int,

ย ย screenHeight: Int

): Point {

ย ย return Point(

ย ย ย ย screen.x / screenWidth,

ย ย ย ย screen.y / screenHeight

ย ย )

}

  

/**

ย* ReferencePath โ Android Path

ย*/

fun referencePathToAndroidPath(

ย ย referencePath: ReferencePath,

ย ย screenWidth: Int,

ย ย screenHeight: Int

): Path {

ย ย val path = Path()

ย ย referencePath.points.forEachIndexed { index, point ->

ย ย ย ย val screenPoint = normalizedToScreen(point, screenWidth, screenHeight)

ย ย ย ย if (index == 0) {

ย ย ย ย ย ย path.moveTo(screenPoint.x, screenPoint.y)

ย ย ย ย } else {

ย ย ย ย ย ย path.lineTo(screenPoint.x, screenPoint.y)

ย ย ย ย }

ย ย }

ย ย if (referencePath.isClosed) {

ย ย ย ย path.close()

ย ย }

ย ย return path

}

JSON Schema

{

ย "lessonId": "basic-circle-001",

ย "referencePath": {

ย ย "points": [

ย ย ย {"x": 0.5, "y": 0.3},

ย ย ย {"x": 0.7, "y": 0.5},

ย ย ย {"x": 0.5, "y": 0.7},

ย ย ย {"x": 0.3, "y": 0.5}

ย ย ],

ย ย "isClosed": true

ย },

ย "strokeParameters": {

ย ย "toleranceRadius": 20.0,

ย ย "minCoverage": 0.7,

ย ย "maxDeviation": 50.0,

ย ย "requiresCorrectDirection": false,

ย ย "minSmoothness": 0.6

ย }

}

  

ะงะะกะขะฌ 7: INTERVIEW TALKING POINTS

7.1 ะขะะะ ะะขะะะขะซ ะะ APPLICATION

Q3: Core Idea ัััะธัะพะฒะพะน ะพัะตะฝะบะธ

ะงัะพ ัั ะฝะฐะฟะธัะฐะป:

"Real-time stroke-by-stroke evaluation using distance metrics and smoothness analysis with immediate visual feedback"

ะะฐะบ ะทะฐัะธัะฐัั: "ะัะฟะพะปัะทัะตะผ ะบะพะผะฑะธะฝะฐัะธั ัะตัััะตั ะผะตััะธะบ. Hausdorff distance ะดะปั ะผะฐะบัะธะผะฐะปัะฝะพะณะพ ะพัะบะปะพะฝะตะฝะธั - ััะผะฟะปะธััั ะพะฑะฐ ะฟััะธ ะฒ 50 ัะพัะตะบ, ะดะปั ะบะฐะถะดะพะน reference ัะพัะบะธ ะฝะฐัะพะถั ะฑะปะธะถะฐะนััั user ัะพัะบั, ะฑะตัั ะผะฐะบัะธะผัะผ. Coverage - ะฟัะพัะตะฝั reference path ะฟะพะบัััะพะณะพ ะฒ ะฟัะตะดะตะปะฐั 20px tolerance. Smoothness ัะตัะตะท velocity variance - ะธะทะผะตััั ะบะพะฝัะธััะตะฝัะฝะพััั ัะบะพัะพััะธ. Direction ัะตัะตะท ััะฐะฒะฝะตะฝะธะต ะฒะตะบัะพัะพะฒ ัะตะณะผะตะฝัะพะฒ. ะะทะฒะตัะธะฒะฐั: coverage 40%, deviation 30%, direction 20%, smoothness 10%."

Follow-up: "ะะพัะตะผั ััะธ ะฒะตัะฐ?"

"Data-driven ะฒ ะธะดะตะฐะปะต - ะพะฑััะธัั ะฝะฐ ัะบัะฟะตััะฝัั ะพัะตะฝะบะฐั. ะกะตะนัะฐั ัะบัะฟะตััะฝัะน judgment ะพั ะฟะตะดะฐะณะพะณะพะฒ. Coverage 40% ะฟะพัะพะผั ััะพ incomplete stroke = ะพัะตะฒะธะดะฝัะน ะฟัะพะฒะฐะป. Deviation 30% - ัะพัะฝะพััั core skill. Direction 20% ะดะปั ัะตัะฝะธะบะธ, ะฒะฐะถะฝะพ ะฒ ะบะฐะปะปะธะณัะฐัะธะธ. Smoothness 10% - refinement, ะฝะต fundamental. ะะตัะฐ ะบะพะฝัะธะณััะธััะตะผัะต per lesson."

  

Q4: Data Model

ะงัะพ ัั ะฝะฐะฟะธัะฐะป:

"Users โ Courses โ Lessons โ Steps โ Reference Paths, plus Gallery, Analytics, Multiplayer"

ะะฐะบ ะทะฐัะธัะฐัั: "ะะตัะฐััะธัะตัะบะฐั ััััะบัััะฐ. User ัะพะดะตัะถะธั subscription, progress, achievements. Course - ะบะพะปะปะตะบัะธั ััะพะบะพะฒ ั category, difficulty. Lesson - ะผะฐััะธะฒ steps, ะบะฐะถะดัะน step ัะพะดะตัะถะธั ReferencePath (normalized coordinates 0-1) ะธ StrokeParameters (tolerance, thresholds). UserProgress ััะตะบะฐะตั completion per lesson. Gallery ะดะปั saved artwork. Analytics ะดะปั metrics. MultiplayerSession ะดะปั collaborative drawing."

Follow-up: "ะะพัะตะผั normalized coordinates?"

"Device fragmentation. Point (0.5, 0.5) ะะกะะะะ ัะตะฝัั ะฝะตะทะฐะฒะธัะธะผะพ ะพั 720p ะธะปะธ 2K ัะบัะฐะฝะฐ. Multiply by actual dimensions at runtime. ะะฝะฐะปะพะณ SVG viewBox."

  

Q8: Correctness Algorithm

ะงัะพ ัั ะฝะฐะฟะธัะฐะป:

"Multi-factor: distance 40%, coverage 30%, smoothness 20%, direction 10% using Hausdorff/Frรฉchet distance, real-time calculation under 16ms frame budget"

ะะฐะบ ะทะฐัะธัะฐัั: "Hausdorff O(nรm) = 2500 ะพะฟะตัะฐัะธะน ะดะปั 50 ัะพัะตะบ, ~0.25ms - ะพัะปะธัะฝะพ. ะะปั real-time ะฒะพ ะฒัะตะผั ACTION_MOVE ัะฟัะพัะฐั: ัะพะปัะบะพ coverage ั 20 ัะพัะบะฐะผะธ = 400 ะพะฟะตัะฐัะธะน, <1ms. ะะฐ ACTION_UP ะฟะพะปะฝะฐั ะพัะตะฝะบะฐ ะฝะฐ background thread - ะฒัะต 4 ะผะตััะธะบะธ, Coroutines Dispatchers.Default, ะผะพะถะฝะพ 10-20ms. Frรฉchet ะฑะพะปะตะต expensive ะธะท-ะทะฐ DP, ะฝะพ space-optimized ะฒะตััะธั O(min(n,m))."

  

Q9: CG Experience

ะงัะพ ัั ะฝะฐะฟะธัะฐะป:

"Google Filament PBR rendering, Snapchat Camera Kit AR, 60fps optimization on mid-range devices"

ะะฐะบ ะทะฐัะธัะฐัั: "ะคัะฝะดะฐะผะตะฝัะฐะปัะฝัะต ะฟัะพะฑะปะตะผั ะธะดะตะฝัะธัะฝั. ะ 3D: real-time input โ geometric processing โ visual feedback @ 60fps. ะ 2D drawing - ัะต ะถะต ะฟัะพะฑะปะตะผั. Touch precision - unprojection 2Dโ3D ะฐะฝะฐะปะพะณะธัะฝะพ touchโpath coordinates. Performance profiling - ัะต ะถะต ะธะฝััััะผะตะฝัั (Systrace, GPU Inspector), ัะต ะถะต bottlenecks (overdraw, draw calls). Filament - PBR rendering, material = basecolor+metallic+roughness, scene graph ัะฟัะฐะฒะปะตะฝะธะต. Snapchat Camera Kit - 68 facial landmarks, AR try-on @ 60fps, LOD systems. Canvas API ะฒัััั ะฑััััะพ - ัะปะพะถะฝัะต ัะฐััะธ ั ะทะฝะฐั."

  

7.2 ะกะะฏะะฌ AR/3D โ 2D DRAWING

Performance optimization

ะะฑัะธะต ะฟัะธะฝัะธะฟั:

3D:ย Reduce draw calls, GPU batching, LOD systems

2D:ย Reduce draw calls, Path batching, dirty rect optimization

  

ะะะะะะะะะ!

Frame budget:

3D @ 60fps:ย 16ms budget, profile ั Systrace

2D @ 60fps:ย 16ms budget, profile ั Systrace

  

ะขะ ะะ ะะะกะขะะฃะะะะขะซ!

Touch precision

3D: 2D screen touch โ unprojection โ 3D world ray โ hit detection

ย ย Matrix math: inverse(ViewProjection) ร screenCoords

  

2D: 2D screen touch โ path coordinates โ distance calculation

ย ย Coordinate transforms: normalize, scale

  

ะะะะะะะะงะะะฏ ะะะขะะะะขะะะ!

Gesture handling

3D: Multi-touch ะดะปั rotate/pan/zoom 3D models

ย ย - Pinch gesture โ scale

ย ย - Two-finger rotate โ rotation matrix

ย ย - Pan โ camera position

  

2D: Multi-touch ะดะปั canvas manipulation

ย ย - Pinch โ zoom canvas

ย ย - Two-finger rotate โ rotate view

ย ย - Pan โ scroll

  

ะขะ ะะ ะะะกะขะซ!

  

7.3 ะะะะะะกะซ ะะะฏ ะะะขะะะะฌะฎะะะ

Technical questions

1. "ะะฐะบะพะน tech stack ะดะปั backend?"

- ะะพะบะฐะทัะฒะฐะตั ะธะฝัะตัะตั ะบ full picture
- ะะพะถะตัั ะฟัะตะดะปะพะถะธัั ะธะดะตะธ ะฟะพ ะธะฝัะตะณัะฐัะธะธ

3. "ะะฐะบ ะฒั handle offline mode ะดะปั lessons?"

- CDN caching strategy?
- Progressive download?

5. "ะััั ะปะธ A/B testing ะดะปั evaluation thresholds?"

- ะะพะบะฐะทัะฒะฐะตั data-driven thinking
- Optimization mindset

Team questions

4. "ะะฐะบ ััััะบัััะธัะพะฒะฐะฝะฐ Android team?"

- ะกะบะพะปัะบะพ ัะฐะทัะฐะฑะพััะธะบะพะฒ?
- Code review process?

6. "ะะฐะบะธะต ะพัะฝะพะฒะฝัะต challenges ัะตะนัะฐั?"

- Performance on low-end devices?
- New features pipeline?

Product questions

6. "ะะฐะบะธะต metrics ะธัะฟะพะปัะทัะตัะต ะดะปั measuring success?"

- User retention?
- Lesson completion rate?
- Daily active users?

  

7.4 RED FLAGS ะงะะะ ะะะะะะะขะฌ

โ ะะ ะะะะะะ:

1. "ะฏ ะฝะต ะทะฝะฐั Canvas API"

ะะะะฅะ: "ะฏ ะฝะต ัะฐะฑะพัะฐะป ั Canvas, ะผะฝะต ะฝัะถะฝะพ ะฒัะตะผั ััะพะฑั ะฒัััะธัั"

ะฅะะะะจะ: "Canvas API ั ะฒัััั ะฑััััะพ - ััะพ ะธะฝััััะผะตะฝั. ะกะปะพะถะฝัะต ัะฐััะธย

ย ย ย ย (performance, real-time evaluation, touch precision) ั ัะถะตย

ย ย ย ย ัะตัะฐะป ะฒ 3D, ะฒ 2D ัะต ะถะต ะฟัะธะฝัะธะฟั"

2. "ะญัะพ ัะปะธัะบะพะผ ัะปะพะถะฝะพ"

ะะะะฅะ: "Stroke evaluation sounds complicated"

ะฅะะะะจะ: "Stroke evaluation - ะธะฝัะตัะตัะฝะฐั ะทะฐะดะฐัะฐ. ะฏ ะดัะผะฐั ะบะพะผะฑะธะฝะฐัะธัย

ย ย ย ย Hausdorff ะดะปั accuracy ะธ coverage ะดะปั completeness ะดะฐััย

ย ย ย ย ัะพัะพัะธะต ัะตะทัะปััะฐัั. ะะพะถะฝะพ ะฝะฐัะฐัั ั ะฟัะพััะพะน ะฒะตััะธะธ ะธ iterate"

3. "ะฃ ะผะตะฝั ะฝะตั ะพะฟััะฐ ะฒ drawing apps"

ะะะะฅะ: "I haven't built drawing apps before"

ะฅะะะะจะ: "Although I haven't built drawing apps specifically, my AR workย

ย ย ย ย is directly transferable - both are real-time user input โย

ย ย ย ย geometric processing โ visual feedback at 60fps"

โ ะะะะะะ:

1. "ะฏ ัะตัะฐะป ะฟะพัะพะถะธะต ะฟัะพะฑะปะตะผั"

"ะ Seamm ั ะพะฟัะธะผะธะทะธัะพะฒะฐะป AR try-on ะดะปั 60fps ะฝะฐ mid-range devices. Drawing app - ัะต ะถะต challenges: real-time rendering, touch precision, performance profiling"

2. "ะฃ ะผะตะฝั ะตััั ะธะดะตะธ"

"ะะฝัะตัะตัะฝะฐั ะผััะปั - ะผะพะถะตะผ ะธัะฟะพะปัะทะพะฒะฐัั machine learning ะดะปั ะฟะตััะพะฝะฐะปะธะทะฐัะธะธ thresholds ะฝะฐ ะพัะฝะพะฒะต user skill level"

3. "ะฏ ะฑััััะพ ััััั"

"Canvas API - ััะพ ะธะฝััััะผะตะฝั, ะตะณะพ ะผะพะถะฝะพ ะฒัััะธัั. ะะฐะถะฝะตะต ะฟะพะฝะธะผะฐัั ััะฝะดะฐะผะตะฝัะฐะปัะฝัะต ะฟัะธะฝัะธะฟั, ะฐ ะธั ั ะทะฝะฐั ะธะท 3D graphics ัะฐะฑะพัั"

  

7.5 CHECKLIST ะะะะะ ะะะขะะะะฌะฎ

ะะฐ ะดะตะฝั ะดะพ ะธะฝัะตัะฒัั:

- [ ] ะะพะฒัะพัะธัั Hausdorff vs Frรฉchet (ะบะปััะตะฒะพะต ัะฐะทะปะธัะธะต)
- [ ] ะะฐะฟะพะผะฝะธัั ัะพัะผัะปั weighted scoring
- [ ] ะะพะฒัะพัะธัั Canvas transformation ะฟะพััะดะพะบ (translateโrotateโscale)
- [ ] ะะพะฒัะพัะธัั MotionEvent action types
- [ ] ะะพะฒัะพัะธัั Frame budget 16ms breakdown

ะะฐ ัะฐั ะดะพ ะธะฝัะตัะฒัั:

- [ ] ะัะบัััั ััะพั ะดะพะบัะผะตะฝั ะดะปั quick reference
- [ ] ะัะพะฒะตัะธัั demo project ะณะพัะพะฒ
- [ ] GitHub profile ะพัะบััั
- [ ] ะะพะดะณะพัะพะฒะธัั 2-3 ะฒะพะฟัะพัะฐ ะดะปั ะธะฝัะตัะฒััะตัะฐ

ะะพ ะฒัะตะผั ะธะฝัะตัะฒัั:

- [ ] ะฃะฟะพะผัะฝััั demo project ะฒ ะฝะฐัะฐะปะต
- [ ] ะะพะบะฐะทะฐัั ัะฝััะทะธะฐะทะผ ะบ ะฟัะพะดัะบัั
- [ ] ะกะฒัะทัะฒะฐัั ะบะฐะถะดัะน ะพัะฒะตั ั AR/3D experience
- [ ] ะะฐะดะฐัั ะผะธะฝะธะผัะผ 2 ะฒะพะฟัะพัะฐ ะฒ ะบะพะฝัะต

  

ะคะะะะะฌะะซะ ะกะะะะขะซ

ะะปะฐะฒะฝะพะต ััะพ ะฝัะถะฝะพ ะดะพะฝะตััะธ:

1. Problem-solving ability

"ะฏ ะฝะต ะทะฝะฐั Canvas API ะฝะฐะธะทัััั, ะฝะพ ั ะทะฝะฐั ะบะฐะบ ัะตัะฐัั performance ะฟัะพะฑะปะตะผั, ะบะฐะบ ัะฐะฑะพัะฐัั ั touch events, ะบะฐะบ ะฟัะพัะธะปะธัะพะฒะฐัั. ะะพะฝะบัะตัะฝัะน API - ััะพ ะดะตัะฐะปะธ"

2. Learning capacity

"ะะฐ 3 ะฝะตะดะตะปะธ ะฒ Seamm ั ะฒัััะธะป Snapchat Camera Kit ั ะฝัะปั ะธ delivered working AR feature. Canvas API ะฟัะพัะต ัะตะผ AR SDK"

3. Technical depth

"ะฏ ะฟะพะฝะธะผะฐั ััะพ ะฟะพะด ะบะฐะฟะพัะพะผ - coordinate transformations, GPU pipeline, rendering optimization. ะญัะพ transferable knowledge"

4. Leadership readiness

"ะ QazCode ั mentoring junior developers, code reviews, ะฐััะธัะตะบัััะฝัะต ัะตัะตะฝะธั. ะะพัะพะฒ ะบ Lead role"

  

ะะขะะะะะะฏ ะขะะะะะฆะ: ะะซะกะขะะะฏ ะกะะะะะะ

|   |   |   |   |
|---|---|---|---|
|ะะพะฝัะตะฟั|ะงัะพ ััะพ|ะะฐัะตะผ|Complexity|
|Hausdorff|Max ะพัะบะปะพะฝะตะฝะธะต|Accuracy|O(nรm) ~0.25ms|
|Frรฉchet|ะก ััะตัะพะผ ะฟะพััะดะบะฐ|ะขะตัะฝะธะบะฐ|O(nรm) ~1ms|
|Coverage|% ะฟะพะบัััะธั|Completeness|O(nรm) ~0.1ms|
|Smoothness|ะะปะฐะฒะฝะพััั|Confidence|O(n) ~0.05ms|
|Weighted|ะะพะผะฑะธะฝะฐัะธั|Robust eval|Sum of above|
|Canvas|2D drawing API|Rendering|Hardware accel|
|Path|Bezier curves|Smooth lines|GPU optimized|
|Touch Events|Input system|User interaction|100-120 Hz|
|Frame Budget|60fps = 16ms|Performance|Critical!|

  

ะฃะะะงะ ะะ ะะะขะะะะฌะฎ! ๐

ะขั ะฟะพะดะณะพัะพะฒะปะตะฝ ะณะปัะฑะถะต ัะตะผ 99% ะบะฐะฝะดะธะดะฐัะพะฒ. ะะพะบะฐะถะธ ะฝะต ัะพะปัะบะพ ะทะฝะฐะฝะธั, ะฝะพ ะธ ัะฟะพัะพะฑะฝะพััั ะะฃะะะขะฌ ะพ ะฟัะพะฑะปะตะผะฐั. ะขะฒะพะน AR/3D ะพะฟัั - ััะพ ัะฒะพะต ะบะพะฝะบััะตะฝัะฝะพะต ะฟัะตะธะผััะตััะฒะพ. ะัะฟะพะปัะทัะน ะตะณะพ!