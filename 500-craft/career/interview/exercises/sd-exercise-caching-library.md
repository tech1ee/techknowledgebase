---
title: "SD Exercise: Caching Library"
created: 2026-02-14
modified: 2026-02-14
type: exercise
status: published
confidence: high
tags:
  - topic/career
  - type/exercise
  - level/advanced
  - interview
  - system-design
related:
  - "[[system-design-android]]"
  - "[[caching-strategies]]"
  - "[[android-data-persistence]]"
prerequisites:
  - "[[system-design-android]]"
reading_time: 15
difficulty: 7
study_status: not_started
mastery: 0
last_reviewed:
next_review:
---

# SD Exercise: Caching Library

Это упражнение по Mobile System Design: проектирование **универсальной кэширующей библиотеки** для мобильной платформы. Формат -- живой диалог кандидата с интервьюером. Задача проверяет умение декомпозировать задачу, предлагать API, проектировать внутреннюю архитектуру и обсуждать trade-offs.

Кэширование -- одна из самых частых тем на Mobile SD-интервью. В отличие от проектирования конкретного экрана (лента, чат, галерея), задача "спроектируй библиотеку" проверяет более глубокое понимание: конкурентность, персистентность, дисковый I/O, управление памятью. Здесь нельзя отделаться общими словами -- нужно показать знание платформенных ограничений.

> Рекомендуется сначала изучить [[system-design-android]] -- там описан общий фреймворк прохождения Mobile SD интервью. Тема кэширования в целом (стратегии, паттерны, инвалидация) детально разобрана в [[caching-strategies]].

---

## Задача -- "Design a Caching Library"

Интервьюер ставит задачу максимально размыто:

> **Interviewer**: Design a caching library for a mobile platform.

Этого определения недостаточно для проектирования. Первый шаг -- **собрать требования** через уточняющие вопросы.

---

## Сбор требований

> **Candidate**: Первый вопрос: эта библиотека проектируется как общая (general-purpose), которую могут подключить разные приложения, или как решение для конкретного приложения?

> **Interviewer**: Общая библиотека. Другие разработчики будут подключать её как зависимость.

> **Candidate**: Понял. Какой тип данных мы кэшируем? Структурированные объекты, изображения, произвольные байты?

> **Interviewer**: Произвольные байты. Библиотека не должна знать о формате данных.

> **Candidate**: Какой формат ключей? Строки?

> **Interviewer**: Да, строковые ключи.

> **Candidate**: Какие ограничения по размеру одного элемента и общему количеству элементов?

> **Interviewer**: До 10 МБ на один элемент, тысячи элементов суммарно.

> **Candidate**: Это важно для выбора хранилища. При таких объёмах нужен гибридный подход: in-memory кэш для быстрого доступа к подмножеству элементов и persistent-хранилище на диске для полного набора данных. Диск -- основное хранилище, память -- "горячий" слой.

> **Interviewer**: Согласен. Продолжай.

> **Candidate**: Какие политики вытеснения нужны? LRU, LFU, FIFO?

> **Interviewer**: Поддержи несколько стратегий, которые настраиваются при инициализации.

> **Candidate**: Нужна ли поддержка шифрования хранимых данных?

> **Interviewer**: Давай вынесем это за рамки MVP и обсудим позже как follow-up.

> **Candidate**: Хорошо. Резюмирую требования.

### Функциональные требования

| # | Требование |
|---|------------|
| F1 | Кэшировать и извлекать произвольные байтовые данные по строковому ключу |
| F2 | Конфигурировать лимиты памяти и диска при инициализации |
| F3 | Конфигурировать политику вытеснения при инициализации |

### Нефункциональные требования

| # | Требование |
|---|------------|
| NF1 | Персистентное хранилище на диске |
| NF2 | In-memory подмножество для быстрого доступа |
| NF3 | Автоматическое вытеснение элементов при превышении лимитов |

### Вне скоупа (MVP)

- Пользовательские стратегии вытеснения
- Шифрование данных
- Кросс-платформенность

---

## Client Public API

> **Candidate**: Начну с публичного API. Я хочу сделать его минимальным, но достаточным.

```
Cache
  + init(config: CacheConfig)
  + set(key: String, value: [byte]): CacheTask
  + get(key: String): CacheTask
  + clear(key: String): CacheTask
  + clearAll()

CacheConfig
  + init(
      maxMemoryCacheSize: Int,
      maxDiskCacheSize: Int,
      evictionPolicy: EvictionPolicy
    )

EvictionPolicy
  LRU | LFU | FIFO

CacheTask
  + isSuccessful(): Bool
  + getCachedData(): [byte]?
  + getErrorMessage(): String?
  + addOnCompleteCallback(callback: (CacheTask) -> Void)
```

> **Interviewer**: Почему `set` и `get` возвращают `CacheTask`, а не данные напрямую?

> **Candidate**: Потому что операции `get` и `set` могут вызвать блокирующие I/O-операции -- чтение/запись на диск. Если вызвать их синхронно на main thread, получим зависание UI, ANR на Android или watchdog-kill на iOS. `CacheTask` -- обёртка для асинхронного результата с callback-ом. Клиент вызывает `addOnCompleteCallback`, и результат приходит когда операция завершена.

> **Interviewer**: Хорошо. Перейдём к внутренней архитектуре.

---

## High-Level Architecture

> **Candidate**: Вот компоненты библиотеки и как они взаимодействуют:

```
┌─────────────────────────────────────────────────┐
│                  Client Code                     │
│           cache.set(key, data)                   │
└────────────────────┬────────────────────────────┘
                     │ CacheTask
                     v
┌─────────────────────────────────────────────────┐
│                  Dispatcher                      │
│         Worker Pool (N threads)                  │
│    ┌──────────┬──────────┬──────────┐           │
│    │ Worker 1 │ Worker 2 │ Worker N │           │
│    └────┬─────┴────┬─────┴────┬─────┘           │
└─────────┼──────────┼──────────┼─────────────────┘
          │          │          │
          v          v          v
┌─────────────────────────────────────────────────┐
│              Core Components                     │
│                                                  │
│  ┌──────────────┐  ┌───────────────────────┐    │
│  │  In-Memory   │  │   Persistent Store    │    │
│  │    Cache     │  │  (File System / DB)   │    │
│  └──────┬───────┘  └──────────┬────────────┘    │
│         │                     │                  │
│         v                     v                  │
│  ┌──────────────────────────────────────────┐   │
│  │              Journal                      │   │
│  │   (key, size, access_count, last_access)  │   │
│  └──────────────────┬───────────────────────┘   │
│                     │                            │
│                     v                            │
│  ┌──────────────────────────────────────────┐   │
│  │          Cache Eviction                   │   │
│  │   LRU / LFU / FIFO                       │   │
│  └──────────────────────────────────────────┘   │
└─────────────────────────────────────────────────┘
```

**Пять ключевых компонентов:**

| Компонент | Ответственность |
|-----------|----------------|
| **Dispatcher** | Координация асинхронных операций чтения/записи |
| **Journal** | Хранение метаданных о каждом элементе кэша |
| **In-Memory Cache** | Быстрый доступ к "горячему" подмножеству |
| **Persistent Store** | Хранение данных на диске |
| **Cache Eviction** | Вытеснение элементов при превышении лимитов |

> **Interviewer**: Хорошо. Давай погружаться в каждый компонент.

---

## Deep Dive: Dispatcher

> **Candidate**: Dispatcher -- это входная точка для всех операций. Его задача -- убрать I/O с main thread.

### Принцип работы

```
Main Thread                    Worker Thread
    │                              │
    │  cache.set(key, data)        │
    │──────────────────────>       │
    │  return CacheTask            │
    │                              │  write to disk
    │                              │  update journal
    │                              │  update memory cache
    │  callback(CacheTask)         │
    │<─────────────────────────────│
    │  (on main thread)            │
```

1. Клиент вызывает `set`/`get` -- Dispatcher помещает задачу в очередь.
2. Свободный Worker из пула забирает задачу, выполняет I/O.
3. Worker уведомляет Dispatcher о завершении.
4. Dispatcher вызывает callback клиента **на main thread** (или на указанном executor-е).

### Пул воркеров

> **Candidate**: Размер пула -- важный trade-off. Слишком мало воркеров -- операции встают в очередь и ждут. Слишком много -- создаём лишние потоки, расходуем память и CPU на переключение контекстов. Для кэширующей библиотеки 2-4 воркера -- разумный дефолт.

> **Interviewer**: Почему не использовать один поток?

> **Candidate**: Один поток создаст узкое место: пока идёт запись элемента на 10 МБ, все чтения будут заблокированы. С пулом из нескольких потоков операции чтения не ждут длинных записей.

### Управление конкурентностью

> **Interviewer**: Как обрабатываешь ситуацию, когда два воркера одновременно пишут по одному ключу?

> **Candidate**: Нужна синхронизация на уровне ключа. Варианты:
> 1. **Глобальный lock** на всю запись -- просто, но убивает параллелизм.
> 2. **Per-key lock** (ConcurrentHashMap<String, Lock>) -- разные ключи обрабатываются параллельно, одинаковые -- последовательно.
> 3. **Оптимистичный подход** -- "последний пишет, тот и прав" (last-write-wins). Для кэша это допустимо: данные по ключу всегда можно перезапросить.

Я бы начал с per-key lock -- это даёт предсказуемое поведение и не сильно усложняет код. Для библиотеки общего назначения предсказуемость важнее абсолютной производительности.

### Обработка ошибок

> **Candidate**: Если I/O-операция упала (диск заполнен, permission denied, corrupted data), Worker ловит исключение, устанавливает `CacheTask.isSuccessful = false` и `errorMessage`, затем вызывает callback. Клиент **всегда** получает результат -- успех или ошибку, но никогда не зависает в ожидании.

---

## Deep Dive: Journal

> **Candidate**: Journal хранит метаданные о каждом кэшированном элементе. Без него невозможно реализовать вытеснение, подсчитать текущий размер кэша или определить, какой элемент использовался давно.

### Структура метаданных

| Поле | Тип | Назначение |
|------|-----|------------|
| `key` | String | Идентификатор элемента (PK) |
| `size_bytes` | Int | Размер в байтах (для контроля лимита) |
| `access_count` | Int | Счётчик обращений (для LFU) |
| `last_accessed` | Date | Время последнего доступа (для LRU) |

При каждом `get` или `set` обновляются `access_count` и `last_accessed`. Эти данные позволяют Cache Eviction решать, какой элемент удалить первым.

### Варианты хранения Journal

> **Interviewer**: Как хранить эти метаданные?

> **Candidate**: Есть три варианта:

| Вариант | Плюсы | Минусы |
|---------|-------|--------|
| **Текстовый файл** | Простота | Нет индексов, медленный поиск |
| **Property List / SharedPrefs** | Простое чтение/запись | Нет partial update, грузится целиком |
| **ORM / реляционная БД** | Индексы, частичное обновление, целостность данных | Зависимость от Room/CoreData/SQLDelight |

> **Candidate**: Я рекомендую **реляционную БД** (Room на Android, SQLDelight для KMP). Нам нужны запросы с сортировкой (`ORDER BY last_accessed`, `ORDER BY access_count`), partial update и целостность данных при крашах. Текстовые файлы или property lists не дадут этого эффективно.

---

## Deep Dive: Persistent Store

> **Candidate**: Теперь -- как хранить сами данные на диске. Два подхода.

### Вариант 1: File System

Каждый элемент кэша -- отдельный файл. Имя файла -- сгенерированный UUID (пользовательские ключи могут содержать недопустимые символы для файловой системы).

**Расширенная структура Journal:**

| Поле | Тип |
|------|-----|
| `key` | String |
| `path` | String (UUID filename) |
| `size_bytes` | Int |
| `access_count` | Int |
| `last_accessed` | Date |
| `state` | Int (CLEAN / DIRTY / REMOVE) |

> **Candidate**: Поле `state` нужно для защиты от race conditions. Представь: мы начали писать файл, приложение крашнулось. Файл записан наполовину, но Journal считает его валидным. Поэтому:
> - **DIRTY** -- запись в процессе
> - **CLEAN** -- запись завершена успешно
> - **REMOVE** -- файл помечен на удаление
>
> При запуске библиотека сканирует Journal и удаляет элементы в состоянии DIRTY или REMOVE.

**Минус:** Journal и файловая система -- два независимых хранилища, которые нужно синхронизировать. Это усложняет код и создаёт потенциальные race conditions.

### Вариант 2: BLOB в базе данных

Бинарные данные хранятся прямо в базе данных рядом с метаданными.

| Поле | Тип |
|------|-----|
| `key` | String |
| `data` | BLOB |
| `size_bytes` | Int |
| `access_count` | Int |
| `last_accessed` | Date |

> **Interviewer**: В чём преимущество?

> **Candidate**: Главное -- **атомарность**. Данные и метаданные хранятся в одной транзакции. Не нужен `state` и нет рассинхрона между Journal и файловой системой. Journal и Persistent Store по сути **объединяются** в один компонент.

### Сравнение подходов

| Критерий | File System | BLOB в БД |
|----------|-------------|-----------|
| Атомарность | Нужен state-машина | Транзакции БД |
| Сложность кода | Высокая (синхронизация) | Низкая |
| Доступ к файлам извне | Возможен | Нет (данные внутри БД) |
| Очистка данных | Удалить файл | Только через БД |
| Подходит для крупных BLOB | Лучше (потоковое чтение) | Хуже (весь BLOB в память) |
| Масштабируемость | Файловая система ОС | Лимиты SQLite |

> **Candidate**: Для элементов до 10 МБ BLOB-подход проще и надёжнее. Если бы элементы были по 100+ МБ, стоило бы использовать файловую систему с потоковым чтением. Рекомендую **BLOB-подход** как дефолт.

---

## Deep Dive: Cache Eviction

> **Candidate**: Cache Eviction -- отдельный компонент. По принципу SRP (Single Responsibility Principle), ни Journal, ни In-Memory Cache не должны знать о логике вытеснения.

### Когда срабатывает

```
set(key, data)
    │
    v
Проверить: currentSize + data.size > maxSize ?
    │                          │
   Нет                        Да
    │                          │
    v                          v
  Записать               Eviction.purge(needToFree)
                               │
                               v
                         Удалить N элементов
                         по выбранной политике
                               │
                               v
                           Записать
```

### Реализация для диска (SQL)

> **Candidate**: Для дискового кэша используем SQL-запрос. Например, для LRU:

```sql
DELETE FROM cache
WHERE key IN (
  SELECT key FROM cache
  ORDER BY last_accessed ASC
  LIMIT ?
)
```

> **Candidate**: Через SQL-курсор мы можем удалить нужное количество элементов без загрузки их данных в память. Это эффективно: не нужно десериализовывать BLOB, только прочитать метаданные.

Для LFU заменяем `ORDER BY last_accessed` на `ORDER BY access_count ASC, last_accessed ASC`. Для FIFO -- по дате создания.

### Реализация для памяти

> **Candidate**: Для in-memory кэша подход другой. Данные уже в памяти, поэтому используем кастомный итератор по коллекции.

> **Interviewer**: Какую структуру данных используешь для in-memory?

> **Candidate**: Самобалансирующееся дерево (TreeMap / red-black tree) с кастомным компаратором по `last_accessed` или `access_count` в зависимости от политики. Это даёт O(log n) на вставку, удаление и извлечение минимального элемента. Альтернатива для LRU -- `LinkedHashMap` с `accessOrder=true`, где вытеснение -- O(1).

### Связь In-Memory и Disk кэша

> **Interviewer**: Как синхронизировать содержимое памяти и диска?

> **Candidate**: Диск -- source of truth. In-memory кэш -- это **read-through подмножество**: при `get`, если элемент есть в памяти, возвращаем мгновенно; если нет -- читаем с диска, кладём в память и возвращаем. При `set` -- пишем на диск и в память одновременно. Если in-memory переполнен, вытесняем из памяти, но на диске элемент остаётся. Таким образом, потеря in-memory кэша (например, при нехватке RAM) не приводит к потере данных.

```
get(key)
    │
    v
In-Memory Cache: есть?
    │           │
   Да          Нет
    │           │
    v           v
  return     Disk: есть?
  data         │         │
              Да        Нет
               │         │
               v         v
          Прочитать    return null
          с диска
               │
               v
          Положить в
          In-Memory
               │
               v
          return data
```

---

## Follow-up: Encrypted Storage

> **Interviewer**: Теперь давай обсудим шифрование. Как бы ты добавил поддержку зашифрованного хранения?

> **Candidate**: Два подхода.

### Подход 1: Шифрование всей БД

Используем SQLCipher или аналог -- вся база данных шифруется одним ключом. Просто подключить, но шифруются **все** данные, даже те, которым шифрование не нужно. Накладные расходы на каждую операцию.

### Подход 2: Шифрование отдельных элементов

Шифруем только BLOB конкретного элемента. Добавляем поле `encrypted: Bool` в схему. Более гибко, но сложнее в реализации.

### Хранение ключей

- **Android**: Android Keystore -- аппаратное хранилище ключей
- **iOS**: Keychain Services

> **Candidate**: Важный момент: данные не могут считаться по-настоящему защищёнными, если ключ шифрования хранится на том же устройстве. Но для большинства сценариев -- это приемлемый уровень защиты.

### Custom Encryption Interface

```
CacheEncryption
  + encrypt(data: [byte]): [byte]
  + decrypt(data: [byte]): [byte]

CacheConfig
  + setCacheEncryption(encryption: CacheEncryption)
```

> **Candidate**: Клиенты передают свою реализацию `CacheEncryption` через конфиг. Это даёт гибкость: кто-то может загрузить ключ с бэкенда при логине, кто-то использует биометрию для доступа к ключу в Keystore. Библиотека не навязывает конкретный способ шифрования.

> **Interviewer**: А как шифрование влияет на производительность?

> **Candidate**: Шифрование и дешифрование -- это CPU-затраты на каждую операцию `set`/`get`. Для AES-256 на современных устройствах с аппаратной поддержкой (ARMv8 Crypto Extensions) overhead минимален: единицы миллисекунд на 10 МБ. Но на старых устройствах без аппаратного ускорения -- может быть заметен. Поэтому шифрование opt-in, а не default.

---

## Follow-up: Cross-Platform

> **Interviewer**: Что если нужно поддержать и Android, и iOS?

> **Candidate**: Два пути:

### Путь 1: Общий модуль на C/C++

Ядро библиотеки (Journal, Eviction, работа с SQLite) пишется на C/C++. Платформенные адаптеры на Java/Kotlin и Swift/Objective-C обеспечивают интеграцию с API платформы.

```
┌─────────────────────────────────────┐
│         Platform Adapters           │
│  ┌──────────┐    ┌──────────────┐  │
│  │  Kotlin  │    │ Swift / ObjC │  │
│  │  Adapter │    │   Adapter    │  │
│  └─────┬────┘    └──────┬───────┘  │
│        │                │          │
│        v                v          │
│  ┌──────────────────────────────┐  │
│  │     Common C/C++ Core       │  │
│  │  Journal + Eviction + SQLite │  │
│  └──────────────────────────────┘  │
└─────────────────────────────────────┘
```

### Путь 2: Kotlin Multiplatform

Общий код на Kotlin, компилируется в JVM bytecode для Android и Kotlin/Native для iOS. Подробнее -- в [[android-data-persistence]] и документации KMP.

### Сложности нативного кода (C/C++)

| Проблема | Влияние |
|----------|---------|
| Отладка | Breakpoints в C++ из Android Studio / Xcode -- больно |
| Crash logs | Stack trace из нативного кода -- нечитаемый без символов |
| Архитектуры | Нужно собирать под arm64, x86_64 и т.д. |
| Стабильность | Segfault вместо Exception -- краш без возможности catch |
| Порог входа | Не каждый мобильный разработчик знает C++ |
| Сообщество | Меньше контрибьюторов, если ядро на C++ |

> **Candidate**: Kotlin Multiplatform сегодня -- более прагматичный выбор для большинства команд. C/C++ оправдан, если нужна максимальная производительность или уже есть экспертиза.

---

## Trade-offs

Подведём итог ключевых компромиссов, принятых при проектировании:

| Решение | Альтернатива | Почему выбрали |
|---------|-------------|----------------|
| Пул из 2-4 воркеров | 1 поток / неограниченный пул | Баланс между отзывчивостью и расходом ресурсов |
| BLOB в БД | Файловая система | Атомарность, простота, нет рассинхрона |
| ORM для Journal | Текстовый файл / SharedPrefs | Индексы, partial update, SQL-запросы для eviction |
| Отдельный Eviction-компонент | Eviction внутри Journal | SRP, тестируемость, заменяемость политики |
| CacheTask (async) | Синхронный API | Безопасность main thread |
| Pre-defined политики | Пользовательские стратегии | Простота MVP, можно расширить позже |

**Главный вывод:** На интервью не нужно делать идеальный дизайн. Нужно показать **сигнал**: ты понимаешь trade-offs, осознанно выбираешь одну сторону и можешь объяснить почему. Интервьюер проверяет не "правильный ответ", а ход мышления. Подробнее о подходе к Mobile SD интервью -- в [[system-design-android]].

### О чём часто забывают на интервью

| Пропущенная тема | Почему это критично |
|-------------------|---------------------|
| Thread safety при конкурентных записях | Без синхронизации -- data corruption |
| Поведение при нехватке дискового пространства | `set` должен возвращать ошибку, а не крашить |
| Миграция схемы БД | Новая версия библиотеки может менять формат Journal |
| Инвалидация по TTL | Многие кэши поддерживают TTL -- стоит упомянуть как расширение |

---

## Проверь себя

Разверни каждый вопрос и проверь, совпадает ли твой ответ с предложенным.

<details>
<summary><strong>1. Почему методы set/get возвращают CacheTask, а не данные напрямую?</strong></summary>

Операции `set` и `get` могут включать блокирующий I/O (чтение/запись на диск). Вызов на main thread приведёт к зависанию UI, ANR (Android) или watchdog-kill (iOS). `CacheTask` -- обёртка для асинхронного результата: клиент подписывается через callback и получает результат когда операция завершена.

</details>

<details>
<summary><strong>2. Зачем нужен Journal, если данные уже хранятся в Persistent Store?</strong></summary>

Journal хранит **метаданные**: размер, счётчик обращений, время последнего доступа. Эти данные необходимы для подсчёта текущего размера кэша и для реализации политик вытеснения (LRU, LFU, FIFO). Без Journal невозможно определить, какой элемент удалить первым, не загружая все BLOB-ы в память.

</details>

<details>
<summary><strong>3. В чём главное преимущество BLOB-хранения перед файловой системой?</strong></summary>

**Атомарность.** Данные и метаданные записываются в одной транзакции БД. Не нужен state-машина (CLEAN/DIRTY/REMOVE), нет рассинхрона между Journal и файловой системой, нет риска "записали файл наполовину, приложение упало".

</details>

<details>
<summary><strong>4. Почему Cache Eviction -- отдельный компонент, а не часть Journal?</strong></summary>

Принцип единственной ответственности (SRP). Journal отвечает за хранение метаданных, In-Memory Cache -- за быстрый доступ. Если добавить туда логику вытеснения, компоненты становятся "толстыми" и сложными для тестирования. Отдельный Eviction-компонент легко тестировать изолированно и можно подменять политику без изменения остального кода.

</details>

<details>
<summary><strong>5. Какие проблемы возникают при использовании C/C++ для кросс-платформенного ядра?</strong></summary>

Сложная отладка (breakpoints через JNI/FFI), нечитаемые crash logs без debug-символов, необходимость собирать под несколько архитектур (arm64, x86_64), segfault вместо исключений (краш без catch), высокий порог входа для мобильных разработчиков и меньше потенциальных контрибьюторов.

</details>

---

## Ключевые карточки

| # | Вопрос | Ответ |
|---|--------|-------|
| 1 | Из каких 5 компонентов состоит Caching Library? | Dispatcher, Journal, In-Memory Cache, Persistent Store, Cache Eviction |
| 2 | Зачем Dispatcher использует пул воркеров? | Чтобы I/O-операции не блокировали main thread и не ждали друг друга |
| 3 | Какие поля хранит Journal? | `key`, `size_bytes`, `access_count`, `last_accessed` |
| 4 | Два варианта Persistent Store и когда какой? | BLOB в БД -- для элементов до 10 МБ (атомарность); File System -- для крупных файлов (потоковое чтение) |
| 5 | Как eviction работает для дискового кэша? | SQL-запрос с ORDER BY по нужной метрике + LIMIT, без загрузки BLOB-ов в память |
| 6 | Как добавить шифрование, не меняя ядро библиотеки? | Кастомный `CacheEncryption` интерфейс: клиент передаёт реализацию encrypt/decrypt через CacheConfig |

---

## Куда дальше

| Направление | Ссылка |
|-------------|--------|
| Общий фреймворк Mobile SD | [[system-design-android]] |
| Стратегии кэширования (backend + mobile) | [[caching-strategies]] |
| Хранение данных на Android | [[android-data-persistence]] |
| Room -- ORM для Android | [[android-room-deep-dive]] |

---

## Источники

- [Mobile System Design Exercises -- Caching Library](https://github.com/iartr/mobile-system-design/blob/master/exercises/caching-library.md) -- исходное упражнение (адаптировано и дополнено)
- [Android Developers -- Data and file storage overview](https://developer.android.com/training/data-storage)
- [SQLite Documentation -- BLOB](https://www.sqlite.org/datatype3.html)
