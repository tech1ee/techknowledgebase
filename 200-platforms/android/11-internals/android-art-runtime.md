---
title: "ART Runtime: от DEX-байткода до машинного кода"
created: 2026-02-19
modified: 2026-02-19
type: deep-dive
area: android
confidence: high
tags:
  - topic/android
  - topic/art
  - topic/runtime
  - topic/internals
  - type/deep-dive
  - level/expert
related:
  - "[[android-boot-process]]"
  - "[[android-app-startup-performance]]"
  - "[[android-process-memory]]"
  - "[[android-compilation-pipeline]]"
  - "[[android-architecture]]"
  - "[[android-kernel-extensions]]"
  - "[[jvm-basics-history]]"
  - "[[jvm-gc-tuning]]"
  - "[[jvm-memory-model]]"
  - "[[jvm-virtual-machine-concept]]"
cs-foundations: [virtual-machine, compiler-design, garbage-collection, class-loading, bytecode-interpretation, jit-compilation, aot-compilation, profile-guided-optimization]
prerequisites:
  - "[[android-architecture]]"
  - "[[android-compilation-pipeline]]"
  - "[[jvm-basics-history]]"
reading_time: 105
difficulty: 9
study_status: not_started
mastery: 0
last_reviewed:
next_review:
---

# ART Runtime: от DEX-байткода до машинного кода

> В Android 5.0 Google совершил одну из самых масштабных замен runtime в истории ПО: Dalvik → ART. 1.4 миллиарда устройств перешли на новую виртуальную машину за два года. Но история на этом не закончилась — с тех пор ART менял стратегию компиляции три раза: AOT-only (5.0) → Hybrid JIT+AOT (7.0) → Profile-guided с Cloud Profiles (9.0+). Каждое изменение — это другой баланс между скоростью запуска, peak performance и размером на диске.

> **Prerequisites:**
> - [[android-architecture]] — общая архитектура Android (слои)
> - [[android-compilation-pipeline]] — как исходный код превращается в DEX (build-time)
> - [[jvm-basics-history]] — концепция виртуальной машины, байткод

---

## Терминология

| Термин | Значение |
|--------|----------|
| **ART** | Android Runtime — виртуальная машина, исполняющая DEX-байткод |
| **Dalvik** | Предшественник ART (Android 1.0–4.4), register-based VM |
| **DEX** | Dalvik Executable — формат байткода для Android |
| **OAT** | Ahead-of-Time compiled native code + DEX (ELF-обёртка) |
| **VDEX** | Verified DEX — верифицированный DEX для ускорения загрузки |
| **CDEX** | Compact DEX — компактный DEX формат (Android 9+) |
| **dex2oat** | Компилятор DEX → OAT (AOT-компиляция) |
| **JIT** | Just-In-Time — компиляция горячих методов во время выполнения |
| **AOT** | Ahead-Of-Time — компиляция до выполнения (при установке или idle) |
| **OSR** | On-Stack Replacement — замена интерпретируемого кода скомпилированным прямо во время выполнения метода |
| **CC GC** | Concurrent Copying Garbage Collector — текущий алгоритм GC в ART |
| **TLAB** | Thread-Local Allocation Buffer — буфер для быстрой аллокации в потоке |
| **PGO** | Profile-Guided Optimization — оптимизация на основе профилей выполнения |
| **Baseline Profile** | Профиль, созданный разработчиком и упакованный в APK |
| **Cloud Profile** | Профиль, агрегированный Google Play из данных пользователей |

---

## Зачем это нужно

| Проблема | Без знания ART | С пониманием ART |
|----------|----------------|------------------|
| Debug build в 3–5× медленнее release | «Так всегда было» | Понимаете: debug = интерпретатор, release = JIT/AOT |
| Не можете объяснить зачем Baseline Profiles | «Модная штука от Google» | Знаете: это входные данные для PGO-компиляции в dex2oat |
| Первый запуск после установки самый медленный | «Надо потерпеть» | Понимаете: нет runtime-профиля, только baseline/cloud |
| GC-паузы в Systrace | «GC — зло» | Знаете алгоритм CC GC, понимаете что паузы ~2ms |
| Multidex issues | «Просто включить multiDexEnabled» | Понимаете DEX format и 64K лимит method_ids |
| ANR при холодном старте | «Сервер медленный» | Понимаете: class verification + DEX loading + interpretation |
| Не можете интерпретировать ART логи | Игнорируете их | Читаете GC логи, compilation status, profile data |

---

## Историческая эволюция: Dalvik → ART

```
┌────────────────────────────────────────────────────────────────────────────────┐
│               ЭВОЛЮЦИЯ ANDROID RUNTIME: 2008 — 2025                           │
├────────────────────────────────────────────────────────────────────────────────┤
│                                                                                │
│  2008    2010      2013       2014        2016         2018        2023+       │
│   │       │         │          │           │            │           │          │
│   ▼       ▼         ▼          ▼           ▼            ▼           ▼          │
│  ┌───┐  ┌─────┐  ┌──────┐  ┌───────┐  ┌────────┐  ┌────────┐  ┌────────┐   │
│  │1.0│  │ 2.2 │  │ 4.4  │  │  5.0  │  │  7.0   │  │  9.0   │  │ 14.0+  │   │
│  │   │  │Froyo│  │KitKat│  │Lolli- │  │Nougat  │  │ Pie    │  │Mainline│   │
│  └─┬─┘  └──┬──┘  └──┬───┘  │ pop  │  └───┬────┘  └───┬────┘  └───┬────┘   │
│    │        │        │      └──┬────┘      │           │           │          │
│    │        │        │         │            │           │           │          │
│  Dalvik  Dalvik   Dalvik+   ART        ART          ART        ART          │
│  interp  +JIT     ART      AOT-only   Hybrid       Cloud      Mainline     │
│  only    trace-   preview  dex2oat    JIT+AOT      Profiles   module       │
│          based             at install  +Profile     PGO        updates      │
│                                                                              │
│  ──────────────── DALVIK ERA ──────────┼──── ART ERA ─────────────────────   │
│                                        │                                     │
│  Стратегия:    Interpret → JIT-only    │  AOT → Hybrid → Profile-guided     │
│  GC паузы:     100–200ms               │  50ms → 5ms → 2ms (CC GC)         │
│  Установка:    Быстрая                 │  15min → Быстрая → Быстрая        │
│  Диск:         Мало                    │  Много → Мало → Оптимально        │
│  Peak perf:    Средний                 │  Высокий → Высокий → Высокий      │
│                                                                              │
└────────────────────────────────────────────────────────────────────────────────┘
```

### Хронология подробно

**2005–2008: Рождение Dalvik**

Дэн Борнстейн (Dan Bornstein) создаёт Dalvik VM. Название — деревня в Исландии, откуда родом предки разработчика. Ключевое решение: **register-based**, а не stack-based как JVM. Причина: меньше инструкций → меньше памяти → меньше расход батареи. Dalvik исполняет собственный байткод (DEX), не Java bytecode (.class).

```
Сравнение: сложение двух локальных переменных

JVM (stack-based):          Dalvik (register-based):
  iload_1                     add-int v0, v1, v2
  iload_2                     // 1 инструкция вместо 3
  iadd
  istore_3
  // 4 инструкции

Причина: register-based VM обращается к регистрам напрямую,
stack-based должна push/pop операнды через стек.
Меньше инструкций = меньше dispatch overhead = быстрее.
```

**2010: Android 2.2 Froyo — JIT в Dalvik**

Trace-based JIT: компилирует горячие **трассы** (traces) — последовательности часто выполняемых инструкций. Не метод целиком, а именно путь выполнения через метод. Даёт 2–5× ускорение горячего кода. Но: JIT-код теряется при перезапуске процесса.

**2013: Android 4.4 KitKat — ART как эксперимент**

ART появляется как экспериментальная опция для разработчиков:

```bash
# Включение ART в KitKat (требовалась перезагрузка)
adb shell setprop persist.sys.dalvik.vm.lib.2 libart.so

# Возврат к Dalvik
adb shell setprop persist.sys.dalvik.vm.lib.2 libdvm.so
```

**2014: Android 5.0 Lollipop — ART по умолчанию, AOT-only**

Dalvik полностью заменён. Стратегия: **AOT-only** через dex2oat при установке. Каждый DEX-файл компилируется целиком в нативный код.

Проблемы AOT-only:
- Установка приложения: **15–30 минут** для крупных приложений (Facebook, Google Maps)
- OTA-обновления системы: часы на перекомпиляцию всех приложений
- Диск: OAT-файлы в 2–3× больше DEX → телефоны на 8–16 GB быстро заполнялись
- Нет runtime-оптимизаций: AOT генерирует консервативный код

**2016: Android 7.0 Nougat — гибридная стратегия (прорыв)**

Революционное решение: комбинация трёх режимов выполнения.

```
┌──────────────────────────────────────────────────────────────────┐
│            ГИБРИДНАЯ СТРАТЕГИЯ ANDROID 7.0+                      │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│  УСТАНОВКА (секунды, не минуты):                                 │
│  ┌──────────────────────────────────────────────────────┐       │
│  │  DEX → verify → quicken → готово (без AOT!)          │       │
│  └──────────────────────────────────────────────────────┘       │
│                                                                  │
│  ПЕРВЫЙ ЗАПУСК:                                                  │
│  ┌──────────────────────────────────────────────────────┐       │
│  │  Холодный код → интерпретатор                        │       │
│  │  Горячий код → JIT-компиляция (в памяти)             │       │
│  │  Профиль → записываются горячие методы               │       │
│  └──────────────────────────────────────────────────────┘       │
│                                                                  │
│  ФОНОВАЯ КОМПИЛЯЦИЯ (устройство idle + зарядка):                │
│  ┌──────────────────────────────────────────────────────┐       │
│  │  Профиль + DEX → dex2oat speed-profile → OAT        │       │
│  │  Компилируются ТОЛЬКО горячие методы из профиля      │       │
│  └──────────────────────────────────────────────────────┘       │
│                                                                  │
│  ПОСЛЕДУЮЩИЕ ЗАПУСКИ:                                            │
│  ┌──────────────────────────────────────────────────────┐       │
│  │  Горячий код → из OAT (нативный)                     │       │
│  │  Холодный код → интерпретатор или JIT                │       │
│  │  Новый горячий код → JIT + обновление профиля        │       │
│  └──────────────────────────────────────────────────────┘       │
│                                                                  │
│  Результат: быстрая установка + eventual peak performance       │
└──────────────────────────────────────────────────────────────────┘
```

**2018: Android 9.0 Pie — Cloud Profiles**

Google Play начинает доставлять **агрегированные анонимизированные профили** от других пользователей. При первой установке приложения уже есть профиль → dex2oat может скомпилировать горячие методы сразу. Средний результат: **15% ускорение холодного старта**.

**2020: Android 11 — улучшения профилей**

Расширение формата профилей, более точная агрегация Cloud Profiles, улучшения инлайнинга в dex2oat.

**2022: Android 13 — Baseline Profile improvements**

Улучшена доставка Baseline Profiles через Play Store. Введены **Startup Profiles** — подмножество профилей специально для оптимизации DEX-layout классов, используемых при старте.

**2023–2025: Android 14+ — ART как Mainline модуль**

ART обновляется через Google Play (Project Mainline) без OTA-обновления системы. В 2025 году Google достиг 18% ускорения компиляции dex2oat без потери качества кода.

---

## Dalvik vs ART: детальное сравнение

```
┌──────────────────────────────────────────────────────────────────────┐
│                   DALVIK vs ART: АРХИТЕКТУРА                          │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌─── DALVIK (2008–2014) ───┐   ┌─── ART (2014+) ──────────────┐  │
│  │                           │   │                               │  │
│  │  ┌─────────────────────┐  │   │  ┌─────────────────────────┐  │  │
│  │  │    DEX Bytecode     │  │   │  │      DEX Bytecode       │  │  │
│  │  └──────────┬──────────┘  │   │  └──────────┬──────────────┘  │  │
│  │             │             │   │             │                  │  │
│  │             ▼             │   │     ┌───────┼────────┐        │  │
│  │  ┌─────────────────────┐  │   │     ▼       ▼        ▼        │  │
│  │  │    Interpreter      │  │   │  ┌──────┐┌──────┐┌────────┐  │  │
│  │  │    (всегда)         │  │   │  │Interp││ JIT  ││  AOT   │  │  │
│  │  └──────────┬──────────┘  │   │  │reter ││      ││(dex2oat│  │  │
│  │             │             │   │  └──┬───┘└──┬───┘└───┬────┘  │  │
│  │             ▼             │   │     └───────┼────────┘        │  │
│  │  ┌─────────────────────┐  │   │             ▼                  │  │
│  │  │  Trace-based JIT    │  │   │  ┌─────────────────────────┐  │  │
│  │  │  (горячие трассы)   │  │   │  │   Profile Collector     │  │  │
│  │  └──────────┬──────────┘  │   │  │   + Background dex2oat  │  │  │
│  │             │             │   │  └─────────────────────────┘  │  │
│  │             ▼             │   │                               │  │
│  │  ┌─────────────────────┐  │   │  ┌─────────────────────────┐  │  │
│  │  │  CMS GC             │  │   │  │  Concurrent Copying GC  │  │  │
│  │  │  паузы 100–200ms    │  │   │  │  паузы ~2ms             │  │  │
│  │  └─────────────────────┘  │   │  └─────────────────────────┘  │  │
│  │                           │   │                               │  │
│  └───────────────────────────┘   └───────────────────────────────┘  │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

### Таблица сравнения

| Характеристика | Dalvik | ART |
|----------------|--------|-----|
| **Тип VM** | Register-based | Register-based (тот же DEX) |
| **Байткод** | DEX (.dex) | DEX (.dex) — полная совместимость |
| **Компиляция** | Interpret + trace-based JIT | Interpret + method-based JIT + AOT |
| **JIT-единица** | Трассы (traces) | Методы (methods) |
| **AOT** | Нет (только dexopt = quicken) | Да — dex2oat генерирует нативный код |
| **Профилирование** | Нет | Runtime profiles, Cloud Profiles, Baseline Profiles |
| **GC** | CMS (Concurrent Mark-Sweep) | CC (Concurrent Copying) с read barriers |
| **GC-паузы** | 100–200ms (stop-the-world для mark) | ~2ms (только root processing) |
| **Compaction** | Нет (фрагментация heap) | Да (CC копирует живые объекты) |
| **Установка** | Быстрая (dexopt ~секунды) | Быстрая (verify + quicken) |
| **Занимаемое место** | Мало (только DEX + ODEX) | Оптимально (VDEX + OAT по профилю) |
| **Debug** | Медленный (interpreter) | Медленный (interpreter) |
| **64-bit** | Нет | Да |
| **SELinux** | Ограниченно | Полная поддержка |

### Почему обе VM register-based

И Dalvik, и ART исполняют **DEX-байткод** — register-based instruction set. Это не случайность:

```
Почему register-based VM лучше для мобильных:

1. Меньше инструкций → меньше decode cycles → экономия батареи
   Stack-based (JVM):   ~1.5× больше инструкций на ту же логику
   Register-based (DEX): ~30% меньше инструкций

2. Меньше обращений к памяти
   Stack-based: каждая операция = push + pop из стека (в RAM)
   Register-based: операнды уже в виртуальных регистрах

3. Проще маппинг на реальные CPU регистры
   ARM имеет 16 general-purpose регистров (r0–r15)
   DEX виртуальные регистры хорошо ложатся на ARM регистры

4. Компактнее DEX-файлы
   Меньше инструкций = меньше файл = меньше I/O при загрузке
```

---

## DEX Format Internals

DEX (Dalvik Executable) — это формат байткода, который исполняет ART. Один DEX-файл содержит определения классов, методов, полей и байткод.

### Структура DEX-файла

```
┌────────────────────────────────────────────────────────────────┐
│                    DEX FILE STRUCTURE                           │
├────────────────────────────────────────────────────────────────┤
│  Offset   │  Section          │  Описание                     │
├───────────┼───────────────────┼───────────────────────────────┤
│  0x00     │  header           │  Magic, checksum, SHA-1,      │
│           │                   │  размеры, offsets             │
├───────────┼───────────────────┼───────────────────────────────┤
│  0x70     │  string_ids       │  Таблица строковых констант   │
│           │                   │  (имена классов, методов)     │
├───────────┼───────────────────┼───────────────────────────────┤
│  varies   │  type_ids         │  Индексы типов → string_ids   │
├───────────┼───────────────────┼───────────────────────────────┤
│  varies   │  proto_ids        │  Прототипы методов            │
│           │                   │  (return type + parameters)   │
├───────────┼───────────────────┼───────────────────────────────┤
│  varies   │  field_ids        │  Определения полей            │
│           │                   │  (class + type + name)        │
├───────────┼───────────────────┼───────────────────────────────┤
│  varies   │  method_ids       │  Определения методов          │
│           │                   │  (class + proto + name)       │
│           │                   │  16-bit index → max 65536!    │
├───────────┼───────────────────┼───────────────────────────────┤
│  varies   │  class_defs       │  Определения классов          │
│           │                   │  (access flags, superclass,   │
│           │                   │   interfaces, source file)    │
├───────────┼───────────────────┼───────────────────────────────┤
│  varies   │  call_site_ids    │  Call sites (invokedynamic)   │
├───────────┼───────────────────┼───────────────────────────────┤
│  varies   │  method_handles   │  Method handles               │
├───────────┼───────────────────┼───────────────────────────────┤
│  varies   │  data             │  Байткод методов, аннотации,  │
│           │                   │  строковые данные, debug info │
├───────────┼───────────────────┼───────────────────────────────┤
│  varies   │  link_data        │  Данные для статической       │
│           │                   │  линковки (обычно пусто)      │
└────────────────────────────────────────────────────────────────┘
```

### DEX Header

```
┌───────────────────────────────────────────────────────────────┐
│                      DEX HEADER (0x70 bytes)                   │
├───────────────────────────────────────────────────────────────┤
│  Offset  │ Size │ Field          │ Пример значения            │
├──────────┼──────┼────────────────┼────────────────────────────┤
│  0x00    │  8   │ magic          │ "dex\n039\0"               │
│          │      │                │  dex\n = DEX файл          │
│          │      │                │  039 = версия формата      │
├──────────┼──────┼────────────────┼────────────────────────────┤
│  0x08    │  4   │ checksum       │ Adler-32 (всё после magic) │
├──────────┼──────┼────────────────┼────────────────────────────┤
│  0x0C    │  20  │ signature      │ SHA-1 (всё после signature)│
├──────────┼──────┼────────────────┼────────────────────────────┤
│  0x20    │  4   │ file_size      │ Размер всего DEX-файла     │
├──────────┼──────┼────────────────┼────────────────────────────┤
│  0x24    │  4   │ header_size    │ 0x70 (112 bytes)           │
├──────────┼──────┼────────────────┼────────────────────────────┤
│  0x28    │  4   │ endian_tag     │ 0x12345678 (little-endian) │
├──────────┼──────┼────────────────┼────────────────────────────┤
│  0x2C    │  4   │ link_size      │ Размер link section        │
├──────────┼──────┼────────────────┼────────────────────────────┤
│  0x30    │  4   │ link_off       │ Offset link section        │
├──────────┼──────┼────────────────┼────────────────────────────┤
│  0x34    │  4   │ map_off        │ Offset map section         │
├──────────┼──────┼────────────────┼────────────────────────────┤
│  0x38    │  4   │ string_ids_size│ Количество строк           │
├──────────┼──────┼────────────────┼────────────────────────────┤
│  0x3C    │  4   │ string_ids_off │ Offset string_ids          │
├──────────┼──────┼────────────────┼────────────────────────────┤
│  ...     │  ... │ type_ids,      │ Аналогично для всех        │
│          │      │ proto_ids,     │ остальных секций            │
│          │      │ field_ids,     │                            │
│          │      │ method_ids,    │                            │
│          │      │ class_defs     │                            │
└───────────────────────────────────────────────────────────────┘
```

### DEX-байткод: пример

Рассмотрим простую Kotlin-функцию и её представление в DEX:

```kotlin
// Kotlin
fun add(a: Int, b: Int): Int {
    return a + b
}
```

```
// DEX-байткод (register-based)
// Метод: add(II)I
// Регистры: v0 = this (если не static), p0 = a, p1 = b

.method public static add(II)I
    .registers 3          // 3 виртуальных регистра

    add-int v0, p0, p1   // v0 = p0 + p1 (одна инструкция!)
    return v0             // return v0

.end method

// Для сравнения — JVM bytecode (stack-based):
//   iload_0          // push a на стек
//   iload_1          // push b на стек
//   iadd             // pop два, push сумму
//   ireturn          // return top of stack
// 4 инструкции vs 2 в DEX
```

Более сложный пример — цикл:

```kotlin
// Kotlin
fun sumRange(n: Int): Int {
    var sum = 0
    for (i in 1..n) {
        sum += i
    }
    return sum
}
```

```
// DEX-байткод (упрощённо)
.method public static sumRange(I)I
    .registers 4
    // p0 = n, v0 = sum, v1 = i, v2 = temp

    const/4 v0, 0         // sum = 0
    const/4 v1, 1         // i = 1

    :loop_start
    if-gt v1, p0, :loop_end   // if (i > n) goto end
    add-int/2addr v0, v1       // sum += i
    add-int/lit8 v1, v1, 1     // i++
    goto :loop_start           // goto start

    :loop_end
    return v0                  // return sum

.end method
```

### 64K Method Limit и Multidex

Таблица `method_ids` использует **16-битный индекс**: максимум 65 536 методов в одном DEX-файле. Это относится ко всем методам, на которые есть ссылки (не только определённым, но и вызываемым).

```
┌──────────────────────────────────────────────────────────────────┐
│                   64K METHOD LIMIT                                │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│  method_ids[] использует uint16 индекс:                          │
│  max index = 0xFFFF = 65535                                      │
│                                                                  │
│  Считаются ВСЕ ссылки на методы:                                 │
│  ┌─────────────────────────────────────────┐                    │
│  │  Ваш код:          ~5,000 методов       │                    │
│  │  AndroidX:          ~20,000 методов      │                    │
│  │  Play Services:     ~15,000 методов      │                    │
│  │  Kotlin stdlib:     ~8,000 методов       │                    │
│  │  Другие библиотеки: ~20,000 методов      │                    │
│  │  ─────────────────────────────────       │                    │
│  │  ИТОГО:             ~68,000 > 65,536!    │                    │
│  └─────────────────────────────────────────┘                    │
│                                                                  │
│  Решение: MULTIDEX                                               │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐                           │
│  │classes  │ │classes2 │ │classes3 │  ...                       │
│  │.dex     │ │.dex     │ │.dex     │                           │
│  │ ≤64K    │ │ ≤64K    │ │ ≤64K    │                           │
│  │ methods │ │ methods │ │ methods │                           │
│  └─────────┘ └─────────┘ └─────────┘                           │
│                                                                  │
│  Android 5.0+ (ART): multidex нативно поддерживается            │
│  Android 4.x (Dalvik): нужна MultiDex support library           │
│  minSdk 21+: просто multiDexEnabled = true в Gradle             │
│                                                                  │
│  R8/D8 распределяют классы между DEX-файлами                    │
│  автоматически, с учётом main-dex правил.                        │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

### Связанные форматы файлов

```
┌──────────────────────────────────────────────────────────────────────┐
│            ФОРМАТЫ ФАЙЛОВ ART RUNTIME                                │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌──────────┐                                                       │
│  │  .apk    │  APK = ZIP-архив с DEX + resources + manifest          │
│  │ (classes │                                                       │
│  │  .dex)   │                                                       │
│  └────┬─────┘                                                       │
│       │                                                              │
│       │ dex2oat (при установке / background / manual)                │
│       │                                                              │
│       ▼                                                              │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────────┐  │
│  │  .vdex   │    │  .odex   │    │  .art    │    │  .prof       │  │
│  │          │    │  (OAT)   │    │  (image) │    │  (profile)   │  │
│  ├──────────┤    ├──────────┤    ├──────────┤    ├──────────────┤  │
│  │Verified  │    │ELF file: │    │Boot image│    │Hot methods   │  │
│  │DEX bytes │    │ oatdata: │    │Pre-loaded│    │Startup       │  │
│  │+ quicken │    │  OAT hdr │    │framework │    │ methods      │  │
│  │info      │    │  + DEX   │    │classes   │    │Hot classes   │  │
│  │          │    │  headers │    │(heap     │    │              │  │
│  │Цель:     │    │ oatexec: │    │ snapshot)│    │Цель: входные │  │
│  │пропустить│    │  native  │    │          │    │данные для    │  │
│  │verify при│    │  code    │    │Цель:     │    │dex2oat       │  │
│  │загрузке  │    │          │    │быстрый   │    │speed-profile │  │
│  │          │    │Цель:     │    │boot (нет │    │              │  │
│  │Android   │    │нативная  │    │загрузки/ │    │              │  │
│  │8.0+      │    │скорость  │    │verify    │    │              │  │
│  │          │    │          │    │framework)│    │              │  │
│  └──────────┘    └──────────┘    └──────────┘    └──────────────┘  │
│                                                                      │
│  CDEX (Compact DEX) — Android 9+:                                    │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │  Оптимизированный формат DEX внутри VDEX:                    │   │
│  │  - Общий пул строк/типов для нескольких DEX                  │   │
│  │  - De-duplication данных                                     │   │
│  │  - Уменьшает RAM и storage на 10–15%                         │   │
│  │  Описан в: art/libdexfile/dex/compact_dex_file.h             │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  Расположение на устройстве:                                         │
│  /data/app/<package>/                                                │
│  ├── base.apk                    (исходный APK)                      │
│  └── oat/arm64/                                                      │
│      ├── base.odex               (OAT — скомпилированный код)        │
│      ├── base.vdex               (VDEX — верифицированный DEX)       │
│      └── base.art               (ART image, если есть)               │
│                                                                      │
│  /data/misc/profiles/cur/0/<package>/primary.prof  (runtime profile) │
│  /data/misc/profiles/ref/<package>/primary.prof    (reference prof)  │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

**Эволюция форматов:**
- **Android 5.0–7.0**: DEX внутри OAT → один большой OAT-файл
- **Android 8.0+**: DEX вынесен в VDEX, OAT содержит только нативный код
- **Android 9.0+**: VDEX может содержать CDEX (Compact DEX) вместо обычного DEX
- **Android 10+**: Profile-guided CDEX layout оптимизирует порядок классов

---

## Три режима выполнения в ART

ART исполняет DEX-байткод тремя способами. Каждый метод в каждый момент времени выполняется одним из этих способов:

```
┌──────────────────────────────────────────────────────────────────────┐
│              ТРИ РЕЖИМА ВЫПОЛНЕНИЯ В ART                             │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌──────────────┐   ┌──────────────┐   ┌──────────────────────────┐ │
│  │ INTERPRETER  │   │     JIT      │   │     AOT (dex2oat)        │ │
│  │              │   │              │   │                          │ │
│  │ Скорость:    │   │ Скорость:    │   │ Скорость:                │ │
│  │ 10–100× slow │   │ ~1× native   │   │ ~1× native              │ │
│  │              │   │              │   │                          │ │
│  │ Latency:     │   │ Latency:     │   │ Latency:                 │ │
│  │ 0 (мгновенно)│   │ ~ms (компил.)│   │ 0 (уже скомпилирован)   │ │
│  │              │   │              │   │                          │ │
│  │ Память:      │   │ Память:      │   │ Память:                  │ │
│  │ Минимум      │   │ JIT cache    │   │ OAT файл на диске       │ │
│  │              │   │ (in-process) │   │                          │ │
│  │ Когда:       │   │ Когда:       │   │ Когда:                   │ │
│  │ - Холодный   │   │ - Метод стал │   │ - Метод в профиле       │ │
│  │   код        │   │   горячим    │   │ - dex2oat отработал     │ │
│  │ - Debug      │   │   (>10K hit) │   │ - Baseline Profile      │ │
│  │ - Первый     │   │ - Горячий    │   │                          │ │
│  │   запуск     │   │   цикл (OSR) │   │                          │ │
│  └──────────────┘   └──────────────┘   └──────────────────────────┘ │
│                                                                      │
│  ПОРЯДОК ПРЕДПОЧТЕНИЯ: AOT > JIT > Interpreter                      │
│  Если для метода есть AOT-код → используется он.                     │
│  Если нет AOT, но метод горячий → JIT-компилируется.                 │
│  Если нет ни AOT, ни JIT → интерпретируется.                        │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

### 6.1 Interpreter (интерпретатор)

Интерпретатор — switch-based C++ реализация, которая выполняет DEX-инструкции одну за другой.

```c
// Упрощённый псевдокод интерпретатора ART
// Исходник: art/runtime/interpreter/interpreter_switch_impl-inl.h

// Главный цикл интерпретатора
void ExecuteSwitchImpl(Thread* self, const DexFile::CodeItem* code_item) {
    uint16_t* dex_pc = code_item->insns_;  // указатель на байткод
    uint32_t* regs = shadow_frame->vregs_; // виртуальные регистры

    while (true) {
        uint16_t inst = *dex_pc;           // читаем инструкцию
        uint8_t opcode = inst & 0xFF;      // опкод = младший байт

        switch (opcode) {

            case NOP:                       // 0x00
                dex_pc++;                   // пропускаем
                break;

            case MOVE:                      // 0x01: move vA, vB
                regs[INST_A(inst)] = regs[INST_B(inst)];
                dex_pc++;
                break;

            case CONST_4:                   // 0x12: const/4 vA, #+B
                regs[INST_A(inst)] = INST_B_SIGNED(inst);
                dex_pc++;
                break;

            case ADD_INT:                   // 0x90: add-int vAA, vBB, vCC
                regs[INST_AA(inst)] = regs[INST_B(inst)] + regs[INST_C(inst)];
                dex_pc += 2;
                break;

            case IF_EQ:                     // 0x32: if-eq vA, vB, +CCCC
                if (regs[INST_A(inst)] == regs[INST_B(inst)]) {
                    dex_pc += (int16_t)INST_CC(inst);  // ветвление
                } else {
                    dex_pc += 2;
                }
                // Обновляем hotness counter для backward branch
                UpdateHotnessCounter(self, dex_pc);
                break;

            case INVOKE_VIRTUAL:            // 0x6E: вызов виртуального метода
                // Resolve метод → dispatch
                DoInvokeVirtual(self, shadow_frame, inst);
                dex_pc += 3;
                break;

            case RETURN:                    // 0x0F: return vAA
                result->SetI(regs[INST_AA(inst)]);
                return;

            // ... 200+ опкодов DEX
        }

        // Проверка: нужно ли GC, отладчик подключён и т.д.
        CheckSuspendPoints(self);
    }
}
```

**Когда используется интерпретатор:**

| Ситуация | Причина |
|----------|---------|
| Первый запуск холодного кода | Нет AOT, нет JIT-кода — нужно начать с чего-то |
| Debug build | Debuggable APK всегда интерпретируется (для breakpoints) |
| Флаг `-Xint` | Принудительный режим интерпретации |
| Методы с breakpoints | Отладчик требует пошагового выполнения |
| После deoptimization | Если JIT-код стал невалидным (например, после class loading) |

**Производительность интерпретатора:**
- **10–100× медленнее** скомпилированного кода
- Основной overhead: dispatch (switch) на каждую инструкцию
- Каждый вызов метода — полный invoke через C++ код
- Нет инлайнинга, нет register allocation, нет dead code elimination

### 6.2 JIT Compiler (Just-In-Time)

JIT-компилятор ART компилирует **горячие методы** в нативный код прямо во время выполнения.

```
┌──────────────────────────────────────────────────────────────────────┐
│                    JIT COMPILATION PIPELINE                           │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. ПРОФИЛИРОВАНИЕ (runtime)                                         │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │  Каждый метод имеет hotness counter (uint16_t)               │   │
│  │  Инкремент при:                                              │   │
│  │    - Вызове метода (+1)                                      │   │
│  │    - Backward branch в цикле (+1)                            │   │
│  │    - Другие эвристики                                        │   │
│  │                                                              │   │
│  │  Порог (dalvik.vm.jitthreshold): 10000 (по умолчанию)        │   │
│  │  Когда counter > threshold → метод ставится в JIT-очередь    │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                              │                                       │
│                              ▼                                       │
│  2. JIT COMPILATION THREAD                                           │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │  Отдельный поток (НЕ main thread!)                           │   │
│  │                                                              │   │
│  │  DEX bytecode                                                │   │
│  │       │                                                      │   │
│  │       ▼                                                      │   │
│  │  ┌─────────────┐                                             │   │
│  │  │  IR Builder │  DEX → HInstruction graph (SSA form)        │   │
│  │  └──────┬──────┘                                             │   │
│  │         ▼                                                    │   │
│  │  ┌─────────────┐                                             │   │
│  │  │ Optimization│  Inlining, constant folding,                │   │
│  │  │   Passes    │  dead code elimination, null check elim,    │   │
│  │  │             │  bounds check elimination, GVN, LICM        │   │
│  │  └──────┬──────┘                                             │   │
│  │         ▼                                                    │   │
│  │  ┌─────────────┐                                             │   │
│  │  │  Register   │  Виртуальные регистры → физические          │   │
│  │  │ Allocation  │  (linear scan или graph coloring)           │   │
│  │  └──────┬──────┘                                             │   │
│  │         ▼                                                    │   │
│  │  ┌─────────────┐                                             │   │
│  │  │  Code Gen   │  HInstruction → ARM64/ARM/x86 машинный код │   │
│  │  └──────┬──────┘                                             │   │
│  │         ▼                                                    │   │
│  │  ┌─────────────┐                                             │   │
│  │  │  JIT Code   │  Результат сохраняется в JIT code cache    │   │
│  │  │  Cache      │  (in-memory, per-process, ~2MB default)    │   │
│  │  └─────────────┘                                             │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                              │                                       │
│                              ▼                                       │
│  3. ИСПОЛЬЗОВАНИЕ                                                    │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │  Entry point метода обновляется: interpreter → JIT code      │   │
│  │  Следующий вызов метода → нативный JIT-код                   │   │
│  │  JIT code cache очищается при OOM или при background dex2oat │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  4. PROFILE RECORDING                                                │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │  JIT записывает в .prof:                                     │   │
│  │  - Горячие методы (hot methods) — для AOT-компиляции         │   │
│  │  - Startup методы — вызываемые при холодном старте            │   │
│  │  - Горячие классы — для pre-loading                          │   │
│  │  Профиль сохраняется в:                                      │   │
│  │  /data/misc/profiles/cur/0/<package>/primary.prof            │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

**OSR — On-Stack Replacement:**

OSR позволяет JIT-компилировать метод **прямо во время его выполнения**. Это критично для длинных циклов: метод вызван один раз, но цикл внутри выполняется миллионы итераций.

```c
// Псевдокод механизма OSR
// Исходник: art/runtime/jit/jit.cc

// В интерпретаторе, при каждом backward branch (цикле):
void UpdateHotnessCounter(Thread* self, uint16_t* dex_pc) {
    ArtMethod* method = GetCurrentMethod();
    method->hotness_count_++;

    if (method->hotness_count_ > jit_threshold_) {
        // Метод горячий — запускаем JIT-компиляцию с OSR
        // OSR сохраняет текущее состояние регистров
        // и переключается на скомпилированный код
        // ПРЯМО В СЕРЕДИНЕ ВЫПОЛНЯЮЩЕГОСЯ МЕТОДА
        jit_compiler_->CompileMethod(method, /*osr=*/true);

        // После компиляции — переключаемся на нативный код
        // с текущим состоянием стека/регистров
        if (method->HasCompiledCode()) {
            // Восстанавливаем состояние в нативном коде
            DoOsrTransition(self, method, dex_pc);
        }
    }
}
```

**Ключевые характеристики JIT в ART:**

| Параметр | Значение |
|----------|----------|
| Единица компиляции | Метод (не трасса, как в Dalvik) |
| Порог компиляции | ~10 000 (настраивается через `dalvik.vm.jitthreshold`) |
| JIT code cache | ~2 MB по умолчанию (per-process, in-memory) |
| Компиляция | В отдельном потоке (не блокирует main thread) |
| OSR | Поддерживается (для длинных циклов) |
| Оптимизации | Inlining, constant folding, null check elimination, GVN, LICM |
| Deoptimization | Возврат к интерпретатору если speculation провалилась |

### 6.3 AOT Compiler (dex2oat)

dex2oat — это отдельный процесс, который компилирует DEX в нативный код заранее (Ahead-Of-Time).

```
┌──────────────────────────────────────────────────────────────────────┐
│                    dex2oat: AOT COMPILATION                          │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Вход:                          Выход:                               │
│  ┌──────────┐                   ┌──────────┐                        │
│  │  .dex    │                   │  .odex   │  OAT с нативным кодом  │
│  │  (APK)   │──── dex2oat ────►│  (OAT)   │                        │
│  └──────────┘       │           └──────────┘                        │
│  ┌──────────┐       │           ┌──────────┐                        │
│  │  .prof   │───────┘           │  .vdex   │  Verified DEX          │
│  │ (profile)│                   └──────────┘                        │
│  └──────────┘                   ┌──────────┐                        │
│                                 │  .art    │  App image (optional)  │
│                                 └──────────┘                        │
│                                                                      │
│  Команда:                                                            │
│  dex2oat --dex-file=base.apk                                        │
│          --oat-file=base.odex                                        │
│          --compiler-filter=speed-profile                             │
│          --profile-file=primary.prof                                 │
│          --instruction-set=arm64                                     │
│          --instruction-set-features=default                          │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

**Compiler Filters — режимы компиляции:**

```
┌──────────────────────────────────────────────────────────────────────┐
│                    COMPILER FILTERS                                   │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Filter           │ Что делает              │ Нативный  │ Размер    │
│                   │                         │ код?      │ на диске  │
│  ─────────────────┼─────────────────────────┼───────────┼────────── │
│  verify           │ Только верификация DEX  │ Нет       │ Мин.     │
│                   │ (самый быстрый)         │           │          │
│  ─────────────────┼─────────────────────────┼───────────┼────────── │
│  quicken          │ verify + quickened      │ Нет       │ Мин.     │
│                   │ bytecode (оптимизация   │           │          │
│                   │ bytecode без native)    │           │          │
│  ─────────────────┼─────────────────────────┼───────────┼────────── │
│  speed-profile    │ verify + компиляция     │ Да, только│ Средний  │
│                   │ методов из профиля      │ hot/start │          │
│                   │ (ОСНОВНОЙ режим)        │ up методы │          │
│  ─────────────────┼─────────────────────────┼───────────┼────────── │
│  speed            │ verify + компиляция     │ Да, ВСЕ   │ Большой  │
│                   │ ВСЕХ методов            │ методы    │          │
│  ─────────────────┼─────────────────────────┼───────────┼────────── │
│  everything       │ speed + debug info      │ Да, ВСЕ   │ Макс.    │
│                   │ (для отладки)           │ + debug   │          │
│                                                                      │
│  КОГДА КАКОЙ ИСПОЛЬЗУЕТСЯ:                                           │
│                                                                      │
│  При установке:                                                      │
│  ├── Есть Baseline/Cloud Profile → speed-profile                    │
│  └── Нет профиля → verify или quicken                               │
│                                                                      │
│  Background dex2oat (idle + charging):                               │
│  └── Runtime profile накоплен → speed-profile                       │
│                                                                      │
│  Ручная команда:                                                     │
│  adb shell cmd package compile -m speed -f com.example.app          │
│  adb shell cmd package compile -m speed-profile -f com.example.app  │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

---

## Profile-Guided Optimization (PGO)

PGO — это стратегия, при которой **runtime-поведение приложения** определяет, какой код компилировать AOT. Это ключевой механизм современного ART.

### Формат профиля

```
┌──────────────────────────────────────────────────────────────────────┐
│                    PROFILE FORMAT (.prof)                             │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Profile содержит:                                                   │
│                                                                      │
│  1. HOT METHODS — методы для AOT-компиляции                         │
│     ┌──────────────────────────────────────────────┐                │
│     │  com.example.app.MainActivity.onCreate       │                │
│     │  com.example.app.data.Repository.fetchData   │                │
│     │  com.example.app.ui.adapter.bind             │                │
│     │  ... (обычно 5–20% всех методов)             │                │
│     └──────────────────────────────────────────────┘                │
│                                                                      │
│  2. STARTUP METHODS — методы холодного старта                        │
│     ┌──────────────────────────────────────────────┐                │
│     │  com.example.app.App.onCreate                │                │
│     │  com.example.app.di.AppModule.provide*       │                │
│     │  com.example.app.MainActivity.<init>         │                │
│     │  ... (влияют на порядок DEX layout)          │                │
│     └──────────────────────────────────────────────┘                │
│                                                                      │
│  3. HOT CLASSES — классы для pre-loading                             │
│     ┌──────────────────────────────────────────────┐                │
│     │  com.example.app.model.User                  │                │
│     │  com.example.app.network.ApiResponse         │                │
│     │  ... (загружаются в boot image)              │                │
│     └──────────────────────────────────────────────┘                │
│                                                                      │
│  4. INLINE CACHES — информация для инлайнинга                       │
│     ┌──────────────────────────────────────────────┐                │
│     │  site_1: receiver → {TypeA: 95%, TypeB: 5%}  │                │
│     │  site_2: receiver → {TypeC: 100%}            │                │
│     │  ... (позволяет speculative inlining)        │                │
│     └──────────────────────────────────────────────┘                │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

### Жизненный цикл PGO

```
┌──────────────────────────────────────────────────────────────────────┐
│                   PGO LIFECYCLE                                      │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  РАЗРАБОТЧИК                                                │    │
│  │                                                             │    │
│  │  1. Создаёт Baseline Profile rules                          │    │
│  │     (baseline-prof.txt или BaselineProfileRule)              │    │
│  │                                                             │    │
│  │  2. Запускает Macrobenchmark → генерируется .prof            │    │
│  │                                                             │    │
│  │  3. Профиль упаковывается в APK/AAB                         │    │
│  │     (assets/dexopt/baseline.prof)                           │    │
│  └────────────────────────────┬────────────────────────────────┘    │
│                               │                                      │
│                               ▼                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  GOOGLE PLAY                                                │    │
│  │                                                             │    │
│  │  1. Получает APK/AAB с Baseline Profile                     │    │
│  │                                                             │    │
│  │  2. Агрегирует Cloud Profiles от пользователей:             │    │
│  │     - Собирает runtime profiles с устройств                 │    │
│  │     - Анонимизирует и агрегирует                            │    │
│  │     - Создаёт .dm (dex metadata) файл                      │    │
│  │                                                             │    │
│  │  3. Доставляет APK + .dm (Baseline + Cloud) на устройство   │    │
│  └────────────────────────────┬────────────────────────────────┘    │
│                               │                                      │
│                               ▼                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  УСТРОЙСТВО                                                 │    │
│  │                                                             │    │
│  │  УСТАНОВКА:                                                 │    │
│  │  ┌────────────────────────────────────────────────────┐     │    │
│  │  │  Baseline + Cloud Profile                          │     │    │
│  │  │       │                                            │     │    │
│  │  │       ▼                                            │     │    │
│  │  │  dex2oat --compiler-filter=speed-profile           │     │    │
│  │  │       │                                            │     │    │
│  │  │       ▼                                            │     │    │
│  │  │  .odex (AOT для hot/startup методов из профиля)    │     │    │
│  │  └────────────────────────────────────────────────────┘     │    │
│  │                                                             │    │
│  │  RUNTIME:                                                   │    │
│  │  ┌────────────────────────────────────────────────────┐     │    │
│  │  │  JIT собирает runtime profile → primary.prof       │     │    │
│  │  │  Новые горячие методы добавляются в профиль        │     │    │
│  │  └────────────────────────────────────────────────────┘     │    │
│  │                                                             │    │
│  │  BACKGROUND (idle + charging):                              │    │
│  │  ┌────────────────────────────────────────────────────┐     │    │
│  │  │  Merged profile (baseline + cloud + runtime)       │     │    │
│  │  │       │                                            │     │    │
│  │  │       ▼                                            │     │    │
│  │  │  dex2oat speed-profile → обновлённый .odex         │     │    │
│  │  └────────────────────────────────────────────────────┘     │    │
│  │                                                             │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

### Baseline Profiles — для разработчика

Baseline Profiles — профили, которые разработчик создаёт и упаковывает в APK. Они гарантируют, что критические методы будут AOT-скомпилированы на **первом запуске** (без ожидания runtime profiling или Cloud Profiles).

```kotlin
// build.gradle.kts — подключение Baseline Profile plugin
plugins {
    id("com.android.application")
    id("androidx.baselineprofile")
}

android {
    // ...
}

baselineProfile {
    // Автоматическая генерация при сборке release
    automaticGenerationDuringBuild = true
}

dependencies {
    // Модуль с тестами для генерации профиля
    baselineProfile(project(":baselineprofile"))
}
```

```kotlin
// :baselineprofile модуль — генерация профиля через Macrobenchmark
@RunWith(AndroidJUnit4::class)
@LargeTest
class BaselineProfileGenerator {

    @get:Rule
    val rule = BaselineProfileRule()

    @Test
    fun generateBaselineProfile() {
        // Этот тест запускает приложение и записывает
        // какие методы вызываются — это становится профилем
        rule.collect(
            packageName = "com.example.app",
            // Максимальное количество итераций для стабильного профиля
            maxIterations = 15,
            stableIterations = 3
        ) {
            // Cold start
            pressHome()
            startActivityAndWait()

            // Critical User Journey: навигация по приложению
            device.findObject(By.text("Feed")).click()
            device.waitForIdle()

            device.findObject(By.text("Search")).click()
            device.waitForIdle()

            // Скролл списка — важно для RecyclerView/LazyColumn
            device.findObject(By.res("feed_list"))
                .scroll(Direction.DOWN, 2f)
        }
    }
}
```

```kotlin
// Ручные правила в baseline-prof.txt
// Формат: [HSP]Lcom/example/ClassName;->methodName(params)returnType

// H = Hot method (компилировать AOT)
// S = Startup method (вызывается при старте)
// P = Post-startup method (вызывается сразу после старта)

HSPLcom/example/app/MainActivity;->onCreate(Landroid/os/Bundle;)V
HSPLcom/example/app/data/Repository;->fetchData()Ljava/util/List;
HPLcom/example/app/ui/adapter/ItemAdapter;->onBindViewHolder(Landroid/view/View;I)V
SPLcom/example/app/App;->onCreate()V
```

### Startup Profiles (Android 13+)

Startup Profiles — подмножество Baseline Profiles, которое влияет на **DEX layout**. Классы, отмеченные как startup, группируются в начале DEX-файла → меньше I/O при загрузке.

```kotlin
// :baselineprofile модуль — генерация startup profile
@RunWith(AndroidJUnit4::class)
@LargeTest
class StartupProfileGenerator {

    @get:Rule
    val rule = BaselineProfileRule()

    @Test
    fun generateStartupProfile() {
        rule.collect(
            packageName = "com.example.app",
            // includeInStartupProfile = true отмечает методы как startup
            includeInStartupProfile = true
        ) {
            // ТОЛЬКО холодный старт — никакой навигации
            pressHome()
            startActivityAndWait()
            // Ждём, пока первый кадр отрисуется
            device.waitForIdle()
        }
    }
}
```

### Cloud Profiles

Cloud Profiles — агрегированные профили от Google Play. Механизм:

1. Устройства отправляют анонимизированные runtime-профили в Play Cloud
2. Play агрегирует профили (берёт методы, горячие на >N% устройств)
3. Агрегированный профиль упаковывается в `.dm` (dex metadata) файл
4. `.dm` файл доставляется вместе с APK при установке

```
┌──────────────────────────────────────────────────────────────────┐
│                   CLOUD PROFILES PIPELINE                         │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Устройство A ──┐                                                │
│  Устройство B ──┤── runtime .prof ──► Play Cloud                │
│  Устройство C ──┤                        │                       │
│  ...            ──┘                        │ агрегация            │
│                                            │ анонимизация         │
│                                            ▼                     │
│                                     Cloud Profile                │
│                                     (.dm файл)                   │
│                                            │                     │
│                 ┌──────────────────────────┤                     │
│                 ▼                          ▼                     │
│          Устройство X              Устройство Y                  │
│          (новая установка)         (обновление)                  │
│          APK + .dm                 APK + .dm                     │
│                │                          │                     │
│                ▼                          ▼                     │
│          dex2oat speed-profile     dex2oat speed-profile        │
│          (горячие методы уже       (обновлённый профиль)         │
│           скомпилированы!)                                       │
│                                                                  │
│  Результат: 15–30% ускорение холодного старта                    │
│  при ПЕРВОМ запуске после установки                              │
│                                                                  │
│  Ограничения:                                                    │
│  - Нужно достаточно пользователей (для агрегации)                │
│  - Задержка: профиль появляется не сразу после публикации        │
│  - Не работает для sideloaded APK                                │
│  - Baseline Profile заполняет этот gap                            │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

---

## Compilation Strategy: полная картина (Android 14+)

```
┌──────────────────────────────────────────────────────────────────────┐
│          ПОЛНОЕ ДЕРЕВО РЕШЕНИЙ КОМПИЛЯЦИИ (ANDROID 14+)             │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  УСТАНОВКА APK                                                       │
│  │                                                                   │
│  ├── Есть .dm (Cloud Profile)?                                       │
│  │   ├── Да → merge с Baseline Profile из APK                       │
│  │   │        → dex2oat speed-profile                                │
│  │   │        → .odex (AOT для hot+startup) + .vdex                 │
│  │   │                                                               │
│  │   └── Нет → Есть Baseline Profile в APK?                         │
│  │            ├── Да → dex2oat speed-profile (только baseline)      │
│  │            │        → .odex + .vdex                               │
│  │            │                                                      │
│  │            └── Нет → dex2oat verify (только верификация)          │
│  │                      → .vdex (без нативного кода)                │
│  │                                                                   │
│  ПЕРВЫЙ ЗАПУСК                                                       │
│  │                                                                   │
│  ├── Метод есть в .odex (AOT)?                                       │
│  │   └── Да → выполняется нативный код (максимальная скорость)      │
│  │                                                                   │
│  ├── Метод нет в .odex?                                              │
│  │   └── Интерпретатор начинает выполнение                          │
│  │       │                                                           │
│  │       ├── hotness_count > threshold (10000)?                      │
│  │       │   └── Да → JIT-компиляция в отдельном потоке             │
│  │       │            → код в JIT code cache (in-memory)            │
│  │       │                                                           │
│  │       └── Нет → продолжает интерпретироваться                    │
│  │                                                                   │
│  ├── JIT записывает runtime profile:                                 │
│  │   - hot methods, startup methods, hot classes                     │
│  │   → /data/misc/profiles/cur/0/<pkg>/primary.prof                 │
│  │                                                                   │
│  BACKGROUND DEX2OAT (устройство idle + зарядка)                      │
│  │                                                                   │
│  ├── Есть новый runtime profile?                                     │
│  │   └── Да → merge (baseline + cloud + runtime)                    │
│  │            → dex2oat speed-profile                                │
│  │            → обновлённый .odex (больше AOT-методов)               │
│  │                                                                   │
│  ПОСЛЕДУЮЩИЕ ЗАПУСКИ                                                 │
│  │                                                                   │
│  ├── Большинство горячего кода → AOT из .odex                       │
│  ├── Новый горячий код → JIT → обновление профиля                    │
│  └── Холодный код → интерпретатор (и это нормально)                 │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

---

## Garbage Collection в ART

### 9.1 Эволюция GC

```
┌──────────────────────────────────────────────────────────────────────┐
│               ЭВОЛЮЦИЯ GC В ANDROID                                  │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Dalvik (2008–2014)                                                  │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  Serial Mark-Sweep → Concurrent Mark-Sweep (CMS)            │    │
│  │  Паузы: 100–200ms (stop-the-world для marking roots)        │    │
│  │  Проблемы:                                                  │    │
│  │  - Нет compaction → фрагментация heap                       │    │
│  │  - Длинные паузы → заметные jank/lag                         │    │
│  │  - GC_FOR_ALLOC: если нет места → полная остановка           │    │
│  └──────────────────────────┬──────────────────────────────────┘    │
│                              │                                       │
│  ART 5.0–7.0 (2014–2016)    ▼                                       │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  Concurrent Mark-Sweep (CMS) — улучшенный                   │    │
│  │  Паузы: ~50ms (короче, но всё ещё заметны)                  │    │
│  │  Улучшения:                                                 │    │
│  │  - Параллельный mark phase                                  │    │
│  │  - Foreground vs Background GC                              │    │
│  │  - Частичный compaction (homogeneous space compact)          │    │
│  └──────────────────────────┬──────────────────────────────────┘    │
│                              │                                       │
│  ART 8.0+ (2017)             ▼                                       │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  Concurrent Copying (CC) — РЕВОЛЮЦИЯ                        │    │
│  │  Паузы: ~2ms (только root processing!)                      │    │
│  │  Прорыв:                                                    │    │
│  │  - Concurrent mark: НЕТ паузы для tracing                   │    │
│  │  - Concurrent copy: объекты перемещаются БЕЗ остановки      │    │
│  │  - Read barriers: перехватывают чтение ссылок               │    │
│  │  - Compaction: фрагментация устраняется автоматически       │    │
│  └──────────────────────────┬──────────────────────────────────┘    │
│                              │                                       │
│  ART 10.0+ (2019)            ▼                                       │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  Generational CC (Gen-CC)                                   │    │
│  │  Паузы: ~2ms (без изменений)                                │    │
│  │  Улучшения:                                                 │    │
│  │  - Young generation: мелкие объекты собираются чаще          │    │
│  │  - Old generation: крупные/долгоживущие — реже               │    │
│  │  - Generational hypothesis: большинство объектов умирают     │    │
│  │    молодыми → собирать young gen дёшево                      │    │
│  │  - Adaptive: young GC vs full-heap GC по throughput          │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  Сравнение пауз (типичные значения):                                 │
│  Dalvik CMS:   ████████████████████████████████ 150ms                │
│  ART CMS:      ██████████ 50ms                                       │
│  ART CC:       █ 2ms                                                 │
│  ART Gen-CC:   █ 2ms (но реже full-heap)                             │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

### 9.2 Concurrent Copying GC (CC) — текущий алгоритм

CC GC — это основной алгоритм сборки мусора в ART начиная с Android 8.0. Его ключевое свойство: **практически всё происходит параллельно с потоками приложения** (mutator threads).

#### Region-based heap

Heap разделён на **регионы** фиксированного размера (256 KB):

```
┌──────────────────────────────────────────────────────────────────────┐
│                   REGION-BASED HEAP                                   │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Heap (256 MB пример):                                               │
│  ┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐     │
│  │ R0 │ R1 │ R2 │ R3 │ R4 │ R5 │ R6 │ R7 │ R8 │ R9 │R10 │... │     │
│  │USED│USED│FREE│USED│FREE│FREE│USED│USED│FREE│USED│FREE│    │     │
│  └────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘     │
│  │ 256KB каждый │                                                    │
│                                                                      │
│  Состояния региона:                                                  │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │  FREE      — свободен, готов к аллокации                  │       │
│  │  ALLOCATED — содержит живые объекты                       │       │
│  │  TO_SPACE  — целевой регион для копирования (CC)          │       │
│  │  FROM_SPACE— исходный регион (объекты будут скопированы)  │       │
│  │  LARGE     — регион для крупных объектов (>1 region)      │       │
│  └──────────────────────────────────────────────────────────┘       │
│                                                                      │
│  Аллокация: bump pointer в TLAB                                      │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │  Thread-Local Allocation Buffer (TLAB):                   │       │
│  │  ┌─────────────────────────────────────┬────────────┐    │       │
│  │  │  obj1  │  obj2  │  obj3  │  ░░░░░░  │  free      │    │       │
│  │  └────────────────────────────┼─────────┴────────────┘    │       │
│  │                               ▲                           │       │
│  │                          bump pointer                     │       │
│  │                                                           │       │
│  │  Скорость аллокации: ~10 наносекунд (один инкремент!)     │       │
│  │  Нет lock contention: каждый поток имеет свой TLAB       │       │
│  └──────────────────────────────────────────────────────────┘       │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

#### Фазы CC GC

```
┌──────────────────────────────────────────────────────────────────────┐
│                  ФАЗЫ CONCURRENT COPYING GC                          │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Время ──────────────────────────────────────────────────────►       │
│                                                                      │
│  App threads:  ████████░░████████████████████████████████████        │
│                         ▲                                            │
│                     ПАУЗА ~2ms                                       │
│                   (только root scan)                                 │
│                                                                      │
│  GC thread:    ────────┤MARK──────────────┤COPY──────────┤──        │
│                                                                      │
│                                                                      │
│  ФАЗА 1: ИНИЦИАЦИЯ (concurrent)                                     │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │  GC триггер: heap usage > threshold (обычно ~75%)        │       │
│  │  Или: explicit System.gc()                               │       │
│  │  Или: native allocation pressure                         │       │
│  └──────────────────────────────────────────────────────────┘       │
│                                                                      │
│  ФАЗА 2: ПАУЗА — ROOT SCAN (~2ms)                                   │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │  STOP THE WORLD (единственная пауза!)                    │       │
│  │                                                          │       │
│  │  Сканируем GC roots:                                     │       │
│  │  ├── Thread stacks (локальные переменные каждого потока)  │       │
│  │  ├── Static fields (статические поля классов)             │       │
│  │  ├── JNI references (ссылки из нативного кода)            │       │
│  │  ├── Monitor locks                                       │       │
│  │  └── Interned strings                                    │       │
│  │                                                          │       │
│  │  Результат: список корневых объектов (gray objects)       │       │
│  └──────────────────────────────────────────────────────────┘       │
│                                                                      │
│  ФАЗА 3: CONCURRENT MARK (параллельно с app!)                       │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │  Tri-color marking (три цвета):                          │       │
│  │                                                          │       │
│  │  WHITE = не посещён (потенциально мусор)                  │       │
│  │  GRAY  = посещён, но дети не обработаны                  │       │
│  │  BLACK = посещён, все дети обработаны (точно живой)        │       │
│  │                                                          │       │
│  │  Алгоритм:                                               │       │
│  │  1. GC roots → GRAY                                      │       │
│  │  2. Берём GRAY объект из worklist                        │       │
│  │  3. Для каждого поля-ссылки:                              │       │
│  │     - Если объект WHITE → помечаем GRAY, добавляем в list │       │
│  │  4. Помечаем текущий объект BLACK                         │       │
│  │  5. Повторяем пока worklist не пуст                       │       │
│  │                                                          │       │
│  │  Всё WHITE после marking = мусор                         │       │
│  │                                                          │       │
│  │  ВАЖНО: app продолжает работать!                          │       │
│  │  Read barrier обеспечивает корректность                   │       │
│  └──────────────────────────────────────────────────────────┘       │
│                                                                      │
│  ФАЗА 4: CONCURRENT COPY (параллельно с app!)                       │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │  Живые объекты копируются из FROM_SPACE в TO_SPACE        │       │
│  │                                                          │       │
│  │  FROM_SPACE:                TO_SPACE:                     │       │
│  │  ┌────────────────────┐    ┌────────────────────┐        │       │
│  │  │ [obj_A] [___] [obj_B]│    │ [obj_A'] [obj_B']    │        │       │
│  │  │ [obj_C] [___] [___] │    │ [obj_C']             │        │       │
│  │  └────────────────────┘    └────────────────────┘        │       │
│  │  (фрагментирован)          (компактный!)                 │       │
│  │                                                          │       │
│  │  Read barrier перенаправляет ссылки:                       │       │
│  │  Когда app читает ссылку → barrier проверяет              │       │
│  │  → если объект скопирован → возвращает новый адрес        │       │
│  └──────────────────────────────────────────────────────────┘       │
│                                                                      │
│  ФАЗА 5: RECLAIM (освобождение)                                     │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │  FROM_SPACE регионы помечаются FREE                       │       │
│  │  Готовы к переиспользованию                               │       │
│  └──────────────────────────────────────────────────────────┘       │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

#### Read Barrier — ключевой механизм

Read barrier — это код, который автоматически вставляется компилятором (JIT/AOT) при каждом чтении ссылочного поля. Он обеспечивает корректность при concurrent copying.

```c
// Псевдокод read barrier
// Исходник: art/runtime/read_barrier-inl.h

// БЕЗ read barrier (обычное чтение):
Object* ref = obj->field_;   // просто чтение поля

// С read barrier (ART CC GC):
Object* ref = ReadBarrier(obj->field_);

// Реализация read barrier:
Object* ReadBarrier(Object* ref) {
    if (ref == nullptr) return nullptr;

    // Проверяем forwarding pointer (Brooks pointer)
    // Каждый объект имеет дополнительное слово — forwarding ptr
    Object* forwarded = ref->forwarding_ptr_;

    if (forwarded != ref) {
        // Объект был скопирован GC!
        // forwarded указывает на новую копию
        return forwarded;
    }

    // Объект не перемещён — возвращаем как есть
    return ref;
}
```

```
┌──────────────────────────────────────────────────────────────────────┐
│                READ BARRIER: ДО И ПОСЛЕ КОПИРОВАНИЯ                  │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ДО копирования:                                                     │
│  ┌──────────────────────────────────────────────┐                   │
│  │  obj.field ──► [Object A]                    │                   │
│  │                 │ forwarding_ptr → self       │                   │
│  │                 │ data: "Hello"               │                   │
│  │                 └────────────────────────     │                   │
│  │                                              │                   │
│  │  ReadBarrier(obj.field):                     │                   │
│  │    forwarded == ref → return ref (без копии) │                   │
│  └──────────────────────────────────────────────┘                   │
│                                                                      │
│  ПОСЛЕ копирования (GC скопировал Object A):                        │
│  ┌──────────────────────────────────────────────┐                   │
│  │  obj.field ──► [Object A] (FROM_SPACE)       │                   │
│  │                 │ forwarding_ptr → ─────┐    │                   │
│  │                 │ data: "Hello"         │    │                   │
│  │                 └──────────────────     │    │                   │
│  │                                        │    │                   │
│  │                                        ▼    │                   │
│  │                 [Object A'] (TO_SPACE)       │                   │
│  │                 │ forwarding_ptr → self       │                   │
│  │                 │ data: "Hello"               │                   │
│  │                 └────────────────────────     │                   │
│  │                                              │                   │
│  │  ReadBarrier(obj.field):                     │                   │
│  │    forwarded != ref → return forwarded       │                   │
│  │    (приложение видит Object A' — новую копию)│                   │
│  └──────────────────────────────────────────────┘                   │
│                                                                      │
│  Overhead read barrier: ~1 дополнительная load инструкция           │
│  На ARM64: 1 LDR (загрузка forwarding pointer) + 1 CMP + branch    │
│  В среднем ~2–5% overhead на throughput (приемлемо для мобильных)    │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

### 9.3 Heap Organization

```
┌──────────────────────────────────────────────────────────────────────┐
│                    ART HEAP LAYOUT                                    │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │  IMAGE SPACE (read-only, shared)                             │   │
│  │  ┌────────────────────────────────────────────────────────┐  │   │
│  │  │  boot.art — предзагруженные framework классы           │  │   │
│  │  │  (String, Integer, ArrayList, HashMap, ...)            │  │   │
│  │  │  Snapshot heap: объекты уже инициализированы            │  │   │
│  │  │  Mapped в память каждого процесса (copy-on-write)      │  │   │
│  │  │  Размер: ~10–30 MB                                     │  │   │
│  │  └────────────────────────────────────────────────────────┘  │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │  REGION SPACE (main heap, используется CC GC)               │   │
│  │  ┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐       │   │
│  │  │Yng │Yng │Old │Old │Free│Free│Old │Yng │Free│Old │       │   │
│  │  │    │    │    │    │    │    │    │    │    │    │       │   │
│  │  └────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘       │   │
│  │  256 KB регионы, bump-pointer аллокация через TLAB          │   │
│  │                                                             │   │
│  │  Gen-CC: Young regions (собираются часто)                   │   │
│  │          Old regions (собираются реже)                      │   │
│  │  Размер: основная часть heap (до 256–512 MB)                │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │  LARGE OBJECT SPACE (LOS)                                   │   │
│  │  ┌──────────────────────────────────────────────────────┐   │   │
│  │  │  Объекты > 12 KB (примитивные массивы > 3 страниц)   │   │   │
│  │  │  Аллоцируются через mmap (отдельные memory mappings)  │   │   │
│  │  │  НЕ перемещаются при GC (pinned)                     │   │   │
│  │  │  Освобождаются через munmap                          │   │   │
│  │  └──────────────────────────────────────────────────────┘   │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │  NON-MOVING SPACE                                           │   │
│  │  ┌──────────────────────────────────────────────────────┐   │   │
│  │  │  Объекты, которые НЕЛЬЗЯ перемещать:                 │   │   │
│  │  │  - JNI global references (C-код держит прямой адрес) │   │   │
│  │  │  - Monitor objects (связаны с lock word)             │   │   │
│  │  │  - Interned strings                                  │   │   │
│  │  │  Аллокация: Rosalloc (thread-safe malloc-like)       │   │   │
│  │  └──────────────────────────────────────────────────────┘   │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │  ZYGOTE SPACE (shared with parent Zygote process)           │   │
│  │  ┌──────────────────────────────────────────────────────┐   │   │
│  │  │  Объекты, созданные Zygote до fork()                 │   │   │
│  │  │  Разделяемые между всеми app-процессами (CoW)        │   │   │
│  │  │  Framework singletons, pre-loaded classes             │   │   │
│  │  └──────────────────────────────────────────────────────┘   │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
│  АДРЕСНОЕ ПРОСТРАНСТВО ПРОЦЕССА:                                     │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │  0x00000000  ─── Image Space (boot.art)                     │   │
│  │  0x........  ─── Zygote Space (shared, CoW)                 │   │
│  │  0x........  ─── Non-Moving Space (pinned objects)          │   │
│  │  0x........  ─── Region Space (main heap, CC GC)            │   │
│  │  0x........  ─── Large Object Space (mmap regions)          │   │
│  │  0x........  ─── JIT Code Cache                             │   │
│  │  0x........  ─── Native heap (malloc)                       │   │
│  │  0x........  ─── Thread stacks                              │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

**Rosalloc (Runs-of-Slots Allocator):**

```c
// Псевдокод Rosalloc — аллокатора для Non-Moving Space
// Исходник: art/runtime/gc/allocator/rosalloc.h

// Rosalloc делит память на size classes (как jemalloc/tcmalloc):
// Размер класса:   8, 16, 24, 32, ... 128, 256, 512, 1024, 2048 bytes
// Каждый класс имеет Thread-Local free list

void* RosAllocate(size_t size) {
    // 1. Определяем size class
    int idx = SizeToIndex(size);  // size → индекс класса

    // 2. Берём из thread-local free list (без lock!)
    Run* thread_local_run = self->rosalloc_runs_[idx];
    if (thread_local_run != nullptr) {
        void* slot = thread_local_run->AllocSlot();  // bump pointer
        if (slot != nullptr) {
            return slot;  // Быстрый путь: ~20ns, без lock
        }
    }

    // 3. Медленный путь: запросить новый Run из центрального пула
    return SlowPathAlloc(idx);  // берёт lock на центральный пул
}
```

### 9.4 Generational CC (Android 10+)

```
┌──────────────────────────────────────────────────────────────────────┐
│               GENERATIONAL CC GC                                     │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Generational hypothesis:                                            │
│  «Большинство объектов умирают молодыми»                             │
│                                                                      │
│  Типичное распределение:                                             │
│  ┌──────────────────────────────────────────┐                       │
│  │                                          │                       │
│  │  Кол-во    █                             │                       │
│  │  объектов  █                             │                       │
│  │            █                             │                       │
│  │            █                             │                       │
│  │            ██                            │                       │
│  │            ███                           │                       │
│  │            ████                          │                       │
│  │            █████▄▄▃▃▂▂▁▁▁▁▁▁▁▁▁▁▁▁     │                       │
│  │  ──────────────────────────────────►     │                       │
│  │            Возраст объекта               │                       │
│  │      young ◄──────► old                  │                       │
│  └──────────────────────────────────────────┘                       │
│                                                                      │
│  Два типа сборок:                                                    │
│                                                                      │
│  YOUNG GC (частый, дешёвый):                                         │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │  Собирает ТОЛЬКО young regions                           │       │
│  │  Young regions = недавно аллоцированные                   │       │
│  │  Большинство объектов уже мертвы → мало копирования       │       │
│  │  Время: ~2–5ms (включая паузу)                           │       │
│  │  Запускается часто (каждые несколько MB аллокаций)        │       │
│  └──────────────────────────────────────────────────────────┘       │
│                                                                      │
│  FULL-HEAP GC (редкий, дорогой):                                     │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │  Собирает ВСЕ регионы (young + old)                      │       │
│  │  Запускается когда:                                      │       │
│  │  - Young GC throughput падает ниже среднего full-heap     │       │
│  │  - Heap close to limit                                   │       │
│  │  - Explicit System.gc()                                  │       │
│  │  Время: ~10–50ms (но пауза всё ещё ~2ms)                │       │
│  └──────────────────────────────────────────────────────────┘       │
│                                                                      │
│  Promotion: young → old                                              │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │  Объект пережил N young GC → перемещается в old region    │       │
│  │  Old region собирается только при full-heap GC            │       │
│  └──────────────────────────────────────────────────────────┘       │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

### 9.5 Сравнение с JVM GC

| Характеристика | ART CC/Gen-CC | HotSpot G1 | ZGC | Shenandoah |
|----------------|---------------|------------|-----|------------|
| **Целевая платформа** | Мобильные (≤512 MB heap) | Серверы (GB-TB heap) | Серверы (TB heap) | Серверы (GB heap) |
| **Max пауза** | ~2ms | ~200ms (target) | <1ms | <10ms |
| **Compaction** | Concurrent copying | Incremental compaction | Concurrent remap | Concurrent compact |
| **Barrier тип** | Read barrier | Write barrier (SATB) | Load barrier (colored ptrs) | Load barrier |
| **Overhead/объект** | 1 word (fwd ptr) | 0 (mark bitmap) | Colored pointer | 1 word (fwd ptr) |
| **Generational** | Да (Gen-CC) | Да (young + old + humongous) | Да (ZGC Gen, JDK 21+) | Нет |
| **Tuning knobs** | Почти нет (простота) | Десятки параметров | Минимум | Минимум |
| **Оптимизирован для** | Latency + battery | Throughput + latency | Ultra-low latency | Low latency |

Ключевое отличие: ART CC оптимизирован для **мобильных условий** — маленький heap, ограниченный CPU, экономия батареи. JVM GC оптимизированы для серверов с гигабайтами RAM и многоядерными CPU.

### 9.6 Чтение GC-логов

```kotlin
// Kotlin: включение GC-логов в adb logcat
// Команда: adb logcat -s art:D

// Пример GC-лога:
// I/art: Explicit concurrent copying GC freed 24351(1412KB) AllocSpace objects,
//        12(512KB) LOS objects, 49% free, 3MB/6MB, paused 1.843ms total 34.362ms

// Разбор:
// ┌───────────────────────────────────────────────────────────┐
// │  Explicit           — тип триггера (явный System.gc())   │
// │  concurrent copying — алгоритм GC                        │
// │  freed 24351(1412KB)— освобождено объектов в RegionSpace  │
// │  12(512KB) LOS      — освобождено в Large Object Space   │
// │  49% free           — 49% heap свободно после GC         │
// │  3MB/6MB            — используется 3MB из 6MB heap       │
// │  paused 1.843ms     — пауза (stop-the-world)            │
// │  total 34.362ms     — общее время GC цикла               │
// └───────────────────────────────────────────────────────────┘
```

```bash
# Полезные команды для GC диагностики
adb logcat -s art:D                           # GC логи
adb shell dumpsys meminfo <package>           # Memory breakdown
adb shell cmd package compile -m speed -f <package>  # Force AOT
adb shell cmd package compile --reset <package>      # Reset compilation

# Systrace с GC-событиями
python systrace.py --time=10 -o trace.html dalvik gfx view
```

---

## Class Loading и Verification

### ClassLoader Hierarchy

```
┌──────────────────────────────────────────────────────────────────────┐
│               ANDROID CLASSLOADER HIERARCHY                          │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  BootClassLoader (Java)                                     │    │
│  │  ┌───────────────────────────────────────────────────────┐  │    │
│  │  │  Загружает core library классы:                        │  │    │
│  │  │  java.lang.*, java.util.*, android.os.*, ...           │  │    │
│  │  │  Из boot.art image (pre-loaded, shared)                │  │    │
│  │  │  Parent: null (вершина иерархии)                       │  │    │
│  │  └───────────────────────────────────────────────────────┘  │    │
│  └──────────────────────────────┬──────────────────────────────┘    │
│                                 │ parent                             │
│                                 ▼                                    │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  PathClassLoader                                            │    │
│  │  ┌───────────────────────────────────────────────────────┐  │    │
│  │  │  Загружает классы приложения из APK:                   │  │    │
│  │  │  /data/app/<package>/base.apk                          │  │    │
│  │  │  Наследует от BaseDexClassLoader                       │  │    │
│  │  │  Используется Android framework для каждого app        │  │    │
│  │  └───────────────────────────────────────────────────────┘  │    │
│  └──────────────────────────────┬──────────────────────────────┘    │
│                                 │ parent                             │
│                                 ▼                                    │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  DexClassLoader (опциональный)                              │    │
│  │  ┌───────────────────────────────────────────────────────┐  │    │
│  │  │  Загружает классы из произвольных DEX/JAR файлов:      │  │    │
│  │  │  Используется для:                                     │  │    │
│  │  │  - Плагинов                                            │  │    │
│  │  │  - Dynamic feature modules                             │  │    │
│  │  │  - Hot patching (не рекомендуется Google)               │  │    │
│  │  └───────────────────────────────────────────────────────┘  │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  InMemoryDexClassLoader (Android 8.0+)                      │    │
│  │  ┌───────────────────────────────────────────────────────┐  │    │
│  │  │  Загружает DEX из ByteBuffer (in-memory):              │  │    │
│  │  │  - Нет файла на диске                                  │  │    │
│  │  │  - Используется для dynamic code loading               │  │    │
│  │  │  - Требует верификацию при каждой загрузке              │  │    │
│  │  └───────────────────────────────────────────────────────┘  │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  Parent delegation model:                                            │
│  loadClass("com.example.MyClass"):                                   │
│  1. Спрашивает parent → BootClassLoader: "знаешь такой?" → Нет      │
│  2. Ищет в своих DEX-файлах → PathClassLoader: находит в base.apk   │
│  3. Загружает, верифицирует, линкует → Class<MyClass>                │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

### BaseDexClassLoader и DexPathList

```
┌──────────────────────────────────────────────────────────────────────┐
│            BaseDexClassLoader INTERNALS                               │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  BaseDexClassLoader                                                  │
│  └── DexPathList pathList                                            │
│      └── Element[] dexElements  ← массив DEX-файлов                 │
│          ├── Element[0]: classes.dex (primary)                       │
│          ├── Element[1]: classes2.dex                                │
│          ├── Element[2]: classes3.dex                                │
│          └── ...                                                     │
│                                                                      │
│  Поиск класса (findClass):                                           │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │  for (Element element : dexElements) {                    │       │
│  │      Class<?> clazz = element.dexFile.loadClassByName(    │       │
│  │          name, classLoader);                              │       │
│  │      if (clazz != null) {                                 │       │
│  │          return clazz;  // Нашли! Возвращаем первый       │       │
│  │      }                                                    │       │
│  │  }                                                        │       │
│  │  return null;  // ClassNotFoundException                   │       │
│  └──────────────────────────────────────────────────────────┘       │
│                                                                      │
│  ВАЖНО: порядок dexElements имеет значение!                          │
│  classes.dex ищется ПЕРВЫМ → classes2.dex → classes3.dex             │
│  Если класс есть в нескольких DEX → используется из первого          │
│  Это основа для hot-fix/patching техник (спорных)                    │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

### Class Verification

Верификация DEX-байткода — критичный шаг для безопасности и стабильности.

```
┌──────────────────────────────────────────────────────────────────────┐
│                CLASS VERIFICATION                                    │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Что проверяется:                                                    │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │  1. Structural validity                                   │       │
│  │     - Корректный DEX format                               │       │
│  │     - Все offsets в пределах файла                         │       │
│  │     - Инструкции корректны для данного opcode              │       │
│  │                                                          │       │
│  │  2. Type safety                                           │       │
│  │     - Типы регистров совместимы с операциями              │       │
│  │     - Возвращаемый тип совпадает с декларацией             │       │
│  │     - Аргументы методов правильных типов                  │       │
│  │                                                          │       │
│  │  3. Access checks                                         │       │
│  │     - private/protected/public — соблюдение видимости     │       │
│  │     - Доступ к полям и методам — разрешён                 │       │
│  │                                                          │       │
│  │  4. Control flow                                          │       │
│  │     - Нет jump за пределы метода                          │       │
│  │     - Все пути выполнения корректны                       │       │
│  │     - Нет unreachable code (warning)                      │       │
│  └──────────────────────────────────────────────────────────┘       │
│                                                                      │
│  Когда верификация происходит:                                       │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │  При установке → dex2oat verify → результат в VDEX       │       │
│  │  При запуске → VDEX уже содержит результат → SKIP!        │       │
│  │  Без VDEX → верификация при каждом запуске (медленно)     │       │
│  └──────────────────────────────────────────────────────────┘       │
│                                                                      │
│  Время верификации:                                                  │
│  Маленькое приложение (~1000 классов): ~100ms                        │
│  Среднее приложение (~5000 классов): ~500ms                          │
│  Крупное приложение (~20000 классов): ~2–5s                          │
│                                                                      │
│  → Поэтому VDEX критичен для быстрого запуска!                       │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

### Class Initialization (<clinit>)

```kotlin
// Kotlin: статический инициализатор
class Config {
    companion object {
        // Это вызовет <clinit> при первом обращении к Config
        val API_URL = "https://api.example.com"
        val TIMEOUT = 30_000L

        init {
            // Этот код — часть <clinit>
            println("Config initialized!")
        }
    }
}

// КОГДА вызывается <clinit>:
// 1. Первое обращение к статическому полю → Config.API_URL
// 2. Первый вызов статического метода
// 3. Первое создание экземпляра → Config()
// 4. Через reflection → Class.forName("Config")

// ВАЖНО: <clinit> выполняется ОДИН раз, thread-safe (lock на Class)
// Но: может вызвать неожиданный jank при первом обращении!
```

```
Порядок инициализации класса в ART:

1. Загрузка (Loading):
   ClassLoader.loadClass() → найти DEX data

2. Линковка (Linking):
   a. Verification — проверить байткод (из VDEX или runtime)
   b. Preparation — выделить память для static fields
   c. Resolution — resolve символьных ссылок (lazy)

3. Инициализация (Initialization):
   a. Рекурсивно инициализировать superclass
   b. Выполнить <clinit> (static initializer)
   c. Записать status = INITIALIZED

ВАЖНО: Class.forName() триггерит ВСЕ 3 фазы!
       Class.forName(name, false, loader) — только Loading (без init)
```

---

## Практическое применение: что это значит для разработчика

### Настройка Baseline Profiles

```kotlin
// build.gradle.kts (app module)
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("androidx.baselineprofile")
}

android {
    defaultConfig {
        minSdk = 24
        targetSdk = 35
    }

    buildTypes {
        release {
            isMinifyEnabled = true
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
        // Build variant для генерации профилей
        create("benchmark") {
            initWith(buildTypes.getByName("release"))
            signingConfig = signingConfigs.getByName("debug")
            matchingFallbacks += listOf("release")
            isDebuggable = false
        }
    }
}

baselineProfile {
    automaticGenerationDuringBuild = true
    // Сохранять profiling APK для отладки
    saveInSrc = true
}

dependencies {
    baselineProfile(project(":baselineprofile"))

    implementation("androidx.profileinstaller:profileinstaller:1.4.1")
}
```

### Интерпретация ART-логов

```bash
# 1. GC-логи
adb logcat -s art:D

# Пример: Young GC (Gen-CC)
# I/art: young concurrent copying GC freed 8234(312KB) AllocSpace objects,
#        0(0B) LOS objects, 82% free, 1MB/8MB, paused 0.890ms total 5.123ms
#
# Разбор: young = только young generation, быстрый, 0.89ms пауза

# Пример: Full-heap GC
# I/art: concurrent copying GC freed 45123(4MB) AllocSpace objects,
#        23(2MB) LOS objects, 45% free, 32MB/64MB, paused 2.1ms total 89ms
#
# Разбор: full-heap, 2.1ms пауза, 45% heap свободно

# 2. Compilation status
adb shell dumpsys package <package> | grep -A5 "compilation"
# Покажет: speed-profile, quicken, verify — текущий compiler filter

# 3. Принудительная компиляция
adb shell cmd package compile -m speed -f com.example.app
# speed = скомпилировать ВСЕ методы (не только из профиля)

adb shell cmd package compile -m speed-profile -f com.example.app
# speed-profile = скомпилировать только hot методы из профиля

# 4. Сброс компиляции (для тестирования)
adb shell cmd package compile --reset com.example.app
# Удаляет OAT/VDEX → приложение будет интерпретироваться

# 5. Просмотр профилей
adb shell profman --dump-info-for \
  /data/misc/profiles/cur/0/com.example.app/primary.prof \
  --apk=/data/app/~~.../com.example.app-.../base.apk

# 6. OAT-файл информация
adb shell oatdump --oat-file=/data/app/.../oat/arm64/base.odex --header-only
```

### GC-friendly паттерны аллокации

```kotlin
// ❌ Плохо: создание объектов в горячем цикле
fun processItems(items: List<Item>): List<Result> {
    val results = mutableListOf<Result>()
    for (item in items) {
        // Каждая итерация создаёт:
        // - StringBuilder (для string interpolation)
        // - String (результат interpolation)
        // - Pair (бессмысленная обёртка)
        // - Result (нужный объект)
        val key = "item_${item.id}"        // StringBuilder + String
        val pair = Pair(key, item.value)    // Pair (лишний объект)
        results.add(Result(pair.first, pair.second))
    }
    return results
}

// ✅ Хорошо: минимизация аллокаций
fun processItems(items: List<Item>): List<Result> {
    // Pre-allocate с известным размером
    val results = ArrayList<Result>(items.size)
    val sb = StringBuilder(32)  // reuse StringBuilder

    for (item in items) {
        sb.setLength(0)          // clear, не создаём новый
        sb.append("item_")
        sb.append(item.id)
        results.add(Result(sb.toString(), item.value))
    }
    return results
}

// ✅ Ещё лучше: object pool для RecyclerView ViewHolder
class ViewHolderPool {
    private val pool = ArrayDeque<ViewHolder>(20)

    fun obtain(): ViewHolder {
        return pool.removeFirstOrNull() ?: ViewHolder()
    }

    fun recycle(holder: ViewHolder) {
        holder.reset()
        if (pool.size < 20) {
            pool.addLast(holder)
        }
    }
}
```

```kotlin
// ❌ Плохо: autoboxing в горячем коде
fun sumValues(map: Map<String, Int>): Int {
    var sum = 0
    for ((_, value) in map) {
        sum += value  // Map<String, Int> хранит Integer (boxed!)
                      // Каждый доступ = unboxing Integer → int
    }
    return sum
}

// ✅ Хорошо: примитивные коллекции (SparseArray, ArrayMap)
fun sumValues(map: SparseIntArray): Int {
    var sum = 0
    for (i in 0 until map.size()) {
        sum += map.valueAt(i)  // int напрямую, без boxing
    }
    return sum
}

// ✅ Для Kotlin: используйте inline classes для обёрток
@JvmInline
value class UserId(val value: Int)  // Нет аллокации в runtime!

fun getUser(id: UserId): User {
    // id.value — это просто int, без обёртки в heap
    return database.query(id.value)
}
```

---

## Подводные камни

### 1. Debug builds — полная интерпретация

```
┌──────────────────────────────────────────────────────────────────┐
│  Debug build: android:debuggable="true"                          │
│                                                                  │
│  ART ОТКЛЮЧАЕТ JIT и AOT для debuggable APK:                    │
│  - Весь код выполняется интерпретатором                          │
│  - Это необходимо для breakpoints и step-by-step debugging       │
│  - Результат: 3–5× медленнее release                            │
│                                                                  │
│  НИКОГДА не бенчмарьте debug build!                               │
│  Всегда используйте release (или benchmark) variant.             │
└──────────────────────────────────────────────────────────────────┘
```

### 2. Первый запуск — самый медленный

```
Первый запуск после установки:
- Нет runtime profile → нет background AOT
- Только Baseline/Cloud profile (если есть) → частичный AOT
- Остальной код → интерпретатор + JIT
- Class verification (если нет VDEX) → дополнительные секунды

Решение: Baseline Profiles покрывают критические пути
```

### 3. Class.forName() вызывает jank

```kotlin
// ❌ Плохо: Class.forName в main thread
class SplashActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Каждый Class.forName() триггерит:
        // 1. Class loading (I/O с DEX файлом)
        // 2. Verification (если нет в VDEX)
        // 3. Initialization (<clinit>)
        // Всё это в MAIN THREAD → jank!
        val pluginClass = Class.forName("com.example.plugin.Engine")
        val instance = pluginClass.newInstance()
    }
}

// ✅ Хорошо: отложить на background thread
class SplashActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        lifecycleScope.launch(Dispatchers.Default) {
            val pluginClass = Class.forName("com.example.plugin.Engine")
            val instance = pluginClass.newInstance()
            withContext(Dispatchers.Main) {
                // Использовать плагин в UI
            }
        }
    }
}
```

### 4. Большие DEX файлы замедляют холодный старт

```
Размер DEX влияет на:
- Время верификации: O(n) от количества классов
- Memory mapping: больше I/O при mmap
- Class search: линейный поиск по dexElements

Решение:
- R8 minification удаляет неиспользуемый код
- Modularization: разбить на dynamic feature modules
- Startup Profile: оптимизирует DEX layout
```

### 5. GC pressure от allocation rate

```kotlin
// ❌ Плохо: высокий allocation rate в onDraw
class CustomView(context: Context) : View(context) {
    override fun onDraw(canvas: Canvas) {
        // onDraw вызывается 60–120 раз/сек!
        val paint = Paint()                    // NEW объект каждый кадр
        val rect = RectF(0f, 0f, width.toFloat(), height.toFloat())  // NEW
        val path = Path()                      // NEW
        // ...
    }
}

// ✅ Хорошо: pre-allocate и reuse
class CustomView(context: Context) : View(context) {
    private val paint = Paint()               // Создаём ОДИН раз
    private val rect = RectF()                // Создаём ОДИН раз
    private val path = Path()                 // Создаём ОДИН раз

    override fun onDraw(canvas: Canvas) {
        rect.set(0f, 0f, width.toFloat(), height.toFloat())
        path.reset()
        // Reuse объектов — 0 аллокаций в onDraw
    }
}
```

### Сводная таблица подводных камней

| Ловушка | Симптом | Решение |
|---------|---------|---------|
| Бенчмарк debug build | Низкие показатели | Всегда бенчмарить release/benchmark |
| Нет Baseline Profile | Медленный первый запуск | Добавить Baseline Profile generation |
| Class.forName() в main thread | Jank при загрузке | Вынести в background |
| Большой DEX без R8 | Медленная верификация | Включить minification (R8) |
| Аллокации в onDraw | GC pressure, dropped frames | Pre-allocate, object pool |
| Чрезмерный boxing | Лишние аллокации | Примитивные коллекции, inline classes |
| System.gc() в production | Непредсказуемые паузы | Убрать явные вызовы GC |

---

## Мифы и заблуждения

### Миф 1: «ART — это JVM»

```
РЕАЛЬНОСТЬ:

ART ≠ JVM. Они отличаются фундаментально:

┌──────────────────────────────────┬─────────────────────────────┐
│          ART                     │          JVM (HotSpot)      │
├──────────────────────────────────┼─────────────────────────────┤
│ Байткод: DEX (register-based)   │ Байткод: .class (stack)     │
│ Instruction set: 16-bit DEX     │ Instruction set: 8-bit JVM  │
│ Формат: .dex/.vdex/.odex        │ Формат: .class/.jar         │
│ AOT compiler: dex2oat           │ AOT: GraalVM native-image   │
│ GC: Concurrent Copying          │ GC: G1/ZGC/Shenandoah      │
│ Heap: <512 MB типично           │ Heap: гигабайты             │
│ Target: mobile (battery!)       │ Target: server (throughput) │
│ Profiles: Baseline + Cloud      │ Profiles: нет стандартных    │
└──────────────────────────────────┴─────────────────────────────┘

ART исполняет DEX-байткод, НЕ Java-байткод.
Kotlin → Java bytecode (.class) → D8/R8 → DEX bytecode (.dex) → ART
```

### Миф 2: «AOT всегда лучше JIT»

```
РЕАЛЬНОСТЬ:

AOT и JIT имеют разные преимущества:

AOT (dex2oat):
+ Нет warmup — код сразу нативный
+ Предсказуемая производительность
+ Нет JIT compilation overhead в runtime
- Консервативный код (не знает runtime типы)
- Больше места на диске
- Нет speculative optimizations

JIT (runtime):
+ Знает runtime типы → может speculate
+ Speculative inlining (виртуальные вызовы → прямые)
+ Deoptimization если speculation неверна
+ Inline caches (мономорфные call sites)
+ Меньше места (только горячий код)
- Warmup period (первый запуск медленнее)
- Overhead на compilation thread

ВЫВОД: ART использует ОБА — AOT для known-hot, JIT для нового горячего кода
```

### Миф 3: «GC вызывает jank»

```
РЕАЛЬНОСТЬ:

CC GC в ART имеет паузы ~2ms. При 16.6ms/frame (60 FPS):
- 2ms пауза = 12% от frame budget
- Обычно НЕ вызывает dropped frames

Что РЕАЛЬНО вызывает GC-related jank:
1. Чрезмерный allocation rate → GC запускается слишком часто
2. Finalization: объекты с finalize() → дополнительный GC цикл
3. Native memory pressure → triggers Java GC unnecessarily
4. Large Object Space allocations → mmap overhead

Решение: оптимизировать allocation rate, а не бороться с GC
```

### Миф 4: «Multidex — решённая проблема»

```
РЕАЛЬНОСТЬ:

Для minSdk ≥ 21 (ART): multidex нативно поддерживается.
НО multidex по-прежнему влияет на:

1. Startup performance: больше DEX файлов → больше I/O при загрузке
2. DEX layout: классы разбросаны по файлам → больше page faults
3. Class search: линейный поиск по dexElements массиву
4. Build time: R8 должен решить какие классы в какой DEX

Startup Profiles помогают: классы из профиля группируются
в начале primary DEX → меньше page faults при старте.
```

### Миф 5: «Baseline Profiles заменяют оптимизацию кода»

```
РЕАЛЬНОСТЬ:

Baseline Profiles ускоряют КОМПИЛЯЦИЮ, не АЛГОРИТМЫ.

Что Baseline Profile делает:
✓ Обеспечивает AOT-компиляцию hot/startup методов
✓ Ускоряет cold start на 15–40%
✓ Уменьшает jank на первых запусках

Что Baseline Profile НЕ делает:
✗ Не исправляет O(n²) алгоритмы
✗ Не уменьшает allocation rate
✗ Не оптимизирует I/O или сетевые вызовы
✗ Не решает проблемы с threading

Baseline Profile — это финишная оптимизация ПОСЛЕ
того, как код уже хорошо написан.
```

---

## CS-фундамент

| CS-концепция | Применение в ART | Где углубиться |
|-------------|-----------------|---------------|
| **Virtual Machine** | ART исполняет DEX-байткод на register-based VM | [[jvm-virtual-machine-concept]] |
| **Compiler Design** | dex2oat: IR (HInstruction) → оптимизации → code gen | [[android-compilation-pipeline]] |
| **JIT Compilation** | Горячие методы компилируются на лету по threshold | [[jvm-basics-history]] |
| **AOT Compilation** | Profile-guided offline компиляция через dex2oat | [[android-compilation-pipeline]] |
| **Garbage Collection** | CC GC: concurrent tri-color mark + copy с read barriers | [[jvm-gc-tuning]] |
| **Class Loading** | Delegation model: Boot → Path → Dex ClassLoader | [[jvm-basics-history]] |
| **Profile-Guided Optimization** | Runtime profiles определяют что компилировать AOT | — |
| **Register Allocation** | Linear scan / graph coloring в JIT и dex2oat | — |
| **SSA Form** | HInstruction graph в dex2oat использует Static Single Assignment | — |
| **Memory Management** | Region-based heap, TLAB, bump-pointer allocation | [[jvm-memory-model]] |
| **Copy-on-Write** | Zygote Space разделяется между процессами через CoW | [[os-memory-management]] |
| **ELF Format** | OAT файлы — это ELF binaries с custom sections | — |

---

## Проверь себя

> [!question]- Почему ART использует три режима выполнения (Interpreter, JIT, AOT) вместо одного?
> Каждый режим оптимизирован для своего сценария. Interpreter обеспечивает мгновенный запуск холодного кода без latency на компиляцию — критично для первого запуска. JIT компилирует горячий код в runtime с полным знанием типов (speculative inlining, deoptimization) — лучше чем AOT для polymorphic call sites. AOT (dex2oat) даёт максимальную скорость без warmup для known-hot методов из профиля. Гибридная стратегия: быстрая установка (verify only) → быстрый запуск (interpret + JIT для нового) → eventual peak performance (background AOT из profile). Один режим не может покрыть все три требования одновременно.

> [!question]- Как Concurrent Copying GC достигает пауз ~2ms при перемещении объектов?
> Ключ — read barriers. CC GC копирует объекты из FROM_SPACE в TO_SPACE ПАРАЛЛЕЛЬНО с работающим приложением. Каждый объект имеет forwarding pointer (Brooks pointer, +1 word). Когда GC копирует объект, он обновляет forwarding pointer старого объекта на адрес новой копии. Компилятор (JIT/AOT) вставляет read barrier при каждом чтении ссылочного поля: barrier проверяет forwarding pointer и возвращает актуальный адрес. Единственная пауза (~2ms) — для сканирования GC roots (стеки потоков, static fields, JNI refs). Tri-color marking и copying — полностью concurrent. Overhead read barrier: ~1 дополнительная load инструкция, ~2-5% throughput — приемлемо для мобильных.

> [!question]- Чем Baseline Profile отличается от Cloud Profile, и зачем нужны оба?
> Baseline Profile создаётся разработчиком (через Macrobenchmark/BaselineProfileRule), упаковывается в APK и доступен на ПЕРВОМ запуске. Cloud Profile агрегируется Google Play из runtime-профилей реальных пользователей и доставляется в .dm файле при установке. Baseline Profile доступен сразу (даже без интернета, для sideloaded APK), но может быть неполным. Cloud Profile более полный (данные от тысяч пользователей), но появляется с задержкой после публикации и недоступен для sideloaded APK. Оптимальная стратегия: Baseline Profile покрывает гарантированный минимум (startup + CUJ), Cloud Profile дополняет его данными из production. При установке ART мержит оба профиля.

> [!question]- Почему debug build в 3-5× медленнее release, и как это связано с ART?
> Когда APK помечен android:debuggable="true", ART отключает JIT-компиляцию и AOT, выполняя ВСЕ методы через интерпретатор. Это необходимо для поддержки breakpoints: отладчик должен иметь возможность остановить выполнение на любой строке, что невозможно для JIT/AOT-скомпилированного нативного кода (без дополнительной инфраструктуры). Интерпретатор выполняет DEX-инструкции одну за другой через switch/case в C++, что в 10-100× медленнее нативного кода. Плюс отключены оптимизации (inlining, DCE, constant folding). Поэтому НИКОГДА нельзя бенчмарить debug build — результаты не отражают реальную производительность release.

> [!question]- Что происходит с DEX-байткодом от момента установки APK до выполнения кода?
> Установка: PackageManager извлекает classes.dex из APK. dex2oat запускается с compiler-filter (speed-profile если есть Baseline/Cloud Profile, или verify если нет). Результат: .vdex (verified DEX, ускоряет будущие загрузки), .odex (OAT — нативный код для hot методов), опционально .art (app image). Файлы сохраняются в /data/app/<pkg>/oat/arm64/. При запуске: PathClassLoader загружает DEX через DexPathList. Для AOT-метода: вызов идёт напрямую в нативный код из .odex. Для не-AOT метода: интерпретатор начинает выполнение. Если метод становится горячим (hotness > 10000): JIT компилирует его на фоновом потоке, результат в JIT code cache. JIT записывает горячие методы в runtime profile. Background dexopt (idle+charging): dex2oat перекомпилирует с merged profile.

---

## Ключевые карточки

Что такое ART и чем он отличается от Dalvik?
?
ART (Android Runtime) — виртуальная машина Android, заменившая Dalvik в Android 5.0. Оба register-based и исполняют DEX-байткод. Ключевые отличия: ART поддерживает AOT+JIT+Interpreter (Dalvik — только JIT), Concurrent Copying GC с ~2ms паузами (Dalvik CMS — 100-200ms), profile-guided optimization (Dalvik — нет), 64-bit (Dalvik — нет). ART значительно быстрее и экономичнее по батарее.

Какие три режима выполнения есть в ART?
?
1) Interpreter — switch-based C++, выполняет DEX-инструкции по одной, 10-100× медленнее нативного, используется для холодного/debug кода. 2) JIT — компилирует горячие методы (hotness > ~10000) в нативный код в JIT code cache (in-memory, per-process), поддерживает OSR. 3) AOT (dex2oat) — компилирует методы из профиля в нативный код заранее, результат в .odex файле. Приоритет: AOT > JIT > Interpreter.

Что такое Concurrent Copying GC и почему он лучше предшественников?
?
CC GC — текущий алгоритм GC в ART (8.0+). Ключевое свойство: concurrent mark + concurrent copy с read barriers. Пауза только ~2ms (root scan), вся трасировка и копирование параллельны с app. Tri-color marking (white/gray/black). Read barrier: при чтении ссылки проверяется forwarding pointer → если объект скопирован, возвращается новый адрес. Compaction (устраняет фрагментацию). Gen-CC (10.0+) добавляет поколения: young GC дёшев, full-heap — реже.

Что такое Baseline Profile и как он влияет на производительность?
?
Baseline Profile — профиль горячих/startup методов, созданный разработчиком и упакованный в APK. При установке dex2oat компилирует эти методы AOT (speed-profile). Результат: 15-40% ускорение cold start на первом запуске. Создаётся через Macrobenchmark/BaselineProfileRule. Формат: HSP-флаги + method signatures. Дополняет Cloud Profiles от Play Store. Startup Profiles (Android 13+) — подмножество для оптимизации DEX layout.

Что такое DEX формат и почему существует 64K method limit?
?
DEX (Dalvik Executable) — register-based bytecode формат Android. Структура: header, string_ids, type_ids, proto_ids, field_ids, method_ids, class_defs, data. 64K limit: method_ids использует uint16 индекс → max 65536 ссылок на методы в одном DEX файле. Считаются ВСЕ referenced методы (свои + библиотечные). Решение: MultiDex — несколько DEX файлов в APK. ART (5.0+) поддерживает MultiDex нативно.

Какие файлы генерирует dex2oat и зачем каждый?
?
.odex (OAT) — ELF-файл с нативным кодом + DEX headers, основной output для AOT. .vdex (Verified DEX) — верифицированный DEX-байткод, позволяет пропустить верификацию при загрузке (Android 8.0+). .art (ART image) — pre-initialized heap snapshot для быстрого boot (framework classes). .prof (profile) — записанные JIT горячие/startup методы, input для speed-profile компиляции. CDEX (Compact DEX, 9.0+) — компактный DEX внутри VDEX с де-дупликацией данных.

Как работает Profile-Guided Optimization в ART?
?
Жизненный цикл: 1) Разработчик создаёт Baseline Profile (Macrobenchmark), упаковывает в APK. 2) Play доставляет Cloud Profile (.dm файл) из агрегированных данных пользователей. 3) При установке: dex2oat speed-profile компилирует методы из merged profile. 4) Runtime: JIT записывает новые горячие методы в runtime profile (/data/misc/profiles/). 5) Background dex2oat (idle+charging): перекомпилирует с merged profile (baseline + cloud + runtime). Результат: progressive optimization — каждый запуск быстрее.

Какие heap spaces существуют в ART и для чего каждый?
?
Image Space — boot.art, pre-loaded framework classes (read-only, shared). Region Space — основной heap для CC GC, 256KB регионы, bump-pointer через TLAB (~10ns аллокация). Large Object Space (LOS) — объекты >12KB, mmap, не перемещаются GC. Non-Moving Space — pinned объекты (JNI refs, monitors), Rosalloc аллокатор. Zygote Space — объекты от Zygote до fork(), shared через Copy-on-Write. JIT Code Cache — скомпилированный JIT-код (in-memory, per-process).

---

## Связь с другими темами

**[[android-compilation-pipeline]]** — Compilation Pipeline покрывает **build-time** преобразования: Kotlin → JVM bytecode → D8/R8 → DEX. Текущий файл продолжает путь DEX-байткода на **runtime**: как ART исполняет, JIT-компилирует, AOT-компилирует и оптимизирует DEX-код на устройстве. Эти файлы дополняют друг друга: pipeline заканчивается DEX в APK, ART Runtime начинается с DEX из APK.

**[[android-boot-process]]** — Boot Process описывает как запускается ART: init → Zygote → fork() → app process. Текущий файл объясняет что происходит ВНУТРИ ART после запуска процесса: class loading, verification, interpretation, JIT, AOT. Boot Process — «когда и как запускается», ART Runtime — «как работает внутри».

**[[android-app-startup-performance]]** — App Startup Performance содержит практические рецепты ускорения cold start. Текущий файл объясняет МЕХАНИЗМЫ, на которых эти рецепты основаны: почему Baseline Profiles ускоряют старт (PGO → dex2oat speed-profile), почему первый запуск медленный (нет runtime profile), почему class loading занимает время (verification + <clinit>).

**[[android-process-memory]]** — Process Memory описывает heap management, LMK, OOM adj. Текущий файл детализирует ВНУТРЕННЮЮ структуру managed heap: Region Space, LOS, Non-Moving Space, Zygote Space, TLAB. Process Memory — внешний вид (Linux perspective), ART Runtime — внутренний вид (GC perspective).

**[[jvm-gc-tuning]]** — JVM GC Tuning покрывает серверные GC алгоритмы (G1, ZGC, Shenandoah). Текущий файл описывает мобильный CC GC в ART — другой алгоритм для другого окружения. Сравнительная таблица в разделе 9.5 связывает оба мира. Общие концепции: tri-color marking, read/write barriers, generational hypothesis.

**[[jvm-basics-history]]** — JVM Basics описывает концепцию виртуальной машины, stack-based bytecode, class loading. Текущий файл показывает альтернативный подход ART: register-based bytecode, hybrid compilation, mobile-optimized GC. Изучение обоих даёт полное понимание виртуальных машин для managed языков.

**[[android-architecture]]** — Architecture даёт обзор слоёв Android: Linux → HAL → ART → Framework → App. Текущий файл — глубокое погружение в слой ART: внутренние механизмы, алгоритмы, форматы файлов, стратегии оптимизации. Architecture — карта, ART Runtime — подробная карта одного района.

---

## Источники и дальнейшее чтение

### Официальная документация AOSP

- [ART and Dalvik](https://source.android.com/docs/core/runtime) — обзор ART runtime
- [ART JIT Compiler](https://source.android.com/docs/core/runtime/jit-compiler) — реализация JIT
- [Configure ART](https://source.android.com/docs/core/runtime/configure) — настройка ART runtime
- [DEX Format Specification](https://source.android.com/docs/core/runtime/dex-format) — спецификация DEX формата
- [Debug ART Garbage Collection](https://source.android.com/docs/core/runtime/gc-debug) — диагностика GC

### AOSP Source Code

- [art/](https://cs.android.com/android/platform/superproject/+/master:art/) — исходный код ART Runtime
- [art/runtime/interpreter/](https://cs.android.com/android/platform/superproject/+/master:art/runtime/interpreter/) — интерпретатор
- [art/runtime/jit/](https://cs.android.com/android/platform/superproject/+/master:art/runtime/jit/) — JIT compiler
- [art/runtime/gc/](https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/) — Garbage Collector
- [art/dex2oat/](https://cs.android.com/android/platform/superproject/+/master:art/dex2oat/) — AOT compiler
- [art/libdexfile/dex/compact_dex_file.h](https://cs.android.com/android/platform/superproject/+/master:art/libdexfile/dex/compact_dex_file.h) — Compact DEX format

### Baseline Profiles

- [Baseline Profiles Overview — Android Developers](https://developer.android.com/topic/performance/baselineprofiles/overview)
- [Create Baseline Profiles — Android Developers](https://developer.android.com/topic/performance/baselineprofiles/create-baselineprofile)
- [Create Startup Profiles — Android Developers](https://developer.android.com/topic/performance/startupprofiles/dex-layout-optimizations)
- [Accelerating Android Apps with Baseline Profiles — Meta Engineering](https://engineering.fb.com/2025/10/01/android/accelerating-our-android-apps-with-baseline-profiles/)
- [Android Calendar Case Study — Android Developers](https://developer.android.com/topic/performance/baselineprofiles/case-study-android-calendar)

### Блоги и статьи

- [Improving App Performance with ART Optimizing Profiles in the Cloud — Android Developers Blog (2019)](https://android-developers.googleblog.com/2019/04/improving-app-performance-with-art.html)
- [Improving App Performance with Baseline Profiles — Android Developers Blog (2022)](https://android-developers.googleblog.com/2022/01/improving-app-performance-with-baseline.html)
- [18% Faster Compiles, 0% Compromises — Android Developers Blog (2025)](https://android-developers.googleblog.com/2025/12/18-faster-compiles-0-compromises.html)
- [ART Cloud Profiling to Improve Android App Performance — InfoQ (2019)](https://www.infoq.com/news/2019/04/play-cloud-art-profiling-android/)
- [Google Boosts ART Compile Times by 18% — InfoQ (2025)](https://www.infoq.com/news/2025/12/android-art-jit-aot-improvement/)
- [Collecting the Garbage: A Brief History of GC over Android Versions — ProAndroidDev](https://proandroiddev.com/collecting-the-garbage-a-brief-history-of-gc-over-android-versions-f7f5583e433c)
- [Android Runtime — How Dalvik and ART work — ProAndroidDev](https://proandroiddev.com/android-runtime-how-dalvik-and-art-work-6e57cf1c50e5)
- [ART JIT in Android N — Linaro (2016)](https://static.linaro.org/connect/las16/Presentations/Tuesday/LAS16-201%20-%20ART%20JIT%20in%20Android%20N.pdf)

### Инструменты анализа

- [LIEF — Android Format Analysis](https://lief.re/doc/stable/tutorials/10_android_formats.html) — анализ DEX/OAT/VDEX форматов
- [dextra — DEX and OAT tool](https://newandroidbook.com/tools/dextra.html) — дамп и анализ DEX/OAT
- [vdexExtractor — GitHub](https://github.com/anestisb/vdexExtractor) — извлечение DEX из VDEX

### Книги

| Книга | Применение |
|-------|-----------|
| Vasavada N. *Android Internals: A Confectioner's Cookbook* (2019) | ART internals, GC, class loading, boot process |
| Levin J. *Android Internals: Power User's View* (2015) | Dalvik → ART transition, kernel, Zygote |
| Dmitry Jemerov, Svetlana Isakova. *Kotlin in Action* (2nd ed., 2024) | Kotlin compilation to DEX, inline classes, coroutines |
| Richard Jones et al. *The Garbage Collection Handbook* (2nd ed., 2023) | Теория GC: copying, concurrent, generational, read barriers |

### Видео

- [ART Improvements in Android N — Google I/O 2016](https://www.youtube.com/results?search_query=ART+improvements+android+N+google+io+2016) — введение гибридной JIT+AOT стратегии
- [Understanding Android Runtime (ART) — Android Dev Summit](https://www.youtube.com/results?search_query=understanding+android+runtime+art+dev+summit) — обзор ART internals

---

## Куда дальше

| Направление | Куда | Зачем |
|-------------|------|-------|
| Следующий в internals | [[android-system-services]] | System Server: AMS, WMS, PMS — services, которые работают поверх ART |
| Предыдущий в internals | [[android-boot-process]] | Загрузка: init → Zygote → SystemServer → как ART запускается |
| Build pipeline | [[android-compilation-pipeline]] | Как Kotlin превращается в DEX (build-time дополнение) |
| Memory | [[android-process-memory]] | Heap management, LMK, OOM adj — внешний вид памяти |
| JVM аналогии | [[jvm-gc-tuning]] | GC алгоритмы на серверных JVM — для сравнения |
| Практика | [[android-app-startup-performance]] | Как применить знания ART для оптимизации cold start |
| Обзор | [[android-internals-overview]] | Вернуться к карте раздела internals |

*Проверено: 2026-02-19 | ART (Android 14+, Mainline), CC GC, Baseline Profiles 1.4+ | Актуально*
