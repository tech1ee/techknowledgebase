---
title: "DataStore: современное key-value хранилище для Android"
created: 2026-02-11
modified: 2026-02-13
type: deep-dive
area: android
status: published
confidence: high
cs-foundations: [key-value-storage, serialization, protocol-buffers, atomic-writes, reactive-streams]
tags:
  - topic/android
  - topic/data
  - type/deep-dive
  - level/intermediate
related:
  - "[[android-data-persistence]]"
  - "[[android-room-deep-dive]]"
  - "[[android-permissions-security]]"
  - "[[kotlin-coroutines]]"
  - "[[kotlin-flow]]"
prerequisites:
  - "[[android-data-persistence]]"
  - "[[kotlin-coroutines]]"
  - "[[kotlin-flow]]"
reading_time: 60
difficulty: 5
study_status: not_started
mastery: 0
last_reviewed:
next_review: 
---

# DataStore: современное key-value хранилище для Android

DataStore -- это библиотека из семейства Android Jetpack, созданная как полноценная замена SharedPreferences. Она решает три фундаментальные проблемы своего предшественника: блокировку главного потока при чтении данных, гонки данных при параллельной записи и полное отсутствие обработки ошибок ввода-вывода. DataStore существует в двух вариантах: **Preferences DataStore** для простого key-value хранения и **Proto DataStore** для типизированных объектов, определённых через Protocol Buffers.

---

## Зачем это знать

Представьте ситуацию: ваше приложение установлено у миллиона пользователей. При каждом холодном запуске приложение читает пользовательские настройки -- тему оформления, язык, флаги уведомлений. SharedPreferences выполняет это чтение синхронно на главном потоке. На мощном Pixel это занимает 5 миллисекунд. На бюджетном Samsung Galaxy A03s с медленным eMMC-хранилищем -- 200-400 миллисекунд. Если в это время пользователь коснулся экрана, система выдаст ANR (Application Not Responding).

Это не теоретическая проблема. Google Play Console показывает тысячи ANR-отчётов, связанных с SharedPreferences, ежедневно. Команда Android в Google признала: SharedPreferences, спроектированный в 2008 году, не подходит для современных приложений. DataStore -- их ответ на эту проблему.

Понимание DataStore критично для трёх практических сценариев. Во-первых, при написании нового кода: Google рекомендует DataStore вместо SharedPreferences для всех новых проектов. Во-вторых, при миграции существующего кода: рано или поздно вам придётся переводить приложение с SharedPreferences на DataStore, и без понимания внутренней механики миграция может привести к потере данных. В-третьих, при отладке: если приложение теряет настройки или записывает неправильные значения, понимание атомарных записей и координации потоков поможет найти причину за минуты, а не за дни.

---

## Терминология

| Термин | Что это | Аналогия из жизни |
|--------|---------|-------------------|
| **SharedPreferences** | Устаревшее key-value хранилище Android (XML-файл) | Бумажный ежедневник -- пишешь ручкой, стереть нельзя, два человека писать одновременно не могут |
| **DataStore** | Современная замена SharedPreferences с асинхронным API | Облачный блокнот (Google Keep) -- изменения видны мгновенно, запись атомарная, конфликты разрешаются |
| **Preferences DataStore** | Вариант DataStore для простых key-value пар | Таблица настроек в приложении -- включить/выключить, выбрать язык |
| **Proto DataStore** | Вариант DataStore для типизированных объектов | Медицинская карта -- строгая структура (ФИО, группа крови), не произвольные заметки |
| **Protocol Buffers** | Формат сериализации данных от Google | Бланк анкеты -- каждое поле определено заранее (имя, возраст, адрес) |
| **Serializer** | Класс, преобразующий объекты в байты и обратно | Переводчик -- превращает мысли в текст и текст обратно в мысли |
| **Atomic write** | Запись, которая либо полностью применяется, либо не применяется вовсе | Банковский перевод -- деньги либо ушли полностью, либо вернулись, не бывает "половина перевелась" |
| **Flow** | Реактивный поток данных из Kotlin Coroutines | Подписка на газету -- вы получаете новый выпуск автоматически при каждом изменении |
| **Migration** | Перенос данных из одного формата хранения в другой | Переезд из старой квартиры в новую -- упаковать, перевезти, проверить, сдать старую |

---

## Историческая справка

История DataStore начинается с самого рождения Android. В 2008 году, когда Google выпустил Android 1.0, в составе SDK появился класс `SharedPreferences`. Его задача была простой: дать разработчикам способ сохранять небольшие настройки приложения -- тему оформления, имя пользователя, флаг "показывать ли приветственный экран". Под капотом SharedPreferences хранил данные в XML-файле в приватной директории приложения (`/data/data/<package>/shared_prefs/`). API был намеренно простым: `getString()`, `putString()`, `getBoolean()`, `putBoolean()`. Для 2008 года это было элегантное решение -- приложения были однопоточными, настроек было мало, а устройства имели схожую производительность.

На протяжении 12 лет SharedPreferences оставался практически неизменным. Единственное значимое обновление -- добавление метода `apply()` в Android 2.3 (2010) как асинхронной альтернативы блокирующему `commit()`. Но за это время изменился сам Android: приложения стали многопоточными, пользователи ожидали мгновенного отклика, а устройства -- всё более разнообразными по производительности. Флагманские смартфоны получили NVMe-хранилища с пропускной способностью в гигабайты в секунду, тогда как бюджетные модели по-прежнему использовали медленный eMMC. Эта разница в производительности диска стала главным источником проблем SharedPreferences.

К 2019-2020 годам проблемы стали критическими. Отчёты ANR в Google Play Console показывали тысячи зависаний, связанных с `SharedPreferences.getString()` на главном потоке. Multi-process приложения (например, использующие Firebase Cloud Messaging, который работает в отдельном процессе) сталкивались с потерей данных из-за отсутствия синхронизации между процессами. Метод `apply()`, задуманный как решение проблемы блокировки, сам создавал новые проблемы: при вызове `Activity.onPause()` система ожидала завершения всех pending `apply()` операций, что снова блокировало UI. Внутри Google эту ситуацию описывали как "death by a thousand cuts" -- каждая отдельная проблема казалась незначительной, но в совокупности они делали SharedPreferences непригодным для production-приложений.

Google анонсировал DataStore на **Android Dev Summit 2020**. Разработку вела команда Android Jetpack, в частности инженеры Rohit Sathyanarayana и Yigit Boyar. Ключевое архитектурное решение -- построить DataStore поверх Kotlin Coroutines и Flow -- было принято осознанно: к 2020 году Kotlin стал рекомендуемым языком для Android, а корутины -- стандартным механизмом асинхронности. Первая альфа-версия вышла в сентябре 2020 года. После года тестирования и доработок стабильный релиз **DataStore 1.0.0** состоялся в **августе 2021 года**. К этому моменту Google настоятельно рекомендовал переход с SharedPreferences на DataStore для всех новых проектов.

> **Ключевой инсайт:** DataStore -- это не просто "улучшенный SharedPreferences". Это фундаментальный переход от синхронного, неструктурированного API к реактивной, типобезопасной архитектуре хранения данных, построенной на Kotlin Coroutines и Flow.

---

## Prerequisites

| Тема | Зачем нужно для DataStore | Где изучить |
|------|---------------------------|-------------|
| Хранение данных в Android | Общая картина: Room, DataStore, Files и когда какой инструмент | [[android-data-persistence]] |
| Kotlin Coroutines | DataStore API полностью построен на suspend-функциях | [[kotlin-coroutines]] |
| Kotlin Flow | Чтение из DataStore возвращает Flow -- реактивный поток | [[kotlin-flow]] |
| Android Context | DataStore привязан к Context приложения | [[android-context-internals]] |

---

## Почему SharedPreferences -- проблема

Чтобы понять ценность DataStore, нужно детально разобрать проблемы его предшественника. SharedPreferences кажется простым и безобидным инструментом, но под капотом скрывается целый ряд архитектурных недостатков, которые проявляются в production. Каждая из этих проблем по отдельности может показаться терпимой. Но вместе они формируют набор ловушек, которые неизбежно срабатывают при масштабировании приложения.

### Синхронное чтение блокирует UI

Когда вы вызываете `SharedPreferences.getString("key", "default")`, система должна сначала загрузить весь XML-файл в память. При первом обращении к SharedPreferences после запуска приложения (холодный старт) происходит полный парсинг XML с диска. Этот процесс выполняется на том потоке, который вызвал метод -- чаще всего на главном (UI) потоке.

На быстром устройстве с NVMe-хранилищем это занимает единицы миллисекунд. Но на бюджетных устройствах с eMMC-хранилищем, особенно если диск фрагментирован или занят другими операциями ввода-вывода, чтение может занять сотни миллисекунд. Системе нужно открыть файл, прочитать XML, распарсить каждый элемент, создать HashMap в памяти. Если главный поток заблокирован более 5 секунд, Android показывает диалог ANR (Application Not Responding) и предлагает пользователю завершить приложение.

Проблема усугубляется тем, что SharedPreferences загружает весь файл целиком, даже если вам нужно только одно значение. Если в файле 200 настроек, а вы запрашиваете одну -- все 200 будут прочитаны и распарсены. Это избыточная работа, которая тем не менее блокирует UI.

Аналогия: представьте кассира в супермаркете. Каждый раз, когда покупатель спрашивает цену товара, кассир уходит на склад, ищет в картотеке, возвращается и отвечает. Очередь стоит. SharedPreferences -- этот кассир. DataStore -- кассир со сканером штрихкодов: запрос отправляется в фоне, ответ приходит мгновенно, а очередь двигается.

### commit() vs apply(): выбор без хорошего варианта

SharedPreferences предлагает два метода записи. `commit()` выполняет запись синхронно и возвращает `true` или `false` в зависимости от успеха. Проблема: он блокирует вызывающий поток до завершения записи на диск. `apply()` выполняет запись асинхронно в фоновом потоке и возвращает управление немедленно. Казалось бы, проблема решена. Но нет.

Метод `apply()` создаёт скрытую ловушку, которую инженеры Google назвали "apply() penalty". Android хранит все незавершённые `apply()` операции в специальной очереди `QueuedWork`. При вызове `Activity.onStop()` или `Service.onDestroy()` система вызывает `QueuedWork.waitToFinish()`, который ждёт завершения **всех** pending `apply()` операций. Если вы вызвали `apply()` десять раз подряд (например, при сохранении формы с множеством полей), а затем пользователь нажал "Назад", система заблокирует переход до завершения всех записей. На медленном диске это снова приводит к ANR.

Особенно коварно это проявляется при работе с сервисами. Если `Service.onDestroy()` ждёт завершения `apply()`, а система хочет убить процесс для освобождения памяти, Android может убить процесс принудительно, потеряв при этом данные, которые `apply()` ещё не успел записать.

### Race conditions при параллельной записи

SharedPreferences не предоставляет механизма координации записей из разных потоков. Если два потока одновременно вызывают `edit().putString().apply()`, результат непредсказуем. Каждый `edit()` создаёт копию текущего состояния HashMap, вносит свои изменения и записывает результат на диск. Если оба потока прочитали одно и то же состояние, внесли разные изменения и записали -- изменения одного из них будут потеряны. Это классическая проблема "lost update", хорошо известная в теории баз данных.

```
Поток A:                     Поток B:
  read(theme=dark)             read(theme=dark)
  set(language=ru)             set(fontSize=large)
  write(theme=dark,            write(theme=dark,
        language=ru)                 fontSize=large)
        ↓                           ↓
  Итог: fontSize=large — изменение потока A ПОТЕРЯНО
```

В реальных приложениях эта проблема проявляется, когда несколько компонентов сохраняют настройки параллельно: Activity сохраняет тему, Service сохраняет токен, BroadcastReceiver сохраняет флаг push-уведомления. Каждый из них работает в своём потоке, и конфликт записей неизбежен.

### Отсутствие обработки ошибок

Если на устройстве закончилось место, SharedPreferences не может записать данные на диск. Метод `apply()` молча проглатывает ошибку -- нет ни исключения, ни callback'а, ни логирования. Метод `commit()` вернёт `false`, но большинство разработчиков не проверяют возвращаемое значение. Данные потеряны, приложение об этом не знает, и продолжает работать как будто запись прошла успешно.

Это особенно опасно для чувствительных настроек. Представьте: пользователь отключил уведомления, `apply()` не смог записать из-за заполненного диска -- при следующем запуске уведомления снова включены, и пользователь получает нежелательные push-сообщения. Или хуже: приложение сохраняет токен авторизации через `apply()`, запись не удалась, при следующем запуске токена нет -- пользователь разлогинен без объяснения причин. Такие баги практически невозможно воспроизвести в лабораторных условиях, они проявляются только на устройствах пользователей с заполненным хранилищем.

### XML-формат: наследие 2008 года

SharedPreferences хранит данные в XML. Это текстовый формат, разработанный для человекочитаемости, а не для эффективности. При каждом чтении или записи весь файл парсится или сериализуется целиком -- нет способа обновить одно значение, не переписывая всё. Для файла с 5 настройками это незаметно. Для файла с 200 настройками (что встречается в реальных приложениях с feature flags, A/B тестами и множеством пользовательских предпочтений) это создаёт ощутимые задержки.

XML также избыточен по размеру. Строка `<string name="theme">dark</string>` занимает 37 байтов для хранения 4 байтов полезных данных. Protocol Buffers, используемый DataStore, хранит ту же информацию в 6-8 байтах. На практике XML-файл SharedPreferences в 3-5 раз больше эквивалентного файла DataStore.

### Multi-process: deprecated и опасный

SharedPreferences имел режим `MODE_MULTI_PROCESS`, позволявший нескольким процессам работать с одним файлом. Этот режим был объявлен deprecated в Android 6.0 (API 23), потому что он никогда не гарантировал корректности. Файл просто перечитывался с диска при каждом обращении, что создавало иллюзию синхронизации, но не защищало от race conditions между процессами. Для приложений с несколькими процессами (например, с Firebase, который использует отдельный процесс для FCM) это означало риск потери данных при каждой конкурентной записи.

> **Мостик:** Мы разобрали, почему SharedPreferences -- проблема. Теперь посмотрим, как Preferences DataStore решает каждую из этих проблем, сохраняя простоту использования.

---

## Preferences DataStore: key-value замена SharedPreferences

Preferences DataStore -- это первый и наиболее простой вариант DataStore. Он предоставляет key-value хранилище, аналогичное SharedPreferences, но с принципиально иной архитектурой: все операции асинхронны, чтение реактивно через Flow, запись атомарна, а ошибки ввода-вывода проходят через стандартный механизм обработки исключений Kotlin. При этом API остаётся компактным и интуитивным -- переход с SharedPreferences на Preferences DataStore не требует переосмысления архитектуры приложения.

### Создание и инициализация

Preferences DataStore создаётся как extension property на `Context`. Важный нюанс: экземпляр DataStore должен быть **singleton** -- один на файл для всего приложения. Создание двух экземпляров для одного файла приведёт к `IllegalStateException`. Это осознанное решение разработчиков: singleton гарантирует координацию всех операций чтения и записи через единую точку. Без этой гарантии DataStore деградировал бы до тех же race conditions, что и SharedPreferences.

Почему именно extension property, а не класс с конструктором? Делегат `preferencesDataStore` решает сразу две проблемы: ленивую инициализацию (DataStore создаётся только при первом обращении, не при запуске приложения) и singleton-гарантию (Kotlin property delegate обеспечивает потокобезопасную однократную инициализацию без ручного double-checked locking).

Следующий код показывает канонический способ создания Preferences DataStore. Делегат `preferencesDataStore` обеспечивает ленивую инициализацию и singleton-гарантию на уровне файла.

```kotlin
// Создание DataStore — один раз на уровне файла
// name = имя файла (без расширения), сохраняется в datastore/
val Context.settingsStore by preferencesDataStore(
    name = "settings"  // Файл: datastore/settings.preferences_pb
)

// Типизированные ключи — compile-time проверка типов
object SettingsKeys {
    val DARK_THEME = booleanPreferencesKey("dark_theme")
    val LANGUAGE = stringPreferencesKey("language")
    val FONT_SIZE = intPreferencesKey("font_size")
}
```

Обратите внимание на типизированные ключи. В отличие от SharedPreferences, где `getString()` и `getInt()` вызываются по строковому ключу (и ничто не мешает вызвать `getInt()` для строкового значения -- результатом будет `ClassCastException` в runtime), Preferences DataStore связывает тип данных с ключом на этапе компиляции. Функция `booleanPreferencesKey("dark_theme")` создаёт объект типа `Preferences.Key<Boolean>`, который гарантирует, что по этому ключу можно записать и прочитать только `Boolean`. Попытка записать строку по этому ключу не скомпилируется. Эта типобезопасность -- прямое следствие использования Kotlin generics вместо Java-стиля API с перегруженными методами.

### Чтение данных через Flow

Чтение из DataStore принципиально отличается от SharedPreferences. Вместо синхронного вызова "дай мне значение прямо сейчас" вы подписываетесь на поток изменений. Каждый раз, когда какой-либо компонент приложения записывает новое значение в DataStore, все подписчики получают обновление автоматически. Это означает, что ваш UI обновится при каждом изменении настройки -- без ручного вызова `invalidate()`, `notifyDataSetChanged()` или callback-механизмов.

Реактивная модель чтения решает важную архитектурную проблему: синхронизацию UI с данными. В SharedPreferences-мире вам нужно было вручную перечитывать настройки при каждом возвращении на экран, регистрировать `OnSharedPreferenceChangeListener` и не забывать его отписывать. В DataStore-мире Flow делает это автоматически и с учётом lifecycle: когда Activity уходит в background, сбор Flow приостанавливается, и resume при возвращении.

Аналогия: SharedPreferences -- это как звонить в справочную каждый раз, когда хочешь узнать погоду. Нужно самому набрать номер, дождаться ответа, записать информацию. DataStore -- это подписка на SMS-рассылку прогноза погоды: новая информация приходит сама, как только появляется, и вам не нужно ничего делать.

Следующий код демонстрирует чтение настроек через Flow с обязательной обработкой ошибок ввода-вывода.

```kotlin
// Чтение — реактивное через Flow
val darkThemeFlow: Flow<Boolean> = context.settingsStore.data
    .catch { exception ->
        // IOException = файл повреждён или диск недоступен
        if (exception is IOException) {
            emit(emptyPreferences()) // Fallback на значения по умолчанию
        } else {
            throw exception          // Другие ошибки пробрасываем
        }
    }
    .map { preferences ->
        preferences[SettingsKeys.DARK_THEME] ?: false // Default = false
    }
```

Блок `catch` -- не опциональная деталь, а обязательный элемент. Без него IOException при повреждении файла обрушит Flow и, следовательно, весь UI-компонент, который его собирает. Стратегия `emit(emptyPreferences())` возвращает значения по умолчанию, позволяя приложению продолжить работу даже при проблемах с диском. Это значительно лучше, чем поведение SharedPreferences, который при повреждении XML-файла просто возвращает пустые данные без уведомления.

### Запись данных

Запись в DataStore выполняется через suspend-функцию `edit()`. Это означает, что вызов должен происходить внутри корутины -- вы физически не сможете вызвать `edit()` на главном потоке без корутинного контекста. Внутри `edit()` вы получаете `MutablePreferences` -- мутабельную копию текущих настроек. Все изменения, сделанные в лямбде, применяются атомарно: либо все записываются на диск, либо ни одно не записывается. Это контрастирует с SharedPreferences, где каждый `putString()` формально независим, и при сбое между двумя вызовами часть данных может быть записана, а часть -- нет.

```kotlin
// Запись — атомарная, через suspend-функцию
suspend fun setDarkTheme(enabled: Boolean) {
    context.settingsStore.edit { preferences ->
        preferences[SettingsKeys.DARK_THEME] = enabled
        // Можно изменить несколько значений — всё атомарно
        preferences[SettingsKeys.FONT_SIZE] = if (enabled) 16 else 14
    }
}
```

Атомарность записи решает проблему race conditions из SharedPreferences. Если два корутина одновременно вызвали `edit()`, DataStore выстроит их в очередь и выполнит последовательно. Каждый корутин увидит актуальное состояние на момент своего выполнения, а не устаревшую копию. Внутри DataStore использует паттерн "read-modify-write": лямбда `edit()` получает текущее состояние, вносит изменения, и результат записывается на диск. Если между чтением и записью другой корутин уже изменил данные, DataStore автоматически перезапустит вашу лямбду с обновлённым состоянием.

### Сравнение API: SharedPreferences vs Preferences DataStore

```
SharedPreferences (синхронный, опасный):
┌──────────────────────────────────────────────┐
│  val prefs = getSharedPreferences("s", 0)    │
│  val theme = prefs.getString("theme", "")    │  ← блокирует UI
│  prefs.edit().putString("theme", "dark")     │
│             .apply()                         │  ← fire-and-forget
└──────────────────────────────────────────────┘

DataStore (асинхронный, безопасный):
┌──────────────────────────────────────────────┐
│  val themeFlow = store.data.map { ... }      │  ← реактивный Flow
│  store.edit { it[KEY] = "dark" }             │  ← suspend + атомарный
│  // Ошибки → catch { }, а не silent fail     │
└──────────────────────────────────────────────┘
```

> **Мостик:** Preferences DataStore отлично работает для простых настроек -- boolean-флагов, строковых значений, числовых параметров. Но что если вам нужно хранить объект с десятком полей и вложенными структурами? Для этого существует Proto DataStore.

---

## Proto DataStore: типизированное хранилище

Proto DataStore -- второй вариант DataStore, предназначенный для хранения структурированных типизированных объектов. Если Preferences DataStore -- это таблица настроек "ключ-значение", похожая на словарь, то Proto DataStore -- это строго определённая схема данных, где каждое поле имеет конкретный тип, а компилятор проверяет корректность обращения к полям. Разница между ними аналогична разнице между HashMap и data class в Kotlin: оба хранят данные, но data class гарантирует структуру.

### Зачем нужен Proto, если есть Preferences

Preferences DataStore имеет фундаментальное ограничение: все данные -- это плоский набор ключей. Нет вложенности, нет гарантии целостности (вы можете записать `language` и забыть `region`, создав невалидное состояние), нет schema evolution (добавление нового поля требует ручного маппинга и проверки "а что если пользователь обновился со старой версии?"). Когда объект имеет больше 5-6 полей, работа с отдельными ключами становится утомительной и подверженной ошибкам.

Представьте настройки приложения для фитнес-трекера: единицы измерения (метрическая/имперская), целевые показатели (шаги, калории, дистанция), настройки уведомлений (утреннее напоминание, вечерний отчёт, достижение цели), параметры синхронизации (Wi-Fi only, частота), внешний вид (тема, размер шрифта, карта/список). Это уже 15-20 полей. В Preferences DataStore каждый из них -- отдельный ключ. Забыли обновить один ключ при изменении связанных настроек? Инвалидное состояние. Опечатались в имени ключа? Runtime ошибка. Proto DataStore решает все эти проблемы через Protocol Buffers.

Аналогия: Preferences DataStore -- это как записывать информацию о пациенте на отдельных стикерах (имя на одном, возраст на другом, группа крови на третьем). Если стикер потерялся или перепутался -- проблема. Proto DataStore -- это медицинская карта: строгая структура, все поля на своих местах, нельзя вписать "рост" в графу "группа крови".

### Protocol Buffers: краткая история

Protocol Buffers (protobuf) были созданы инженерами Google в **2001 году** как внутренний формат обмена данными между сервисами. К тому моменту Google уже столкнулся с ограничениями XML для межсервисного взаимодействия: медленный парсинг, избыточный размер, отсутствие строгой типизации. Внутренняя инфраструктура Google обрабатывала миллиарды запросов в день, и каждый лишний байт и миллисекунда парсинга имели значение. Джефф Дин (Jeff Dean) и Сандживар Гемават (Sanjay Ghemawat) -- легендарные инженеры Google, стоявшие у истоков MapReduce и BigTable -- были среди тех, кто продвигал protobuf как стандарт внутри компании.

В **2008 году** Google опубликовал protobuf как open-source проект. К 2024 году Protocol Buffers стали стандартом де-факто для межсервисного взаимодействия (gRPC, который тоже создан Google, использует protobuf по умолчанию) и используются практически в каждом продукте Google: от Android до YouTube, от Gmail до Google Maps. Protobuf поддерживает кодогенерацию для Java, Kotlin, Python, Go, C++, Rust и множества других языков.

Преимущества protobuf перед JSON и XML: бинарный формат (в 3-10 раз компактнее JSON), быстрый парсинг (в 20-100 раз быстрее XML), строгая типизация (компилятор проверяет типы полей), обратная совместимость при добавлении новых полей (старый код просто игнорирует неизвестные поля). Последний пункт особенно важен для мобильных приложений: пользователи обновляют приложение неравномерно, и формат данных должен оставаться совместимым между версиями.

### Создание .proto файла

Для Proto DataStore вы создаёте файл с расширением `.proto`, описывающий структуру ваших данных. Этот файл -- контракт, который гарантирует типобезопасность и обратную совместимость. Файл размещается в директории `app/src/main/proto/` и компилируется Gradle-плагином `protobuf` в Java/Kotlin-классы.

Следующий пример показывает определение настроек пользователя в формате Protocol Buffers. Каждое поле имеет тип и уникальный номер -- номер используется для бинарной сериализации и не должен меняться после публикации. Если вам нужно удалить поле, его номер "резервируется" ключевым словом `reserved`, чтобы не быть случайно переиспользованным.

```proto
// файл: app/src/main/proto/user_settings.proto
syntax = "proto3";

option java_package = "com.example.app";
option java_multiple_files = true;

message UserSettings {
  bool dark_theme = 1;          // Номера полей НЕ менять после релиза
  string language = 2;
  int32 font_size = 3;
  NotificationSettings notifications = 4;  // Вложенный объект
}

message NotificationSettings {
  bool enabled = 1;
  bool sound = 2;
  bool vibration = 3;
}
```

Обратите внимание на вложенный объект `NotificationSettings`. В Preferences DataStore такую структуру пришлось бы "расплющивать" в плоские ключи (`notification_enabled`, `notification_sound`, `notification_vibration`), теряя логическую группировку. В Proto DataStore иерархия данных сохраняется естественным образом. Кроме того, protobuf позволяет добавлять новые поля в будущих версиях без нарушения совместимости: если старая версия приложения встретит поле с неизвестным номером, она просто проигнорирует его.

### Serializer: мост между объектами и байтами

Для работы Proto DataStore необходим Serializer -- класс, который умеет превращать ваш protobuf-объект в массив байтов (для записи на диск) и обратно (для чтения). Serializer выполняет три функции: определяет значение по умолчанию (когда файл ещё не создан), десериализует данные из потока байтов в типизированный объект и сериализует объект обратно в поток байтов. Это паттерн, знакомый разработчикам, работавшим с Java Serializable, но более безопасный и производительный.

```kotlin
// Serializer — преобразует объект <-> байты
object UserSettingsSerializer : Serializer<UserSettings> {
    override val defaultValue: UserSettings =
        UserSettings.getDefaultInstance() // Protobuf default values

    override suspend fun readFrom(input: InputStream): UserSettings =
        try {
            UserSettings.parseFrom(input)  // Десериализация из байтов
        } catch (e: InvalidProtocolBufferException) {
            throw CorruptionException("Cannot read proto", e)
        }

    override suspend fun writeTo(t: UserSettings, output: OutputStream) =
        t.writeTo(output)  // Сериализация в байты
}
```

Метод `readFrom()` оборачивает ошибку парсинга в `CorruptionException`. Это важно: DataStore перехватывает `CorruptionException` и может запустить восстановление данных (например, удалить повреждённый файл и начать с defaultValue). Без этой обёртки повреждение файла приведёт к необработанному исключению, которое обрушит приложение. Стратегия "сбросить до значений по умолчанию при повреждении" лучше, чем "упасть и не запускаться", хотя для критичных данных стоит добавить backup-механизм.

### Чтение и запись Proto DataStore

API чтения и записи Proto DataStore аналогичен Preferences DataStore, но вместо работы с ключами вы работаете с типизированным объектом. Компилятор гарантирует, что вы не обратитесь к несуществующему полю и не запишете строку вместо числа. Вместо `edit()` используется `updateData()`, а вместо `MutablePreferences` -- builder-паттерн protobuf.

```kotlin
// Чтение — типизированный Flow
val settingsFlow: Flow<UserSettings> = userSettingsStore.data

// Запись — через updateData с типизированным builder
suspend fun enableDarkTheme() {
    userSettingsStore.updateData { currentSettings ->
        currentSettings.toBuilder()
            .setDarkTheme(true)        // Compile-time проверка типа
            .setFontSize(16)           // Тип гарантирован: int32
            .build()
    }
}
```

Метод `updateData()` работает аналогично `edit()` из Preferences DataStore: получает текущее состояние, позволяет внести изменения и записывает результат атомарно. Builder-паттерн protobuf гарантирует, что вы не сможете создать невалидный объект -- все поля инициализируются значениями по умолчанию (false для boolean, 0 для int, пустая строка для string), и изменить можно только существующие поля.

### Когда выбрать Proto вместо Preferences

| Критерий | Preferences DataStore | Proto DataStore |
|----------|----------------------|-----------------|
| Количество полей | 1-5 | 6+ |
| Вложенные объекты | Невозможно | Естественно |
| Schema evolution | Ручной маппинг | Автоматическая совместимость |
| Настройка проекта | Минимальная | Нужен protobuf plugin + .proto файл |
| Типобезопасность | Ключи типизированы | Полный объект типизирован |
| Размер файла | Больше (текстовый формат) | Меньше (бинарный protobuf) |

**Правило большого пальца:** если ваши настройки помещаются в 5 строк `SharedPreferences.Editor`, используйте Preferences DataStore. Если настроек больше, есть вложенные объекты или нужна гарантия schema evolution -- Proto DataStore. Дополнительная сложность настройки проекта (protobuf plugin, .proto файл) окупается при первом же добавлении нового поля -- вам не нужно писать код миграции, protobuf делает это автоматически.

> **Мостик:** Мы разобрали оба варианта DataStore с точки зрения пользователя. Теперь заглянем внутрь: как DataStore обеспечивает атомарность, координацию и устойчивость к ошибкам на уровне файловой системы.

---

## DataStore internals: как это работает внутри

Понимание внутреннего устройства DataStore помогает в двух практических ситуациях: при отладке (почему данные не обновились? почему произошла CorruptionException?) и при проектировании (сколько DataStore экземпляров можно создать без потери производительности? что произойдёт при конкурентной записи?). Знание internals превращает DataStore из "чёрного ящика" в прозрачный механизм, поведение которого вы можете предсказывать.

### File-based storage: один файл -- один DataStore

DataStore хранит данные в одном файле на диске. Preferences DataStore использует формат Protocol Buffers (несмотря на название "Preferences" -- это не XML и не JSON, что удивляет многих разработчиков). Proto DataStore также использует Protocol Buffers. Файлы располагаются в директории `datastore/` внутри приватной директории приложения:

```
/data/data/com.example.app/
    └── files/
        └── datastore/
            ├── settings.preferences_pb    ← Preferences DataStore
            └── user_settings.pb           ← Proto DataStore
```

Каждый файл полностью перезаписывается при каждой операции записи. DataStore не поддерживает частичные обновления -- это осознанное решение, упрощающее гарантию атомарности. Для типичных настроек (десятки-сотни байтов) полная перезапись быстрее, чем поиск и обновление конкретного фрагмента файла. Но именно поэтому DataStore не подходит для больших объёмов данных -- перезаписывать мегабайтный файл при каждом изменении одного флага неэффективно.

### Atomic writes: запись через переименование

Атомарность записи -- ключевое преимущество DataStore над SharedPreferences. Механизм основан на фундаментальном свойстве файловых систем Linux: операция `rename()` атомарна. Это означает, что переименование файла -- мгновенная операция на уровне файловой системы, которая либо полностью завершается, либо не происходит вовсе. Даже при внезапном отключении питания файл не окажется в промежуточном состоянии.

Алгоритм записи работает так:

1. DataStore создаёт временный файл (`settings.preferences_pb.tmp`)
2. Записывает все данные в временный файл
3. Вызывает `fsync()` -- системный вызов, который гарантирует, что данные из буфера ядра записаны на физический диск
4. Атомарно переименовывает временный файл в основной (`rename()`)

Если приложение "упадёт" или устройство перезагрузится на шагах 2-3, временный файл будет либо неполным, либо отсутствовать. При следующем запуске DataStore обнаружит, что основной файл не повреждён (он не был тронут), и продолжит работу с последними корректно сохранёнными данными.

```
Безопасная запись (DataStore):
┌──────────────────────────────────────────────────┐
│ 1. Создать temp file                             │
│ 2. Записать данные → temp file                   │
│ 3. fsync() — данные физически на диске            │
│ 4. rename(temp → original) — АТОМАРНО            │
│                                                  │
│ Если crash на шаге 2-3: temp file удаляется,     │
│ original file не тронут → данные целы             │
└──────────────────────────────────────────────────┘

Опасная запись (SharedPreferences):
┌──────────────────────────────────────────────────┐
│ 1. Открыть original file                         │
│ 2. Записать данные → original file               │
│ 3. Если crash на шаге 2: файл повреждён,         │
│    данные потеряны, восстановление невозможно     │
└──────────────────────────────────────────────────┘
```

Аналогия: представьте, что вы редактируете важный документ в текстовом редакторе. SharedPreferences -- это редактирование оригинала напрямую: если компьютер выключится посреди записи, документ будет частично обновлён и повреждён. DataStore -- это функция "Сохранить как" в Word: вы сначала записываете новую версию в отдельный файл, проверяете что запись прошла успешно, а потом мгновенно заменяете старый файл новым. Если что-то пойдёт не так -- старый файл по-прежнему цел.

### Координация через последовательный dispatcher

Внутри DataStore все операции записи проходят через один координатор -- класс `SingleProcessDataStore`. Он использует `Mutex` из kotlinx.coroutines и однопоточный dispatcher для гарантии последовательного выполнения. Когда два корутина одновременно вызывают `edit()`, второй ждёт завершения первого. Это устраняет race conditions на архитектурном уровне: вместо того чтобы требовать от разработчиков ручной синхронизации, DataStore делает её автоматически.

Важно понимать, что последовательное выполнение означает, что запись в DataStore -- не параллельная операция. Если вы вызываете `edit()` из 10 корутин одновременно, они будут выполнены последовательно, одна за другой. Для типичного приложения это незаметно (настройки меняются редко), но для высокочастотных записей это может стать узким местом. Именно для таких сценариев существует MMKV, который рассмотрен далее.

Именно поэтому критически важно иметь **один экземпляр DataStore на файл**. Если создать два экземпляра для одного файла, каждый будет иметь свой Mutex и свой координатор. Они не знают друг о друге и начнут перезаписывать изменения друг друга -- та же проблема race conditions, что и в SharedPreferences, только теперь с иллюзией безопасности.

### Почему нельзя два экземпляра на файл

Если вы случайно создадите два `DataStore` для одного файла, последствия зависят от версии библиотеки. В ранних версиях это приводило к `CorruptionException` и потере данных -- два координатора перезаписывали файл поочерёдно, и один из них читал частично записанные данные другого. В современных версиях DataStore проверяет, существует ли уже активный экземпляр для данного файла, и выбрасывает `IllegalStateException` с сообщением "There are multiple DataStores active for the same file". Это "fast fail" -- лучше упасть сразу с понятным сообщением, чем молча портить данные часами.

> **Мостик:** Теперь, когда мы понимаем внутреннее устройство DataStore, разберём практический сценарий, с которым сталкивается каждый Android-разработчик -- миграция с SharedPreferences.

---

## Миграция с SharedPreferences

Большинство Android-приложений, написанных до 2021 года, используют SharedPreferences. Переход на DataStore не означает "удали SharedPreferences и перепиши всё". Google предоставляет встроенный механизм миграции, который переносит данные автоматически и безопасно. Правильная миграция -- это невидимый для пользователя процесс: обновление приложения, все настройки на месте, никаких потерь.

### Принцип миграции

Миграция работает по принципу "один раз и навсегда". При первом обращении к DataStore (а именно при первом `collect()` или `first()` на `data` Flow) DataStore проверяет, существует ли файл SharedPreferences с указанным именем. Если существует -- читает все значения, переносит их в DataStore и **удаляет** файл SharedPreferences. При последующих запусках миграция не выполняется, потому что файл SharedPreferences уже удалён. Весь процесс происходит до того, как Flow эмитит первое значение, поэтому вызывающий код не замечает разницы -- он всегда работает с DataStore API.

Аналогия: это как переезд из старой квартиры в новую. Вы упаковываете вещи (читаете SharedPreferences), перевозите (записываете в DataStore), проверяете что ничего не забыли (валидация), и сдаёте ключи от старой квартиры (удаляете SP файл). Повторный "переезд" невозможен -- квартира уже сдана. Но если по какой-то причине перевозка не завершилась (crash посреди миграции), старая квартира остаётся нетронутой -- DataStore удаляет SP файл только после успешной записи в собственный файл.

### Пошаговая реализация

Следующий код показывает миграцию SharedPreferences с именем "app_settings" в Preferences DataStore. Обратите внимание на параметр `produceMigrations` -- именно он запускает процесс переноса данных. Миграция ленивая: она выполняется не при создании делегата, а при первом обращении к данным.

```kotlin
// Миграция — автоматическая, одноразовая
val Context.settingsStore by preferencesDataStore(
    name = "settings",
    produceMigrations = { context ->
        listOf(
            SharedPreferencesMigration(
                context = context,
                sharedPreferencesName = "app_settings" // Имя SP файла
                // keysToMigrate — если null, мигрирует ВСЕ ключи
            )
        )
    }
)
```

После первого запуска файл `shared_prefs/app_settings.xml` будет удалён. Все данные окажутся в `datastore/settings.preferences_pb`. Процесс атомарен: если приложение упадёт посреди миграции, при следующем запуске DataStore обнаружит, что SP файл всё ещё существует, и повторит миграцию.

### Маппинг ключей при миграции

Если имена ключей в SharedPreferences отличаются от желаемых ключей в DataStore (например, вы хотите переименовать `isDarkMode` в `dark_theme`), можно выполнить маппинг через параметр `migrate` в конструкторе `SharedPreferencesMigration`. Это полезно для очистки исторического багажа: переименования ключей с неудачными именами, удаления устаревших настроек, которые больше не используются, преобразования типов (например, строковый "true"/"false" в boolean).

Важно помнить, что маппинг -- это одноразовая операция. Если вы допустили ошибку в маппинге и выпустили обновление, исправить её будет сложно: SP файл уже удалён, а DataStore содержит некорректные данные. Поэтому миграцию необходимо тщательно тестировать.

### Тестирование миграции

Миграция -- критический путь. Ошибка в миграции означает потерю настроек у всех пользователей при обновлении приложения. Это один из тех редких сценариев, где автоматические тесты не просто желательны, а обязательны. Рекомендуется создать инструментальный тест (androidTest), который:

1. Записывает тестовые данные в SharedPreferences с известными значениями
2. Создаёт DataStore с миграцией
3. Читает данные из DataStore и проверяет корректность каждого поля
4. Проверяет, что файл SharedPreferences удалён
5. Повторно обращается к DataStore и проверяет, что миграция не выполняется повторно

Для Proto DataStore миграция требует дополнительного параметра `produceMigrations` с маппингом ключей SharedPreferences на поля protobuf-объекта. Это более трудоёмко, но и более безопасно -- компилятор проверит типы при маппинге.

> **Мостик:** DataStore решает проблемы SharedPreferences через асинхронный API и атомарные записи. Но это не единственная альтернатива на рынке. Рассмотрим MMKV -- решение от Tencent, которое выбирает принципиально другой технический путь.

---

## MMKV как альтернатива

MMKV (Memory Mapped Key-Value) -- это библиотека от Tencent (создатели WeChat, крупнейшего мессенджера Китая с более чем миллиардом пользователей), опубликованная в open-source в 2018 году. Если DataStore решает проблемы SharedPreferences через асинхронный API и координацию корутин, то MMKV решает их через memory-mapped файлы -- принципиально иной механизм записи данных на уровне операционной системы.

### Как работает MMKV

Обычная запись на диск проходит через несколько уровней абстракции: приложение вызывает `write()`, данные попадают в системный буфер ядра (page cache), ядро периодически сбрасывает буфер на физический диск. Каждый переход между уровнями -- потенциальная задержка и точка отказа. MMKV использует системный вызов `mmap()` (memory map), который "отображает" файл прямо в адресное пространство процесса. Запись в memory-mapped файл -- это запись в оперативную память, а операционная система берёт на себя синхронизацию с диском в фоновом режиме, прозрачно для приложения.

Для приложения это означает, что запись в MMKV по скорости сопоставима с записью в обычную переменную в памяти. Результат: запись в MMKV в **10-100 раз быстрее**, чем в SharedPreferences, и в **3-10 раз быстрее**, чем в DataStore. MMKV также безопасен для multi-process из коробки -- несколько процессов могут читать и писать в один файл без блокировок и race conditions, что невозможно ни в SharedPreferences, ни в стандартном SingleProcessDataStore.

### Когда использовать MMKV

MMKV оптимален для сценариев с высокочастотной записью, где DataStore становится узким местом из-за последовательного выполнения операций. Типичные примеры: аналитические события (записываются при каждом действии пользователя -- нажатие кнопки, скролл, открытие экрана), позиция прокрутки (сохраняется при каждом скролле для восстановления при возврате на экран), промежуточные состояния игры (позиция персонажа, текущий уровень, набранные очки), real-time метрики и логи.

### Когда НЕ использовать MMKV

Для обычных пользовательских настроек (тема, язык, уведомления) MMKV -- overkill. DataStore проще в использовании, является частью официального Android Jetpack, имеет лучшую документацию и интеграцию с Compose, ViewModel и другими Jetpack-компонентами. Если ваше приложение записывает настройки 5-10 раз за сессию, разница в производительности между DataStore и MMKV незаметна -- обе операции займут единицы миллисекунд. MMKV также добавляет native-зависимость (.so файл), что увеличивает размер APK и усложняет отладку.

| Критерий | DataStore | MMKV |
|----------|-----------|------|
| Производительность записи | Средняя (файл + fsync) | Очень высокая (mmap) |
| Официальная поддержка Google | Да (Jetpack) | Нет (Tencent) |
| Реактивное чтение (Flow) | Из коробки | Нужен wrapper |
| Multi-process | Нет (single process) | Да |
| Типизация (Proto) | Есть | Нет |
| Размер библиотеки | ~100 KB | ~1 MB (native .so) |
| Документация/сообщество | Большое (Google) | Среднее |

**Правило выбора:** начинайте с DataStore. Переходите на MMKV только если профилирование показало, что запись данных -- узкое место производительности.

---

## EncryptedSharedPreferences: безопасное хранение

Некоторые данные требуют шифрования: API-токены, пользовательские credentials, чувствительные настройки (PIN-коды, биометрические флаги). Хранить их в открытом виде -- в DataStore или SharedPreferences -- небезопасно: на rooted-устройстве злоумышленник может прочитать приватные файлы приложения. Для этого существует `EncryptedSharedPreferences` из библиотеки AndroidX Security, построенной поверх криптографической библиотеки Google Tink.

### Как работает шифрование

EncryptedSharedPreferences оборачивает обычный SharedPreferences и шифрует как ключи, так и значения перед записью на диск. Используются два алгоритма: **AES256-SIV** для ключей (детерминированное шифрование -- один и тот же ключ всегда шифруется одинаково, что позволяет искать по ключу без расшифровки всех записей) и **AES256-GCM** для значений (аутентифицированное шифрование -- гарантирует не только конфиденциальность, но и целостность данных, то есть невозможность их подмены).

Шифрование выполняется с помощью MasterKey -- главного ключа, который хранится в Android Keystore. Keystore -- это аппаратное (на устройствах с Secure Element или TEE) или программное хранилище криптографических ключей, защищённое операционной системой. Ключ из Keystore нельзя извлечь даже с root-доступом -- операции шифрования выполняются внутри защищённой области, а приложение получает только результат.

Следующий код демонстрирует создание EncryptedSharedPreferences с MasterKey. API остаётся идентичным обычному SharedPreferences, шифрование полностью прозрачно для вызывающего кода.

```kotlin
// MasterKey — ключ шифрования в Android Keystore
val masterKey = MasterKey.Builder(context)
    .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
    .build()

// EncryptedSharedPreferences — API идентичен обычным SP
val securePrefs = EncryptedSharedPreferences.create(
    context, "secure_prefs", masterKey,
    EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
    EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
)
// Использование: securePrefs.edit().putString("token", jwt).apply()
```

Под капотом EncryptedSharedPreferences создаёт обычный XML-файл, но содержимое зашифровано. Даже на rooted-устройстве злоумышленник увидит только набор случайных байтов вместо читаемых ключей и значений.

### Ограничения EncryptedSharedPreferences

Есть три существенных ограничения, которые важно учитывать при выборе этого инструмента. Во-первых, шифрование и дешифрование занимают вычислительное время -- EncryptedSharedPreferences в 2-5 раз медленнее обычных SharedPreferences, что делает их непригодными для высокочастотных операций. Во-вторых, API остаётся синхронным (это всё ещё SharedPreferences под капотом), поэтому проблемы блокировки UI при чтении никуда не делись -- для чувствительных данных, к которым нужен асинхронный доступ, придётся оборачивать вызовы в корутины вручную. В-третьих, на момент 2026 года **не существует** официальной DataStore-версии с шифрованием -- Google пока не выпустил EncryptedDataStore, хотя сообщество активно просит эту функциональность.

Для шифрования файлов (не key-value) используйте `EncryptedFile` из той же библиотеки AndroidX Security. Для хранения криптографических ключей и сертификатов -- Android Keystore напрямую через `KeyStore` API.

> **Мостик:** Мы рассмотрели все варианты хранения настроек в Android. Теперь разберём типичные ошибки, которые допускают разработчики при работе с DataStore, и как их избежать.

---

## Распространённые ошибки

### 1. Несколько экземпляров DataStore для одного файла

Самая частая и самая опасная ошибка. Если `preferencesDataStore()` вызван дважды для одного имени файла (например, в двух разных Activity или в двух разных модулях проекта), DataStore не сможет координировать записи. Результат: `IllegalStateException` в лучшем случае или потеря данных в худшем. Эту ошибку легко допустить в крупном проекте, где несколько разработчиков работают над разными модулями и не знают о существующих DataStore-экземплярах.

**Решение:** всегда объявляйте DataStore как extension property на `Context` в top-level файле одного модуля. Делегат `by preferencesDataStore(name = "settings")` гарантирует единственный экземпляр на уровне процесса. В проектах с DI-фреймворком (Hilt, Koin) создавайте DataStore в DI-модуле как singleton.

### 2. Блокирующее чтение через runBlocking

Некоторые разработчики, привыкшие к синхронному API SharedPreferences, оборачивают Flow DataStore в `runBlocking { dataStore.data.first() }`. Это уничтожает главное преимущество DataStore -- асинхронность -- и снова создаёт риск ANR. Особенно часто эту ошибку можно встретить в `Application.onCreate()`, где разработчик хочет "быстро прочитать" настройки до создания первого Activity.

**Решение:** используйте `Flow.collect()` в корутине или `stateIn()` для преобразования Flow в StateFlow в ViewModel. Если блокирующее чтение действительно необходимо (например, в `ContentProvider.onCreate()`, который не поддерживает корутины), используйте `runBlocking` осознанно и только вне главного потока.

### 3. Забытый catch для IOException

Без обработки `IOException` в операторе `catch` повреждение файла DataStore или недоступность диска обрушит Flow. Все UI-компоненты, подписанные на этот Flow, перестанут получать обновления, и экран "замёрзнет" на последнем известном состоянии. Хуже того, исключение может "всплыть" до CoroutineExceptionHandler и обрушить всё приложение.

**Решение:** всегда добавляйте `.catch { if (it is IOException) emit(emptyPreferences()) else throw it }` перед `.map {}`. Рассмотрите также логирование IOException для мониторинга здоровья хранилища на устройствах пользователей.

### 4. DataStore внутри Activity

Если привязать DataStore к `Activity.applicationContext`, проблем не будет -- applicationContext живёт столько же, сколько процесс. Но если случайно привязать к самой Activity (без `.applicationContext`), при каждом повороте экрана Activity пересоздаётся, а вместе с ней -- потенциально и DataStore-экземпляр, что может привести к конфликтам при параллельном существовании старого и нового экземпляра.

**Решение:** всегда используйте `applicationContext` или, ещё лучше, внедряйте DataStore через DI-фреймворк (Hilt, Koin) как singleton с привязкой к application scope.

### 5. Хранение больших объектов

DataStore предназначен для небольших данных -- настройки, токены, флаги, пользовательские предпочтения. Хранение объектов размером более 1 MB приведёт к заметным задержкам при каждой операции, потому что весь файл перезаписывается целиком при каждом `edit()`. Если в DataStore хранится 2 MB данных и вы изменяете один boolean-флаг, DataStore запишет все 2 MB заново.

**Решение:** для больших объектов используйте Room (структурированные данные с запросами) или файловое хранилище (бинарные данные, JSON-кэш). DataStore оптимален для объёмов до 100 KB.

---

## Распространённые заблуждения

| Заблуждение | Реальность |
|-------------|-----------|
| "DataStore шифрует данные" | Нет. DataStore хранит данные в открытом виде на диске. Любой пользователь с root-доступом может прочитать файл. Для шифрования используйте EncryptedSharedPreferences или собственную обёртку с AndroidX Security |
| "SharedPreferences больше нельзя использовать" | SharedPreferences не deprecated -- Google не объявил их устаревшими. Для legacy-кода, который уже стабильно работает, замена не обязательна. Но для нового кода Google рекомендует DataStore |
| "Proto DataStore быстрее Preferences DataStore" | Оба используют один и тот же механизм записи (temp file + rename). Proto компактнее на диске (бинарный формат), но разница в скорости чтения/записи незаметна для типичных настроек объёмом в сотни байтов |
| "DataStore работает в multi-process" | Стандартный SingleProcessDataStore НЕ поддерживает multi-process. Существует экспериментальный MultiProcessDataStore, но он менее стабилен и не рекомендуется для production без тщательного тестирования |
| "DataStore заменяет Room для малых данных" | DataStore -- для настроек (key-value или типизированные объекты). Room -- для структурированных данных с SQL-запросами, связями и индексами. Даже если данных мало, если нужны запросы -- используйте Room |
| "Чем больше DataStore файлов, тем лучше" | Каждый DataStore = файл + координатор + корутина + Mutex. 2-3 файла -- норма (настройки, кэш, пользовательские данные). 20 файлов -- перерасход ресурсов. Группируйте логически связанные настройки в один DataStore |
| "runBlocking с DataStore -- это нормально" | runBlocking блокирует текущий поток до завершения корутины. На главном потоке это вызывает ANR -- ту же проблему, от которой DataStore должен был избавить. Допустимо только в тестах и в редких случаях вне UI-потока |

---

## Подводные камни

### Первое чтение после установки

При самом первом обращении к DataStore (после установки приложения) файл ещё не существует на диске. DataStore возвращает `defaultValue` -- пустые Preferences или defaultInstance для Proto. Если ваш код не обрабатывает случай "нет сохранённых данных" и предполагает, что значения всегда присутствуют, UI может показать некорректное состояние. Например, если язык приложения определяется настройкой из DataStore, а при первом запуске DataStore возвращает пустую строку -- приложение может упасть или показать пустой экран. Всегда определяйте разумные значения по умолчанию через оператор Elvis (`?:`) при чтении.

### Миграция и обновления приложения

Миграция с SharedPreferences выполняется один раз и привязана к наличию SP-файла на диске. Если пользователь обновляет приложение с версии 1 (SharedPreferences) на версию 3 (DataStore), а миграция была добавлена в версии 2, всё работает корректно -- DataStore просто проверяет наличие SP файла, независимо от истории обновлений. Но если файл SharedPreferences был удалён вручную (например, пользователь нажал "Очистить данные" в настройках Android между обновлениями), миграция не произойдёт и пользовательские настройки будут потеряны -- DataStore начнёт с defaultValue.

### Конкурентная запись из разных корутин

DataStore гарантирует последовательное выполнение `edit()` операций -- каждая следующая увидит результат предыдущей. Но если ваша бизнес-логика зависит от конкретного порядка записей из разных корутин (например, "сначала записать токен, потом записать флаг авторизации"), DataStore **не гарантирует** этот порядок -- он гарантирует только атомарность и изоляцию каждой отдельной записи. Для гарантии порядка используйте один корутин, `Mutex` на уровне репозитория, или объедините обе записи в один `edit()` вызов.

### Производительность на старых устройствах

DataStore использует Protocol Buffers и Kotlin Coroutines, которые добавляют overhead по памяти (примерно 500 KB для библиотек protobuf и coroutines). На устройствах с 1 GB RAM и Android 5.0 (которые всё ещё составляют значительную часть рынка в развивающихся странах) это может быть заметно. Для таких устройств SharedPreferences (при аккуратном использовании) или MMKV могут быть лучшим выбором с точки зрения потребления памяти.

---

## Связь с другими темами

**[[android-data-persistence]]** -- обзорный материал по всем способам хранения данных в Android: Room, DataStore, файловое хранилище, ContentProvider. Рекомендуется прочитать до текущего материала для понимания общей картины -- когда использовать DataStore, а когда Room или файлы. Текущий материал углубляет раздел DataStore из обзорной статьи, добавляя историю, internals, миграцию и альтернативы.

**[[android-room-deep-dive]]** -- Room и DataStore решают разные задачи, но часто используются вместе в одном приложении. Room хранит структурированные данные (пользователи, заказы, сообщения), DataStore хранит настройки (тема, язык, токены). Понимание обоих инструментов необходимо для проектирования слоя данных (data layer) в Android-приложении. Типичный паттерн: Room для основных данных + DataStore для пользовательских предпочтений.

**[[android-permissions-security]]** -- раздел EncryptedSharedPreferences из текущего материала непосредственно связан с темой безопасности Android. Хранение токенов и credentials требует не только шифрования, но и понимания модели разрешений Android: какие файлы доступны другим приложениям, как работает Scoped Storage, зачем нужен Android Keystore. Рекомендуется изучать безопасность параллельно с persistence.

**[[kotlin-coroutines]]** -- весь API DataStore построен на suspend-функциях. Метод `edit()` -- это suspend-функция. Координация записей происходит через `Mutex` из kotlinx.coroutines. Без понимания structured concurrency, dispatchers и exception handling в корутинах невозможно правильно использовать DataStore. Изучайте корутины до или параллельно с DataStore.

**[[kotlin-flow]]** -- чтение из DataStore возвращает `Flow<Preferences>` или `Flow<T>` для Proto. Операторы `map`, `catch`, `distinctUntilChanged`, `combine` -- рабочие инструменты при работе с DataStore. Без понимания холодных потоков (cold flows), операторов терминации и backpressure вы не сможете эффективно интегрировать DataStore с ViewModel и Compose. Особенно важен оператор `catch` -- без него приложение уязвимо к IOException.

---

## Источники и дальнейшее чтение

- **Meier, R. (2022).** *Professional Android.* -- Глава о DataStore содержит сравнение с SharedPreferences, примеры миграции и рекомендации по архитектуре слоя данных. Один из немногих печатных источников, покрывающих DataStore на production-уровне с учётом реальных edge cases.

- **Phillips, B. et al. (2022).** *Android Programming: The Big Nerd Ranch Guide.* -- Пошаговое руководство по переходу с SharedPreferences на DataStore. Хорош для первого знакомства, но менее глубок в части Proto DataStore и internals. Рекомендуется для начинающих.

- **Google.** *Protocol Buffers Documentation.* -- Официальная документация формата protobuf: синтаксис .proto файлов, правила обратной совместимости, best practices. Необходимо для работы с Proto DataStore и понимания ограничений формата.

- **Android Developers.** *DataStore Guide.* -- Официальная документация Google по DataStore: setup, Preferences и Proto варианты, миграция, тестирование. Первый источник при возникновении вопросов по API. Содержит codelabs для практики.

- **Sathyanarayana, R. (2020).** *Prefer Storing Data with Jetpack DataStore* (Android Developers Blog). -- Оригинальный анонс DataStore от инженера Google. Объясняет мотивацию создания библиотеки и ключевые design decisions: почему Flow, почему protobuf, почему не просто починить SharedPreferences.

---

*Создано: 2026-02-11 | На основе официальной документации Android Jetpack и Professional Android (Meier, 2022)*

---

## Проверь себя

> [!question]- Почему DataStore безопаснее SharedPreferences для concurrent access?
> SharedPreferences: apply() асинхронный, но может блокировать UI при вызове из Service (IPC). getAll() синхронный на Main Thread -- ANR при большом файле. Data corruption при concurrent write из разных процессов. DataStore: Coroutines (non-blocking), single writer с Mutex, atomic file operations, Flow для reads.

> [!question]- Сценарий: нужно хранить пользовательские настройки с 20 полями разных типов. Preferences DataStore или Proto DataStore?
> Proto DataStore: 1) Type-safe (protobuf schema). 2) Валидация при компиляции. 3) Один atomic объект вместо 20 отдельных ключей. 4) Default values в schema. Preferences DataStore подходит для простых случаев (3-5 key-value). Для 20+ полей Proto обеспечивает лучшую типизацию и maintainability.


---

## Ключевые карточки

Какие типы DataStore есть?
?
Preferences DataStore: key-value без schema (аналог SharedPreferences). Proto DataStore: typed data с protobuf schema. Оба: Coroutines, Flow, atomic operations. Proto безопаснее для сложных данных.

Как читать/писать в Preferences DataStore?
?
Read: dataStore.data.map { prefs -> prefs[KEY] }. Write: dataStore.edit { prefs -> prefs[KEY] = value }. KEY = stringPreferencesKey('name'). Всё async через Coroutines. Flow для reactive updates.

Как мигрировать с SharedPreferences на DataStore?
?
PreferencesMigration: DataStoreFactory.create(migrations = listOf(SharedPreferencesMigration(context, 'prefs_name'))). Автоматически переносит данные при первом чтении. SharedPreferences файл удаляется после миграции.

Что такое Proto DataStore?
?
DataStore с protobuf schema. Определяете .proto файл с message. Serializer конвертирует proto в/из InputStream. Type-safe access: dataStore.data.map { it.userName }. Компиляция .proto генерирует Kotlin/Java классы.

Как DataStore обрабатывает ошибки?
?
dataStore.data может emit IOException. Обработка: .catch { if (it is IOException) emit(defaults) }. При ошибке записи: edit{} бросает exception. Atomic: неудачная запись не ломает файл (write to temp, rename).


---

## Куда дальше

| Направление | Куда | Зачем |
|-------------|------|-------|
| Следующий шаг | [[android-networking]] | Networking для удаленных данных |
| Углубиться | [[android-data-persistence]] | Обзор всех механизмов хранения |
| Смежная тема | [[ios-data-persistence]] | Data persistence в iOS: UserDefaults и Core Data |
| Обзор | [[android-overview]] | Вернуться к карте раздела |

