---
title: "iOS Compilation Pipeline: от Swift до .app"
created: 2026-01-11
modified: 2026-02-13
type: deep-dive
reading_time: 108
difficulty: 6
study_status: not_started
mastery: 0
last_reviewed:
next_review:
status: published
tags:
  - type/deep-dive
  - topic/ios
  - topic/compilation
  - level/intermediate
related:
  - "[[android-compilation-pipeline]]"
  - "[[compilation-pipeline]]"
  - "[[native-compilation-llvm]]"
prerequisites:
  - "[[ios-overview]]"
  - "[[ios-xcode-fundamentals]]"
---

# iOS Compilation Pipeline: от Swift до .app

## TL;DR

Компиляция iOS-приложения — это многоэтапный процесс превращения Swift-кода в машинный код через несколько промежуточных представлений (AST → SIL → LLVM IR → Machine Code). Понимание этого процесса критически важно для отладки странных ошибок компиляции, оптимизации времени сборки и понимания производительности приложения. Финальный результат — App Bundle (.app), содержащий исполняемый файл, ресурсы и метаданные.

---

## Зачем это нужно?

### Практическая польза понимания компиляции

**Отладка ошибок компиляции:**
- Понимание, на каком этапе возникла ошибка (парсинг, type checking, linking)
- Расшифровка криптических сообщений компилятора
- Диагностика "expression too complex" через понимание type inference

**Оптимизация времени сборки:**
- Правильная настройка Whole Module Optimization
- Понимание incremental compilation
- Оптимизация структуры модулей

**Оптимизация производительности:**
- Понимание inline-оптимизаций
- Знание, какой код генерируется для generics
- ARC-оптимизации на уровне SIL

**Code signing и distribution:**
- Понимание структуры App Bundle
- Диагностика проблем с подписью
- Отладка проблем App Store

---

## Аналогии из жизни

### Кулинарная аналогия компиляции

```
┌─────────────────────────────────────────────────────────────────────┐
│                    КУЛИНАРНАЯ АНАЛОГИЯ                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Swift файл = Рецепт на русском языке                               │
│  ┌───────────────────────────────────────┐                          │
│  │ "Взять 200г муки, добавить 2 яйца,    │                          │
│  │  замесить тесто, выпекать 30 минут"   │                          │
│  └───────────────────────────────────────┘                          │
│                    │                                                │
│                    ▼                                                │
│  SIL = Рецепт на универсальном кулинарном языке                     │
│  ┌───────────────────────────────────────┐                          │
│  │ INGREDIENT flour: 200g                │                          │
│  │ INGREDIENT eggs: 2 units              │                          │
│  │ ACTION mix(flour, eggs) -> dough      │                          │
│  │ ACTION bake(dough, 30min) -> result   │                          │
│  └───────────────────────────────────────┘                          │
│                    │                                                │
│                    ▼                                                │
│  LLVM IR = Пошаговые инструкции для любой кухни                     │
│  ┌───────────────────────────────────────┐                          │
│  │ 1. Открыть контейнер с мукой          │                          │
│  │ 2. Взять мерный стакан                │                          │
│  │ 3. Отмерить 200г                      │                          │
│  │ 4. Высыпать в миску                   │                          │
│  │ ...                                   │                          │
│  └───────────────────────────────────────┘                          │
│                    │                                                │
│                    ▼                                                │
│  Machine Code = Готовое блюдо для конкретной плиты (arm64)          │
│  ┌───────────────────────────────────────┐                          │
│  │ Инструкции для плиты Samsung:         │                          │
│  │ "Режим 3, мощность 180°C, таймер 30"  │                          │
│  │ (Для плиты LG были бы другие команды) │                          │
│  └───────────────────────────────────────┘                          │
│                    │                                                │
│                    ▼                                                │
│  App Bundle = Упакованный обед с контейнерами и приборами           │
│  ┌───────────────────────────────────────┐                          │
│  │ 📦 Коробка с:                         │                          │
│  │   🍽️ Само блюдо (executable)          │                          │
│  │   🥄 Приборы (frameworks)             │                          │
│  │   📋 Инструкция по разогреву (plist)  │                          │
│  │   🖼️ Фото блюда (assets)              │                          │
│  │   ✅ Сертификат качества (signature)  │                          │
│  └───────────────────────────────────────┘                          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Почему нужны промежуточные этапы?

1. **Swift файл → SIL**: Как перевод рецепта с национального языка на международный кулинарный стандарт. Позволяет применять универсальные оптимизации.

2. **SIL → LLVM IR**: Как разбиение "замесить тесто" на атомарные действия. Каждый шаг настолько простой, что его может выполнить любой.

3. **LLVM IR → Machine Code**: Как адаптация инструкций под конкретное оборудование. "Включи духовку" превращается в конкретные кнопки для конкретной модели.

4. **Machine Code → App Bundle**: Как упаковка готового обеда. Еда + контейнеры + приборы + инструкция + сертификат.

---

## Этапы компиляции

### Полная схема pipeline

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        iOS COMPILATION PIPELINE                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────────┐                                                            │
│  │ Source Code  │  .swift файлы                                              │
│  │  (Swift)     │                                                            │
│  └──────┬───────┘                                                            │
│         │                                                                    │
│         ▼                                                                    │
│  ┌──────────────┐                                                            │
│  │   Lexer      │  Разбивает код на токены                                   │
│  │  (Tokenizer) │  let, func, class, {, }, =, ...                            │
│  └──────┬───────┘                                                            │
│         │                                                                    │
│         ▼                                                                    │
│  ┌──────────────┐                                                            │
│  │   Parser     │  Строит синтаксическое дерево                              │
│  │              │  Проверяет грамматику                                      │
│  └──────┬───────┘                                                            │
│         │                                                                    │
│         ▼                                                                    │
│  ┌──────────────┐                                                            │
│  │     AST      │  Abstract Syntax Tree                                      │
│  │              │  Структурированное представление кода                      │
│  └──────┬───────┘                                                            │
│         │                                                                    │
│         ▼                                                                    │
│  ┌──────────────┐                                                            │
│  │  Semantic    │  Type Checking                                             │
│  │  Analysis    │  Type Inference                                            │
│  │              │  Name Resolution                                           │
│  └──────┬───────┘                                                            │
│         │                                                                    │
│         ▼                                                                    │
│  ┌──────────────┐     ┌─────────────────────────────────────────────┐        │
│  │   SILGen     │────▶│  Raw SIL (Swift Intermediate Language)      │        │
│  │              │     │  - Высокоуровневое представление            │        │
│  └──────┬───────┘     │  - Swift-специфичные оптимизации            │        │
│         │             └─────────────────────────────────────────────┘        │
│         ▼                                                                    │
│  ┌──────────────┐     ┌─────────────────────────────────────────────┐        │
│  │    SIL       │────▶│  Canonical SIL                              │        │
│  │ Optimizer    │     │  - ARC оптимизации                          │        │
│  │              │     │  - Девиртуализация                          │        │
│  └──────┬───────┘     │  - Inlining                                 │        │
│         │             │  - Generic specialization                   │        │
│         ▼             └─────────────────────────────────────────────┘        │
│  ┌──────────────┐                                                            │
│  │   IRGen      │  Генерация LLVM IR                                         │
│  │              │                                                            │
│  └──────┬───────┘                                                            │
│         │                                                                    │
│         ▼                                                                    │
│  ┌──────────────┐     ┌─────────────────────────────────────────────┐        │
│  │   LLVM IR    │────▶│  Платформо-независимое представление        │        │
│  │              │     │  - SSA форма                                │        │
│  └──────┬───────┘     │  - Типизированные инструкции                │        │
│         │             └─────────────────────────────────────────────┘        │
│         ▼                                                                    │
│  ┌──────────────┐                                                            │
│  │    LLVM      │  Оптимизации уровня LLVM                                   │
│  │  Optimizer   │  - Dead code elimination                                   │
│  │              │  - Loop unrolling                                          │
│  │              │  - Vectorization                                           │
│  └──────┬───────┘                                                            │
│         │                                                                    │
│         ▼                                                                    │
│  ┌──────────────┐                                                            │
│  │    Code      │  Генерация машинного кода                                  │
│  │  Generator   │  arm64, arm64e, x86_64 (симулятор)                         │
│  └──────┬───────┘                                                            │
│         │                                                                    │
│         ▼                                                                    │
│  ┌──────────────┐                                                            │
│  │   Object     │  .o файлы                                                  │
│  │   Files      │  Объектный код                                             │
│  └──────┬───────┘                                                            │
│         │                                                                    │
│         ▼                                                                    │
│  ┌──────────────┐                                                            │
│  │   Linker     │  Связывание объектных файлов                               │
│  │    (ld64)    │  + Системные библиотеки                                    │
│  │              │  + Frameworks                                              │
│  └──────┬───────┘                                                            │
│         │                                                                    │
│         ▼                                                                    │
│  ┌──────────────┐                                                            │
│  │  Executable  │  Mach-O бинарник                                           │
│  │              │                                                            │
│  └──────┬───────┘                                                            │
│         │                                                                    │
│         ▼                                                                    │
│  ┌──────────────┐                                                            │
│  │ App Bundle   │  .app директория                                           │
│  │  Packaging   │  + Info.plist                                              │
│  │              │  + Assets                                                  │
│  │              │  + Frameworks                                              │
│  └──────┬───────┘                                                            │
│         │                                                                    │
│         ▼                                                                    │
│  ┌──────────────┐                                                            │
│  │    Code      │  Подпись приложения                                        │
│  │   Signing    │  + Entitlements                                            │
│  │              │  + Provisioning Profile                                    │
│  └──────────────┘                                                            │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Детальное описание каждого этапа

#### 1. Lexing (Токенизация)

```swift
// Исходный код
let count = 42

// После лексера (токены):
// [KEYWORD: let] [IDENTIFIER: count] [OPERATOR: =] [INTEGER: 42]
```

#### 2. Parsing → AST

```
                    ┌─────────────────┐
                    │ VariableDecl    │
                    │   name: count   │
                    │   type: inferred│
                    └────────┬────────┘
                             │
                    ┌────────▼────────┐
                    │ IntegerLiteral  │
                    │   value: 42     │
                    └─────────────────┘
```

#### 3. Semantic Analysis

```
Проверки:
├── Type Checking: Int совместим с контекстом?
├── Type Inference: count : Int (выведен)
├── Name Resolution: count уникален в scope?
├── Access Control: private/public корректен?
└── Generic Constraints: T соответствует протоколу?
```

#### 4. SIL Generation

```
// Swift код
func add(_ a: Int, _ b: Int) -> Int {
    return a + b
}

// SIL (упрощённо)
sil @add : $@convention(thin) (Int, Int) -> Int {
bb0(%0 : $Int, %1 : $Int):
  %2 = struct_extract %0 : $Int, #Int._value
  %3 = struct_extract %1 : $Int, #Int._value
  %4 = builtin "add_Int64"(%2 : $Builtin.Int64, %3 : $Builtin.Int64)
  %5 = struct $Int (%4 : $Builtin.Int64)
  return %5 : $Int
}
```

#### 5. SIL Optimization

```
Оптимизации на уровне SIL:
├── ARC Optimization
│   └── Удаление лишних retain/release
├── Devirtualization
│   └── Замена динамических вызовов статическими
├── Generic Specialization
│   └── Создание специализированных версий для конкретных типов
├── Inlining
│   └── Встраивание тел функций
└── Escape Analysis
    └── Оптимизация аллокаций (stack vs heap)
```

#### 6. LLVM IR Generation

```llvm
; LLVM IR для функции add
define i64 @add(i64 %0, i64 %1) {
entry:
  %2 = add i64 %0, %1
  ret i64 %2
}
```

#### 7. Machine Code Generation

```asm
; ARM64 assembly
_add:
    add x0, x0, x1
    ret
```

---

## Swift Compiler (swiftc)

### Архитектура компилятора

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          SWIFT COMPILER ARCHITECTURE                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                           FRONTEND                                      │ │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │ │
│  │  │  Lexer   │─▶│  Parser  │─▶│   Sema   │─▶│  SILGen  │─▶│ SIL Opt  │  │ │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │ │
│  │                                                                         │ │
│  │  Задачи:                                                                │ │
│  │  • Парсинг Swift-синтаксиса                                             │ │
│  │  • Type checking и type inference                                       │ │
│  │  • Swift-специфичные оптимизации                                        │ │
│  │  • Генерация диагностик (ошибок и warnings)                             │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                      │                                       │
│                                      ▼                                       │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                            BACKEND                                      │ │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐               │ │
│  │  │  IRGen   │─▶│ LLVM Opt │─▶│ CodeGen  │─▶│  Object  │               │ │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘               │ │
│  │                                                                         │ │
│  │  Задачи:                                                                │ │
│  │  • Преобразование SIL → LLVM IR                                         │ │
│  │  • Платформо-независимые оптимизации                                    │ │
│  │  • Генерация машинного кода                                             │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Whole Module Optimization (WMO)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    WHOLE MODULE OPTIMIZATION                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  БЕЗ WMO (File-by-file):                                                     │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐                                       │
│  │ File1.o │  │ File2.o │  │ File3.o │  Каждый файл компилируется            │
│  └────┬────┘  └────┬────┘  └────┬────┘  независимо                           │
│       │            │            │                                            │
│       └────────────┼────────────┘                                            │
│                    ▼                                                         │
│              ┌──────────┐                                                    │
│              │  Linker  │  Оптимизации между файлами невозможны              │
│              └──────────┘                                                    │
│                                                                              │
│  ────────────────────────────────────────────────────────────────────────── │
│                                                                              │
│  С WMO:                                                                      │
│  ┌─────────────────────────────────────┐                                     │
│  │  File1.swift + File2.swift + File3  │  Все файлы анализируются вместе    │
│  └─────────────────┬───────────────────┘                                     │
│                    ▼                                                         │
│  ┌─────────────────────────────────────┐                                     │
│  │       SIL для всего модуля          │                                     │
│  │  • Cross-file inlining              │                                     │
│  │  • Девиртуализация internal методов │                                     │
│  │  • Dead code elimination            │                                     │
│  └─────────────────┬───────────────────┘                                     │
│                    ▼                                                         │
│              ┌──────────┐                                                    │
│              │ Module.o │  Один оптимизированный объектный файл              │
│              └──────────┘                                                    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Включение WMO:**
```
// Build Settings
SWIFT_COMPILATION_MODE = wholemodule

// Или в командной строке
swiftc -whole-module-optimization
```

### Incremental Compilation

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      INCREMENTAL COMPILATION                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Первая сборка:                                                              │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐                                       │
│  │ File1.o │  │ File2.o │  │ File3.o │  Все файлы компилируются              │
│  │ (new)   │  │ (new)   │  │ (new)   │                                       │
│  └─────────┘  └─────────┘  └─────────┘                                       │
│       +            +            +                                            │
│  ┌─────────────────────────────────────┐                                     │
│  │     Dependency Graph (.swiftdeps)   │  Сохраняется граф зависимостей      │
│  └─────────────────────────────────────┘                                     │
│                                                                              │
│  Повторная сборка (изменён только File2):                                    │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐                                       │
│  │ File1.o │  │ File2.o │  │ File3.o │                                       │
│  │ (cached)│  │ (REBUILD)│ │ (check) │                                       │
│  └─────────┘  └─────────┘  └─────────┘                                       │
│                    │                                                         │
│                    ▼                                                         │
│  Анализ зависимостей:                                                        │
│  • File1 не зависит от изменённых типов → пропустить                         │
│  • File3 использует функцию из File2, но сигнатура не изменилась → пропустить│
│                                                                              │
│  Результат: перекомпилирован только File2                                    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Флаги компилятора для отладки

```bash
# Просмотр AST
swiftc -dump-ast source.swift

# Просмотр Raw SIL (до оптимизаций)
swiftc -emit-silgen source.swift

# Просмотр Canonical SIL (после оптимизаций)
swiftc -emit-sil source.swift

# Просмотр LLVM IR
swiftc -emit-ir source.swift

# Просмотр ассемблера
swiftc -emit-assembly source.swift

# Просмотр времени компиляции по фазам
swiftc -Xfrontend -debug-time-compilation source.swift

# Предупреждения о долгих type-check выражениях
swiftc -Xfrontend -warn-long-expression-type-checking=100 source.swift
```

### Пример вывода SIL

```swift
// Исходный код
class Counter {
    var value = 0

    func increment() {
        value += 1
    }
}
```

```
// SIL (упрощённо)
sil_vtable Counter {
  #Counter.value!getter: @Counter.value.getter
  #Counter.value!setter: @Counter.value.setter
  #Counter.increment: @Counter.increment
}

sil @Counter.increment : $@convention(method) (@guaranteed Counter) -> () {
bb0(%0 : $Counter):
  %1 = ref_element_addr %0 : $Counter, #Counter.value
  %2 = begin_access [modify] %1 : $*Int
  %3 = load %2 : $*Int
  %4 = integer_literal $Builtin.Int64, 1
  %5 = struct_extract %3 : $Int, #Int._value
  %6 = builtin "add_Int64"(%5, %4)
  %7 = struct $Int (%6)
  store %7 to %2 : $*Int
  end_access %2 : $*Int
  return
}
```

---

## LLVM в iOS

### Что такое LLVM

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              LLVM ARCHITECTURE                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  LLVM = Low Level Virtual Machine (исторически)                              │
│       = Compiler Infrastructure (современное понимание)                      │
│                                                                              │
│  ┌────────────┐    ┌────────────┐    ┌────────────┐                          │
│  │   Swift    │    │    C/C++   │    │    Rust    │   Языки-источники        │
│  └─────┬──────┘    └─────┬──────┘    └─────┬──────┘                          │
│        │                 │                 │                                 │
│        ▼                 ▼                 ▼                                 │
│  ┌────────────┐    ┌────────────┐    ┌────────────┐                          │
│  │Swift Front│    │   Clang    │    │   rustc    │   Фронтенды               │
│  └─────┬──────┘    └─────┬──────┘    └─────┬──────┘                          │
│        │                 │                 │                                 │
│        └────────────────┬┴─────────────────┘                                 │
│                         ▼                                                    │
│               ┌─────────────────┐                                            │
│               │    LLVM IR      │  Универсальное промежуточное               │
│               │                 │  представление                             │
│               └────────┬────────┘                                            │
│                        │                                                     │
│                        ▼                                                     │
│               ┌─────────────────┐                                            │
│               │  LLVM Optimizer │  Платформо-независимые оптимизации         │
│               └────────┬────────┘                                            │
│                        │                                                     │
│        ┌───────────────┼───────────────┐                                     │
│        ▼               ▼               ▼                                     │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐                                │
│  │  arm64   │    │  x86_64  │    │  wasm    │   Целевые платформы            │
│  └──────────┘    └──────────┘    └──────────┘                                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Преимущества LLVM

1. **Модульность**: Фронтенды и бэкенды независимы
2. **Оптимизации**: Единый набор мощных оптимизаций для всех языков
3. **Расширяемость**: Легко добавить новый язык или платформу
4. **Производительность**: Годы работы над оптимизациями

### Bitcode (историческая справка)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    BITCODE (2015-2023, deprecated)                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Концепция:                                                                  │
│  ┌──────────────┐                                                            │
│  │ App + Bitcode│ ────▶ App Store ────▶ Перекомпиляция для новых устройств  │
│  └──────────────┘                                                            │
│                                                                              │
│  Как работало:                                                               │
│  1. Разработчик отправляет LLVM Bitcode вместо машинного кода                │
│  2. Apple перекомпилирует для каждой архитектуры                             │
│  3. Пользователь получает оптимизированный бинарник                          │
│                                                                              │
│  Почему deprecated (Xcode 14+):                                              │
│  • Все iOS устройства теперь arm64                                           │
│  • Усложняло отладку (символы не совпадали)                                  │
│  • Проблемы с reproducible builds                                            │
│  • Увеличивало размер отправляемого архива                                   │
│                                                                              │
│  Текущее состояние:                                                          │
│  • Xcode 14+: Bitcode удалён                                                 │
│  • watchOS: тоже не требует                                                  │
│  • Отправляется готовый машинный код                                         │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### arm64 vs arm64e

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         ARM64 ARCHITECTURE VARIANTS                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  arm64 (AArch64):                                                            │
│  ├── Базовая 64-bit ARM архитектура                                          │
│  ├── Все iPhone 5s и новее                                                   │
│  ├── Все iPad Air и новее                                                    │
│  └── Apple Silicon Mac (M1/M2/M3)                                            │
│                                                                              │
│  arm64e (Enhanced):                                                          │
│  ├── arm64 + Pointer Authentication (PAC)                                    │
│  ├── A12 Bionic и новее (iPhone XS+)                                         │
│  ├── Защита от атак ROP/JOP                                                  │
│  └── Используется системой, не для App Store                                 │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │                    POINTER AUTHENTICATION                                ││
│  │                                                                          ││
│  │  Обычный указатель (arm64):                                              ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │ 0x00000001 8B3C4000                                               │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  │                                                                          ││
│  │  Подписанный указатель (arm64e):                                         ││
│  │  ┌──────────────┬─────────────────────────────────────────────────────┐  ││
│  │  │  PAC (16bit) │ 0x00000001 8B3C4000                                │  ││
│  │  └──────────────┴─────────────────────────────────────────────────────┘  ││
│  │                                                                          ││
│  │  При вызове функции проверяется подпись указателя                        ││
│  │  Если изменён → SIGBUS/crash (защита от эксплойтов)                      ││
│  │                                                                          ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  Для разработчика:                                                           │
│  • App Store принимает только arm64                                          │
│  • arm64e используется только для системных фреймворков                      │
│  • Симулятор использует x86_64 (Intel Mac) или arm64 (Apple Silicon)         │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## App Bundle Structure

### Полная структура .app

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APP BUNDLE STRUCTURE                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  MyApp.app/                                                                  │
│  ├── MyApp                          # Executable (Mach-O binary)             │
│  ├── Info.plist                     # Bundle metadata                        │
│  ├── PkgInfo                        # Package type (APPL????)                │
│  │                                                                           │
│  ├── Assets.car                     # Compiled asset catalog                 │
│  │   ├── App icons                                                           │
│  │   ├── Image sets                                                          │
│  │   ├── Colors                                                              │
│  │   └── Data assets                                                         │
│  │                                                                           │
│  ├── Base.lproj/                    # Base localization                      │
│  │   ├── Main.storyboard           # (compiled to .storyboardc)              │
│  │   └── LaunchScreen.storyboard                                             │
│  │                                                                           │
│  ├── en.lproj/                      # English localization                   │
│  │   ├── Localizable.strings                                                 │
│  │   └── InfoPlist.strings                                                   │
│  │                                                                           │
│  ├── ru.lproj/                      # Russian localization                   │
│  │   ├── Localizable.strings                                                 │
│  │   └── InfoPlist.strings                                                   │
│  │                                                                           │
│  ├── Frameworks/                    # Embedded frameworks                    │
│  │   ├── MyFramework.framework                                               │
│  │   │   ├── MyFramework            # Framework executable                   │
│  │   │   ├── Info.plist                                                      │
│  │   │   └── _CodeSignature/                                                 │
│  │   └── SwiftUI.framework          # (если не стандартный)                  │
│  │                                                                           │
│  ├── PlugIns/                       # App extensions                         │
│  │   ├── WidgetExtension.appex                                               │
│  │   └── NotificationExtension.appex                                         │
│  │                                                                           │
│  ├── _CodeSignature/                # Code signature                         │
│  │   └── CodeResources             # Resource hashes                         │
│  │                                                                           │
│  ├── embedded.mobileprovision       # Provisioning profile                   │
│  │                                                                           │
│  └── [Other resources]                                                       │
│      ├── *.json                     # Data files                             │
│      ├── *.pdf                      # Vector graphics                        │
│      └── *.mlmodelc                 # Compiled ML models                     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Детальное описание компонентов

#### Info.plist

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN">
<plist version="1.0">
<dict>
    <!-- Идентификация -->
    <key>CFBundleIdentifier</key>
    <string>com.company.MyApp</string>

    <key>CFBundleName</key>
    <string>MyApp</string>

    <key>CFBundleDisplayName</key>
    <string>My Awesome App</string>

    <!-- Версии -->
    <key>CFBundleShortVersionString</key>
    <string>1.0.0</string>

    <key>CFBundleVersion</key>
    <string>42</string>

    <!-- Executable -->
    <key>CFBundleExecutable</key>
    <string>MyApp</string>

    <!-- UI Configuration -->
    <key>UILaunchStoryboardName</key>
    <string>LaunchScreen</string>

    <key>UISupportedInterfaceOrientations</key>
    <array>
        <string>UIInterfaceOrientationPortrait</string>
    </array>

    <!-- Capabilities -->
    <key>NSCameraUsageDescription</key>
    <string>Нужен доступ к камере для сканирования</string>

    <!-- Required device capabilities -->
    <key>UIRequiredDeviceCapabilities</key>
    <array>
        <string>arm64</string>
    </array>
</dict>
</plist>
```

#### Executable (Mach-O)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           MACH-O FILE FORMAT                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                         MACH-O HEADER                               │    │
│  │  • Magic number (0xFEEDFACF for 64-bit)                             │    │
│  │  • CPU type (arm64)                                                 │    │
│  │  • File type (executable, dylib, bundle)                            │    │
│  │  • Number of load commands                                          │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                        LOAD COMMANDS                                │    │
│  │  • LC_SEGMENT_64: __TEXT, __DATA, __LINKEDIT                        │    │
│  │  • LC_DYLD_INFO: Dynamic linker info                                │    │
│  │  • LC_SYMTAB: Symbol table                                          │    │
│  │  • LC_LOAD_DYLIB: Linked frameworks                                 │    │
│  │  • LC_CODE_SIGNATURE: Code signature                                │    │
│  │  • LC_ENCRYPTION_INFO: App Store encryption                         │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                          SEGMENTS                                   │    │
│  │                                                                     │    │
│  │  __TEXT (read-only, executable)                                     │    │
│  │  ├── __text: Machine code                                           │    │
│  │  ├── __stubs: Symbol stubs                                          │    │
│  │  ├── __cstring: C strings                                           │    │
│  │  └── __swift5_types: Swift metadata                                 │    │
│  │                                                                     │    │
│  │  __DATA (read-write)                                                │    │
│  │  ├── __data: Initialized data                                       │    │
│  │  ├── __bss: Uninitialized data                                      │    │
│  │  ├── __objc_classlist: ObjC class references                        │    │
│  │  └── __swift5_proto: Swift protocol conformances                    │    │
│  │                                                                     │    │
│  │  __LINKEDIT (read-only)                                             │    │
│  │  ├── Symbol table                                                   │    │
│  │  ├── String table                                                   │    │
│  │  └── Code signature                                                 │    │
│  │                                                                     │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Просмотр Mach-O:**
```bash
# Общая информация
otool -hv MyApp.app/MyApp

# Load commands
otool -l MyApp.app/MyApp

# Linked libraries
otool -L MyApp.app/MyApp

# Symbols
nm MyApp.app/MyApp
```

#### Assets.car (Asset Catalog)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         ASSET CATALOG COMPILATION                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  До компиляции (в проекте):                                                  │
│                                                                              │
│  Assets.xcassets/                                                            │
│  ├── AppIcon.appiconset/                                                     │
│  │   ├── Contents.json                                                       │
│  │   ├── icon-60@2x.png                                                      │
│  │   └── icon-60@3x.png                                                      │
│  ├── Logo.imageset/                                                          │
│  │   ├── Contents.json                                                       │
│  │   ├── logo@2x.png                                                         │
│  │   └── logo@3x.png                                                         │
│  └── AccentColor.colorset/                                                   │
│      └── Contents.json                                                       │
│                                                                              │
│                         │                                                    │
│                         ▼  actool (Asset Catalog Tool)                       │
│                                                                              │
│  После компиляции (в .app):                                                  │
│                                                                              │
│  Assets.car (бинарный формат)                                                │
│  • Оптимизированные изображения                                              │
│  • Device-specific variants                                                  │
│  • Сжатие и slicing                                                          │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### _CodeSignature

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           CODE SIGNATURE                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  _CodeSignature/                                                             │
│  └── CodeResources        # XML plist с хешами ресурсов                      │
│                                                                              │
│  Структура CodeResources:                                                    │
│  <dict>                                                                      │
│    <key>files2</key>                                                         │
│    <dict>                                                                    │
│      <key>Assets.car</key>                                                   │
│      <dict>                                                                  │
│        <key>hash2</key>                                                      │
│        <data>BASE64_HASH</data>                                              │
│      </dict>                                                                 │
│      <key>Info.plist</key>                                                   │
│      <dict>                                                                  │
│        <key>hash2</key>                                                      │
│        <data>BASE64_HASH</data>                                              │
│      </dict>                                                                 │
│      ...                                                                     │
│    </dict>                                                                   │
│  </dict>                                                                     │
│                                                                              │
│  Подпись включает:                                                           │
│  • Хеши всех ресурсов                                                        │
│  • Сертификат разработчика                                                   │
│  • Entitlements                                                              │
│  • Team ID                                                                   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Проверка подписи:**
```bash
# Verify signature
codesign -vvv MyApp.app

# Show signature details
codesign -dv --verbose=4 MyApp.app

# Show entitlements
codesign -d --entitlements :- MyApp.app
```

---

## Распространённые ошибки

### 1. Игнорирование времени компиляции

```
❌ НЕПРАВИЛЬНО: Сложные type inference выражения

let result = array
    .filter { $0.isValid }
    .map { $0.transform() }
    .flatMap { $0.children }
    .reduce(into: [:]) { dict, item in
        dict[item.key, default: []].append(item.value)
    }

// Компилятор тратит много времени на вывод типов
```

```
✅ ПРАВИЛЬНО: Явные типы в сложных цепочках

let filtered: [Item] = array.filter { $0.isValid }
let transformed: [TransformedItem] = filtered.map { $0.transform() }
let children: [Child] = transformed.flatMap { $0.children }
let result: [String: [Value]] = children.reduce(into: [:]) { dict, item in
    dict[item.key, default: []].append(item.value)
}

// Или разбить на отдельные let с явными типами
```

### 2. Неправильная структура модулей

```
❌ НЕПРАВИЛЬНО: Один огромный модуль

MyApp/
├── Sources/           # 500 файлов в одном таргете
│   ├── Feature1/
│   ├── Feature2/
│   ├── Feature3/
│   └── ...
└── MyApp.xcodeproj

// WMO работает долго, incremental compilation неэффективна
```

```
✅ ПРАВИЛЬНО: Модульная архитектура

MyApp/
├── App/               # Точка входа
├── Core/              # Отдельный framework
├── Feature1/          # Отдельный framework
├── Feature2/          # Отдельный framework
└── Package.swift      # SPM или xcworkspace

// Каждый модуль компилируется независимо
// Изменения в Feature1 не требуют перекомпиляции Feature2
```

### 3. Непонимание access control и WMO

```
❌ НЕПРАВИЛЬНО: Всё public без необходимости

public class DataManager {
    public var cache: [String: Any] = [:]

    public func fetchData() { ... }
    public func processData() { ... }  // Используется только внутри модуля
}

// Компилятор не может инлайнить, девиртуализировать
```

```
✅ ПРАВИЛЬНО: Минимально необходимый access level

public class DataManager {
    private var cache: [String: Any] = [:]

    public func fetchData() { ... }
    internal func processData() { ... }  // Или private
}

// WMO может оптимизировать internal/private методы
// Девиртуализация, инлайнинг возможны
```

### 4. Избыточные dynamic dispatch

```
❌ НЕПРАВИЛЬНО: Ненужный @objc и dynamic

class ViewModel: ObservableObject {
    @objc dynamic var title: String = ""  // Зачем?

    @objc dynamic func loadData() {       // ObjC runtime не нужен
        // ...
    }
}

// Лишний dynamic dispatch, невозможна оптимизация
```

```
✅ ПРАВИЛЬНО: Использовать только когда необходимо

class ViewModel: ObservableObject {
    @Published var title: String = ""

    func loadData() {
        // ...
    }
}

// @objc только для: KVO, Selectors, ObjC interop
// dynamic только для: Runtime swizzling, KVO в особых случаях
```

### 5. Неправильная работа с generics

```
❌ НЕПРАВИЛЬНО: Неспециализируемые generics

protocol DataProcessor {
    associatedtype Input
    associatedtype Output
    func process(_ input: Input) -> Output
}

func processAll<P: DataProcessor>(items: [P.Input], processor: P) -> [P.Output] {
    items.map { processor.process($0) }
}

// Каждый вызов через witness table (медленно)
```

```
✅ ПРАВИЛЬНО: Помогаем компилятору специализировать

@inlinable
func processAll<P: DataProcessor>(items: [P.Input], processor: P) -> [P.Output] {
    items.map { processor.process($0) }
}

// Или конкретные типы там, где важна производительность
func processInts(items: [Int], processor: IntProcessor) -> [String] {
    items.map { processor.process($0) }
}

// @inlinable позволяет специализацию в модуле-потребителе
```

### 6. Игнорирование App Thinning

```
❌ НЕПРАВИЛЬНО: Все ресурсы в bundle без оптимизации

Resources/
├── background.png        # 5MB, один размер
├── icon.png              # 1MB, не в Asset Catalog
└── data.json             # 10MB, не сжат

// Огромный размер приложения для всех устройств
```

```
✅ ПРАВИЛЬНО: Использование Asset Catalog и On-Demand Resources

Assets.xcassets/
├── Background.imageset/
│   ├── background@2x.png    # Для iPhone 8
│   └── background@3x.png    # Для iPhone 15
├── Icon.appiconset/
│   └── [все размеры]
└── Contents.json

// On-Demand Resources для больших данных
// App Thinning автоматически выбирает нужные ресурсы
```

---

## Ментальные модели

### 1. Модель "Конвейерная лента"

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         МОДЕЛЬ "КОНВЕЙЕРНАЯ ЛЕНТА"                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Компиляция = конвейер на заводе                                             │
│                                                                              │
│  ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐        │
│  │ Станция │──▶│ Станция │──▶│ Станция │──▶│ Станция │──▶│ Станция │        │
│  │    1    │   │    2    │   │    3    │   │    4    │   │    5    │        │
│  └─────────┘   └─────────┘   └─────────┘   └─────────┘   └─────────┘        │
│   Parsing       Sema         SIL Gen      Optimization   CodeGen            │
│                                                                              │
│  Ключевые идеи:                                                              │
│                                                                              │
│  1. Каждая станция имеет свой "формат" входа и выхода                        │
│     Parser понимает текст → выдаёт AST                                       │
│     SILGen понимает AST → выдаёт SIL                                         │
│                                                                              │
│  2. Ошибка на станции останавливает конвейер                                 │
│     Синтаксическая ошибка → Parser не может продолжить                       │
│     Type error → Sema не пропускает дальше                                   │
│                                                                              │
│  3. Оптимизации могут откатывать на предыдущую станцию                       │
│     WMO видит весь поток → может реорганизовать                              │
│                                                                              │
│  4. Финальный продукт = сумма работы всех станций                            │
│     Если любая станция работает плохо → плохой результат                     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2. Модель "Матрёшка абстракций"

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       МОДЕЛЬ "МАТРЁШКА АБСТРАКЦИЙ"                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Каждый уровень компиляции = снятие слоя абстракции                          │
│                                                                              │
│         ┌───────────────────────────────────────────────────┐                │
│         │  Swift: Высокоуровневые концепции                 │                │
│         │  class, protocol, async, Optional, generics       │                │
│         │    ┌───────────────────────────────────────────┐  │                │
│         │    │  SIL: Swift-специфичная семантика         │  │                │
│         │    │  retain, release, vtable, witness_method   │  │                │
│         │    │    ┌───────────────────────────────────┐  │  │                │
│         │    │    │  LLVM IR: Типизированные операции │  │  │                │
│         │    │    │  add, load, store, call, branch   │  │  │                │
│         │    │    │    ┌───────────────────────────┐  │  │  │                │
│         │    │    │    │  Machine Code: Биты       │  │  │  │                │
│         │    │    │    │  mov, add, bl, ret        │  │  │  │                │
│         │    │    │    └───────────────────────────┘  │  │  │                │
│         │    │    └───────────────────────────────────┘  │  │                │
│         │    └───────────────────────────────────────────┘  │                │
│         └───────────────────────────────────────────────────┘                │
│                                                                              │
│  Ключевые идеи:                                                              │
│                                                                              │
│  1. Каждый уровень проще предыдущего                                         │
│     Swift Optional → SIL enum проверка → IR ветвление → ARM branch           │
│                                                                              │
│  2. Информация теряется при спуске                                           │
│     На уровне IR нет понятия "protocol"                                      │
│     На уровне machine code нет понятия "тип"                                 │
│                                                                              │
│  3. Отладка легче на высоких уровнях                                         │
│     Поэтому dSYM содержит маппинг machine code → Swift                       │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3. Модель "Translator Chain"

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       МОДЕЛЬ "ЦЕПОЧКА ПЕРЕВОДЧИКОВ"                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Компиляция = последовательный перевод между языками                         │
│                                                                              │
│  Русский → Английский → Китайский → Корейский                                │
│  Swift   → SIL        → LLVM IR   → Machine Code                             │
│                                                                              │
│  Каждый переводчик:                                                          │
│  • Идеально знает два "языка" (вход и выход)                                 │
│  • Может улучшить текст при переводе (оптимизации)                           │
│  • Должен сохранить смысл (семантику)                                        │
│                                                                              │
│  Почему не напрямую Swift → Machine Code?                                    │
│                                                                              │
│  1. Сложность: один "супер-переводчик" слишком сложен                        │
│                                                                              │
│  2. Повторное использование:                                                 │
│     LLVM IR → Machine Code используется для многих языков                    │
│     Rust, C++, Swift делят один бэкенд                                       │
│                                                                              │
│  3. Специализация оптимизаций:                                               │
│     SIL: ARC-оптимизации (Swift-специфично)                                  │
│     LLVM: Vectorization (универсально)                                       │
│                                                                              │
│  4. Тестируемость:                                                           │
│     Можно проверить каждый переход отдельно                                  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4. Модель "Сборка LEGO"

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          МОДЕЛЬ "СБОРКА LEGO"                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  App Bundle = собранная модель LEGO                                          │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                                                                     │    │
│  │   📦 Коробка (App Bundle)                                           │    │
│  │   │                                                                 │    │
│  │   ├── 📋 Инструкция (Info.plist)                                    │    │
│  │   │   "Это модель космического корабля, 8+"                         │    │
│  │   │                                                                 │    │
│  │   ├── 🧱 Основная конструкция (Executable)                          │    │
│  │   │   Все детали спаяны вместе                                      │    │
│  │   │                                                                 │    │
│  │   ├── 🎨 Наклейки и декор (Assets)                                  │    │
│  │   │   Можно заменить без пересборки                                 │    │
│  │   │                                                                 │    │
│  │   ├── 🔧 Дополнительные механизмы (Frameworks)                      │    │
│  │   │   Переиспользуемые компоненты                                   │    │
│  │   │                                                                 │    │
│  │   └── ✅ Сертификат качества (Code Signature)                       │    │
│  │       "Собрано на официальной фабрике"                              │    │
│  │                                                                     │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  Ключевые идеи:                                                              │
│                                                                              │
│  1. Финальный bundle не редактируем                                          │
│     Изменение любой части → нужна пересборка + переподпись                   │
│                                                                              │
│  2. Модульность важна                                                        │
│     Frameworks = готовые подсборки                                           │
│     Можно обновить framework, не пересобирая всё                             │
│                                                                              │
│  3. Сертификат критичен                                                      │
│     Без подписи iOS не запустит приложение                                   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5. Модель "Оптимизация на каждом уровне"

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    МОДЕЛЬ "МНОГОУРОВНЕВАЯ ОПТИМИЗАЦИЯ"                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Разные оптимизации эффективны на разных уровнях                             │
│                                                                              │
│  SWIFT LEVEL:                                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ • @inlinable - разрешить инлайнинг между модулями                   │    │
│  │ • final class - запретить наследование → статический dispatch       │    │
│  │ • Copy-on-Write контейнеры                                          │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  SIL LEVEL:                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ • ARC optimization - удаление лишних retain/release                 │    │
│  │ • Devirtualization - замена виртуальных вызовов прямыми             │    │
│  │ • Generic specialization - создание версий для конкретных типов     │    │
│  │ • Stack promotion - аллокация на стеке вместо кучи                  │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  LLVM LEVEL:                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ • Dead code elimination - удаление недостижимого кода               │    │
│  │ • Loop unrolling - развёртывание циклов                             │    │
│  │ • Vectorization - SIMD инструкции                                   │    │
│  │ • Constant folding - вычисление констант во время компиляции        │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  MACHINE LEVEL:                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ • Register allocation - эффективное использование регистров         │    │
│  │ • Instruction scheduling - оптимальный порядок инструкций           │    │
│  │ • Peephole optimization - локальные улучшения                       │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  Правило: чем выше уровень, тем больше информации для оптимизации            │
│  На уровне Swift компилятор знает о generics, на уровне IR — нет             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

## Связь с другими темами

**[[android-compilation-pipeline]]** — Сравнение pipeline компиляции iOS (Swift → SIL → LLVM IR → ARM64 machine code) и Android (Kotlin → JVM bytecode → DEX → ART) выявляет принципиальные различия: iOS использует AOT-компиляцию с агрессивными оптимизациями на уровне SIL и LLVM, тогда как Android сочетает AOT (при установке) и JIT (при выполнении). Понимание обоих pipeline необходимо для оптимизации производительности кросс-платформенных приложений. Рекомендуется изучать параллельно для формирования глубокого понимания компиляции.

**[[native-compilation-llvm]]** — LLVM является ключевым компонентом iOS compilation pipeline, превращающим LLVM IR в оптимизированный машинный код для ARM64. Понимание LLVM passes (оптимизации), target description и code generation объясняет, почему Whole Module Optimization значительно ускоряет runtime за счёт cross-function inlining и dead code elimination. Изучите iOS pipeline для общего понимания, затем углубитесь в LLVM для оптимизации производительности.

**[[ios-code-signing]]** — Code signing является финальным этапом compilation pipeline: после создания App Bundle (.app) он подписывается сертификатом разработчика. Понимание структуры App Bundle (executable + resources + Info.plist + embedded.mobileprovision) из этой заметки объясняет, что именно подписывается и как codesign верифицирует целостность. Рекомендуется изучить pipeline компиляции, затем переходить к code signing.

**[[ios-performance-profiling]]** — Instruments и анализ производительности напрямую связаны с compilation pipeline: dSYM файлы (генерируемые при компиляции) используются для символизации стеков вызовов, а понимание inline-оптимизаций и ARC-вставок на уровне SIL помогает интерпретировать результаты Time Profiler. Без знания pipeline сложно понять, почему определённый код выполняется быстрее или медленнее ожидаемого.

---

## Источники

### Официальная документация

1. **Swift.org Compiler Architecture**
   - https://swift.org/swift-compiler/
   - Официальное описание архитектуры Swift компилятора

2. **LLVM Documentation**
   - https://llvm.org/docs/
   - LLVM IR Reference, Passes, Target Description

3. **Apple Developer Documentation**
   - https://developer.apple.com/documentation/xcode/build-settings-reference
   - Build Settings Reference

### WWDC сессии

1. **WWDC 2015: Optimizing Swift Performance**
   - Введение в SIL и оптимизации

2. **WWDC 2016: Understanding Swift Performance**
   - Детальный разбор dispatch, generics, ARC

3. **WWDC 2018: Building Faster in Xcode**
   - Incremental compilation, parallelization

4. **WWDC 2019: What's New in Swift**
   - Module stability, ABI stability

5. **WWDC 2022: Link Fast: Improve Build and Launch Times**
   - Оптимизация linking

### Книги и статьи

1. **"Swift Compiler Internals"** — Swift Weekly Brief
   - Серия статей о внутреннем устройстве компилятора

2. **"Understanding Swift Performance"** — objc.io
   - Практическое руководство по оптимизации

3. **"LLVM Essentials"** — Packt Publishing
   - Введение в LLVM для разработчиков

### Инструменты

1. **swiftc** — Swift compiler CLI
   ```bash
   swiftc -help
   swiftc -emit-sil source.swift
   ```

2. **otool** — Mach-O analysis
   ```bash
   otool -L binary
   otool -hv binary
   ```

3. **nm** — Symbol table viewer
   ```bash
   nm -g binary
   ```

4. **codesign** — Code signature management
   ```bash
   codesign -vvv app.app
   ```

## Источники и дальнейшее чтение

- Eidhof C. et al. (2019). *Advanced Swift.* — объясняет продвинутые механизмы Swift (generics specialization, protocol witness tables, value types vs reference types), которые напрямую влияют на оптимизации на уровне SIL
- Neuburg M. (2023). *iOS 17 Programming Fundamentals with Swift.* — описывает структуру Xcode проекта, build settings и процесс сборки с практической точки зрения разработчика
- Apple (2023). *The Swift Programming Language.* — официальная документация языка, необходимая для понимания типов и конструкций, которые компилятор обрабатывает на каждом этапе pipeline

---

## Проверь себя

> [!question]- Почему Swift компилятор использует промежуточное представление SIL вместо прямой генерации LLVM IR?
> SIL (Swift Intermediate Language) позволяет выполнять Swift-специфичные оптимизации, недоступные на уровне LLVM IR: проверка lifetime объектов, оптимизация ARC (retain/release), девиртуализация вызовов протоколов, проверка эксклюзивного доступа к памяти. LLVM IR слишком низкоуровневый для этих оптимизаций. SIL -- мост между семантикой Swift и машинным кодом.

> [!question]- Чем Whole Module Optimization (WMO) отличается от обычной компиляции и как влияет на время сборки?
> Обычно: каждый .swift файл компилируется отдельно (параллельно), но компилятор не видит реализации из других файлов (консервативные оптимизации). WMO: весь модуль компилируется как единица, позволяя cross-file inlining, девиртуализацию, удаление неиспользуемого кода. Минус: дольше компиляция (нет параллелизма). Рекомендуется для Release builds.

> [!question]- Сценарий: Debug-сборка занимает 5 минут. Как сократить время инкрементальной компиляции?
> 1) Проверить, что WMO выключен в Debug (должен быть incremental). 2) Уменьшить вывод типов (явные типы вместо сложных generic expressions). 3) Разбить большие файлы (>500 строк). 4) Модуляризация через SPM (инкрементальная перекомпиляция модулей). 5) Использовать Xcode Build Timeline для нахождения bottleneck файлов. 6) Explicit dependency modules.

---

## Ключевые карточки

Какие этапы проходит Swift код до машинного кода?
?
Parsing (AST) -> Semantic Analysis (типы, проверки) -> SILGen (Swift IL) -> SIL Optimization (ARC, devirtualization) -> IRGen (LLVM IR) -> LLVM Optimization -> Machine Code. Финал: линковка в исполняемый файл, упаковка в .app bundle.

Что такое SIL и зачем он нужен?
?
Swift Intermediate Language -- промежуточное представление между AST и LLVM IR. Позволяет Swift-специфичные оптимизации: ARC optimization (удаление лишних retain/release), memory access verification, protocol devirtualization, generic specialization. Две формы: raw SIL и canonical SIL.

Что такое App Bundle (.app) и что он содержит?
?
Директория с расширением .app: исполняемый файл (Mach-O), Info.plist (метаданные), Assets.car (ресурсы), Frameworks/ (встроенные фреймворки), _CodeSignature (подпись), Storyboards/XIBs (скомпилированные). IPA = zip-архив с App Bundle внутри Payload/.

Чем отличается Debug и Release конфигурации сборки?
?
Debug: нет оптимизаций (-Onone), debug symbols, assertions включены, incremental compilation. Release: полные оптимизации (-O или -Osize), strip symbols, assertions выключены, WMO. Debug для разработки (быстрая сборка, отладка), Release для App Store (скорость выполнения).

Что такое LLVM и его роль в компиляции Swift?
?
Low Level Virtual Machine -- модульная система компиляции. Swift frontend генерирует LLVM IR (промежуточное представление), LLVM backend оптимизирует и генерирует машинный код для целевой платформы (arm64, x86_64). Позволяет Swift работать на разных архитектурах с одним frontend.

---

## Куда дальше

| Направление | Куда | Зачем |
|-------------|------|-------|
| Следующий шаг | [[ios-xcode-fundamentals]] | Проекты, targets, build settings |
| Углубиться | [[native-compilation-llvm]] | Детали LLVM и нативной компиляции |
| Смежная тема | [[android-compilation-pipeline]] | Компиляция Android для сравнения (Kotlin -> DEX) |
| Обзор | [[ios-overview]] | Вернуться к карте раздела |
