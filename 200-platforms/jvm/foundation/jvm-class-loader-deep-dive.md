---
title: "Class Loader: как JVM загружает классы"
created: 2025-11-25
modified: 2026-02-13
tags:
  - topic/jvm
  - class-loader
  - bytecode
  - type/deep-dive
  - level/beginner
type: deep-dive
status: published
area: programming
confidence: high
related:
  - "[[jvm-memory-model]]"
  - "[[jvm-bytecode-manipulation]]"
  - "[[jvm-module-system]]"
reading_time: 24
difficulty: 5
study_status: not_started
mastery: 0
last_reviewed:
next_review:
---

# Class Loader: как JVM загружает классы

> **TL;DR:** ClassLoader загружает .class файлы лениво (при первом использовании). Три встроенных: Bootstrap (java.lang.*) → Platform (javax.*) → Application (ваш код). Parent Delegation = сначала спроси родителя. Это даёт безопасность (нельзя подменить String) и изоляцию (Tomcat = разные ClassLoader для разных webapp). Hot reload работает через создание нового ClassLoader.

---

## Пререквизиты

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| Как работает JVM | Понимать роль ClassLoader в архитектуре | [[jvm-basics-history]] |
| Bytecode basics | Что такое .class файл | [[jvm-virtual-machine-concept]] |
| Иерархия классов Java | Наследование, интерфейсы | Любой Java tutorial |

---

## Зачем это знать

Без понимания ClassLoader невозможно диагностировать целый класс ошибок: `ClassNotFoundException`, `NoClassDefFoundError`, загадочные `ClassCastException` между "одинаковыми" классами. Эти ошибки возникают в production, и без знания механизма загрузки их невозможно отличить друг от друга — не говоря о том, чтобы исправить.

Серверы приложений (Tomcat, WildFly), фреймворки (Spring), IDE (IntelliJ IDEA) и системы плагинов (OSGi) — все они работают на основе custom ClassLoader. Понимание того, как классы загружаются, изолируются и выгружаются, позволяет не только чинить баги, но и проектировать расширяемые системы.

---

## Терминология для новичков

| Термин | Что это | Аналогия из жизни |
|--------|---------|-------------------|
| **ClassLoader** | Объект, отвечающий за поиск и загрузку классов | Библиотекарь, который ищет книги по запросу |
| **Bytecode** | Скомпилированный .class файл | Рецепт блюда, записанный в стандартном формате |
| **Loading** | Поиск и чтение .class файла | Библиотекарь нашёл книгу на полке |
| **Linking** | Верификация, подготовка памяти, разрешение ссылок | Проверка книги на подлинность и подготовка места |
| **Initialization** | Выполнение static блоков | Открытие книги и чтение предисловия |
| **Parent Delegation** | Модель делегирования загрузки родительскому ClassLoader | Сначала спроси начальника, потом делай сам |
| **Context ClassLoader** | ClassLoader, привязанный к потоку | VIP-карта, определяющая доступ к ресурсам |
| **Hot Reload** | Перезагрузка классов без рестарта | Замена колеса на ходу, без остановки машины |

---

## Историческая справка

ClassLoader — одна из старейших подсистем Java, появившаяся в самой первой версии (Java 1.0, 1996). Первоначальная мотивация была не модульность и не hot reload — это была **безопасность**. Java создавалась для запуска кода из сети (Java Applets), и нужен был механизм, который не позволит скачанному из интернета коду подменить системные классы вроде `java.lang.String` или `java.lang.System`.

Именно для этого была придумана модель делегирования (Parent Delegation Model): любой запрос на загрузку класса сначала передаётся родительскому ClassLoader, и только если тот не нашёл класс — дочерний ищет сам. Это гарантирует, что `java.lang.String` всегда загружается из доверенного источника (Bootstrap ClassLoader), а не из пользовательского кода.

С ростом enterprise Java (конец 1990-х — начало 2000-х) ClassLoader стал использоваться для модульности. Серверы приложений (JBoss, WebLogic, WebSphere) создавали изолированные ClassLoader для каждого развёрнутого приложения. Это позволяло разным приложениям на одном сервере использовать разные версии библиотек без конфликтов.

В 2000-х годах проект OSGi (Open Service Gateway initiative, стартовал в 1999) довёл идею до предела: каждый модуль (bundle) имел свой ClassLoader с точным контролем экспортируемых и импортируемых пакетов. Eclipse IDE и Apache Felix построены на OSGi. Однако сложность модели — особенно проблемы с циклическими зависимостями и "class loading hell" — привела к тому, что многие разработчики считают OSGi overengineered для большинства задач.

Java 9 (2017) представила Java Platform Module System (JPMS, Project Jigsaw), которая предложила более простой подход к модульности. JPMS добавила слой контроля видимости поверх ClassLoader: модули явно объявляют, какие пакеты они экспортируют. При этом иерархия ClassLoader осталась прежней, но ExtClassLoader был переименован в Platform ClassLoader, отражая новую архитектуру модулей.

---

## Аналогия: система образования

Модель делегирования ClassLoader похожа на то, как работает система образования, когда студенту нужно найти ответ на вопрос.

Представьте студента, который столкнулся с вопросом. Он не пытается ответить сам — сначала спрашивает преподавателя (Application ClassLoader → Platform ClassLoader). Преподаватель тоже не отвечает сразу — направляет запрос декану факультета (Platform ClassLoader → Bootstrap ClassLoader). Декан — это высшая инстанция: если вопрос из его компетенции (фундаментальные науки, как `java.lang.*`), он отвечает сам. Если нет — возвращает вопрос преподавателю. Преподаватель ищет в своей области (расширения JDK). Если не нашёл — вопрос возвращается студенту, и он ищет ответ сам (в своём коде, classpath).

Эта модель гарантирует, что фундаментальные знания (системные классы) всегда идут из авторитетного источника. Студент не может "переопределить" законы физики, преподаваемые деканом, — точно так же, как пользовательский код не может подменить `java.lang.Object`.

---

## Три фазы загрузки класса

Когда JVM впервые встречает ссылку на класс, происходит трёхфазный процесс. Понимание этих фаз помогает диагностировать ошибки вроде `NoClassDefFoundError` или проблемы со static инициализацией.

### Аналогия: доставка товаров

Загрузка класса похожа на процесс получения товара интернет-магазином. Сначала товар ищется на складе и доставляется в магазин (**Loading** — поиск и чтение .class файла). Затем товар проходит проверку на контроле качества: не подделка ли, не повреждён ли, соответствует ли стандартам (**Verification**). После проверки товар распаковывается, ему выделяется место на полке, но ценники пока ставятся нулевые (**Preparation** — выделение памяти под static поля с default значениями). Затем проверяются все ссылки: если на коробке написано "совместим с аксессуаром X", магазин проверяет, что аксессуар X тоже есть на складе (**Resolution** — разрешение символических ссылок). И наконец, товар выставляется на витрину с реальными ценниками и описанием (**Initialization** — выполнение static блоков и присваивание начальных значений).

Если на любом этапе что-то пошло не так — товар не нашли, проверка показала подделку, аксессуар отсутствует — процесс прерывается, и товар не попадает на витрину.

### Фаза 1: Loading

На этой фазе ClassLoader находит физический .class файл и читает его байты в память. Источником может быть файловая система, JAR-архив, сеть, или даже генерация байткода на лету.

Loading начинается с запроса к ClassLoader по полному имени класса (например, `com.example.MyService`). ClassLoader преобразует это имя в путь (`com/example/MyService.class`) и ищет соответствующий файл в своих источниках. Для Application ClassLoader источниками являются директории и JAR-файлы, перечисленные в classpath. Для Bootstrap ClassLoader — модули JDK.

После чтения байтов JVM создаёт объект `java.lang.Class`, который представляет загруженный класс. Этот объект содержит метаинформацию: имя класса, список полей и методов, суперкласс, интерфейсы. Объект Class размещается в Metaspace (до Java 8 — в PermGen), и именно через него работает Reflection API.

Важно понимать, что на этом этапе JVM ещё не проверяет корректность байткода и не разрешает ссылки на другие классы. Класс прочитан, но ещё не готов к использованию. Static поля не инициализированы, ссылки на другие классы остаются символическими строками.

```
.class файл → Чтение байтов → Создание java.lang.Class
             (с диска, JAR,    (объект в Metaspace)
              сети, памяти)
```

Если ClassLoader не находит .class файл, выбрасывается `ClassNotFoundException`. Это checked exception, и программа может его перехватить и обработать — например, попробовать загрузить альтернативную реализацию.

### Фаза 2: Linking

Linking — самая технически сложная фаза, состоящая из трёх подфаз. Именно здесь JVM превращает "сырые" байты в структуру, пригодную для выполнения.

**Verification (верификация)** — JVM проверяет, что байткод безопасен и соответствует спецификации JVM. Верификатор работает в несколько проходов. Первый проход проверяет формат: magic number (0xCAFEBABE), версию class-файла, структуру constant pool. Второй проход проверяет семантику байткода: корректность типов на стеке, отсутствие переполнения или недополнения стека операндов, правильность обращений к полям и методам.

Верификация — это наследие эпохи Java Applets. Когда код скачивается из сети, JVM не может доверять ему. Верификатор гарантирует, что код не нарушает правила системы типов Java на уровне байткода: невозможно обратиться к приватному полю чужого класса, невозможно вызвать несуществующий метод, невозможно привести `int` к `Object` напрямую.

Если загрузить модифицированный .class файл с невалидным байткодом, верификация провалится с `VerifyError`. Это одна из причин, почему Java безопаснее C++ — виртуальная машина не доверяет входящему коду и проверяет его перед выполнением.

Верификацию можно отключить флагом `-Xverify:none` (до Java 13) или `-XX:-BytecodeVerificationRemote` для ускорения старта. Но это компромисс безопасности: без верификации вредоносный байткод может обойти access control и выполнить произвольные действия. В production отключение верификации не рекомендуется.

**Preparation (подготовка)** — JVM выделяет память для static полей класса и присваивает им значения по умолчанию. Не пользовательские значения — именно default values по типу: 0 для числовых типов, `false` для boolean, `null` для ссылок. Это важный момент, который часто путают: на этапе Preparation поле `static int counter = 42` содержит 0, а не 42. Присваивание 42 произойдёт только на этапе Initialization.

Preparation также выделяет память для method tables (vtable для виртуальных методов, itable для интерфейсов). Эти таблицы используются для динамической диспетчеризации вызовов — механизма, обеспечивающего полиморфизм.

```java
class Example {
    static int counter = 42;      // На этапе Preparation: counter = 0
    static String name = "test";  // На этапе Preparation: name = null
}
```

**Resolution (разрешение)** — символические ссылки преобразуются в прямые адреса. В байткоде все ссылки на классы, поля и методы представлены текстовыми строками в constant pool. Например, когда ваш код вызывает `list.add(item)`, в байткоде записано нечто вроде "вызови метод `add` с дескриптором `(Ljava/lang/Object;)Z` в классе `java/util/ArrayList`". Resolution находит реальный объект класса ArrayList, находит в нём метод `add` и заменяет символическую ссылку на прямой указатель.

Resolution может происходить лениво (lazy resolution) — только при первом использовании конкретной ссылки, а не при загрузке класса. Это поведение по умолчанию в HotSpot JVM. Альтернатива — eager resolution, когда все ссылки разрешаются сразу при linking. Ленивое разрешение ускоряет старт приложения: не нужно загружать все транзитивные зависимости класса, пока они реально не понадобятся.

Если при Resolution не удаётся найти класс, поле или метод, выбрасываются ошибки: `NoClassDefFoundError`, `NoSuchFieldError`, `NoSuchMethodError`. Эти ошибки отличаются от `ClassNotFoundException` тем, что возникают не при явном запросе на загрузку, а при попытке использовать уже загруженный класс, ссылки которого не удалось разрешить.

### Фаза 3: Initialization

Самая важная для прикладного программиста фаза. Здесь выполняются static блоки и присваиваются начальные значения static полям. JVM гарантирует, что инициализация каждого класса происходит ровно один раз (за исключением случаев с несколькими ClassLoader) и является потокобезопасной — если два потока одновременно триггерят инициализацию класса, один из них заблокируется до завершения.

Порядок инициализации определён строго: сначала инициализируется суперкласс (если ещё не инициализирован), затем static поля и static блоки — в порядке их появления в исходном коде. Компилятор javac объединяет все static-инициализаторы в один метод `<clinit>` (class initialization), который JVM вызывает при инициализации.

```java
class Database {
    static {
        System.out.println("Connecting to database...");
        connection = DriverManager.getConnection(url);  // Может бросить Exception!
    }

    static Connection connection;
}
```

**Критический момент:** если static инициализатор бросает исключение, класс помечается как "failed". Первый вызов получит `ExceptionInInitializerError`, а все последующие попытки использовать этот класс приведут к `NoClassDefFoundError`, а не к повторной инициализации. JVM не повторяет инициализацию — если она провалилась один раз, класс считается непригодным навсегда (до перезапуска JVM). Это частая ловушка: в логах вы видите `NoClassDefFoundError`, но настоящая причина — exception в static блоке — логировалась раньше и могла быть пропущена.

Initialization происходит при первом **активном использовании** класса:
- Создание экземпляра (`new`)
- Вызов static метода
- Обращение к static полю (кроме compile-time констант)
- Reflection: `Class.forName()`
- Инициализация подкласса (сначала инициализируется суперкласс)

Важно: обращение к compile-time константе (`static final` поле с литеральным значением) **не** триггерит инициализацию класса. Компилятор встраивает значение константы напрямую в вызывающий код. Например, `static final int MAX = 100` — при обращении к `MAX` из другого класса javac подставит число 100 напрямую. Это означает, что если вы измените значение константы и перекомпилируете только класс-владелец, но не вызывающие классы — они продолжат использовать старое значение. Это одна из причин, по которой после изменения констант рекомендуется полная перекомпиляция проекта.

Потокобезопасность инициализации заслуживает отдельного внимания. JVM использует внутренний lock на объекте класса, чтобы гарантировать, что `<clinit>` выполняется ровно одним потоком. Если поток A начал инициализацию, а поток B обращается к тому же классу — поток B заблокируется до завершения. Это делает паттерн Initialization-on-Demand Holder (Bill Pugh singleton) потокобезопасным без synchronized: вложенный класс с static полем инициализируется лениво и атомарно.

```
.class файл → Loading → Linking → Initialization → Готов к использованию
                         │
                         ├─ Verification
                         ├─ Preparation
                         └─ Resolution
```

Мы разобрали, КАК классы загружаются. Но КТО решает, какой ClassLoader будет загружать какой класс? Ответ — в модели делегирования.

---

## Иерархия ClassLoaders

JVM использует несколько ClassLoader, организованных в иерархию. Каждый отвечает за загрузку классов из определённых источников.

### Bootstrap ClassLoader

Самый первый ClassLoader, написанный на C++ (не Java). Загружает ядро JDK: `java.lang.*`, `java.util.*`, `java.io.*` и другие фундаментальные классы.

Эти классы находятся в модулях JDK (начиная с Java 9) или в rt.jar (Java 8 и ранее). Когда вы вызываете `String.class.getClassLoader()`, получаете `null` — потому что Bootstrap ClassLoader не представлен Java-объектом.

### Platform ClassLoader (Java 9+) / Extension ClassLoader (Java 8)

Загружает расширения JDK: `javax.*`, `java.sql.*`, `java.security.*`. В Java 8 это был ExtClassLoader, в Java 9+ переименован в Platform ClassLoader.

Находит классы в JDK extension modules. В отличие от Bootstrap, это уже Java-объект.

### Application ClassLoader (System ClassLoader)

Загружает ваш код и ваши зависимости. Источники:
- Classpath (`-cp` или переменная CLASSPATH)
- JAR-файлы вашего приложения
- Maven/Gradle зависимости

Именно этот ClassLoader вы получаете через `ClassLoader.getSystemClassLoader()`.

Application ClassLoader — точка входа для загрузки пользовательского кода. Когда вы запускаете `java -jar app.jar`, JVM создаёт Application ClassLoader с classpath, включающим app.jar и все его зависимости. Порядок JAR-файлов в classpath имеет значение: если один и тот же класс присутствует в двух JAR, загружается тот, что идёт первым. Это источник труднодиагностируемых багов при конфликтах версий библиотек.

### Custom ClassLoaders

Вы можете создавать свои ClassLoader для специальных задач: загрузка плагинов из отдельных директорий, шифрованные .class файлы, генерация классов на лету.

```
Bootstrap ClassLoader (C++, загружает java.lang.*, java.util.*)
    │
    ▼
Platform ClassLoader (загружает javax.*, java.sql.*)
    │
    ▼
Application ClassLoader (загружает ваш код и зависимости)
    │
    ▼
Custom ClassLoaders (плагины, изолированные модули)
```

---

## Parent Delegation Model

Когда ClassLoader получает запрос на загрузку класса, он сначала делегирует запрос родителю. Только если родитель не смог найти класс, дочерний ClassLoader пытается загрузить его сам.

Рассмотрим пример: ваш код вызывает `new ArrayList()`.

1. Application ClassLoader получает запрос "загрузи java.util.ArrayList"
2. Вместо самостоятельного поиска, он спрашивает Platform ClassLoader
3. Platform ClassLoader спрашивает Bootstrap ClassLoader
4. Bootstrap ClassLoader: "ArrayList у меня!" → загружает и возвращает класс
5. Класс передаётся вниз по цепочке к вашему коду

**Зачем такая модель?**

**Безопасность:** Вы не можете подменить `java.lang.String` своей версией. Даже если создадите файл `java/lang/String.class` в своём проекте, Application ClassLoader сначала спросит Bootstrap, и Bootstrap загрузит настоящий String.

**Консистентность:** Гарантируется, что базовые классы JDK одинаковы для всего приложения. Нет риска, что разные части кода видят разные версии String.

**Единственный экземпляр:** Класс загружается только один раз (если не используются изолированные ClassLoader). Это важно для static полей и синглтонов.

```
Запрос: "загрузи com.example.MyClass"

Application CL: Есть ли у родителя? → спрашивает Platform CL
Platform CL:    Есть ли у родителя? → спрашивает Bootstrap CL
Bootstrap CL:   Нет, это не мой класс → возвращает null
Platform CL:    Не нашёл в своих источниках → возвращает null
Application CL: Ищу сам в CLASSPATH → нашёл! → загружаю → возвращаю класс
```

### Parent-First vs Child-First

Стандартная модель делегирования — parent-first: запрос всегда идёт вверх к родителю, и только если он не нашёл — дочерний ClassLoader ищет сам. Но в некоторых случаях эта модель создаёт проблемы.

Представьте: сервер приложений (Tomcat) загружен с библиотекой Guava 28 в своём classpath. Ваше веб-приложение требует Guava 31 с новыми API. В parent-first модели Application ClassLoader вашего webapp спросит родителя (ClassLoader Tomcat), родитель найдёт Guava 28 — и вернёт устаревшую версию. Ваш код получит `NoSuchMethodError` при вызове метода, существующего только в Guava 31.

Решение — **child-first** (parent-last) модель: ClassLoader сначала ищет класс в своих источниках, и только если не нашёл — делегирует родителю. Именно так работают ClassLoader в Tomcat для WAR-приложений (за исключением классов из `java.*` и `javax.*`, которые всегда делегируются вверх). Это позволяет каждому webapp использовать свою версию библиотек, изолированно от сервера и других приложений.

Child-first модель нарушает стандартную спецификацию, и это осознанный trade-off. Она решает проблему конфликтов версий, но создаёт другую: если общий интерфейс загружен разными ClassLoader, объекты одного типа становятся несовместимыми (ClassCastException). Поэтому типы, используемые для коммуникации между модулями (интерфейсы, DTO), должны загружаться общим родительским ClassLoader.

OSGi пошла ещё дальше: каждый bundle (модуль) имеет свой ClassLoader, а загрузка класса направляется не вверх по иерархии, а **горизонтально** — к тому bundle, который экспортирует нужный пакет. Это сетевая модель делегирования, а не древовидная. Она мощнее, но значительно сложнее в отладке — отсюда термин "class loading hell", ставший синонимом OSGi-проблем.

### Context ClassLoader

Thread Context ClassLoader — механизм для фреймворков и библиотек, которым нужно загружать классы, определённые пользователем.

**Проблема:** представьте ServiceLoader, который ищет реализации интерфейса. ServiceLoader — часть JDK, загружен Bootstrap ClassLoader. Но реализации находятся в вашем коде, загруженном Application ClassLoader. Bootstrap ClassLoader не видит Application ClassLoader — он выше в иерархии. Модель делегирования позволяет делегировать только вверх (к родителю), а не вниз (к детям). Как ServiceLoader найдёт ваши реализации?

Эта проблема была осознана ещё в Java 1.2 и стала известна как "class loader inversion problem". Корень проблемы — SPI (Service Provider Interface) паттерн: интерфейс определён в JDK (загружен Bootstrap), реализации — в пользовательском коде (загружены Application ClassLoader).

**Решение:** Context ClassLoader — это ClassLoader, привязанный к потоку через `Thread.currentThread().getContextClassLoader()`. По умолчанию он установлен в Application ClassLoader. Фреймворки и системные библиотеки используют его вместо своего собственного ClassLoader:

```java
// Фреймворк или библиотека:
ClassLoader contextCL = Thread.currentThread().getContextClassLoader();
ServiceLoader<MyService> loader = ServiceLoader.load(MyService.class, contextCL);
```

Context ClassLoader — по сути "дыра" в модели делегирования: он позволяет коду, загруженному родительским ClassLoader, получить доступ к классам дочернего. Это не нарушает безопасность (Context ClassLoader устанавливается доверенным кодом), но создаёт неявную зависимость: если кто-то изменит Context ClassLoader потока, фреймворк может перестать находить нужные классы.

В серверах приложений Context ClassLoader автоматически переключается при передаче управления между контейнером и пользовательским кодом. Например, при обработке HTTP-запроса Tomcat устанавливает Context ClassLoader текущего потока на ClassLoader соответствующего webapp. Это позволяет JNDI, JDBC-драйверам и другим SPI-механизмам находить пользовательские классы.

Вы можете изменить Context ClassLoader для специальных случаев, но всегда восстанавливайте его в finally-блоке:

```java
ClassLoader original = Thread.currentThread().getContextClassLoader();
try {
    Thread.currentThread().setContextClassLoader(myPluginClassLoader);
    runFrameworkCode();  // Фреймворк увидит классы из myPluginClassLoader
} finally {
    Thread.currentThread().setContextClassLoader(original);
}
```

---

## Custom ClassLoader: плагины, hot reload, изоляция

Создание собственного ClassLoader позволяет контролировать источник и обработку классов. Это не экзотика — это основа работы серверов приложений, IDE и систем плагинов.

### Зачем нужен

- **Плагины:** загружать расширения из отдельных директорий, не добавляя их в основной CLASSPATH
- **Hot reload:** создавать новый ClassLoader для перезагрузки изменённых классов без рестарта
- **Изоляция:** позволять разным модулям использовать разные версии библиотек
- **Защита:** расшифровывать зашифрованные .class файлы

### Как работает hot reload

Hot reload — одно из самых ценных применений custom ClassLoader в development. Ключевое ограничение: загруженный класс нельзя "перезагрузить" в том же ClassLoader. Объект `java.lang.Class` — immutable, и JVM не предоставляет API для замены уже загруженного класса. Это фундаментальное ограничение, вытекающее из модели безопасности.

Решение — создать **новый** ClassLoader. Когда разработчик изменяет файл, система создаёт свежий ClassLoader, который загружает обновлённую версию класса. Старый ClassLoader и все загруженные им классы становятся кандидатами на сборку мусора (если на них не осталось ссылок). Именно так работают Spring DevTools, JRebel и HotswapAgent.

Spring DevTools разделяет классы на две группы: "base" (библиотеки, которые не меняются) и "restart" (ваш код). При изменении файла пересоздаётся только restart-ClassLoader, а base-ClassLoader остаётся. Это позволяет перезагружать приложение за 1-2 секунды вместо 30-60.

Однако hot reload через custom ClassLoader имеет ограничения. Нельзя изменить сигнатуру метода или иерархию наследования — это потребовало бы обновления всех ссылающихся классов. Нельзя добавить или удалить static поля. Состояние (значения instance-полей) теряется при перезагрузке — новый ClassLoader создаёт новые объекты, и данные старых экземпляров недоступны.

Ещё одна тонкость: ClassLoader и все загруженные им классы выгружаются только после того, как GC соберёт **все** ссылки — и на ClassLoader, и на все объекты загруженных им классов, и на все объекты `java.lang.Class`. Если хотя бы одна ссылка сохранилась (например, в ThreadLocal, в static поле родительского ClassLoader, или в стеке потока), весь ClassLoader и все его классы останутся в Metaspace. Это классическая причина утечки памяти при hot reload в production.

Для полноценного hot reload без ограничений нужны инструменты вроде DCEVM (Dynamic Code Evolution VM), которые модифицируют саму JVM, позволяя переопределять классы с изменением структуры.

### Плагинные системы

Плагинная система — классический сценарий для custom ClassLoader. Архитектура следующая: основное приложение определяет интерфейс (например, `Plugin`), который загружается общим ClassLoader. Каждый плагин — отдельный JAR, загружаемый своим ClassLoader с parent = Application ClassLoader. Плагин реализует интерфейс `Plugin`, и основное приложение может работать с ним через этот интерфейс.

Ключевой принцип: типы, пересекающие границу между ClassLoader (интерфейсы, DTO, исключения), должны загружаться общим родительским ClassLoader. Типы, специфичные для плагина, загружаются его собственным ClassLoader. Это позволяет разным плагинам использовать разные версии библиотек без конфликтов.

IntelliJ IDEA использует именно эту модель: каждый плагин имеет свой ClassLoader, а JetBrains Platform API загружается общим. Minecraft-моды работают аналогично: Forge/Fabric предоставляют API, каждый мод загружается изолированно.

### Пример минимального custom ClassLoader

Для создания custom ClassLoader достаточно переопределить метод `findClass()`. Метод `loadClass()` (унаследованный) уже реализует parent delegation — сначала спросит родителя, и только если тот не нашёл, вызовет ваш `findClass()`:

```java
public class PluginClassLoader extends ClassLoader {
    private final Path pluginDir;

    public PluginClassLoader(Path pluginDir, ClassLoader parent) {
        super(parent);             // parent обеспечивает delegation
        this.pluginDir = pluginDir;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        String path = name.replace('.', '/') + ".class";
        Path classFile = pluginDir.resolve(path);
        try {
            byte[] bytes = Files.readAllBytes(classFile);
            return defineClass(name, bytes, 0, bytes.length);
        } catch (IOException e) {
            throw new ClassNotFoundException(name, e);
        }
    }
}
```

Метод `defineClass()` — защищённый метод ClassLoader, который превращает массив байтов в объект `Class`. Именно здесь происходит проверка: байты должны быть валидным class-файлом, иначе JVM выбросит `ClassFormatError`.

**Когда НЕ стоит использовать Custom ClassLoader:**

| Ситуация | Почему не нужен Custom ClassLoader |
|----------|-----------------------------------|
| Простая модульность | Используйте Java Modules (JPMS) |
| Разные версии для тестов | Maven/Gradle dependency scopes |
| Динамическая загрузка JAR | `URLClassLoader` достаточен |
| Изоляция в микросервисах | Отдельные процессы надёжнее |

---

## Типичные ошибки ClassLoader

### ClassNotFoundException

```java
Class.forName("com.example.MyClass");
// → ClassNotFoundException: com.example.MyClass
```

**Что произошло:** ClassLoader не нашёл .class файл при явном запросе через `Class.forName()` или `ClassLoader.loadClass()`.

**Причины:**
- Класс отсутствует в CLASSPATH
- Опечатка в имени класса
- JAR-файл не добавлен в зависимости

### NoClassDefFoundError

```java
new MyClass();
// → NoClassDefFoundError: com/example/MyClass
```

**Что произошло:** Класс был доступен при компиляции, но отсутствует или сломан при запуске. Это Error, не Exception — ситуация считается фатальной.

**Разница с ClassNotFoundException:**
- ClassNotFoundException — класс не найден при явном запросе
- NoClassDefFoundError — класс был при компиляции, но нет при запуске, или инициализация провалилась

**Частая скрытая причина — ошибка в static инициализации:**

```java
class DatabaseConfig {
    static {
        // Бросит exception при первой загрузке
        Connection conn = DriverManager.getConnection("bad-url");
    }
}
// Первый вызов: → ExceptionInInitializerError
// Все последующие: → NoClassDefFoundError
```

JVM не повторяет инициализацию — если она провалилась один раз, класс считается непригодным навсегда (до перезапуска JVM).

### ClassCastException между "одинаковыми" классами

**Что произошло:** Класс загружен двумя разными ClassLoader. Для JVM это два **разных** класса, даже если они имеют одинаковое имя и идентичный байткод.

**Правило идентичности класса:** Класс уникально идентифицируется парой (ClassLoader, FullyQualifiedName). Два ClassLoader — два разных класса.

**Когда возникает:**
- Плагинные системы с изолированными ClassLoader
- OSGi контейнеры
- Web-приложения в сервлетных контейнерах (каждый webapp имеет свой ClassLoader)

**Решение:** Использовать общий ClassLoader для типов, которые нужно передавать между модулями, или работать через интерфейсы из общего родительского ClassLoader.

---

## Распространённые заблуждения

| Заблуждение | Почему это неверно |
|-------------|-------------------|
| "Класс загружается при запуске программы" | Класс загружается **lazy** — только при первом активном обращении. JVM использует отложенную загрузку для экономии памяти и быстрого старта. Обращение к compile-time константе не триггерит загрузку |
| "Parent ClassLoader физически содержит child" | Это **делегирование**, не наследование. Parent и child — отдельные объекты, связанные через ссылку. Child делегирует загрузку parent'у, но сам parent не знает о child'ах |
| "System ClassLoader загружает всё" | Application ClassLoader загружает только из classpath. Платформенные классы грузит Platform CL, а bootstrap классы (java.lang.*) — Bootstrap CL, написанный на C++ |
| "Два класса с одинаковым именем — это один класс" | Класс уникален парой **(имя + ClassLoader)**. `com.app.User` от ClassLoader A и от ClassLoader B — два РАЗНЫХ типа, несовместимых при присваивании |
| "ClassNotFoundException = класс не существует" | Это значит, что ClassLoader не нашёл класс **в своей иерархии**. Класс может существовать в другом ClassLoader (например, в дочернем или параллельном) |
| "Custom ClassLoader = сложно и не нужно" | IDE, серверы, frameworks активно используют custom ClassLoader. Это основа hot reload, модульности и изоляции. Минимальная реализация — ~15 строк кода |
| "Загруженный класс нельзя выгрузить" | Класс выгружается когда **нет ссылок** ни на ClassLoader, ни на объекты этого класса. GC собирает и ClassLoader, и загруженные им классы. Это основа hot reload |
| "Parent Delegation — единственная модель" | Tomcat, OSGi, JNDI используют **child-first** или сетевую модель. Parent-first — default, но не единственная. Выбор модели зависит от задачи (изоляция vs консистентность) |
| "Java 9 модули заменили ClassLoader" | JPMS добавляет слой **видимости** (exports/opens) поверх ClassLoader. ClassLoader по-прежнему загружают классы; модули контролируют, кому что видно. Это ортогональные механизмы |
| "Bootstrap ClassLoader можно получить через getClassLoader()" | `String.class.getClassLoader()` возвращает **null**. Bootstrap CL — native код JVM, не Java объект. null означает "bootstrap" |

---

## Java 9+ Module System

Начиная с Java 9, модульная система (JPMS) добавляет ещё один уровень контроля над видимостью классов.

Модули явно декларируют, какие пакеты они экспортируют и какие модули требуют. Даже если класс физически находится в модуле, он может быть недоступен для reflection без директивы `opens`.

```
Java 8:
  Bootstrap → Extension → Application
  (всё видят всё через reflection)

Java 9+:
  Bootstrap → Platform → Application
      │
      └── Module Layer (контроль exports/opens)
```

Подробнее: [[jvm-module-system]]

---

## Кто использует и реальные примеры

| Технология | Как использует ClassLoader | Зачем |
|------------|---------------------------|-------|
| **Tomcat/Jetty** | Отдельный ClassLoader для каждого webapp | Изоляция: webapp A с Guava 28 и webapp B с Guava 31 одновременно |
| **OSGi** | Динамические модули с собственными ClassLoader | Enterprise (Eclipse, IntelliJ IDEA plugins) |
| **Spring DevTools** | Два ClassLoader: restartLoader + baseLoader | Fast restart: перезагружаем только ваш код, не библиотеки |
| **JRebel** | Bytecode instrumentation + custom ClassLoader | Hot reload в development: сохранил файл → код обновился |
| **HotswapAgent** | Open-source альтернатива JRebel | Бесплатный hot reload с поддержкой Spring, Hibernate |
| **Minecraft mods** | Custom ClassLoader для загрузки модов | Расширяемость игры без доступа к исходникам |

### Spring DevTools: как работает fast restart

```
Первый запуск:
baseClassLoader → библиотеки (Spring, Hibernate, etc.) — НЕ перезагружается
restartClassLoader → ваш код (com.myapp.*) — перезагружается

При изменении файла:
1. Старый restartClassLoader выбрасывается
2. Создаётся новый restartClassLoader
3. Ваш код загружается заново
4. Приложение "перезапускается" за 1-2 секунды вместо 30-60
```

---

## Отладка проблем с ClassLoader

### Определить, кто загрузил класс

```java
Class<?> clazz = MyClass.class;
ClassLoader cl = clazz.getClassLoader();
System.out.println("Class: " + clazz.getName());
System.out.println("ClassLoader: " + cl);
System.out.println("Source: " + clazz.getProtectionDomain()
                                     .getCodeSource()
                                     .getLocation());
```

Вывод покажет полный путь к JAR или директории, откуда загружен класс — критически полезно при конфликтах версий.

### JVM флаги для отладки

```bash
# Показать каждую загрузку класса
java -verbose:class MyApp

# Более детально (Java 9+)
java -Xlog:class+load=info MyApp
```

### Чеклист диагностики

```
□ ClassNotFoundException: класс в CLASSPATH?
  → jar -tf lib/*.jar | grep ClassName

□ NoClassDefFoundError: класс был при компиляции?
  → Проверить static initializers на exceptions
  → Проверить зависимости в runtime vs compile time

□ ClassCastException между "одинаковыми" классами:
  → obj.getClass().getClassLoader() — один ли ClassLoader?

□ LinkageError: конфликт версий?
  → Найти дубликаты классов в разных JAR

□ Включить отладку: java -verbose:class MyApp
□ Найти источник: clazz.getProtectionDomain().getCodeSource()
```

---

## Связь с другими темами

**[[jvm-memory-model]] — Metaspace и хранение классов.** Загруженные ClassLoader классы размещаются в Metaspace (до Java 8 — PermGen). Понимание ClassLoader необходимо для диагностики утечек Metaspace: если ClassLoader не может быть собран GC (есть ссылки на его классы или экземпляры), все загруженные им классы остаются в памяти. Это частая причина OutOfMemoryError: Metaspace в серверах приложений при частых redeploy. Рекомендуется сначала изучить ClassLoader, затем Memory Model.

**[[jvm-bytecode-manipulation]] — модификация классов при загрузке.** ClassLoader — точка входа для bytecode manipulation. Java Agent API (java.lang.instrument) позволяет перехватывать классы в момент загрузки и модифицировать их байткод через ClassFileTransformer. Это основа работы AOP-фреймворков (AspectJ), профилировщиков (JProfiler, YourKit) и инструментов покрытия кода (JaCoCo). Понимание фаз загрузки помогает понять, когда и как можно вмешаться в байткод.

**[[jvm-module-system]] — JPMS и контроль видимости.** Java Platform Module System работает поверх ClassLoader. Модули определяют, какие пакеты экспортируются (видны другим модулям) и какие открыты для reflection. ClassLoader по-прежнему загружает классы, но модульная система добавляет дополнительную проверку доступа. Понимание ClassLoader — prerequisite для понимания JPMS, поскольку модули не заменяют ClassLoader, а дополняют их.

---

## Источники и дальнейшее чтение

- **Lindholm T. et al. (2014). The Java Virtual Machine Specification, Java SE 8 Edition.** — формальное описание процесса загрузки, связывания и инициализации классов (Chapter 5). Это спецификация, не руководство — полезна как точный reference, когда нужно знать гарантии JVM.

- **Venners B. (2000). Inside the Java Virtual Machine, 2nd Edition.** — глава про class loading одна из лучших объяснений модели делегирования и custom ClassLoader с примерами. Книга старая, но фундаментальные концепции ClassLoader не менялись.

- **Liang S., Bracha G. (1998). Dynamic Class Loading in the Java Virtual Machine.** — оригинальная исследовательская работа, описывающая формальную модель загрузки классов в JVM. Авторы — инженеры Sun Microsystems, создавшие спецификацию. Важна для понимания design decisions и trade-offs.

- [JVM Specification: Loading, Linking, Initializing](https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-5.html) — официальная спецификация
- [ClassLoader javadoc](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ClassLoader.html) — API документация
- [Understanding Class Loading](https://www.baeldung.com/java-classloaders) — Baeldung tutorial

---

---

## Проверь себя

> [!question]- Почему NoClassDefFoundError и ClassNotFoundException -- это разные ошибки, хотя обе связаны с отсутствием класса?
> ClassNotFoundException -- checked exception, возникает при явном запросе через `Class.forName()` или `ClassLoader.loadClass()`, когда ClassLoader не нашёл .class файл. NoClassDefFoundError -- unchecked Error, возникает когда класс был доступен при компиляции, но отсутствует или сломан в runtime (часто из-за упавшего static инициализатора). Разница в механизме: первая -- явный поиск, вторая -- неявное разрешение ссылок.

> [!question]- В Tomcat два разных webapp используют Guava 28 и Guava 31. Как Tomcat изолирует эти версии и какая модель делегирования для этого используется?
> Tomcat использует child-first (parent-last) модель: ClassLoader каждого webapp сначала ищет класс в своём WEB-INF/lib, и только если не нашёл -- делегирует родителю. Это позволяет webapp A загрузить Guava 28 из своего JAR, а webapp B -- Guava 31 из своего. Исключение: классы java.* и javax.* всегда делегируются вверх к Bootstrap/Platform ClassLoader для безопасности.

> [!question]- У вас Spring Boot приложение с DevTools, и после изменения класса hot reload создаёт утечку Metaspace. Какие GC roots могут удерживать старый ClassLoader от сборки?
> Старый ClassLoader не собирается, если существует хотя бы одна ссылка на него, его классы или их экземпляры. Типичные источники удержания: ThreadLocal, содержащий объект старого класса; static поле в родительском ClassLoader, ссылающееся на объект дочернего; незавершённый поток, стек которого содержит frames с классами старого ClassLoader; JDBC-драйвер, зарегистрированный через DriverManager.

> [!question]- Зачем нужен Context ClassLoader и какую проблему иерархической модели делегирования он решает?
> Context ClassLoader решает "class loader inversion problem": системный код (загруженный Bootstrap ClassLoader) не может видеть пользовательские классы (загруженные Application ClassLoader), потому что делегирование работает только вверх. ServiceLoader, JNDI, JDBC используют Context ClassLoader потока для доступа к реализациям, определённым пользователем. Это "дыра" в модели делегирования, позволяющая родительскому коду загружать классы дочернего ClassLoader.

---

## Ключевые карточки

Какие три фазы проходит класс при загрузке в JVM?
?
Loading (поиск и чтение .class файла), Linking (Verification + Preparation + Resolution) и Initialization (выполнение static блоков и присваивание начальных значений static полям).

Что означает Parent Delegation Model в ClassLoader?
?
При запросе на загрузку класса ClassLoader сначала делегирует запрос родительскому ClassLoader. Только если родитель не нашёл класс, дочерний ClassLoader ищет сам. Это гарантирует безопасность (нельзя подменить java.lang.String) и консистентность.

Чем отличается child-first от parent-first модели делегирования?
?
В parent-first (стандарт) запрос всегда идёт к родителю. В child-first ClassLoader сначала ищет в своих источниках, потом у родителя. Child-first используется в Tomcat для изоляции версий библиотек между webapp.

Почему после ExceptionInInitializerError все последующие обращения к классу дают NoClassDefFoundError?
?
JVM не повторяет инициализацию класса. Если static инициализатор бросил исключение, класс помечается как "failed" навсегда (до перезапуска JVM). Первый вызов получит ExceptionInInitializerError, все последующие -- NoClassDefFoundError.

Как обеспечить hot reload классов, если загруженный класс нельзя перезагрузить?
?
Создать новый ClassLoader, который загрузит обновлённую версию класса. Старый ClassLoader и его классы станут кандидатами на GC (если нет ссылок). Spring DevTools использует два ClassLoader: base (библиотеки) и restart (пользовательский код, пересоздаётся при изменениях).

Что такое Context ClassLoader и зачем он нужен?
?
ClassLoader, привязанный к потоку через Thread.getContextClassLoader(). Решает проблему "class loader inversion": позволяет коду, загруженному родительским ClassLoader (например, ServiceLoader из JDK), находить реализации из дочернего ClassLoader.

Почему два класса с одинаковым именем могут вызвать ClassCastException?
?
Класс в JVM уникально идентифицируется парой (ClassLoader, FullyQualifiedName). Два ClassLoader загружают один и тот же .class файл -- для JVM это два разных типа, несовместимых при присваивании.

---

## Куда дальше

| Направление | Куда | Зачем |
|-------------|------|-------|
| Следующий шаг | [[jvm-jit-compiler]] | Понять, что происходит с загруженным классом дальше -- компиляция в native code |
| Углубиться | [[jvm-module-system]] | JPMS добавляет контроль видимости поверх ClassLoader |
| Связанная тема | [[jvm-bytecode-manipulation]] | Java Agent API перехватывает классы в момент загрузки |
| Смежная область | [[compilation-pipeline]] | Как работает компиляция в других языках и VM -- сравнение подходов |
| Обзор | [[jvm-overview]] | Вернуться к карте раздела |

---

*Проверено: 2026-02-11 | Источники: JVM Spec, Venners (2000), Liang & Bracha (1998), Baeldung, Spring docs*
