---
title: "Стандарт глубины: учебник-энциклопедия"
created: 2026-02-10
modified: 2026-02-10
type: reference
status: published
confidence: high
tags:
  - system/guidelines
  - system/metadata
related:
  - "[[improvements]]"
  - "[[content-types]]"
  - "[[content-levels]]"
  - "[[cognitive-science-rules]]"
---

# Стандарт глубины: учебник-энциклопедия

> Каждый материал — глава учебника. Понятная с нуля, с источниками, с объяснением каждого термина. Теория доминирует. Код — иллюстрация.

---

## Философия

Vault — не инженерный справочник и не набор шпаргалок. Это **теоретический учебник-энциклопедия**: сборка лучших источников по каждой теме, написанная так, чтобы человек с нулевыми знаниями (при наличии prerequisites) понял каждую концепцию.

Три принципа:
1. **Теория доминирует** — текст объясняет, код иллюстрирует
2. **Понятность с нуля** — каждый термин объяснён, каждый переход обоснован
3. **Источники** — каждый файл опирается на признанные книги и papers

---

## Соотношение контента

### Для deep-dive и concept (intermediate+)

```
Текст (теория, объяснения, история, аналогии):  80%+
Диаграммы (ASCII, таблицы):                      10-15%
Код (иллюстрации):                               5-10%
```

### Почему 80%+ текста

Текст — основной носитель знания. Читатель учится через объяснение, не через копирование кода. Код помогает увидеть абстрактную идею в конкретном виде, но без окружающего текста он бесполезен.

> **Научная база:** Dual Coding Theory (Paivio, 1986) — визуал дополняет текст, но не заменяет. Текст формирует семантические связи в долговременной памяти, код формирует процедурные.

### Правила для кода

```
Каждый фрагмент кода:
□ Не более 10-15 строк
□ Каждая строка прокомментирована — ПОЧЕМУ, не ЧТО
□ Абзац ДО кода: что будем показывать и зачем
□ Абзац ПОСЛЕ кода: что это демонстрирует, какой вывод

Количество code blocks на файл:
- concept: 3-5 (ключевые, тщательно разобранные)
- deep-dive: 5-8 (каждый обёрнут пояснениями)
- tutorial: столько, сколько нужно
- reference: по необходимости
```

---

## Минимальный объём пояснительного текста

Объём считается в словах **пояснительного текста** (без кода и таблиц).

| Тип \ Уровень | Beginner | Intermediate | Advanced |
|---------------|:--------:|:------------:|:--------:|
| concept | 1500-3000 | 3000-5000 | 5000-8000 |
| deep-dive | 3000-5000 | 5000-8000 | 8000-12000 |
| comparison | 1500-2500 | 2500-4000 | 4000-6000 |
| explainer | 800-1500 | 1500-3000 | 3000-5000 |
| reference | 500-1000 | 1000-2000 | 2000-3000 |

### Что это значит на практике

**3000-5000 слов (intermediate concept)** — это 6-10 страниц текста. Примерно как одна глава учебника. Каждая концепция занимает 3-5 абзацев, не одно предложение.

**5000-8000 слов (intermediate deep-dive)** — это 10-16 страниц. Полноценная глава с историей, несколькими аналогиями, пошаговыми объяснениями и разбором заблуждений.

---

## Обязательные элементы (учебник-формат)

### Каждый файл intermediate+ MUST иметь:

#### Структура

```
□ Вводный абзац (что + зачем + ключевой инсайт) — 50-100 слов
□ "Зачем это знать" — мотивация: конкретная проблема, которую решает понимание темы
□ Терминология — таблица терминов с аналогиями из реальной жизни
□ Историческая справка — кто, когда, почему придумали (с датами и именами)
□ Prerequisites — таблица со ссылками на prerequisite-материалы
```

#### Теория

```
□ Каждая концепция — минимум 3-5 абзацев развёрнутого объяснения
  (не "X — это Y", а развёрнутое рассуждение: что, почему, как, зачем)
□ Минимум 2 аналогии из реальной жизни (НЕ из IT)
□ Минимум 2 ASCII-диаграммы с объяснением КАЖДОГО элемента в тексте
□ Мостики между разделами — текстовый переход
  ("Мы разобрали ГДЕ живут объекты. Но КТО их убирает?")
□ "Почему именно так" — объяснение design decisions и исторических причин
□ "Распространённые заблуждения" — что люди думают неправильно и почему
```

#### Границы

```
□ "Когда НЕ применяется" — ограничения с объяснением причин
□ "Подводные камни" — что может пойти не так и почему
```

#### Связи

```
□ Секция "Связь с другими темами" — абзац про каждую related-ссылку:
  чем связано, что даёт понимание одного для другого, в каком порядке читать
□ "Что читать дальше" — рекомендованный порядок чтения
```

#### Источники

```
□ Секция "Источники и дальнейшее чтение"
□ Минимум 2-3 признанных источника (книги, papers, talks)
□ Формат: Автор (год). Название. — зачем читать / что даёт
```

---

## Правило "Код как иллюстрация" (Code as Illustration)

### Антипаттерн: код как основной контент

```markdown
❌ ПЛОХО:

## Mutex

```kotlin
val mutex = Mutex()
mutex.lock()
try { sharedState++ }
finally { mutex.unlock() }
```

Код есть. Объяснения нет. Читатель видит синтаксис,
но не понимает ЗАЧЕМ, ПОЧЕМУ, и ЧТО будет если этого не делать.
```

### Правильно: код иллюстрирует теорию

```markdown
✅ ХОРОШО:

## Mutex: взаимное исключение

Mutex (mutual exclusion) — механизм, гарантирующий что только один
поток в каждый момент времени выполняет критическую секцию кода.

Представь дверь с одним ключом: пока один человек внутри, остальные
ждут у двери. Ключ — это mutex. Человек берёт ключ (lock), входит,
делает дело, выходит и возвращает ключ (unlock). Пока ключ занят —
никто другой войти не может.

Почему это нужно? Без mutex два потока могут одновременно читать
и записывать одну переменную. Результат непредсказуем — это
называется race condition (гонка данных). Классический пример:
два кассира одновременно снимают деньги с одного счёта.

```kotlin
val mutex = Mutex()          // Создаём "ключ от двери"
mutex.lock()                 // Берём ключ — теперь мы одни внутри
try {
    sharedState++            // Безопасно: никто другой не изменит
} finally {
    mutex.unlock()           // Возвращаем ключ — следующий может войти
}
```

Блок `try/finally` гарантирует, что ключ будет возвращён даже если
внутри произошла ошибка. Без этого — deadlock: ключ потерян,
остальные ждут вечно. Это одна из самых частых ошибок при работе
с блокировками (подробнее: [[synchronization-primitives]]).
```

### Чеклист для каждого code block

```
□ Абзац ДО: что будем показывать и зачем
□ Комментарии в коде: ПОЧЕМУ, не ЧТО
□ Абзац ПОСЛЕ: что это демонстрирует, какой вывод, что будет если не делать
□ Код ≤ 15 строк (если больше — разбить на части с объяснениями между)
```

---

## Правило источников

### MUST для каждого файла intermediate+

```
□ Минимум 2 признанных источника (книги, статьи, доклады)
□ Формат: Автор (год). Название. — зачем читать / что даёт
□ Приоритет: учебники > papers > talks > блоги
```

### Каталог признанных источников по областям

**Memory & OS:**
- Tanenbaum, A. (2014). Modern Operating Systems — фундамент: процессы, память, файловые системы
- Bryant, R. & O'Hallaron, D. (2015). Computer Systems: A Programmer's Perspective — связь hardware и software
- Love, R. (2010). Linux Kernel Development — как это реализовано в Linux
- Silberschatz, A. et al. (2018). Operating System Concepts — альтернативный учебник, хорош для сравнения

**Compilation:**
- Aho, A. et al. (2006). Compilers: Principles, Techniques, and Tools (Dragon Book) — каноническая книга по компиляторам
- Appel, A. (1998). Modern Compiler Implementation — более практичный подход
- Grune, D. et al. (2012). Modern Compiler Design — современный взгляд

**Type Systems:**
- Pierce, B. (2002). Types and Programming Languages (TAPL) — библия систем типов
- Cardelli, L. & Wegner, P. (1985). On Understanding Types, Data Abstraction, and Polymorphism — фундаментальная статья

**Concurrency:**
- Herlihy, M. & Shavit, N. (2012). The Art of Multiprocessor Programming — от теории к практике
- Ben-Ari, M. (2006). Principles of Concurrent and Distributed Programming — академический подход
- Pike, R. (2012). Concurrency is not Parallelism (talk) — каноническое объяснение разницы

**Algorithms & Data Structures:**
- Cormen, T. et al. (2009). Introduction to Algorithms (CLRS) — стандартный учебник
- Sedgewick, R. & Wayne, K. (2011). Algorithms — более доступный подход
- Knuth, D. (1997). The Art of Computer Programming — для глубокого погружения
- Halim, S. (2013). Competitive Programming Handbook — для олимпиадных структур данных

**General CS:**
- Abelson, H. & Sussman, G. (1996). Structure and Interpretation of Computer Programs (SICP)
- Patterson, D. & Hennessy, J. (2017). Computer Organization and Design — архитектура компьютера

---

## Понятность с нуля (Zero-Knowledge Accessibility)

### Принцип

Каждый файл intermediate+ должен быть понятен человеку, который:
- Имеет prerequisites (указаны в frontmatter)
- Имеет НУЛЕВЫЕ знания по текущей теме
- Возможно, имеет проблемы с концентрацией (ADHD)

> **Научная база:** Зона ближайшего развития (Vygotsky, 1978) — эффективное обучение возможно только в зоне между "уже знаю" и "слишком сложно". Prerequisites определяют нижнюю границу. Текущий материал — содержимое зоны.

### Что это значит на практике

```
□ Каждый термин объяснён при первом появлении
□ Нет "подразумеваемых" знаний — всё явно
□ Аналогии из реальной жизни для абстрактных концепций
□ Переход от простого к сложному (scaffolding)
□ Каждый раздел опирается на предыдущий
```

### Антипаттерн

```
❌ "Type erasure обеспечивает backwards compatibility через raw types."
(Предполагает знание: что такое erasure, что такое backwards compatibility
в контексте generics, что такое raw types)

✅ "Когда Java 5 добавила generics в 2004, миллионы строк кода уже
работали без них. Удалить старый код нельзя — сломаешь всё. Решение:
компилятор проверяет типы, а потом СТИРАЕТ их (type erasure). В
байткоде List<String> и List<Integer> — одинаковые. Это позволило
старому коду работать с новым без изменений, но создало проблемы..."
```

---

## ADHD-friendly структура

> **Источник:** Gloria Mark (2016) — средний attention span на одном экране: 47 секунд.

```
□ Визуальный прерыватель каждые 200-300 слов
  (диаграмма, таблица, callout, code block)
□ Короткие абзацы (3-5 предложений максимум)
□ Заголовки — вопросы или утверждения
  ("ПОЧЕМУ память разделена?", не "Организация памяти")
□ Мостики между разделами — текстовый переход
  ("Мы разобрали X. Но остался вопрос: Y?")
□ Callout-боксы для ключевых идей:
  > **Ключевая идея:** ...
□ Разная длина предложений:
  Короткое. Среднее с контекстом. А иногда длинное,
  которое связывает идеи и разворачивает мысль.
```

---

## Чеклист перед публикацией

> 7 пунктов — в пределах эффективности (Gawande, 2009)

```
□ Текст 80%+ (теория доминирует, код — иллюстрация)
□ Каждая концепция: 3-5 абзацев объяснения (не 1 предложение)
□ Каждый code block обёрнут пояснениями (абзац до + абзац после)
□ Источники: 2+ признанных книг/papers с пояснением "зачем читать"
□ Связи: абзац-объяснение для каждой related-ссылки
□ Понятность: термины объяснены при первом появлении
□ Визуальный прерыватель каждые 200-300 слов
```

---

## Связанные файлы

- [[improvements]] — MUST/SHOULD/NICE чеклисты (пункт 7: глубина и источники)
- [[content-types]] — типы контента и обязательные элементы
- [[content-levels]] — уровни качества и Bloom's Taxonomy
- [[cognitive-science-rules]] — научная база: Scaffolding, Dual Coding, Source Authority

---

*Создано: 2026-02-10*
