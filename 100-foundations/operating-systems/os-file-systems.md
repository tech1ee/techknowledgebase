---
title: "Файловые системы: как данные хранятся на диске"
created: 2025-12-02
modified: 2025-12-02
type: deep-dive
status: published
area: operating-systems
confidence: high
tags:
  - topic/os
  - filesystem
  - storage
  - io
  - type/deep-dive
  - level/intermediate
related:
  - "[[os-overview]]"
  - "[[os-io-devices]]"
  - "[[database-design-optimization]]"
prerequisites:
  - "[[os-io-devices]]"
  - "[[os-memory-management]]"
reading_time: 45
difficulty: 7
study_status: not_started
mastery: 0
last_reviewed:
next_review:
---

# Файловые системы: как данные хранятся на диске

Файловая система — абстракция, превращающая блоки на диске в иерархию файлов и директорий. Она отвечает за организацию данных (где физически лежит файл), метаданные (имя, права, время модификации), и надёжность (что делать при сбое питания). Понимание файловых систем объясняет почему `fsync()` важен для баз данных, почему удаление большого файла может быть мгновенным, и как работает journaling.

---

## TL;DR

> **Что:** Файловая система = "библиотечный каталог" для диска. Превращает хаос блоков в файлы и папки.
>
> **Inode:** Каждый файл имеет inode — "паспорт" с метаданными (размер, права, указатели на блоки). Имя файла НЕ в inode, а в директории.
>
> **Journaling:** Перед изменением записываем намерение в journal. Если crash — можно восстановиться за секунды (vs часы fsck).
>
> **Page Cache:** Диск медленный → ОС кэширует данные в RAM. write() → cache → return, fsync() → диск.
>
> **fsync() важен:** Без него данные могут потеряться при crash. Базы данных обязательно используют fsync.
>
> **VFS:** Единый API для всех ФС (ext4, XFS, NFS) — приложения не зависят от конкретной ФС.

---

## Часть 1: Интуиция без кода

### 📚 Аналогия 1: Библиотека (файловая система)

**Файловая система — это библиотечный каталог**, превращающий хаос полок с книгами в организованную систему.

```
Физический диск (полки с книгами):
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
│ A │ B │ C │ D │ E │ F │ G │ H │ I │ J │ ← Блоки данных (4KB каждый)
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘

Файловая система (библиотечный каталог):
┌─────────────────────────────────────────────────────────────┐
│  Superblock: "В нашей библиотеке 1000 книг, 500 полок"      │
├─────────────────────────────────────────────────────────────┤
│  Inode #1: размер=3 блока, блоки=[A, C, F]                  │ → файл 1
│  Inode #2: размер=2 блока, блоки=[B, E]                     │ → файл 2
│  Inode #3: размер=4 блока, блоки=[D, G, H, I]               │ → файл 3
├─────────────────────────────────────────────────────────────┤
│  Директория /home:                                          │
│    "report.txt"  → inode #1                                 │
│    "photo.jpg"   → inode #2                                 │
│    "video.mp4"   → inode #3                                 │
└─────────────────────────────────────────────────────────────┘
```

**Ключевой инсайт:** Имя файла НЕ в inode! Директория — это просто таблица "имя → inode".

### 🪪 Аналогия 2: Паспорт файла (Inode)

**Inode — это паспорт файла**, содержащий всё о файле, кроме имени:

```
┌─────────────────────────────────────────────────────────────┐
│                    ПАСПОРТ (INODE #42)                       │
├─────────────────────────────────────────────────────────────┤
│  Тип: обычный файл                                          │
│  Размер: 12,345 байт                                        │
│  Владелец: user (uid=1000)                                  │
│  Группа: staff (gid=50)                                     │
│  Права: rwxr-xr-x (755)                                     │
│                                                             │
│  Создан: 2024-01-15 10:30:00                                │
│  Изменён: 2024-06-20 14:15:30                               │
│  Последний доступ: 2024-06-21 09:00:00                      │
│                                                             │
│  Блоки данных: [100, 101, 102, 505, 506]                    │
│                                                             │
│  Количество hardlinks: 2                                    │
│  (два имени указывают на этот inode)                        │
└─────────────────────────────────────────────────────────────┘

НЕТ ИМЕНИ В INODE! Имя хранится в директории.
```

**Почему это важно:**
1. `mv file1 file2` — мгновенно (меняется только запись в директории)
2. Можно иметь несколько имён для одного файла (hardlinks)
3. `ls -l` показывает данные из inode, а имя — из директории

### 📝 Аналогия 3: Черновик заказа (Journal)

**Journaling — это черновик**, куда записывают намерение перед действием:

```
Без journaling (crash = катастрофа):

Операция: создать файл
1. Обновить bitmap ✓
2. Записать inode  ← CRASH здесь!
3. Обновить директорию

Результат: bitmap говорит "блок занят", но файла нет!
fsck должен проверить ВСЕ блоки = часы на большом диске

─────────────────────────────────────────────────────────────

С journaling (crash = восстановление за секунды):

1. Записать в journal: "Собираюсь: bitmap+inode+dir"
2. Обновить bitmap ✓
3. Записать inode ← CRASH здесь!
4. Обновить директорию
5. Удалить запись из journal

При восстановлении:
- Читаем journal: "Операция не завершена"
- Откатываем или повторяем
- Готово за секунды!
```

**Режимы journaling:**
| Режим | Что журналируется | Скорость | Надёжность |
|-------|------------------|----------|------------|
| **metadata** (default ext4) | Только метаданные | Быстро | Файлы OK, данные могут быть мусором |
| **data=ordered** | Данные записываются ДО метаданных | Средне | Файлы целые, без мусора |
| **data=journal** | Всё: данные + метаданные | Медленно | Максимальная |

### 📋 Аналогия 4: Книга на столе vs в хранилище (Page Cache)

**Page Cache — это стол читателя**: книги из хранилища (диска) лежат на столе (RAM) для быстрого доступа.

```
RAM в 100,000 раз быстрее диска!

Без page cache:
read() → диск → 10ms → данные
write() → диск → 10ms → OK

С page cache:
read() → RAM (cache hit) → 100ns → данные
write() → RAM → 100ns → OK (диск потом)

┌─────────────────────────────────────────────────────────────┐
│                         RAM                                  │
│  ┌─────────────────────────────────────────────────────┐    │
│  │              PAGE CACHE (~50% свободной RAM)         │    │
│  │                                                      │    │
│  │  file.txt:  [page 0] [page 1] [page 2]              │    │
│  │  data.db:   [page 0] [page 1] ... [page 1000]       │    │
│  │  log.txt:   [page 0] ← dirty, ещё не на диске       │    │
│  │                                                      │    │
│  └─────────────────────────────────────────────────────┘    │
│                          ↑↓ sync                             │
├─────────────────────────────────────────────────────────────┤
│                         ДИСК                                 │
│                  (медленное хранилище)                       │
└─────────────────────────────────────────────────────────────┘

write() возвращается СРАЗУ (данные в cache)
fsync() гарантирует запись на диск
```

**Опасность:** Без fsync() данные могут потеряться при crash!

### 🔗 Аналогия 5: Два имени одной книги (Hardlink vs Symlink)

```
HARDLINK: два названия в каталоге → один inode

Директория /home/alice:
  "my_report.txt" → inode #42

Директория /home/bob:
  "shared_doc.txt" → inode #42  ← ТОТ ЖЕ inode!

- Удаление одного имени не удаляет файл
- Файл удаляется когда link count = 0
- Нельзя hardlink на другой раздел
- Нельзя hardlink на директорию

─────────────────────────────────────────────────────────────

SYMLINK: записка "файл там-то"

/home/alice/shortcut → "/home/bob/original.txt"

Symlink — это отдельный файл (свой inode),
содержащий ПУТЬ к другому файлу.

- Можно на другой раздел
- Можно на директорию
- Может быть "битым" (если original удалён)

┌──────────────────────────────────────────────────────────┐
│ $ ls -la /home/alice/                                     │
│                                                          │
│ -rw-r--r-- 2 alice staff  1234 my_report.txt            │
│            ^ link count = 2 (hardlink)                   │
│                                                          │
│ lrwxrwxrwx 1 alice staff    20 shortcut -> /home/bob/..  │
│ ^                               ^ содержимое = путь      │
│ l = symlink                                              │
└──────────────────────────────────────────────────────────┘
```

### 🔢 Численная интуиция

| Операция | HDD | SSD | Page Cache |
|----------|-----|-----|------------|
| Random read | 10 ms | 0.1 ms | 0.0001 ms |
| Sequential read | 100 MB/s | 500 MB/s | 10,000 MB/s |
| fsync() | 5-10 ms | 0.1-1 ms | N/A |

**Пример: база данных с fsync()**
```
Без fsync() (опасно!):
- INSERT → cache → 0.001 ms → "OK"
- CRASH → данные потеряны!

С fsync() на каждую транзакцию (надёжно, но медленно):
- INSERT → cache → fsync() → 10 ms → "OK"
- Max throughput на HDD: ~100 transactions/sec

С group commit (компромисс):
- Собираем 100 INSERTs → один fsync() → 10 ms
- Throughput: ~10,000 transactions/sec
```

**Почему ext4 default = metadata journaling:**
```
data=journal:  Всё через journal = 2x записи = медленно
data=ordered:  Данные до метаданных = безопасно, 1x записи
data=writeback: Без гарантий порядка = быстро, но данные могут быть мусором
```

---

## Часть 2: Почему это сложно

### ❌ Ошибка 1: "write() = данные на диске"

**СИМПТОМ:** Данные потеряны после crash, хотя write() вернул успех.

**ПОЧЕМУ ВОЗНИКАЕТ:** write() возвращается после записи в page cache, не на диск.

**ДЕМОНСТРАЦИЯ:**
```c
// ❌ Опасно: данные могут потеряться
int fd = open("important.txt", O_WRONLY | O_CREAT, 0644);
write(fd, data, size);  // → page cache (RAM)
close(fd);              // Данные всё ещё в RAM!
// CRASH → данные потеряны

// ✅ Безопасно: данные на диске
int fd = open("important.txt", O_WRONLY | O_CREAT, 0644);
write(fd, data, size);
fsync(fd);              // → диск (гарантированно)
close(fd);
```

**ПРАВИЛО:** Для критичных данных (БД, транзакции) ВСЕГДА используй fsync().

---

### ❌ Ошибка 2: "Удаление файла мгновенно освобождает место"

**СИМПТОМ:** `rm big_file.txt`, но `df` показывает то же свободное место.

**ПОЧЕМУ ВОЗНИКАЕТ:** Файл удаляется только когда:
1. Все hardlinks удалены (link count = 0)
2. Все процессы закрыли файл (open count = 0)

**ПРИМЕР:**
```bash
# Процесс A открывает файл
tail -f /var/log/huge.log &  # PID 1234, держит файл открытым

# Процесс B удаляет файл
rm /var/log/huge.log  # Удаляет имя, но НЕ данные!

# Проверяем
ls /var/log/huge.log  # "No such file"
df -h                 # Место НЕ освободилось!

# Находим "удалённый" файл
lsof | grep deleted
# tail 1234 ... /var/log/huge.log (deleted)

# Решение: убить процесс
kill 1234
df -h                 # Теперь место освободилось!
```

---

### ❌ Ошибка 3: "mv мгновенен, cp — нет"

**СИМПТОМ:** `mv` между разделами неожиданно долгий.

**ПОЧЕМУ ВОЗНИКАЕТ:** `mv` в пределах раздела = изменение записи в директории (мгновенно). `mv` между разделами = copy + delete.

```bash
# Мгновенно (тот же раздел)
mv /home/file.txt /home/backup/file.txt
# Просто меняется запись в директории

# Долго (разные разделы)
mv /home/file.txt /mnt/usb/file.txt
# 1. Копирование всех данных
# 2. Удаление оригинала
# Эквивалентно: cp + rm
```

**РЕШЕНИЕ:** Для атомарного перемещения — используй тот же раздел.

---

### ❌ Ошибка 4: "Больше inodes = лучше"

**СИМПТОМ:** "No space left on device", хотя `df` показывает свободное место.

**ПОЧЕМУ ВОЗНИКАЕТ:** Закончились inodes, не место.

```bash
$ df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1       100G   50G   50G  50% /

$ df -i
Filesystem      Inodes  IUsed   IFree IUse% Mounted on
/dev/sda1       6.5M    6.5M       0  100% /  ← Все inodes заняты!

# Много мелких файлов исчерпали inodes
# Например: миллион 1-байтовых файлов
```

**РЕШЕНИЕ:**
- Для много мелких файлов: выбирай ФС с большим числом inodes
- XFS, Btrfs создают inodes динамически
- Или используй базу данных вместо миллиона файлов

---

### ❌ Ошибка 5: "fsync(file) достаточно для надёжности"

**СИМПТОМ:** После crash файл пустой или отсутствует, хотя fsync() вызывали.

**ПОЧЕМУ ВОЗНИКАЕТ:** fsync() гарантирует данные файла, но НЕ запись в директорию!

```c
// ❌ Может потерять файл при crash
int fd = open("data/file.txt", O_CREAT | O_WRONLY, 0644);
write(fd, data, size);
fsync(fd);   // Данные файла на диске
close(fd);
// Но запись "file.txt" в директории "data/" может быть в cache!

// ✅ Полностью надёжно
int fd = open("data/file.txt", O_CREAT | O_WRONLY, 0644);
write(fd, data, size);
fsync(fd);   // Данные файла

int dir_fd = open("data/", O_RDONLY);
fsync(dir_fd);  // Запись в директорию тоже на диске!
close(dir_fd);
close(fd);
```

---

### ❌ Ошибка 6: Использование O_DIRECT без понимания

**СИМПТОМ:** "O_DIRECT быстрее" — но производительность хуже.

**ПОЧЕМУ ВОЗНИКАЕТ:** O_DIRECT обходит page cache, что убирает двойное копирование, НО:
- Требует выровненные буферы (alignment)
- Нет prefetch и read-ahead
- Каждый read() = реальный I/O

```c
// O_DIRECT требует выравнивание!
void* buf;
posix_memalign(&buf, 4096, size);  // Выравнивание на 4KB

int fd = open("file", O_RDONLY | O_DIRECT);
read(fd, buf, size);  // Прямо с диска, без cache
```

**КОГДА ИСПОЛЬЗОВАТЬ O_DIRECT:**
- База данных с собственным кэшем (PostgreSQL, MySQL)
- Избежать "двойного кэширования"

**КОГДА НЕ ИСПОЛЬЗОВАТЬ:**
- Обычные приложения (page cache эффективнее)
- Случайный доступ к мелким файлам

---

## Часть 3: Ментальные модели

### 🧠 Модель 1: "Путь от имени файла к данным"

```
open("/home/user/file.txt", O_RDONLY)

1. Найти inode корня "/"
   └── Superblock указывает: root inode = 2

2. Найти "home" в директории "/"
   └── Читаем блоки inode 2
   └── Находим запись: "home" → inode 100

3. Найти "user" в директории "home"
   └── Читаем блоки inode 100
   └── Находим: "user" → inode 150

4. Найти "file.txt" в директории "user"
   └── Читаем блоки inode 150
   └── Находим: "file.txt" → inode 200

5. Вернуть file descriptor, связанный с inode 200

read() использует указатели на блоки из inode 200
```

### 🧠 Модель 2: "Жизненный цикл записи"

```
write(fd, data, 1000)

┌─────────────────────────────────────────────────────────────┐
│ 1. Копируем данные в page cache                             │
│    user buffer → kernel page cache                          │
│    Страница помечается как "dirty"                          │
└───────────────────────────┬─────────────────────────────────┘
                            │ write() returns (async!)
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. Dirty pages в page cache                                 │
│    Ожидают записи на диск                                   │
│    Kernel периодически (30 сек) сбрасывает dirty pages     │
└───────────────────────────┬─────────────────────────────────┘
                            │ fsync() или dirty page writeback
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. Запись в journal (если journaling)                       │
│    "Собираюсь записать блок X с данными Y"                  │
└───────────────────────────┬─────────────────────────────────┘
                            │ journal commit
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. Запись данных на диск                                    │
│    Page → disk block                                        │
│    Page помечается как "clean"                              │
└───────────────────────────┬─────────────────────────────────┘
                            │ checkpoint
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. Очистка journal                                          │
│    Удаляем запись о завершённой операции                    │
└─────────────────────────────────────────────────────────────┘
```

### 🧠 Модель 3: "Сравнение файловых систем"

```
┌────────────────────────────────────────────────────────────────────────┐
│                      СРАВНЕНИЕ ФАЙЛОВЫХ СИСТЕМ                          │
├──────────────┬──────────────┬──────────────┬──────────────┬─────────────┤
│ Критерий     │ ext4         │ XFS          │ Btrfs        │ ZFS         │
├──────────────┼──────────────┼──────────────┼──────────────┼─────────────┤
│ Max file     │ 16 TB        │ 8 EB         │ 16 EB        │ 16 EB       │
│ Max FS       │ 1 EB         │ 8 EB         │ 16 EB        │ 256 ZB      │
├──────────────┼──────────────┼──────────────┼──────────────┼─────────────┤
│ Journaling   │ Да           │ Да           │ CoW          │ CoW         │
│ Snapshots    │ Нет          │ Нет          │ Да           │ Да          │
│ Checksums    │ Метаданные   │ Нет          │ Все данные   │ Все данные  │
│ RAID встроен │ Нет          │ Нет          │ Да           │ Да          │
├──────────────┼──────────────┼──────────────┼──────────────┼─────────────┤
│ Применение   │ General      │ Большие      │ Advanced     │ Enterprise  │
│              │ purpose      │ файлы, БД    │ desktop      │ storage     │
└──────────────┴──────────────┴──────────────┴──────────────┴─────────────┘
```

### 🧠 Модель 4: "VFS как адаптер"

```
┌─────────────────────────────────────────────────────────────┐
│                    ПРИЛОЖЕНИЕ                                │
│         open(), read(), write(), close()                     │
└───────────────────────────┬─────────────────────────────────┘
                            │ Единый API
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                         VFS                                  │
│              (Virtual File System)                           │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ struct inode, struct dentry, struct file            │   │
│  │ Общие структуры для всех файловых систем            │   │
│  └─────────────────────────────────────────────────────┘   │
└───────────────────────────┬─────────────────────────────────┘
         ┌──────────────────┼──────────────────┐
         │                  │                  │
         ↓                  ↓                  ↓
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   ext4_ops  │    │   xfs_ops   │    │   nfs_ops   │
│ ext4_read() │    │ xfs_read()  │    │ nfs_read()  │
│ ext4_write()│    │ xfs_write() │    │ nfs_write() │
└──────┬──────┘    └──────┬──────┘    └──────┬──────┘
       │                  │                  │
       ↓                  ↓                  ↓
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ Локальный   │    │ Локальный   │    │ Сетевой     │
│ диск (ext4) │    │ диск (XFS)  │    │ сервер      │
└─────────────┘    └─────────────┘    └─────────────┘
```

### 🧠 Модель 5: "Дерево решений: fsync или нет?"

```
Нужна ли durability (данные должны пережить crash)?
│
├── НЕТ (временные файлы, кэш)
│   └── Не вызывай fsync() → максимальная скорость
│
└── ДА (транзакции, пользовательские данные)
    │
    ├── Можно потерять последние N секунд?
    │   ├── ДА → sync каждые N секунд (fsyncd, pdflush)
    │   └── НЕТ → fsync() после каждой записи
    │
    └── Нужна атомарность (всё или ничего)?
        │
        ├── ДА → write temp file + fsync + rename
        │       (rename атомарен в POSIX)
        │
        └── НЕТ → просто fsync() достаточно

Паттерн "безопасная запись":
1. write("file.tmp", data)
2. fsync("file.tmp")
3. fsync(parent_dir)         # Важно!
4. rename("file.tmp", "file") # Атомарно!
5. fsync(parent_dir)         # Гарантирует rename
```

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| [[os-overview]] | Базовые концепции ОС, syscalls (open, read, write) | Предыдущий материал раздела |
| [[os-io-devices]] | Как ОС взаимодействует с дисками (блочные устройства, DMA) | Предыдущий материал (рекомендуется) |
| Блочные устройства | Понимание что диск работает блоками по 512B/4KB | [Linux Journey: Block Devices](https://linuxjourney.com/) |
| Основы командной строки | Практика с mount, df, stat | [Linux Journey](https://linuxjourney.com/) |

**Время на подготовку:** ~2-3 дня если знаете предыдущие темы

---

## Терминология для новичков

| Термин | Что это | Аналогия из жизни |
|--------|---------|-------------------|
| **Блок (Block)** | Минимальная единица чтения/записи (обычно 4KB) | Страница книги: ОС не читает буквы, только целые страницы |
| **Inode** | "Паспорт" файла: размер, права, указатели на блоки. Имя НЕ здесь! | Карточка в библиотечном каталоге: вся информация о книге, кроме названия |
| **Superblock** | Метаданные всей файловой системы (размер, кол-во inodes) | Обложка библиотечного каталога: сколько книг, сколько полок |
| **Journal** | Лог "что собираемся сделать" для recovery | Черновик заказа: если упадём — знаем что делали |
| **Extent** | Непрерывная последовательность блоков | Полка с серией книг подряд (vs разбросанные по библиотеке) |
| **Фрагментация** | Блоки файла разбросаны по диску | Главы книги на разных этажах — долго собирать |
| **VFS** | Единый API для разных ФС (ext4, XFS, NFS) | Универсальный пульт для всех телевизоров |
| **Page Cache** | Кэш файловых данных в RAM (быстрее диска в 100,000x) | Книги на столе читателя vs в хранилище |
| **fsync()** | Принудительная запись кэша на диск | "Сохранить" в документе — данные точно на диске |
| **Hardlink** | Второе имя для того же inode | Два названия одной книги в каталоге |
| **Symlink** | Ссылка на путь (может быть битой) | Записка "книга в комнате 5" (комната может быть пустой) |
| **Copy-on-Write** | Копирование только при изменении | Фотокопия делается только когда кто-то хочет исправить оригинал |

---

## Структура диска

### Физический уровень

```
HDD:                              SSD:
┌─────────────────────────┐      ┌─────────────────────────┐
│ Секторы по 512 байт     │      │ Pages по 4-16 KB        │
│ на вращающихся пластинах│      │ в NAND flash чипах      │
│                         │      │                         │
│ Seek time: 5-10ms       │      │ Latency: 0.05-0.1ms     │
│ Sequential: 100-200 MB/s│      │ Sequential: 500+ MB/s   │
└─────────────────────────┘      └─────────────────────────┘
```

### Логический уровень

```
┌─────────────────────────────────────────────────────────────────┐
│                          ДИСК                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────┬──────────────┬────────────────────────────────┐  │
│  │ Boot     │ Superblock   │ Блоки данных и метаданных      │  │
│  │ Sector   │              │                                │  │
│  │          │ - размер FS  │ ┌────────┬────────┬──────────┐ │  │
│  │          │ - кол-во     │ │ Inodes │ Bitmaps│ Data     │ │  │
│  │          │   inodes     │ │        │        │ Blocks   │ │  │
│  │          │ - свободное  │ │        │        │          │ │  │
│  │          │   место      │ └────────┴────────┴──────────┘ │  │
│  └──────────┴──────────────┴────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Inode: сердце файловой системы

### Что такое inode

Inode (index node) — структура данных, хранящая всю информацию о файле **кроме имени**:

```c
// Упрощённая структура inode
struct inode {
    uint32_t mode;           // Тип файла + права (rwxr-xr-x)
    uint32_t uid;            // Владелец
    uint32_t gid;            // Группа
    uint64_t size;           // Размер в байтах
    time_t atime;            // Access time
    time_t mtime;            // Modification time
    time_t ctime;            // Change time (метаданные)
    uint32_t link_count;     // Количество hard links
    uint32_t blocks[15];     // Указатели на блоки данных
    // [0-11]: прямые указатели
    // [12]: indirect (указатель на блок указателей)
    // [13]: double indirect
    // [14]: triple indirect
};
```

### Почему имя не в inode?

Один файл может иметь несколько имён (hard links). Имена хранятся в директориях — специальных файлах, которые содержат mapping "имя → номер inode".

```
Директория /home/user:
┌──────────────────────────────────────┐
│ Name           │ Inode Number        │
├──────────────────────────────────────┤
│ .              │ 1001                │  (сама директория)
│ ..             │ 1000                │  (родительская)
│ document.txt   │ 2345                │
│ photo.jpg      │ 2346                │
│ link_to_doc    │ 2345                │  (hard link на тот же inode!)
└──────────────────────────────────────┘
```

### Указатели на блоки данных

Для маленьких файлов достаточно 12 прямых указателей (12 × 4KB = 48KB).

Для больших файлов — indirect pointers:

```
Размер блока: 4KB
Размер указателя: 4 байта
Указателей в блоке: 4KB / 4 = 1024

Прямые указатели (12):
  12 × 4KB = 48 KB

Single indirect:
  1024 × 4KB = 4 MB

Double indirect:
  1024 × 1024 × 4KB = 4 GB

Triple indirect:
  1024 × 1024 × 1024 × 4KB = 4 TB

┌────────────────────────────────────────────────────────────────┐
│                        INODE                                    │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  Direct [0-11] ──────────▶ Data Block                          │
│                                                                │
│  Indirect [12] ──────────▶ ┌──────────┐                        │
│                            │ ptr → DB │                        │
│                            │ ptr → DB │                        │
│                            │ ...      │                        │
│                            └──────────┘                        │
│                                                                │
│  Double Indirect [13] ───▶ ┌──────────┐    ┌──────────┐       │
│                            │ ptr ──────────▶│ ptr → DB │       │
│                            │ ptr ─────┐    │ ...      │       │
│                            └──────────┘    └──────────┘       │
│                                    │       ┌──────────┐       │
│                                    └──────▶│ ptr → DB │       │
│                                            │ ...      │       │
│                                            └──────────┘       │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## Операции с файлами

### Чтение файла

```
read("/home/user/document.txt", buffer, 100):

1. Найти inode корневой директории (/)
   - Номер inode "/" известен (обычно 2)

2. Прочитать директорию /, найти "home"
   - Получить номер inode "home"

3. Прочитать директорию /home, найти "user"
   - Получить номер inode "user"

4. Прочитать директорию /home/user, найти "document.txt"
   - Получить номер inode = 2345

5. Прочитать inode 2345
   - Получить указатели на блоки данных

6. Прочитать нужные блоки данных
   - Вернуть содержимое

Каждый шаг = чтение с диска (без кэша)
Path traversal дорогой!
```

### Запись файла

```
write(fd, data, 100):

1. Найти inode файла (по file descriptor)

2. Найти блок для записи
   - Если файл не имеет места → выделить новый блок
   - Обновить bitmap свободных блоков

3. Записать данные в блок

4. Обновить inode
   - size
   - mtime
   - указатели (если новый блок)

5. Данные в page cache (не на диске!)
   - write() возвращается
   - Позже: writeback на диск
```

### Удаление файла

```
unlink("/home/user/document.txt"):

1. Найти inode директории /home/user

2. Удалить запись "document.txt" из директории

3. Уменьшить link_count в inode файла

4. Если link_count == 0 и файл не открыт:
   - Освободить блоки данных (пометить в bitmap как свободные)
   - Освободить inode

Почему "удаление" мгновенно:
- Данные НЕ стираются
- Только метаданные обновляются
- Блоки помечаются как свободные
```

---

## Journaling: защита от сбоев

### Проблема без journaling

Запись файла — несколько операций:
1. Записать данные в блок
2. Обновить inode
3. Обновить bitmap

Если питание отключится между шагами — файловая система повреждена.

```
Сценарий повреждения:

1. Записали данные в новый блок ✓
2. Обновили inode, добавили указатель на блок ✓
3. [СБОЙ ПИТАНИЯ]
4. Bitmap не обновлён — блок считается свободным!

После перезагрузки:
- Файл указывает на блок X
- Bitmap говорит блок X свободен
- Создаётся новый файл → получает блок X → данные перезаписаны!
```

### Решение: Journal

Перед изменением файловой системы записываем намерение в journal:

```
┌─────────────────────────────────────────────────────────────────┐
│                    JOURNALING WRITE                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Записать в journal:                                         │
│     "Собираюсь: обновить inode X, bitmap Y, блок Z"             │
│                                                                 │
│  2. Выполнить операции на файловой системе                      │
│                                                                 │
│  3. Пометить транзакцию в journal как завершённую               │
│                                                                 │
│  При recovery после сбоя:                                       │
│  - Незавершённые транзакции → отменить (rollback)               │
│  - Завершённые транзакции → проверить, доделать (redo)          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Типы journaling

**Data journaling (полный):** Журналируются и метаданные, и данные. Надёжно, но медленно — данные пишутся дважды.

**Metadata journaling (ordered):** Журналируются только метаданные. Данные пишутся до метаданных. ext4 default.

**Writeback:** Журналируются только метаданные. Порядок записи данных не гарантирован. Быстро, но данные могут быть повреждены.

---

## Основные файловые системы

### ext4 (Linux default)

```
Характеристики:
- Максимальный размер файла: 16 TB
- Максимальный размер FS: 1 EB
- Extents вместо block mapping (меньше фрагментация)
- Delayed allocation (лучше производительность)
- Metadata journaling

Команды:
mkfs.ext4 /dev/sda1
tune2fs -l /dev/sda1    # Информация о FS
```

### XFS (enterprise, large files)

```
Характеристики:
- Оптимизирован для больших файлов
- Отличная параллельная запись
- Allocation groups (параллелизм)
- Online defragmentation

Используется: Red Hat Enterprise, high-performance storage
```

### Btrfs (modern, copy-on-write)

```
Характеристики:
- Copy-on-Write (COW)
- Snapshots (мгновенные снимки)
- Встроенная компрессия
- Checksums для данных (обнаружение повреждений)
- RAID на уровне FS

Используется: SUSE, Facebook (для некоторых workloads)
```

### ZFS (enterprise, data integrity)

```
Характеристики:
- Checksums везде (end-to-end integrity)
- Copy-on-Write
- Snapshots и clones
- Встроенный RAID-Z
- Дедупликация
- Требует много RAM

Используется: FreeBSD, enterprise storage, NAS
```

---

## Page Cache

### Зачем кэшировать

Диск медленный (даже SSD). Ядро кэширует прочитанные данные в RAM:

```
Без кэша:                  С кэшем:
read() → disk (10ms)       read() → RAM (100ns) = 100,000x быстрее!

┌─────────────────────────────────────────────────────────────────┐
│                         PAGE CACHE                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Application                                                    │
│      │                                                          │
│      ▼ read(fd, buf, 4096)                                      │
│  ┌───────────┐                                                  │
│  │ VFS Layer │                                                  │
│  └─────┬─────┘                                                  │
│        │                                                        │
│        ▼                                                        │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │                      PAGE CACHE                            │ │
│  │  ┌─────────────────────────────────────────────────────┐  │ │
│  │  │ file X, page 0 │ file X, page 1 │ file Y, page 0 │  │  │ │
│  │  └─────────────────────────────────────────────────────┘  │ │
│  │                                                            │ │
│  │  Cache Hit? ──Yes──▶ Return from RAM                       │ │
│  │      │                                                     │ │
│  │      No                                                    │ │
│  │      │                                                     │ │
│  │      ▼                                                     │ │
│  │  Read from disk, add to cache, return                      │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Write-back vs Write-through

**Write-back (Linux default):**
1. write() записывает в page cache
2. Страница помечается "dirty"
3. write() возвращается (быстро!)
4. Позже: background writeback на диск

**Write-through:**
1. write() записывает в cache И на диск
2. write() возвращается только после записи на диск
3. Медленно, но данные гарантированно на диске

### fsync() и fdatasync()

```c
// fsync — принудительная запись на диск
int fd = open("important.dat", O_WRONLY);
write(fd, data, size);

fsync(fd);  // Ждём, пока данные на диске
// Теперь данные гарантированно сохранены

// fdatasync — только данные, не метаданные
fdatasync(fd);  // Быстрее fsync, но mtime может не обновиться
```

**Почему это важно для баз данных:**
```
Без fsync:
1. Database записывает транзакцию
2. write() возвращается
3. Database говорит "committed"
4. [СБОЙ ПИТАНИЯ]
5. Данные в page cache потеряны!

С fsync:
1. Database записывает транзакцию
2. fsync() ждёт записи на диск
3. Database говорит "committed"
4. [СБОЙ ПИТАНИЯ]
5. Данные на диске, транзакция восстановлена
```

---

## VFS: Virtual File System

VFS — слой абстракции, позволяющий работать с разными файловыми системами через единый API:

```
┌─────────────────────────────────────────────────────────────────┐
│                    APPLICATION                                   │
│                    open(), read(), write()                       │
└─────────────────────────────────────────┬───────────────────────┘
                                          │
                                          ▼
┌─────────────────────────────────────────────────────────────────┐
│                          VFS LAYER                               │
│                                                                 │
│  struct inode, struct dentry, struct file                       │
│  Общий интерфейс для всех файловых систем                       │
└─────────────────────────────────────────┬───────────────────────┘
                                          │
          ┌───────────────────────────────┼───────────────────────┐
          │                               │                       │
          ▼                               ▼                       ▼
┌─────────────────┐           ┌─────────────────┐     ┌─────────────────┐
│      ext4       │           │      XFS        │     │      NFS        │
│                 │           │                 │     │   (network)     │
└─────────────────┘           └─────────────────┘     └─────────────────┘
```

Благодаря VFS:
- `ls` работает одинаково на ext4, XFS, NFS
- Приложения не зависят от конкретной файловой системы
- Можно монтировать разные FS в одно дерево

---

## Подводные камни файловых систем

### 1. fsync() не гарантирует durability

```c
write(fd, data, size);  // Данные в page cache
fsync(fd);              // Данные на диске... или нет?
```

**Проблема:** Некоторые диски врут о fsync (write-back cache без battery). Данные в кэше контроллера, не на пластинах.

**Решение:** Для критичных данных — диски с battery-backed cache или отключение write cache.

### 2. rename() атомарность — только в пределах одной ФС

```bash
mv /home/user/file /tmp/file  # Может быть НЕ атомарно!
# /home и /tmp могут быть на разных ФС
```

**Атомарный rename:** Только если source и destination на одной файловой системе.

### 3. Ext4 delayed allocation и потеря данных

```c
fd = open("file", O_CREAT);
write(fd, data, size);
// Crash here!
// Данные могут быть потеряны — delayed allocation
```

**Проблема:** ext4 откладывает выделение блоков. При crash данные в памяти теряются.

**Решение:** fsync() после критичных записей, или O_SYNC флаг.

### 4. Hardlinks и inode confusion

```bash
ln file1 file2          # Тот же inode
echo "new" > file1      # file2 тоже изменился!
rm file1                # file2 всё ещё существует
```

**Ловушка:** Hardlinks разделяют inode. Изменение одного — изменение всех.

### 5. Журнал защищает метаданные, не данные

**ext4 default (ordered):** Журналирует метаданные, данные пишет перед метаданными.
**ext4 data=journal:** Журналирует и данные — медленнее, но безопаснее.

При crash без data=journal: метаданные консистентны, но данные файла могут быть мусором.

---

## Практические команды

```bash
# Информация о файловой системе
df -h                     # Использование дискового пространства
df -i                     # Использование inodes
stat file.txt             # Информация о файле (включая inode)
ls -i                     # Показать номера inodes

# Операции с файловыми системами
mount                     # Показать смонтированные FS
mount /dev/sda1 /mnt      # Смонтировать
umount /mnt               # Отмонтировать

# Журнал и recovery
journalctl -k | grep ext4 # Сообщения ядра о ext4
fsck /dev/sda1            # Проверка файловой системы

# Page cache
free -h                   # buff/cache показывает размер page cache
sync                      # Записать dirty pages на диск
echo 3 > /proc/sys/vm/drop_caches  # Очистить cache (для тестов)

# Мониторинг I/O
iostat -x 1               # Статистика I/O
iotop                     # I/O по процессам
```

---

## Связь с другими темами

**[[os-overview]]** — Обзор ОС объясняет системные вызовы (open, read, write, close), через которые приложения взаимодействуют с файловой системой, и VFS (Virtual File System) — абстракцию, позволяющую ядру работать с ext4, XFS, Btrfs и NFS через единый интерфейс. Каждый файловый системный вызов проходит через VFS layer, затем конкретную FS-реализацию, затем block I/O layer — и понимание этого стека критично для диагностики производительности. Концепция file descriptor, возвращаемого open(), связывает процесс с файлом через таблицу открытых файлов ядра и таблицу inodes. Понимание kernel/user mode разделения объясняет, почему каждый read()/write() — это системный вызов с переходом в ядро, что мотивирует буферизацию в userspace (stdio).

**[[os-io-devices]]** — Устройства ввода-вывода являются физическим фундаментом файловых систем: файловая система — это абстракция поверх блочного устройства (HDD, SSD, NVMe). Понимание разницы между HDD (seek time 4-10 ms, sequential throughput 100-200 MB/s) и SSD (random access 50-100 µs, throughput 500-7000 MB/s) объясняет, почему файловые системы оптимизируют размещение данных по-разному: ext4 использует extents для sequential allocation, а Btrfs — COW (Copy-on-Write) для SSD-friendly записи. Механизмы DMA и interrupt-driven I/O определяют, как данные перемещаются между диском и page cache без участия CPU. Планировщик I/O (CFQ, mq-deadline, BFQ) взаимодействует с файловой системой, переупорядочивая запросы для минимизации seek time на HDD.

**[[database-design-optimization]]** — Базы данных строят свои storage engine поверх файловых систем (или обходят их через direct I/O), и понимание FS-механизмов критично для оптимизации производительности БД. Многие СУБД (PostgreSQL, MySQL InnoDB) используют O_DIRECT для обхода page cache ядра, реализуя собственный buffer pool с более интеллектуальным управлением — ядро не знает паттерны доступа к B-tree страницам, а БД знает. Журналирование файловой системы (ext4 journal) и WAL (Write-Ahead Log) базы данных решают одну и ту же проблему — crash recovery — но на разных уровнях абстракции; двойное журналирование (FS + DB) создаёт overhead, который O_DIRECT помогает устранить. fsync() — критическая операция для durability баз данных: без fsync() после записи WAL данные могут потеряться при crash, а стоимость fsync() (0.1-10 ms) определяет максимальную пропускную способность транзакций.

**Связанные концепции:**
- [[os-memory-management]] — page cache использует виртуальную память, mmap() связывает файлы и память
- [[os-virtualization]] — контейнеры могут использовать overlay filesystems (aufs, overlayfs)

---

## Рекомендуемые источники

### Учебники

- Tanenbaum A., Bos H. (2014). *"Modern Operating Systems, 4th Edition."* — глава 4 (File Systems) покрывает от directory structure до journaling и NFS; глава 11 (Case Study: Linux) показывает реализацию VFS и ext-семейства в Linux.
- Silberschatz A., Galvin P., Gagne G. (2018). *"Operating System Concepts, 10th Edition."* — главы 13 (File-System Interface), 14 (File-System Implementation) и 15 (File-System Internals) — полный цикл от API до allocation methods (contiguous, linked, indexed) и free-space management; хорош для подготовки к экзаменам.
- Arpaci-Dusseau R., Arpaci-Dusseau A. (2018). *"Operating Systems: Three Easy Pieces."* — главы 36-43 (Persistence) — от устройств до crash consistency и journaling, с пошаговыми примерами создания файла и fsck; бесплатно.
- Bryant R., O'Hallaron D. (2015). *"Computer Systems: A Programmer's Perspective, 3rd Edition."* — глава 10 (System-Level I/O) объясняет Unix I/O модель (file descriptors, buffering) с точки зрения программиста; практический код с open/read/write/mmap.
- Love R. (2010). *"Linux Kernel Development, 3rd Edition."* — глава 13 (The Virtual Filesystem) и глава 16 (The Page Cache and Page Writeback) — VFS как абстракция, inode operations, dentry cache, writeback механизм в ядре Linux.

### Книги и курсы
- [OSTEP: File Systems chapters](https://pages.cs.wisc.edu/~remzi/OSTEP/file-intro.pdf) — бесплатная книга, главы 36-43
- [MIT 6.S081: File System lab](https://pdos.csail.mit.edu/6.1810/2025/) — практическая работа с ФС в xv6

### Официальная документация
- [ext4 Documentation](https://www.kernel.org/doc/html/latest/admin-guide/ext4.html) — документация Linux kernel
- [XFS Documentation](https://xfs.wiki.kernel.org/) — официальная wiki XFS

### Статьи и туториалы
- [GeeksforGeeks: File Systems](https://www.geeksforgeeks.org/operating-systems/file-systems-in-operating-system/) — базовое объяснение
- [LWN: Ext4 design](https://lwn.net/Articles/283128/) — глубокий анализ ext4
- [Understanding fsync](https://blog.httrack.com/blog/2013/11/15/everything-you-always-wanted-to-know-about-fsync/) — почему fsync важен

---

*Обновлено: 2026-01-09 — добавлены педагогические секции (5 аналогий: библиотека, паспорт/inode, черновик/journal, page cache, hardlink vs symlink; 6 типичных ошибок; 5 ментальных моделей: путь к данным, жизненный цикл записи, сравнение ФС, VFS адаптер, дерево решений fsync)*

---

## Проверь себя

> [!question]- PostgreSQL гарантирует durability через WAL (Write-Ahead Log). Объясни, почему одного write() недостаточно и какую роль играет fsync() в цепочке durability.
> `write()` помещает данные в page cache ОС (RAM) и возвращается. Данные ещё **не на диске** — при crash (сбой питания, kernel panic) они потеряются. `fsync(fd)` заставляет ядро записать все dirty pages файла на физическое устройство и дождаться подтверждения. Цепочка durability: `write()` → page cache → `fsync()` → disk controller cache → пластины диска. Но даже fsync() может быть ненадёжен: некоторые диски врут о записи (write-back cache без battery). Для полной гарантии: battery-backed disk cache или `O_SYNC` флаг. PostgreSQL делает WAL write + fsync при каждом COMMIT — стоимость 0.1-10 ms определяет max TPS.

> [!question]- Разработчик удалил файл на 10 GB, но `df -h` показывает, что свободное место не увеличилось. Объясни механизм и как решить проблему.
> Файл удалён из directory entry (имя отвязано от inode), но inode и блоки данных не освобождены, потому что у файла **открытый file descriptor** в каком-то процессе. В Unix/Linux файл физически удаляется (inode + blocks freed), когда link count = 0 И нет открытых fd. `lsof +D /path | grep deleted` покажет процесс. Решения: (1) перезапустить процесс — fd закроется, блоки освободятся; (2) `> /proc/<pid>/fd/<fd_number>` — truncate файл через /proc (не удаляя fd); (3) для production: graceful restart сервиса.

> [!question]- Почему ext4 с delayed allocation может потерять данные при crash, хотя journaling "гарантирует" целостность? Какой режим журнала это исправляет?
> ext4 **delayed allocation** откладывает выделение дисковых блоков: `write()` → данные в page cache → блоки НЕ выделены на диске. При crash данные в page cache теряются. Journaling (default mode=ordered) журналирует только **метаданные**, не данные. Ordered mode гарантирует порядок: данные пишутся перед метаданными — но delayed allocation ломает это, потому что данные ещё не имеют блоков. **`data=journal`** — журналирует и данные тоже: данные → journal → диск. Безопаснее, но медленнее (двойная запись). Альтернатива: использовать `fsync()` после каждой критичной записи.

> [!question]- Сервер с ext4 показывает "No space left on device", но `df -h` показывает 40% свободного места. В чём причина и как диагностировать?
> Закончились **inodes**, не дисковое пространство. `df -i` покажет: 100% inode usage. Каждый файл (даже пустой) требует inode. Количество inodes фиксируется при создании ФС (`mkfs.ext4 -N`). Причина: миллионы мелких файлов (mail spool, session files, cache). Диагностика: `find / -xdev -type d | while read d; do echo "$(ls -1 "$d" | wc -l) $d"; done | sort -rn | head` — найти директории с максимумом файлов. Решения: (1) удалить ненужные файлы; (2) пересоздать ФС с `-N` (больше inodes); (3) для будущего: XFS или Btrfs (динамические inodes, не фиксированные).

---

## Ключевые карточки

Что такое inode и что он НЕ хранит?
?
Inode — структура данных, описывающая файл: права доступа (mode), владелец (uid/gid), размер, timestamps (atime, mtime, ctime), указатели на блоки данных, счётчик hardlinks (nlink). Inode **НЕ хранит имя файла** — имя хранится в directory entry, которая связывает строку-имя с номером inode. Один inode может иметь несколько имён (hardlinks).

В чём разница между hardlink и symlink?
?
**Hardlink:** новое имя для того же inode (разделяют данные). Нельзя на директории. Нельзя между ФС. `rm` удаляет только имя, данные живут пока nlink > 0. **Symlink:** отдельный файл со строкой-путём к target. Может на директории. Может между ФС. Может быть "битым" (target удалён). Symlink имеет свой inode, hardlink — нет.

Почему write() возвращается быстро, а fsync() медленно?
?
**write():** записывает в page cache (RAM), помечает страницу dirty, возвращается. ~100 ns. Данные НЕ на диске. **fsync():** ждёт пока ядро запишет ВСЕ dirty pages файла на физическое устройство. 0.1-10 ms (зависит от объёма и устройства). Без fsync — данные потеряются при crash. С fsync — durability гарантирована. Writeback daemon ядра периодически (каждые ~30 sec) записывает dirty pages без fsync.

Как journaling ускоряет recovery после crash?
?
**Без журнала:** при crash нужен полный fsck — проверка ВСЕЙ файловой системы. На больших дисках — часы. **С журналом:** операции записываются в journal ДО выполнения. При crash — replay незавершённых транзакций (секунды). Три режима ext4: **writeback** (метаданные в журнал, данные когда угодно), **ordered** (данные до метаданных, default), **journal** (и данные, и метаданные — самый безопасный, самый медленный).

Что делает VFS (Virtual File System)?
?
VFS — абстракция ядра, предоставляющая единый API (open/read/write/close) для всех файловых систем. Приложение вызывает read() → VFS определяет какая ФС → вызывает конкретную реализацию (ext4, XFS, NFS). Благодаря VFS: `ls` работает одинаково на ext4 и NFS, можно монтировать разные ФС в одно дерево, приложения не зависят от конкретной ФС.

Что такое page cache и почему повторное чтение файла быстрее?
?
Page cache — кэш содержимого файлов в RAM. При первом read(): данные загружаются с диска (~10ms HDD, ~0.1ms SSD) в page cache. При повторном read(): данные уже в RAM (~100 ns) — 100,000x быстрее. Ядро автоматически управляет: кэширует часто читаемые файлы, вытесняет редко используемые при нехватке RAM. `free -h` показывает размер в колонке buff/cache.

Почему базы данных используют O_DIRECT?
?
O_DIRECT обходит page cache ОС: данные пишутся/читаются напрямую с диска. Причины: (1) БД имеют свой buffer pool, оптимизированный для B-tree доступа — page cache ОС не знает паттерны доступа БД; (2) двойная буферизация (page cache + buffer pool) тратит RAM; (3) O_DIRECT + WAL = контроль durability. PostgreSQL, MySQL InnoDB используют O_DIRECT для data files.

---

## Куда дальше

| Направление | Куда | Зачем |
|-------------|------|-------|
| Следующий шаг | [[os-io-devices]] | Файловая система — абстракция поверх блочных устройств (HDD, SSD) |
| Следующий шаг | [[os-memory-management]] | Page cache, mmap() связывают файлы с виртуальной памятью |
| Углубиться | [[database-design-optimization]] | БД строят storage engine поверх FS, используют O_DIRECT и fsync |
| Углубиться | [[os-virtualization]] | OverlayFS — layered FS для Docker контейнеров |
| Смежная тема | [[databases-transactions-acid]] | Durability в ACID реализуется через fsync() + WAL |
| Смежная тема | [[git-workflows]] | Git — content-addressable filesystem с объектами по SHA |
| Обзор | [[os-overview]] | Вернуться к карте раздела Operating Systems |

---

*Последнее обновление: 2026-02-14*
*Проверено: 2026-02-14*
