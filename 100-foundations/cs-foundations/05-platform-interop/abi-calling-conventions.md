---
title: "ABI и Calling Conventions: как бинарный код общается"
created: 2026-01-04
modified: 2026-02-13
type: deep-dive
reading_time: 28
difficulty: 9
study_status: not_started
mastery: 0
last_reviewed:
next_review:
status: published
tags:
  - topic/cs-foundations
  - type/deep-dive
  - level/expert
related:
  - "[[memory-model-fundamentals]]"
  - "[[native-compilation-llvm]]"
  - "[[ffi-foreign-function-interface]]"
prerequisites:
  - "[[cpu-architecture-basics]]"
  - "[[memory-model-fundamentals]]"
  - "[[native-compilation-llvm]]"
  - "[[ffi-foreign-function-interface]]"
---

# ABI и Calling Conventions: как бинарный код общается

> **TL;DR:** ABI (Application Binary Interface) — контракт между скомпилированным кодом и операционной системой. Calling convention определяет: в каких регистрах передавать аргументы, кто очищает стек, какие регистры сохраняются. x86-64 System V (Linux/macOS): аргументы в RDI, RSI, RDX, RCX, R8, R9; возврат в RAX. ARM64 AAPCS: аргументы в X0-X7; возврат в X0. ABI stability критична для библиотек — изменение ABI требует перекомпиляции всех зависимостей.

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **Memory Model** | Stack vs heap, адресация | [[memory-model-fundamentals]] |
| **Native Compilation** | Как код становится машинным | [[native-compilation-llvm]] |

---

## Терминология

| Термин | Что это | Аналогия из жизни |
|--------|---------|-------------------|
| **ABI** | Бинарный контракт между программой и ОС | Стандарт размера розеток в стране |
| **Calling Convention** | Правила вызова функций | Протокол телефонного разговора: кто первый говорит, кто кладёт трубку |
| **Register** | Сверхбыстрая память в CPU | Карманы рабочего — самое доступное место |
| **Stack Frame** | Область стека для одного вызова функции | Страница в блокноте для одной задачи |
| **Caller** | Функция, которая вызывает другую | Тот, кто звонит |
| **Callee** | Функция, которую вызвали | Тот, кому звонят |

---

## Зачем это знать

Понимание ABI — одна из тех тем, которые отделяют разработчика, "пишущего код", от разработчика, "понимающего, что происходит под капотом". Когда ты вызываешь функцию из чужой библиотеки, когда линкуешь C-код с Kotlin/Native, когда обновляешь системную библиотеку и внезапно всё ломается — за всем этим стоит ABI.

Без понимания ABI ты не сможешь объяснить, почему приложение крашится после обновления зависимости без изменения кода. Почему одна и та же функция вызывается по-разному на Linux и Windows. Почему Kotlin/Native генерирует разные бинарники для `iosArm64` и `iosX64`. Всё это — вопросы ABI.

> **Ключевая идея:** ABI — это "язык жестов" машинного кода. Два скомпилированных модуля, собранных разными компиляторами, в разное время, могут работать вместе только потому, что оба следуют одному ABI.

---

## Историческая справка

Проблема бинарной совместимости возникла не сразу. В эпоху первых компьютеров (1950-60-е) каждая программа была монолитной — один файл, один компилятор, один запуск. Никакого взаимодействия между отдельно скомпилированными модулями не требовалось.

Всё изменилось с появлением **раздельной компиляции** (separate compilation) и **библиотек**. В 1970-х годах Unix ввёл концепцию shared libraries — общих библиотек, которые загружались в память один раз и использовались несколькими программами. Внезапно появилась проблема: если библиотеку обновили, а программу не перекомпилировали, всё должно продолжить работать. Для этого нужен был контракт на бинарном уровне.

Термин "ABI" формализовался в 1980-х, когда UNIX System V определил первый стандарт ABI для платформы. Документ описывал всё: от layout данных в памяти до правил вызова функций. Это позволило разным производителям выпускать совместимые Unix-системы.

В 2003 году AMD опубликовала x86-64 System V ABI для новой 64-битной архитектуры, ставший стандартом для Linux и macOS. Microsoft пошла своим путём, создав собственный x64 calling convention для Windows. Эта историческая развилка объясняет, почему один и тот же C-код, скомпилированный на Linux и Windows, использует разные регистры для передачи аргументов.

ARM тоже создал свой стандарт — AAPCS (ARM Architecture Procedure Call Standard), который стал основой для iOS и Android. С выходом Swift 5.0 в 2019 году Apple достигла ABI stability для Swift — важнейшая веха, позволившая включить Swift runtime в саму ОС.

---

## ЧТО такое ABI и ПОЧЕМУ он нужен

### Аналогия: протокол общения между незнакомцами

Представь, что ты приехал в чужую страну и тебе нужно отправить посылку. Ты не знаешь местного языка, местный почтальон не знает твоего. Но вы оба знаете международные почтовые стандарты: куда писать адрес, какого размера должна быть коробка, какие документы приложить. Этот общий стандарт и есть аналог ABI.

ABI (Application Binary Interface) — контракт, определяющий, как скомпилированный код взаимодействует с другим скомпилированным кодом и с операционной системой. Важно подчеркнуть: ABI работает на уровне **машинного кода**, а не исходного. Ты не видишь ABI, когда пишешь программу на Kotlin. Но компилятор обязан ему следовать, иначе твой код не сможет вызывать системные функции и библиотеки.

Подобно тому, как дипломатический протокол определяет, кто первым подаёт руку, кто садится первым, кто говорит первым — ABI определяет, кто передаёт аргументы, куда их кладёт, кто очищает ресурсы после вызова. Без этого протокола два скомпилированных модуля — как два дипломата из разных стран без переводчика: каждый делает по-своему, результат — хаос.

Почему нельзя обойтись без ABI? Потому что в реальных системах код компилируется **по частям**. Операционная система скомпилирована отдельно от приложения. Библиотека SQLite скомпилирована отдельно от твоего кода. Kotlin/Native runtime скомпилирован отдельно от твоего бизнес-кода. Все эти модули должны "говорить на одном языке" на бинарном уровне — и этот язык определяет ABI.

### Проблема: код компилируется отдельно

Представь ситуацию: ты написал приложение на Kotlin/Native. Оно использует библиотеку, скомпилированную кем-то другим. Как твой код "общается" с библиотекой?

```
┌─────────────────────────────────────────────────────────────┐
│                    ПРОБЛЕМА БЕЗ ABI                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Твой код (Kotlin):                                        │
│   val result = someLibrary.calculate(10, 20)                │
│                                                             │
│   Библиотека (C):                                           │
│   int calculate(int a, int b) { return a + b; }             │
│                                                             │
│   ВОПРОСЫ:                                                  │
│   - Где искать аргументы 10 и 20?                          │
│   - В регистрах? В каких? В стеке?                         │
│   - Куда положить результат 30?                            │
│   - Кто должен освободить память?                          │
│                                                             │
│   Без соглашений — хаос. Код не сможет общаться.           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Аналогия: международная почта

ABI — как международные почтовые стандарты:

- **Формат адреса:** куда писать страну, индекс, город
- **Размер конверта:** стандартные размеры для автоматической сортировки
- **Язык адреса:** латиница для международных отправлений

Без этих стандартов письма бы терялись. Каждая страна изобретала бы свой формат.

### ABI vs API

Многие путают эти понятия:

| Аспект | API | ABI |
|--------|-----|-----|
| **Уровень** | Исходный код | Машинный код |
| **Что определяет** | Имена функций, типы параметров | Регистры, stack layout, name mangling |
| **Когда нужен** | При написании кода | При линковке и runtime |
| **Изменение** | Требует переписывания кода | Требует перекомпиляции |

```
┌─────────────────────────────────────────────────────────────┐
│                    API vs ABI                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   API (Source Level):                                       │
│   fun greet(name: String): String                          │
│                                                             │
│   "Функция greet принимает строку, возвращает строку"      │
│                                                             │
│   ─────────────────────────────────────────────────────    │
│                                                             │
│   ABI (Binary Level):                                       │
│   - name передаётся в регистре RDI                         │
│   - Возврат через RAX (указатель на строку)                │
│   - Символ: _Z5greetPKc (name mangling)                    │
│   - Stack alignment: 16 bytes                              │
│                                                             │
│   "КАК именно это происходит на уровне машинного кода"     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## ЧТО определяет ABI

ABI — это набор соглашений о:

### 1. Calling Conventions

Как вызывать функции:
- Где передавать аргументы (регистры, стек)
- Как возвращать значения
- Кто очищает стек после вызова

### 2. Data Representation

Как представлять данные:
- Размеры примитивных типов (`int` = 4 байта)
- Alignment (выравнивание)
- Порядок байтов (endianness)
- Layout структур

### 3. Name Mangling

Как кодировать имена функций:
- C++: `greet(std::string)` → `_Z5greetNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE`
- C: `greet` → `greet` (без mangling)

### 4. Exception Handling

Как обрабатывать исключения:
- Stack unwinding
- Exception tables

### 5. System Calls

Как обращаться к ОС:
- Номера syscall
- Регистры для параметров

---

## Calling Conventions: КАК функция "общается" с вызывающим

### Аналогия: отправка письма

Calling convention — это как правила отправки посылки. Представь, что ты отправляешь посылку (вызываешь функцию):

1. **Куда положить содержимое?** — В ящик (регистры) или на полку (стек)?
2. **В каком порядке?** — Сначала большие предметы, потом мелкие? Или наоборот?
3. **Кто забирает коробку со склада?** — Отправитель (caller) или получатель (callee)?
4. **Куда положить ответ?** — В определённый ящик (регистр RAX/X0)?

Разные страны (платформы) установили разные правила. Именно поэтому существует несколько calling conventions, и каждая платформа выбрала свой вариант исходя из своей архитектуры и исторических причин.

Ключевых вопросов, на которые отвечает calling convention, всего четыре: (1) где передаются аргументы, (2) где возвращается результат, (3) кто отвечает за очистку стека, (4) какие регистры вызываемая функция обязана сохранить. Эти четыре решения определяют всё поведение вызова на бинарном уровне.

### Обзор основных конвенций

| Convention | Аргументы | Очистка стека | Где используется |
|------------|-----------|---------------|------------------|
| **cdecl** | Stack (RTL) | Caller | C default, varargs |
| **stdcall** | Stack (RTL) | Callee | Win32 API |
| **fastcall** | Registers + stack | Callee | Performance-critical |
| **System V x64** | 6 регистров + stack | Caller | Linux/macOS x64 |
| **Microsoft x64** | 4 регистра + stack | Caller | Windows x64 |
| **AAPCS64** | 8 регистров + stack | Caller | ARM64 (iOS, Android) |

### cdecl (C Declaration)

Классическая конвенция для C на x86:

```
┌─────────────────────────────────────────────────────────────┐
│                    cdecl: calculate(10, 20)                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Caller (вызывающий):                                      │
│   1. push 20         ; Второй аргумент в стек              │
│   2. push 10         ; Первый аргумент в стек              │
│   3. call calculate  ; Вызов функции                       │
│   4. add esp, 8      ; Caller очищает стек!                │
│                                                             │
│   Stack (до вызова):        Stack (после push):            │
│   │           │              │    20     │ ← ESP           │
│   │           │              │    10     │                  │
│   │           │              │ ret addr  │                  │
│   └───────────┘              └───────────┘                  │
│                                                             │
│   RTL = Right To Left: аргументы справа налево             │
│   Это позволяет varargs (printf)!                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**Почему caller очищает стек?**

Это позволяет функции с переменным числом аргументов (varargs):

```c
printf("%d %d %d", 1, 2, 3);  // 4 аргумента
printf("%d", 42);              // 2 аргумента
```

`printf` не знает сколько аргументов получила. Только caller знает и очищает.

### stdcall (Standard Call)

Конвенция Win32 API:

```
┌─────────────────────────────────────────────────────────────┐
│                    stdcall vs cdecl                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   cdecl:                      stdcall:                      │
│   push arg2                   push arg2                     │
│   push arg1                   push arg1                     │
│   call func                   call func                     │
│   add esp, 8  ← Caller        ; Callee очищает!            │
│                               ; ret 8 внутри func           │
│                                                             │
│   Преимущество stdcall:                                     │
│   Меньше кода в caller (очистка один раз в callee)         │
│                                                             │
│   Недостаток:                                               │
│   Нельзя varargs — callee должен знать размер              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### x86-64 System V ABI (Linux/macOS)

Современная конвенция для 64-bit:

```
┌─────────────────────────────────────────────────────────────┐
│                 x86-64 System V ABI                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   INTEGER ARGUMENTS (первые 6):                             │
│   ┌─────┬─────┬─────┬─────┬─────┬─────┐                    │
│   │ RDI │ RSI │ RDX │ RCX │  R8 │  R9 │                    │
│   │ 1st │ 2nd │ 3rd │ 4th │ 5th │ 6th │                    │
│   └─────┴─────┴─────┴─────┴─────┴─────┘                    │
│   7+ аргументы → stack                                      │
│                                                             │
│   FLOATING POINT (первые 8):                                │
│   XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6, XMM7           │
│                                                             │
│   RETURN VALUE:                                             │
│   RAX        — integer/pointer (64 bit)                    │
│   RAX + RDX  — 128 bit values                              │
│   XMM0       — floating point                              │
│                                                             │
│   CALLEE-SAVED (сохраняет вызываемая функция):             │
│   RBX, RBP, R12, R13, R14, R15                             │
│                                                             │
│   CALLER-SAVED (может изменить вызываемая):                │
│   RAX, RDI, RSI, RDX, RCX, R8, R9, R10, R11                │
│                                                             │
│   STACK ALIGNMENT: 16 bytes                                 │
│   RED ZONE: 128 bytes ниже RSP (можно использовать)        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**Пример вызова на System V:**

```c
long calculate(long a, long b, long c) {
    return a + b + c;
}

// Вызов: calculate(10, 20, 30)
```

```asm
; Caller
mov rdi, 10      ; Первый аргумент
mov rsi, 20      ; Второй аргумент
mov rdx, 30      ; Третий аргумент
call calculate
; Результат в RAX

; Callee (calculate)
calculate:
    ; a в RDI, b в RSI, c в RDX
    add rdi, rsi
    add rdi, rdx
    mov rax, rdi  ; Возврат через RAX
    ret
```

### ARM64 AAPCS (iOS, Android)

Apple и Android используют ARM64 AAPCS:

```
┌─────────────────────────────────────────────────────────────┐
│                    ARM64 AAPCS                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   INTEGER ARGUMENTS (первые 8):                             │
│   ┌────┬────┬────┬────┬────┬────┬────┬────┐                │
│   │ X0 │ X1 │ X2 │ X3 │ X4 │ X5 │ X6 │ X7 │                │
│   └────┴────┴────┴────┴────┴────┴────┴────┘                │
│   9+ аргументы → stack                                      │
│                                                             │
│   FLOATING POINT: V0-V7                                     │
│                                                             │
│   RETURN VALUE:                                             │
│   X0        — integer/pointer                              │
│   X0 + X1   — 128 bit                                      │
│   V0        — floating point                               │
│                                                             │
│   SPECIAL REGISTERS:                                        │
│   X29 (FP)  — Frame Pointer                                │
│   X30 (LR)  — Link Register (return address)               │
│   X18 (PR)  — Platform Register (reserved)                 │
│   SP        — Stack Pointer                                │
│                                                             │
│   CALLEE-SAVED: X19-X28, V8-V15 (lower 64 bits)            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**Почему ARM использует Link Register (LR)?**

На x86 return address кладётся в стек командой `call`. ARM использует регистр X30 (LR):

```asm
; x86-64
call function    ; Push return address to stack — адрес сохраняется в стеке
ret              ; Pop and jump — извлекаем адрес из стека

; ARM64
bl function      ; Branch with Link — адрес сохраняется в регистре LR
ret              ; Branch to LR — прыгаем по адресу из регистра
```

Для leaf functions (функций, которые не вызывают другие функции) подход ARM даёт существенное преимущество: не нужно трогать стек для сохранения и восстановления адреса возврата. Регистр быстрее стека примерно в 100 раз (1 cycle vs доступ к памяти). Если функция вызывает другие функции (non-leaf), она всё равно должна сохранить LR в стек, но таких функций статистически меньше.

Мы разобрали, КАК разные конвенции передают аргументы и возвращают результаты. Но остаётся важный вопрос: КАК компилятор "запоминает", какой функции принадлежит какое имя в бинарном коде? Этот вопрос приводит нас к name mangling.

---

## Name Mangling: ПОЧЕМУ компиляторы меняют имена

### Проблема перегрузки

В C имя функции уникально: не может быть двух функций `add`. Но C++ и Kotlin поддерживают **перегрузку** (overloading) — несколько функций с одним именем, но разными параметрами. На уровне исходного кода компилятор различает их по сигнатуре. Но в бинарном файле имена должны быть уникальными строками, потому что линкер работает с символами как с текстовыми идентификаторами.

Представь себе библиотеку с двумя функциями:

```cpp
int add(int a, int b);        // Сложение целых чисел
double add(double a, double b); // Сложение дробных чисел
```

Как линкер узнает, какую `add` вызвать? Если обе называются `add` в бинарном файле — никак. Поэтому компилятор **искажает** (mangles) имена, кодируя в них информацию о типах параметров.

### Как работает mangling

Каждый компилятор использует свою схему, но идея одинаковая — закодировать сигнатуру функции в её имя.

```
┌─────────────────────────────────────────────────────────────┐
│                    NAME MANGLING                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Исходный код C++:                                        │
│   int add(int, int)              → _Z3addii                │
│   double add(double, double)     → _Z3adddd                │
│   void MyClass::method(int)      → _ZN7MyClass6methodEi    │
│                                                             │
│   Декодирование _Z3addii:                                  │
│   _Z  — префикс mangled имени (Itanium ABI)               │
│   3   — длина имени "add" (3 символа)                      │
│   add — имя функции                                        │
│   i   — параметр типа int                                  │
│   i   — ещё один параметр типа int                         │
│                                                             │
│   Исходный код C:                                          │
│   int add(int, int)              → add (без mangling!)     │
│                                                             │
│   Поэтому extern "C" отключает mangling:                   │
│   extern "C" int add(int, int)   → add                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

Именно поэтому C-библиотеки так легко использовать через FFI: их имена не искажены. Функция `sqlite3_open` в бинарном файле так и называется `sqlite3_open`. А вот C++ библиотеки без `extern "C"` обёрток вызвать из другого языка почти невозможно, потому что каждый компилятор использует свою схему mangling.

> **Важно:** Стандарт C++ не определяет формат mangling. GCC и Clang используют Itanium ABI (одинаковый формат), но MSVC на Windows использует свой. Это одна из причин, почему смешивать объектные файлы от разных компиляторов C++ опасно.

Аналогия из жизни: mangling — это как паспортная система. В жизни может быть много людей с именем "Алексей". Но в паспорте каждый уникален: "Алексей Иванович Петров, 01.01.1990, Москва". Компилятор делает то же самое — превращает неуникальное имя функции в уникальный идентификатор, добавляя "паспортные данные" (типы параметров, класс, namespace).

Kotlin/Native при компиляции в native-код тоже использует mangling, но по своей схеме. При взаимодействии с C-кодом через cinterop, Kotlin/Native генерирует bindings, которые используют оригинальные C-имена (без mangling), обеспечивая совместимость.

Мы разобрали, как компиляторы кодируют имена функций. Но есть ещё один важный механизм, который ABI определяет на бинарном уровне — полиморфизм. Как процессор "знает", какую версию метода вызвать для конкретного объекта?

---

## Vtable: КАК полиморфизм реализован на уровне машинного кода

### Проблема: какой метод вызвать?

Когда ты пишешь `animal.speak()`, компилятор не знает на этапе компиляции, какой именно метод вызвать — `Cat.speak()` или `Dog.speak()`. Это определяется в runtime, когда известен реальный тип объекта. Но machine code не умеет "думать" — он умеет только прыгать по адресам. Как реализовать такой "выбор" без if/else?

Ответ — **vtable** (virtual method table), или таблица виртуальных методов. Это массив указателей на функции, который компилятор создаёт для каждого класса, имеющего виртуальные методы.

### Аналогия: телефонный справочник

Представь, что каждая организация (класс) имеет свой телефонный справочник (vtable). В справочнике записано: "Отдел продаж — номер 123", "Бухгалтерия — номер 456". У разных организаций одни и те же "должности" (методы), но разные номера телефонов (адреса функций).

Когда кто-то звонит и говорит "соедините с отделом продаж", секретарь (CPU) смотрит в справочник своей организации и набирает нужный номер. Справочник определяется типом организации, а не тем, кто звонит.

### Как устроена vtable

```
┌─────────────────────────────────────────────────────────────┐
│                    VTABLE MECHANISM                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   open class Animal {                                       │
│       open fun speak() { ... }    // Индекс 0 в vtable      │
│       open fun move() { ... }     // Индекс 1 в vtable      │
│   }                                                         │
│   class Cat : Animal() {                                    │
│       override fun speak() { ... } // Свой адрес по индексу 0│
│   }                                                         │
│                                                             │
│   Animal vtable:              Cat vtable:                   │
│   ┌─────┬────────────┐      ┌─────┬────────────┐           │
│   │  0  │ Animal.speak│      │  0  │ Cat.speak  │           │
│   │  1  │ Animal.move │      │  1  │ Animal.move│           │
│   └─────┴────────────┘      └─────┴────────────┘           │
│                                                             │
│   Объект Cat в памяти:                                      │
│   ┌────────────────────┐                                    │
│   │ vptr ──────────────┼──▶ Cat vtable                      │
│   │ field1             │                                    │
│   │ field2             │                                    │
│   └────────────────────┘                                    │
│                                                             │
│   animal.speak() компилируется в:                           │
│   1. Загрузить vptr из объекта          (1 memory read)     │
│   2. По vptr найти vtable                                   │
│   3. Взять адрес по индексу 0           (1 memory read)     │
│   4. Вызвать функцию по этому адресу    (indirect call)     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

Каждый объект, имеющий виртуальные методы, содержит скрытое поле — **vptr** (virtual table pointer). Это указатель на vtable своего класса. Когда компилятор видит вызов виртуального метода, он генерирует не прямой вызов функции (`call Cat_speak`), а косвенный: "загрузи адрес из vtable, прыгни туда".

Стоимость виртуального вызова — обычно 2 дополнительных чтения памяти (vptr + vtable entry) и один indirect branch. На практике это 5-25 наносекунд — незаметно для единичных вызовов, но ощутимо в tight loops с миллионами итераций.

> **Ключевая идея:** Vtable — это причина, по которой добавление виртуального метода в базовый класс ломает ABI. Все индексы в vtable сдвигаются, и код, скомпилированный со старой vtable, будет вызывать не те методы.

### Vtable и ABI stability

Почему vtable напрямую связан с ABI? Потому что порядок методов в vtable — часть бинарного контракта. Если библиотека v1.0 имела vtable `[speak, move]`, а v2.0 добавила метод `eat` между ними — `[speak, eat, move]` — весь код, скомпилированный под v1.0, будет вызывать `eat` вместо `move` по индексу 1. Это одна из самых коварных форм ABI breakage, потому что программа не крашится сразу — она просто вызывает не ту функцию.

В C++ это хорошо известная проблема, и COM (Component Object Model) на Windows решал её, фиксируя vtable layout как часть контракта интерфейса. В Java и Kotlin на JVM vtable управляется виртуальной машиной, которая пересчитывает индексы при загрузке классов, поэтому ABI breakage на уровне vtable в JVM-мире не существует. Но в Kotlin/Native, который компилируется в native-код, vtable вновь становится частью ABI.

Итак, мы разобрали name mangling и vtable — два механизма, которые ABI определяет для корректной работы скомпилированного кода. Теперь вернёмся к физической структуре вызова функции — stack frame.

---

## Stack Frame: анатомия

### Структура кадра стека

```
┌─────────────────────────────────────────────────────────────┐
│                    STACK FRAME                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Высокие адреса                                            │
│   ┌─────────────────┐                                       │
│   │  Argument 8+    │  ← Аргументы сверх регистров         │
│   │  Argument 7     │                                       │
│   ├─────────────────┤                                       │
│   │  Return Address │  ← Куда вернуться после ret          │
│   ├─────────────────┤                                       │
│   │  Saved RBP      │  ← Предыдущий frame pointer          │
│   ├─────────────────┤ ← RBP указывает сюда                 │
│   │  Local var 1    │                                       │
│   │  Local var 2    │                                       │
│   │  ...            │                                       │
│   ├─────────────────┤                                       │
│   │  Saved regs     │  ← Callee-saved регистры             │
│   ├─────────────────┤                                       │
│   │  (Red zone)     │  ← 128 bytes для leaf functions      │
│   └─────────────────┘ ← RSP указывает сюда                 │
│   Низкие адреса                                             │
│                                                             │
│   Stack растёт ВНИЗ (к меньшим адресам)                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Пролог и эпилог функции

```asm
; Function prologue (начало)
push rbp           ; Сохранить старый frame pointer
mov rbp, rsp       ; Установить новый frame pointer
sub rsp, 32        ; Выделить место для локальных переменных
push rbx           ; Сохранить callee-saved регистры

; ... тело функции ...

; Function epilogue (конец)
pop rbx            ; Восстановить callee-saved
mov rsp, rbp       ; Освободить локальные переменные
pop rbp            ; Восстановить старый frame pointer
ret                ; Вернуться
```

### Red Zone (System V)

System V ABI определяет "красную зону" — 128 байт ниже RSP, которые можно использовать без изменения RSP:

```
┌─────────────────────────────────────────────────────────────┐
│                    RED ZONE                                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Обычно:                       С Red Zone:                 │
│   sub rsp, 16                   ; Ничего не делаем         │
│   mov [rsp], rax                mov [rsp-8], rax           │
│   ...                           ...                         │
│   add rsp, 16                   ; Ничего не делаем         │
│                                                             │
│   Условие: leaf function (не вызывает другие функции)      │
│   Преимущество: быстрее, меньше инструкций                 │
│                                                             │
│   Windows x64 НЕ имеет red zone — нужен shadow space       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## ABI Stability: почему это важно

### Что ломает ABI

| Изменение | Ломает ABI? | Почему |
|-----------|-------------|--------|
| Добавить аргумент в функцию | Да | Другие регистры/stack layout |
| Изменить порядок полей struct | Да | Смещения полей изменятся |
| Добавить поле в struct | Да | Размер struct изменится |
| Изменить calling convention | Да | Весь механизм вызова другой |
| Добавить новую функцию | Нет | Не влияет на существующий код |
| Изменить реализацию (не сигнатуру) | Нет | Интерфейс не изменился |

### Пример поломки ABI

```c
// Версия 1.0
struct User {
    int id;
    char name[32];
};

// Версия 2.0 — добавили поле
struct User {
    int id;
    int age;        // НОВОЕ ПОЛЕ
    char name[32];
};
```

```
┌─────────────────────────────────────────────────────────────┐
│                    ABI BREAK                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   v1.0 скомпилированный код:                               │
│   user.name находится по смещению 4 (sizeof(int))          │
│                                                             │
│   v2.0 скомпилированный код:                               │
│   user.name находится по смещению 8 (2 * sizeof(int))      │
│                                                             │
│   Если v1.0 код вызывает v2.0 библиотеку:                  │
│   v1.0 читает name по смещению 4 → получает age!           │
│   → Мусор, crash, undefined behavior                       │
│                                                             │
│   Решение: перекомпилировать ВСЕ зависимости               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Swift ABI Stability (2019)

До Swift 5.0 каждое приложение включало Swift runtime:

```
┌─────────────────────────────────────────────────────────────┐
│              Swift До и После ABI Stability                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Swift 4.x (до ABI stability):                            │
│   ┌───────────────┐                                         │
│   │    App.app    │                                         │
│   │  ┌─────────┐  │                                         │
│   │  │ Swift   │  │  ← Каждое приложение ~5-10 MB          │
│   │  │ Runtime │  │    runtime внутри                      │
│   │  └─────────┘  │                                         │
│   └───────────────┘                                         │
│                                                             │
│   Swift 5.0+ (с ABI stability):                            │
│   ┌───────────────┐    ┌─────────────────┐                 │
│   │    App.app    │───▶│  iOS/macOS      │                 │
│   │  (меньше!)    │    │  Swift Runtime  │                 │
│   └───────────────┘    └─────────────────┘                 │
│                                                             │
│   Преимущества:                                             │
│   - Приложения меньше (runtime в ОС)                       │
│   - Обновления Swift без перекомпиляции                    │
│   - Можно использовать Swift в системных frameworks        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Практика: отладка ABI проблем

### Симптомы ABI mismatch

```kotlin
// Kotlin/Native вызывает C библиотеку
// После обновления библиотеки:

// 1. Crash при вызове
// SIGSEGV in libsomething.so

// 2. Неправильные данные
val user = getUser()
println(user.name)  // Выводит мусор

// 3. Corrupted memory
// Heap corruption detected
```

### Диагностика

```bash
# Проверить символы в библиотеке
nm -D libsomething.so | grep myFunction

# Проверить ABI версию
readelf -d libsomething.so | grep SONAME

# Сравнить header и .so
# Если header обновился, а .so нет — ABI mismatch
```

### Kotlin/Native и ABI

Kotlin/Native генерирует код под конкретную платформу:

```kotlin
// build.gradle.kts
kotlin {
    // Каждый target имеет свой ABI
    iosArm64()    // ARM64 AAPCS
    iosX64()      // x86-64 System V (симулятор)
    linuxX64()    // x86-64 System V
    mingwX64()    // Microsoft x64 ABI
}
```

При использовании `cinterop` важно:
- Header файлы должны соответствовать библиотеке
- Версия библиотеки должна быть совместима
- Структуры должны иметь одинаковый layout

---

## Подводные камни

### Распространённые ошибки

| Ошибка | Последствие | Как избежать |
|--------|-------------|--------------|
| Смешивание calling conventions | Crash, wrong data | Explicit annotation |
| Обновление .h без обновления .so | ABI mismatch | Rebuild all |
| Разный alignment на платформах | Memory corruption | Use fixed-size types |
| Игнорирование endianness | Wrong byte order | Network byte order |

### Мифы и заблуждения

**Миф:** "ABI и API — это одно и то же"
**Реальность:** API — контракт для программиста (исходный код). ABI — контракт для машинного кода. Можно изменить API без изменения ABI и наоборот.

**Миф:** "Calling conventions — деталь реализации компилятора"
**Реальность:** Calling conventions — часть ABI платформы. Все компиляторы должны следовать одним правилам для interoperability.

**Миф:** "На современных платформах ABI не важен"
**Реальность:** ABI критичен для interop между языками (Kotlin ↔ C ↔ Swift), использования системных библиотек, и стабильности экосистемы.

---

## Распространённые заблуждения

**Заблуждение:** "ABI и API — это одно и то же, только на разных уровнях"
**Реальность:** Это принципиально разные контракты. Можно изменить ABI, сохранив API (например, поменять calling convention). И можно изменить API, сохранив ABI (переименовать параметр функции — ABI не меняется, потому что имена параметров не входят в бинарный контракт). Путаница возникает потому, что обе аббревиатуры содержат "Interface", но API — интерфейс для программиста, а ABI — интерфейс для машинного кода.

**Заблуждение:** "Calling conventions — деталь реализации компилятора, и мне не нужно о них думать"
**Реальность:** В пределах одного языка — да, компилятор всё решает. Но как только ты пересекаешь границу языков (Kotlin ↔ C, Swift ↔ Objective-C), тебе нужно понимать, какую конвенцию использует каждая сторона. Ошибка в calling convention — crash без внятного сообщения об ошибке.

**Заблуждение:** "Vtable — устаревший механизм, современные компиляторы его не используют"
**Реальность:** Vtable по-прежнему основной механизм полиморфизма в C++, Kotlin/Native, Swift, Rust (для trait objects). Компиляторы оптимизируют (девиртуализация — замена косвенного вызова прямым, когда тип известен), но vtable остаётся fallback для всех случаев, когда тип определяется в runtime.

---

## Связь с другими темами

Понимание ABI тесно связано с несколькими фундаментальными областями, и чтение этих материалов значительно усилит твоё понимание.

**[[memory-model-fundamentals]]** — ABI определяет, как данные раскладываются в стеке и на heap. Без понимания модели памяти (что такое стек, как растёт, что такое адресное пространство) невозможно понять stack frame layout и calling conventions. Рекомендуется прочитать сначала memory model, затем эту статью.

**[[native-compilation-llvm]]** — компилятор — это инструмент, который реализует ABI. LLVM, используемый Kotlin/Native и Clang, генерирует код в соответствии с ABI целевой платформы. Понимание компиляции объясняет, КАК ABI-правила превращаются в машинный код.

**[[ffi-foreign-function-interface]]** — FFI — практическое применение ABI. Когда два языка общаются через FFI, они обязаны использовать общий ABI (обычно C ABI). Эта статья объясняет теорию, FFI — практику. Рекомендуется читать после ABI.

**[[cpu-architecture-basics]]** — регистры, которые упоминаются в calling conventions (RAX, RDI, X0-X7), — часть архитектуры процессора. Понимание CPU помогает понять, ПОЧЕМУ конвенции используют именно эти регистры и почему их количество ограничено.

---

## Источники и дальнейшее чтение

- Levine, J. (1999). *Linkers and Loaders*. — Фундаментальная книга о том, как линкер соединяет отдельно скомпилированные модули, как работает name resolution, relocation и symbol tables. Единственная книга, которая объясняет весь путь от объектного файла до исполняемого.
- Bryant, R. & O'Hallaron, D. (2015). *Computer Systems: A Programmer's Perspective*. — Глава 7 (Linking) подробно разбирает, как ABI влияет на линковку, а глава 3 (Machine-Level Representation) объясняет calling conventions на уровне ассемблера с примерами.
- Patterson, D. & Hennessy, J. (2017). *Computer Organization and Design*. — Глава о procedure calls объясняет, как calling conventions связаны с hardware архитектурой и почему ARM и x86 выбрали разные подходы.
- [Agner Fog: Calling Conventions](https://www.agner.org/optimize/calling_conventions.pdf) — самый полный технический справочник по calling conventions разных платформ, поддерживается в актуальном состоянии.
- [System V ABI x86-64 Specification](https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf) — оригинальная спецификация ABI для Linux/macOS на x86-64.
- [Swift ABI Stability and More](https://www.swift.org/blog/abi-stability-and-more/) — как Apple решила проблему ABI stability для Swift, и почему это заняло 5 лет (от Swift 1.0 до 5.0).

---

## Проверь себя

> [!question]- Почему cinterop в KMP генерирует разные бинарники для iosArm64 и iosX64, хотя Kotlin-код один?
> Разные ABI (Application Binary Interface): ARM64 использует AAPCS64 (8 регистров x0-x7 для аргументов, 8 float-регистров d0-d7), а x86-64 — System V AMD64 ABI (6 регистров rdi, rsi, rdx, rcx, r8, r9 для integer-аргументов). Calling conventions определяют: как передаются аргументы, как возвращаются значения, какие регистры сохраняются. Один и тот же вызов функции транслируется в разные последовательности машинных инструкций — поэтому бинарники разные.

> [!question]- Что такое ABI stability и почему Apple потратила 5 лет (Swift 1.0 до 5.0) на её достижение?
> ABI stability означает: библиотека, скомпилированная старым компилятором, может вызываться кодом, скомпилированным новым. Для этого нужно зафиксировать: layout объектов в памяти, calling conventions, name mangling, vtable layout. До Swift 5.0 каждая версия Swift могла менять эти детали, и приложения должны были нести свою копию Swift runtime. После ABI stability — runtime поставляется с ОС. 5 лет ушло на стабилизацию всех аспектов бинарного интерфейса.

> [!question]- Почему функция на C с 10 аргументами может работать медленнее, чем с 6 аргументами, даже если все аргументы int?
> Из-за calling conventions: на x86-64 System V ABI первые 6 integer-аргументов передаются в регистрах (rdi, rsi, rdx, rcx, r8, r9) — быстро. Аргументы 7-10 передаются через стек — медленнее (запись в RAM, чтение из RAM, возможные cache misses). На ARM64 — 8 регистровых аргументов. Переход "регистры -> стек" создаёт заметный overhead в горячих циклах.

---

## Ключевые карточки

Что такое ABI (Application Binary Interface)?
?
ABI — контракт на бинарном уровне: как скомпилированный код одной программы взаимодействует с другой. Включает: calling conventions (передача аргументов, возврат значений), data layout (размеры типов, alignment), name mangling (как имена кодируются в binary), system call interface. Если ABI совпадает — библиотеки совместимы без перекомпиляции.

---

Чем calling convention определяет порядок вызова функции?
?
Calling convention задаёт: (1) В каких регистрах/на стеке передаются аргументы. (2) Кто чистит стек (caller vs callee). (3) В каком регистре возвращается результат. (4) Какие регистры callee-saved (сохраняются вызываемой функцией) vs caller-saved. Примеры: cdecl, stdcall (Windows), System V AMD64, AAPCS64 (ARM).

---

Сколько аргументов передаётся в регистрах на x86-64 и ARM64?
?
x86-64 System V: 6 integer (rdi, rsi, rdx, rcx, r8, r9) + 8 float (xmm0-xmm7). ARM64 AAPCS: 8 integer (x0-x7) + 8 float (d0-d7). Остальные аргументы — через стек. ARM64 щедрее на регистровые аргументы, что важно для мобильных (iOS) — меньше обращений к памяти.

---

Что такое name mangling и зачем оно нужно?
?
Name mangling — кодирование имён функций/методов в уникальные символы для binary. C++ кодирует: имя, namespace, типы аргументов, const/volatile. Например: `void Foo::bar(int, double)` -> `_ZN3Foo3barEid`. Нужно для перегрузки (overloading): две функции с одним именем, но разными типами, получают разные mangled names в binary.

---

Почему Kotlin/Native использует Objective-C interop, а не Swift interop для iOS?
?
Objective-C имеет стабильный ABI: runtime, objc_msgSend, vtable layout зафиксированы Apple. Swift ABI стабилизирован только с версии 5.0 (2019), но экспортировать Swift-классы напрямую из Kotlin до Swift Export (2.2+) было невозможно. Objective-C runtime позволяет создавать ObjC-совместимые классы из любого языка через C API. Swift Export — попытка решить это ограничение.

---

## Куда дальше

| Направление | Куда | Зачем |
|-------------|------|-------|
| Следующий шаг | [[ffi-foreign-function-interface]] | Понять, как FFI использует ABI для вызовов между языками |
| Углубиться | [[memory-layout-marshalling]] | Как данные хранятся в памяти и конвертируются между форматами |
| Смежная тема | [[cpu-architecture-basics]] | Регистры и инструкции процессора, на которых строится ABI |
| Обзор | [[cs-foundations-overview]] | Вернуться к навигации по разделу |

---

*Проверено: 2026-02-13*
