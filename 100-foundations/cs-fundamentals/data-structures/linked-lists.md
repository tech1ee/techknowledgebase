---
title: "Связные списки (Linked Lists)"
created: 2025-12-29
modified: 2026-02-13
type: deep-dive
status: published
difficulty: beginner
confidence: high
cs-foundations:
  - pointers-and-references
  - dynamic-memory-allocation
  - sequential-access
  - cache-locality
  - space-time-tradeoff
  - recursion-data-structures
prerequisites:
  - "[[big-o-complexity]]"
  - "[[arrays-strings]]"
teaches:
  - nodes-and-pointers
  - singly-linked-list
  - doubly-linked-list
  - circular-linked-list
  - fast-slow-pointers
  - in-place-reversal
unlocks:
  - "[[stacks-queues]]"
  - "[[trees-binary]]"
  - "[[graphs]]"
tags:
  - topic/cs-fundamentals
  - type/deep-dive
  - level/beginner
  - interview
related:
  - "[[stacks-queues]]"
  - "[[trees-binary]]"
  - "[[graphs]]"

reading_time: 85
difficulty: 3
study_status: not_started
mastery: 0
last_reviewed:
next_review:
---

# Linked Lists

> **TL;DR:** Linked List — структура данных где элементы (узлы) связаны "стрелками" (указателями). Главное преимущество: O(1) вставка/удаление в любом месте, если знаешь позицию. Главный недостаток: O(n) доступ по индексу. Три типа: singly (вперёд), doubly (вперёд и назад), circular (по кругу).

---

## Часть 1: Интуиция без кода — Указатели как адреса

### Аналогия: Дома и адреса (понимание указателей)

Прежде чем понять linked list, нужно понять **указатели**. Это САМАЯ сложная часть.

```
┌──────────────────────────────────────────────────────────────────┐
│              УКАЗАТЕЛИ = АДРЕСА ДОМОВ                            │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    ГОРОД (оперативная память компьютера):                        │
│                                                                  │
│         ┌─────────┐                                              │
│         │   🏠    │ Дом на улице 0x1000                          │
│         │ "Вася"  │ (внутри живёт значение "Вася")               │
│         └─────────┘                                              │
│              ↑                                                   │
│              │                                                   │
│         ┌────┴────┐                                              │
│         │ 0x1000  │ ← ЭТО УКАЗАТЕЛЬ (просто адрес дома)          │
│         └─────────┘                                              │
│                                                                  │
│    УКАЗАТЕЛЬ — это бумажка с адресом дома.                       │
│    Сам по себе он НЕ содержит Васю.                              │
│    Он содержит АДРЕС, где Васю найти.                            │
│                                                                  │
│    АНАЛОГИЯ ИЗ ЖИЗНИ:                                            │
│    • Контакт в телефоне = указатель (хранит номер, не человека)  │
│    • Ссылка в интернете = указатель (хранит URL, не контент)     │
│    • GPS-координаты = указатель (место, не сам объект)           │
└──────────────────────────────────────────────────────────────────┘
```

### Аналогия: Цепочка записок (как работает linked list)

```
┌──────────────────────────────────────────────────────────────────┐
│              LINKED LIST = ЦЕПОЧКА ЗАПИСОК                       │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    Представь: ты оставляешь другу серию записок                  │
│                                                                  │
│    Записка 1 (на столе):                                         │
│    ┌─────────────────────────────────────┐                       │
│    │ "Пароль от WiFi: 12345"             │ ← данные (data)       │
│    │ Следующая записка: под кроватью     │ ← указатель (next)    │
│    └─────────────────────────────────────┘                       │
│                                                                  │
│    Записка 2 (под кроватью):                                     │
│    ┌─────────────────────────────────────┐                       │
│    │ "Ключ от сейфа: 9999"               │ ← данные              │
│    │ Следующая записка: в книге          │ ← указатель           │
│    └─────────────────────────────────────┘                       │
│                                                                  │
│    Записка 3 (в книге):                                          │
│    ┌─────────────────────────────────────┐                       │
│    │ "Деньги: под матрасом"              │ ← данные              │
│    │ Следующая записка: НЕТ (конец)      │ ← null                │
│    └─────────────────────────────────────┘                       │
│                                                                  │
│    ЭТО LINKED LIST!                                              │
│    • Каждая записка = узел (Node)                                │
│    • "Следующая записка" = указатель (next)                      │
│    • "НЕТ" = null (конец списка)                                 │
│    • Первая записка "на столе" = head                            │
│                                                                  │
│    ВАЖНО: Чтобы найти записку 3, нужно СНАЧАЛА найти 1, потом 2! │
│    Нельзя прыгнуть сразу к записке 3 (это O(n) доступ).         │
└──────────────────────────────────────────────────────────────────┘
```

### Визуальное сравнение: Массив vs Linked List

```
┌──────────────────────────────────────────────────────────────────┐
│              МАССИВ: КАЗАРМЫ В АРМИИ                             │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    Солдаты стоят в СТРОЮ — все рядом, по порядку:                │
│                                                                  │
│    ┌─────┬─────┬─────┬─────┬─────┐                              │
│    │ Иван│ Пётр│Олег │Миша │Саша │                              │
│    └─────┴─────┴─────┴─────┴─────┘                              │
│       0     1     2     3     4                                  │
│                                                                  │
│    "Третий, шаг вперёд!" → Олег сразу выходит (O(1))            │
│    "Встань между 1 и 2!" → ВСЕ сдвигаются (O(n))                │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────┐
│              LINKED LIST: АГЕНТЫ-ШПИОНЫ                          │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    Каждый агент знает ТОЛЬКО следующего в цепочке:               │
│                                                                  │
│    Агент Иван          Агент Пётр         Агент Олег             │
│    ┌───────────────┐   ┌───────────────┐   ┌───────────────┐    │
│    │ Миссия: X     │──►│ Миссия: Y     │──►│ Миссия: Z     │──►?│
│    │ Контакт: Пётр │   │ Контакт: Олег │   │ Контакт: ???  │    │
│    └───────────────┘   └───────────────┘   └───────────────┘    │
│                                                                  │
│    "Найди Олега!" → Иван → Пётр → Олег (O(n))                    │
│    "Вставь нового между Иваном и Петром!"                        │
│    → Просто поменяй "Контакт" Ивана (O(1))                       │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

---

## Часть 2: Почему Linked Lists бывают сложными?

### Исследования: Главные проблемы студентов

Согласно [исследованию IEEE (2021)](https://ieeexplore.ieee.org/document/9637318):

> "Results showed that **56.5% of students had incorrect mental models** of pointers. Using visualization strategies improved accuracy from 56.5% to 87.1%."

Исследование [ScienceDirect (2022)](https://www.sciencedirect.com/science/article/abs/pii/S2590118422000818):

> "Students had good conceptual understanding of how to insert and delete nodes. However, **many struggled with pointer manipulation** needed to correctly implement operations."

### Проблема 1: Абстрактная природа указателей

```
┌──────────────────────────────────────────────────────────────────┐
│              УКАЗАТЕЛИ — ГЛАВНАЯ СЛОЖНОСТЬ                       │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    ❌ КАК ДУМАЮТ НОВИЧКИ:                                        │
│    "Переменная = коробка с данными"                              │
│                                                                  │
│        ┌─────────┐                                               │
│    x = │  "Вася" │   x СОДЕРЖИТ "Вася"                          │
│        └─────────┘                                               │
│                                                                  │
│    ✅ КАК РАБОТАЕТ НА САМОМ ДЕЛЕ:                                │
│    "Переменная = стрелка на адрес в памяти"                      │
│                                                                  │
│              ┌─────────┐                                         │
│    x ───────►│ "Вася"  │   x УКАЗЫВАЕТ на объект с "Вася"       │
│              └─────────┘                                         │
│              адрес 0x1000                                        │
│                                                                  │
│    ПОЧЕМУ ЭТО ВАЖНО?                                             │
│    Когда делаешь y = x, ты копируешь СТРЕЛКУ, не данные!         │
│                                                                  │
│    x ────┐    ┌─────────┐                                        │
│          ├───►│ "Вася"  │   x и y указывают на ОДИН объект!     │
│    y ────┘    └─────────┘                                        │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

### Проблема 2: Разрыв между диаграммой и кодом

```
┌──────────────────────────────────────────────────────────────────┐
│              ДИАГРАММА vs КОД — ТИПИЧНАЯ ПРОБЛЕМА                │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    ДИАГРАММА (понятна):                                          │
│                                                                  │
│    [A] ──► [B] ──► [C] ──► null                                  │
│     ↓                                                            │
│    Хочу вставить X между A и B                                   │
│                                                                  │
│    [A] ──► [X] ──► [B] ──► [C] ──► null                          │
│                                                                  │
│    Студент: "Понял! Просто добавляю X."                          │
│                                                                  │
│    ────────────────────────────────────────────────────────────  │
│                                                                  │
│    КОД (непонятен):                                              │
│                                                                  │
│    newNode.next = A.next  // ??? Почему не B.next?               │
│    A.next = newNode       // А где B? Не потеряли?               │
│                                                                  │
│    Студент: "Подождите, что? Почему такой порядок?"              │
│                                                                  │
│    КОРЕНЬ ПРОБЛЕМЫ:                                              │
│    Диаграмма — статична (показывает состояние)                   │
│    Код — динамичен (показывает последовательность изменений)     │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

### Проблема 3: Порядок операций критичен

```
┌──────────────────────────────────────────────────────────────────┐
│              ПОРЯДОК ОПЕРАЦИЙ = ЖИЗНЬ ИЛИ СМЕРТЬ                 │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    ЗАДАЧА: Вставить X между A и B                                │
│                                                                  │
│    ❌ НЕПРАВИЛЬНЫЙ ПОРЯДОК (потеря данных):                      │
│                                                                  │
│    Шаг 1: A.next = newNode                                       │
│           [A] ──► [X]       [B] ──► [C]  ← B потерян!            │
│                                                                  │
│    Шаг 2: newNode.next = B  // ОШИБКА! Где взять B?              │
│           Мы уже потеряли ссылку на B!                           │
│                                                                  │
│    ────────────────────────────────────────────────────────────  │
│                                                                  │
│    ✅ ПРАВИЛЬНЫЙ ПОРЯДОК:                                        │
│                                                                  │
│    Шаг 1: newNode.next = A.next  (X теперь указывает на B)       │
│           [A] ──► [B]                                            │
│           [X] ──► [B]   ← X тоже указывает на B                  │
│                                                                  │
│    Шаг 2: A.next = newNode  (A теперь указывает на X)            │
│           [A] ──► [X] ──► [B]   ← Готово!                        │
│                                                                  │
│    ПРАВИЛО: Сначала "подключи" новый узел к цепочке,             │
│             ПОТОМ меняй старые связи!                            │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

### Проблема 4: null — источник 90% багов

```
┌──────────────────────────────────────────────────────────────────┐
│              NULL POINTER — ГЛАВНЫЙ ВРАГ                         │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    null — это "ничто", "пустота", "нет адреса"                   │
│                                                                  │
│    ❌ ТИПИЧНАЯ ОШИБКА:                                           │
│                                                                  │
│    while (current.next != null) {  // А если current УЖЕ null?  │
│        current = current.next       // CRASH! NullPointerExc!   │
│    }                                                             │
│                                                                  │
│    ✅ ПРАВИЛЬНО:                                                 │
│                                                                  │
│    while (current != null) {        // Сначала проверяем current │
│        // делаем что-то с current                                │
│        current = current.next                                    │
│    }                                                             │
│                                                                  │
│    ────────────────────────────────────────────────────────────  │
│                                                                  │
│    ЧЕКЛИСТ ПРОВЕРОК:                                             │
│    □ head может быть null (пустой список)                        │
│    □ current может стать null (дошли до конца)                   │
│    □ current.next может быть null (последний элемент)            │
│    □ prev может быть null (если удаляем head)                    │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

---

## Часть 3: Ментальные модели для Linked Lists

### Модель 1: "Эстафета" (для понимания обхода)

```
┌──────────────────────────────────────────────────────────────────┐
│              МОДЕЛЬ: ЭСТАФЕТА С ПАЛОЧКОЙ                         │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    Представь эстафетный бег:                                     │
│                                                                  │
│    Бегун A ──передаёт──► Бегун B ──передаёт──► Бегун C           │
│      │                     │                     │               │
│      └── "Дальше к B!"     └── "Дальше к C!"     └── "Финиш!"    │
│                                                                  │
│    current = head (стартуем с бегуна A)                          │
│    while (current != null):                                      │
│        print(current)      # Смотрим на текущего бегуна          │
│        current = current.next  # Передаём палочку следующему     │
│                                                                  │
│    КОГДА ИСПОЛЬЗОВАТЬ:                                           │
│    При обходе (traversal) — идём от head до null                 │
└──────────────────────────────────────────────────────────────────┘
```

### Модель 2: "Цирковой акробат" (для понимания разворота)

```
┌──────────────────────────────────────────────────────────────────┐
│              МОДЕЛЬ: АКРОБАТ НА КОЛЬЦАХ                          │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    Акробат держится за 3 кольца одновременно:                    │
│                                                                  │
│         prev     curr     next                                   │
│           ○        ○        ○                                    │
│           │        │        │                                    │
│          null ←── [A] ──► [B] ──► [C]                           │
│                                                                  │
│    ПРАВИЛО АКРОБАТА:                                             │
│    "Прежде чем отпустить одно кольцо,                            │
│     схватись за следующее!"                                      │
│                                                                  │
│    Шаг 1: next = curr.next     (хватаем следующее кольцо)        │
│    Шаг 2: curr.next = prev     (разворачиваем стрелку)           │
│    Шаг 3: prev = curr          (переносим левую руку)            │
│    Шаг 4: curr = next          (переносим среднюю руку)          │
│                                                                  │
│    НИКОГДА не отпускай кольцо, пока не схватился за другое!      │
│    (Иначе потеряешь часть списка)                                │
│                                                                  │
│    КОГДА ИСПОЛЬЗОВАТЬ:                                           │
│    При развороте списка — reverse linked list                    │
└──────────────────────────────────────────────────────────────────┘
```

### Модель 3: "Черепаха и Заяц" (Floyd's Algorithm)

```
┌──────────────────────────────────────────────────────────────────┐
│              МОДЕЛЬ: ЧЕРЕПАХА И ЗАЯЦ НА ТРЕКЕ                    │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    ТРЕК БЕЗ ЦИКЛА (прямая дорожка):                              │
│                                                                  │
│    🐢 ─────────────────────────────► 🏁                          │
│    🐰 ═══════════════════════════════════════► 🏁               │
│                                                                  │
│    Заяц бежит в 2 раза быстрее.                                  │
│    Когда заяц на финише, черепаха — ПОСЕРЕДИНЕ!                  │
│    → Используем для поиска середины списка                       │
│                                                                  │
│    ────────────────────────────────────────────────────────────  │
│                                                                  │
│    ТРЕК С ЦИКЛОМ (беговая дорожка):                              │
│                                                                  │
│         ┌──────────────┐                                         │
│         │     🐰       │  Заяц бежит по кругу                    │
│    ────►│ ○ → ○ → ○ → ○│                                         │
│         │ ↑    🐢    ↓ │  Черепаха тоже по кругу                 │
│         │ ○ ← ○ ← ○ ← ○│                                         │
│         └──────────────┘                                         │
│                                                                  │
│    Если есть цикл — они ОБЯЗАТЕЛЬНО встретятся!                  │
│    (Заяц "догонит" черепаху, как на стадионе)                    │
│    → Используем для обнаружения цикла                            │
│                                                                  │
│    КОГДА ИСПОЛЬЗОВАТЬ:                                           │
│    • slow + fast для поиска середины                             │
│    • slow + fast для обнаружения цикла                           │
└──────────────────────────────────────────────────────────────────┘
```

### Модель 4: "Фейковый вагон" (Dummy Node / Sentinel)

```
┌──────────────────────────────────────────────────────────────────┐
│              МОДЕЛЬ: ФЕЙКОВЫЙ ВАГОН В НАЧАЛЕ ПОЕЗДА              │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│    ПРОБЛЕМА: Много специальных случаев для head                  │
│                                                                  │
│    "Удалить первый элемент" → head = head.next                   │
│    "Вставить перед первым" → newNode.next = head; head = newNode │
│    "Список пустой" → head == null — особый случай!               │
│                                                                  │
│    РЕШЕНИЕ: Добавить "фейковый" вагон перед всеми                │
│                                                                  │
│    БЕЗ DUMMY:                                                    │
│    head → [A] → [B] → [C] → null                                 │
│      ↑                                                           │
│      Что если head == null? Особый случай!                       │
│                                                                  │
│    С DUMMY:                                                      │
│    dummy → [A] → [B] → [C] → null                                │
│      ↑                                                           │
│      Всегда существует! head = dummy.next                        │
│                                                                  │
│    ПРЕИМУЩЕСТВО:                                                 │
│    • Нет специальных случаев для head                            │
│    • Код проще и единообразнее                                   │
│    • Особенно полезен при merge, удалении по условию             │
│                                                                  │
│    КОГДА ИСПОЛЬЗОВАТЬ:                                           │
│    • Merge Two Sorted Lists                                      │
│    • Remove Elements (удаление по значению)                      │
│    • Partition List                                              │
└──────────────────────────────────────────────────────────────────┘
```

### Сравнение моделей: когда какую использовать

| Модель | Когда использовать | Задачи |
|--------|-------------------|--------|
| **Эстафета** | Простой обход списка | Print list, Find element |
| **Акробат на кольцах** | Изменение указателей | Reverse, Insert, Delete |
| **Черепаха и Заяц** | Два указателя с разной скоростью | Middle, Cycle detection |
| **Фейковый вагон** | Упрощение edge cases | Merge, Remove by value |

---

## 1. Зачем это нужно?

### Представьте ситуацию

Вы разработчик Spotify и вам нужно реализовать плейлист.

**Требования:**
1. Добавлять песни в начало, середину и конец
2. Удалять песни из любого места
3. Перемешивать (shuffle) песни
4. Размер неизвестен заранее

**Попробуем с массивом:**

```
Плейлист (массив): [Song1, Song2, Song3, Song4, Song5]
                     0      1      2      3      4

Хотим добавить новую песню на позицию 2:

Шаг 1: Сдвинуть Song3, Song4, Song5 вправо
       [Song1, Song2, ___, Song3, Song4, Song5]

Шаг 2: Вставить NewSong
       [Song1, Song2, NewSong, Song3, Song4, Song5]

При 1,000,000 песен:
- Вставка в середину = 500,000 сдвигов!
- Удаление из середины = 500,000 сдвигов!
```

### Проблема в числах

```
МАССИВ vs LINKED LIST: Вставка в середину

Массив с 1,000,000 элементами:
┌──────────────────────────────────────────────────┐
│ Вставка в середину: O(n) = 500,000 операций     │
│ Удаление из середины: O(n) = 500,000 операций   │
│ Время: ~50 миллисекунд                          │
└──────────────────────────────────────────────────┘

Linked List с 1,000,000 элементами:
┌──────────────────────────────────────────────────┐
│ Вставка (если знаем позицию): O(1) = 2 операции │
│ Удаление (если знаем позицию): O(1) = 2 операции│
│ Время: ~0.0001 миллисекунды                     │
└──────────────────────────────────────────────────┘

Разница: в 250,000 раз быстрее!
```

**НО есть цена:** Доступ по индексу (arr[500000]) — O(1) в массиве, O(n) в linked list.

### Где реально используется?

| Применение | Почему Linked List? |
|------------|---------------------|
| **Browser History** | Кнопки "Назад/Вперёд" — doubly linked |
| **Undo/Redo** | Каждое действие связано с предыдущим |
| **Music Playlist** | Добавление/удаление песен на лету |
| **LRU Cache** | Быстрое перемещение элементов (doubly linked) |
| **Memory Allocator** | ОС хранит свободные блоки памяти |
| **Round-Robin Scheduler** | Процессы по кругу (circular) |

---

## 1.5 Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **Big O Notation** | Понимание O(1) vs O(n) — ключ к пониманию trade-offs linked list vs array | [[big-o-complexity]] |
| **Массивы** | Для сравнения: контрастное понимание показывает сильные и слабые стороны | [[arrays-strings]] |
| **CS: Указатели и ссылки** | Linked List построен на указателях — адресах в памяти | [[pointers-references]] |
| **CS: Динамическая память** | Узлы выделяются в heap, не на стеке | [[memory-management]] |

---

## 2. Что это такое?

### Объяснение для 5-летнего

**Представь поезд:**

```
╔═══════════════════════════════════════════════════════════════╗
║                           ПОЕЗД                                ║
║                                                                ║
║   ┌─────────┐      ┌─────────┐      ┌─────────┐               ║
║   │Локомотив│ ──── │ Вагон 1 │ ──── │ Вагон 2 │ ──── ...      ║
║   │ (HEAD)  │      │  Data   │      │  Data   │               ║
║   └─────────┘      └─────────┘      └─────────┘               ║
║                                                                ║
║   Каждый вагон:                                                ║
║   • Содержит груз (DATA)                                       ║
║   • Сцеплен со следующим вагоном (NEXT)                       ║
║                                                                ║
║   Можно легко:                                                 ║
║   • Добавить вагон (отцепил-прицепил)                         ║
║   • Убрать вагон (отцепил от соседей)                         ║
║                                                                ║
║   Нельзя легко:                                                ║
║   • "Дай мне вагон номер 47" — нужно идти с начала!           ║
║                                                                ║
╚═══════════════════════════════════════════════════════════════╝
```

**Linked List — это "поезд из данных":**
1. Каждый "вагон" называется **Node (узел)**
2. "Сцепка" — это **Pointer (указатель)** на следующий узел
3. "Локомотив" — это **Head (голова)** — начало списка

### Ещё одна аналогия: Охота за сокровищами

```
╔═══════════════════════════════════════════════════════════════╗
║                    TREASURE HUNT                               ║
║                                                                ║
║   Подсказка 1:              Подсказка 2:                      ║
║   ┌─────────────────┐       ┌─────────────────┐               ║
║   │ "Код: 1234"     │       │ "Код: 5678"     │               ║
║   │                 │  ──→  │                 │  ──→  ...     ║
║   │ Следующая       │       │ Следующая       │               ║
║   │ подсказка под   │       │ подсказка в     │               ║
║   │ старым дубом    │       │ библиотеке      │               ║
║   └─────────────────┘       └─────────────────┘               ║
║                                                                ║
║   Каждая подсказка содержит:                                   ║
║   • Данные (код)                                               ║
║   • Указание, где искать СЛЕДУЮЩУЮ подсказку                  ║
║                                                                ║
║   Нельзя: прыгнуть сразу к подсказке #5                       ║
║   Нужно: идти по порядку от первой                            ║
║                                                                ║
╚═══════════════════════════════════════════════════════════════╝
```

### Постепенное усложнение

**Уровень 1 (интуиция):**

> Linked List — это цепочка "коробок" где каждая коробка знает только про следующую. Чтобы найти нужную коробку — иди с начала по цепочке.

**Уровень 2 (программирование):**

> Linked List — структура данных где каждый элемент (Node) содержит:
> 1. **Data** — сами данные
> 2. **Next** — указатель (адрес в памяти) следующего элемента

**Уровень 3 (формальное определение):**

> Linked List — линейная динамическая структура данных, состоящая из узлов (nodes), связанных указателями. Обеспечивает O(1) вставку/удаление при известной позиции и O(n) произвольный доступ. Занимает больше памяти чем массив из-за хранения указателей.

---

## 3. Linked List vs Array: Когда что использовать?

### Визуальное сравнение

```
МАССИВ (Array):
┌─────┬─────┬─────┬─────┬─────┐
│  A  │  B  │  C  │  D  │  E  │  Непрерывная память
└─────┴─────┴─────┴─────┴─────┘
  [0]   [1]   [2]   [3]   [4]

✓ Доступ по индексу: O(1) — сразу знаем адрес!
✗ Вставка в середину: O(n) — нужно сдвигать


LINKED LIST:
┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬────┐
│ A │ ●─┼──→│ B │ ●─┼──→│ C │ ●─┼──→│ D │ ●─┼──→│ E │null│
└───┴───┘   └───┴───┘   └───┴───┘   └───┴───┘   └───┴────┘
   ↑
  HEAD      Разбросаны в памяти, связаны указателями

✗ Доступ по индексу: O(n) — нужно идти по цепочке
✓ Вставка в середину: O(1) — просто перецепляем указатели
```

### Сравнение сложности операций

| Операция | Array | Linked List |
|----------|-------|-------------|
| **Доступ по индексу** | **O(1)** | O(n) |
| **Поиск элемента** | O(n) | O(n) |
| **Вставка в начало** | O(n) | **O(1)** |
| **Вставка в конец** | O(1)* | O(n)** |
| **Вставка в середину** | O(n) | **O(1)*** |
| **Удаление из начала** | O(n) | **O(1)** |
| **Удаление из конца** | O(1) | O(n) |
| **Удаление из середины** | O(n) | **O(1)*** |

*амортизированно | **O(1) если есть tail pointer | ***если известна позиция

### Cache Locality: Скрытый враг Linked List

```
МАССИВ в памяти (Cache-Friendly):
┌──────────────────────────────────┐
│ [A][B][C][D][E][F][G][H]...     │ ← Все рядом!
└──────────────────────────────────┘
  CPU загружает сразу блок в кэш → БЫСТРО

LINKED LIST в памяти (Cache-Unfriendly):
┌─────┐      ┌─────┐              ┌─────┐
│  A  │ ...  │  B  │ ............│  C  │ ...
└─────┘      └─────┘              └─────┘
 0x100        0x500                0x900

  Узлы разбросаны → Много cache misses → МЕДЛЕННО
```

**Важно:** Для маленьких данных массив часто быстрее даже при вставках!

### Когда использовать Linked List?

| Используй Linked List когда: | Используй Array когда: |
|------------------------------|------------------------|
| Частые вставки/удаления в начале | Нужен быстрый доступ по индексу |
| Размер сильно меняется | Размер известен заранее |
| Данные большие (сдвиг дорогой) | Данные маленькие |
| Реализуешь Stack/Queue | Нужна сортировка |
| Неизвестен максимальный размер | Важна cache locality |

---

## 4. Три типа Linked List

### Singly Linked List (Односвязный)

```
Каждый узел знает только СЛЕДУЮЩИЙ

HEAD
 ↓
┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬────┐
│ A │ ●─┼──→│ B │ ●─┼──→│ C │ ●─┼──→│ D │null│
└───┴───┘   └───┴───┘   └───┴───┘   └───┴────┘
                                         ↑
                                        TAIL

Структура узла:
┌──────────────────────┐
│  ┌──────┐  ┌──────┐ │
│  │ Data │  │ Next │─┼──→ (к следующему)
│  └──────┘  └──────┘ │
└──────────────────────┘

Плюсы: Меньше памяти (1 указатель)
Минусы: Только вперёд, удаление с конца O(n)
Где: Stack, простой список задач
```

### Doubly Linked List (Двусвязный)

```
Каждый узел знает ПРЕДЫДУЩИЙ и СЛЕДУЮЩИЙ

       HEAD
        ↓
null←──┌───┬───┬───┐   ┌───┬───┬───┐   ┌───┬───┬───┐──→null
       │ ● │ A │ ● │←→│ ● │ B │ ● │←→│ ● │ C │ ● │
       └───┴───┴───┘   └───┴───┴───┘   └───┴───┴───┘
                                            ↑
                                           TAIL

Структура узла:
┌──────────────────────────────┐
│  ┌──────┐  ┌──────┐  ┌──────┐│
│←─┤ Prev │  │ Data │  │ Next ├┼─→
│  └──────┘  └──────┘  └──────┘│
└──────────────────────────────┘

Плюсы: Движение в обе стороны, O(1) удаление с конца
Минусы: Больше памяти (2 указателя), сложнее код
Где: Browser history, Undo/Redo, LRU Cache
```

### Circular Linked List (Кольцевой)

```
Последний указывает на ПЕРВЫЙ (нет null)

    ┌────────────────────────────────────┐
    │                                    │
    ↓                                    │
┌───┬───┐   ┌───┬───┐   ┌───┬───┐      │
│ A │ ●─┼──→│ B │ ●─┼──→│ C │ ●─┼──────┘
└───┴───┘   └───┴───┘   └───┴───┘
    ↑
   HEAD

Нет конца! Можно ходить по кругу бесконечно.

Плюсы: Легко реализовать круговой обход
Минусы: Нужно следить чтобы не зациклиться
Где: Round-robin scheduling, Playlist loop, Netflix scroll
```

**Netflix Analogy:**
> Когда ты листаешь "Мой список" на Netflix и доходишь до конца — он возвращается к началу. Это Circular Linked List!

---

## 5. Терминология

| Термин | Простое объяснение | Формальное определение |
|--------|-------------------|------------------------|
| **Node (Узел)** | "Вагон поезда" — содержит груз и сцепку | Элемент списка с данными и указателем(ями) |
| **Head (Голова)** | "Локомотив" — начало поезда | Указатель на первый узел списка |
| **Tail (Хвост)** | "Последний вагон" | Указатель на последний узел (next = null) |
| **Next Pointer** | "Сцепка вперёд" | Адрес следующего узла в памяти |
| **Prev Pointer** | "Сцепка назад" (doubly) | Адрес предыдущего узла в памяти |
| **Traversal** | "Идти по вагонам" | Последовательный обход всех узлов |
| **Dummy/Sentinel** | "Фейковый вагон" для упрощения | Вспомогательный узел перед head |

---

## 6. Как это работает: Пошаговые операции

### Вставка в начало (O(1))

```
БЫЛО:
HEAD → [A] → [B] → [C] → null

ДОБАВЛЯЕМ "X" В НАЧАЛО:

Шаг 1: Создаём новый узел [X]
       [X] → ???

Шаг 2: X.next = HEAD (X указывает на A)
       [X] → [A] → [B] → [C] → null
              ↑
             HEAD (пока ещё тут)

Шаг 3: HEAD = X (теперь HEAD указывает на X)
       HEAD
        ↓
       [X] → [A] → [B] → [C] → null

СТАЛО:
HEAD → [X] → [A] → [B] → [C] → null

Всего 2 операции = O(1)!
```

### Удаление из середины (O(1) если знаем предыдущий)

```
БЫЛО:
HEAD → [A] → [B] → [C] → [D] → null
              ↑
        Хотим удалить B

УДАЛЯЕМ "B":

Шаг 1: Найти узел ПЕРЕД удаляемым (A)
       prev = [A]

Шаг 2: "Перешагнуть" через B
       A.next = B.next (A теперь указывает на C)

       HEAD → [A] ────────→ [C] → [D] → null
                    [B] → ↗
                    (отцеплён!)

Шаг 3: Удалить B из памяти (в C/C++)
       delete B

СТАЛО:
HEAD → [A] → [C] → [D] → null

Важно: "Перешагни" ПЕРЕД удалением, иначе потеряешь указатель!
```

### Разворот списка (Reverse) — Пошагово

```
БЫЛО:
[1] → [2] → [3] → null

Инициализация:
prev = null
curr = HEAD → [1]

════════════════════════════════════════════════════
Итерация 1:
                prev   curr
                 ↓      ↓
        null    [1] → [2] → [3] → null

1. Сохраняем next = curr.next = [2]
2. Разворачиваем: curr.next = prev

        null ← [1]    [2] → [3] → null
                ↑      ↑
              prev   curr → next

3. Двигаем: prev = curr, curr = next

        null ← [1]    [2] → [3] → null
                ↑      ↑
              prev   curr

════════════════════════════════════════════════════
Итерация 2:
        null ← [1] ← [2]    [3] → null
                      ↑      ↑
                    prev   curr

════════════════════════════════════════════════════
Итерация 3:
        null ← [1] ← [2] ← [3]    null
                            ↑      ↑
                          prev   curr

════════════════════════════════════════════════════
curr == null → Конец!
Возвращаем prev = [3]

СТАЛО:
[3] → [2] → [1] → null
```

**Ключевой инсайт:** Сохраняй next ПЕРЕД изменением curr.next!

---

## 7. Fast & Slow Pointers (Floyd's Algorithm)

### Аналогия: Черепаха и Заяц

```
╔══════════════════════════════════════════════════════════════╗
║                    ЧЕРЕПАХА И ЗАЯЦ                            ║
║                                                               ║
║   Черепаха (Slow): идёт по 1 шагу                            ║
║   Заяц (Fast): бежит по 2 шага                               ║
║                                                               ║
║   Если дорожка прямая:                                        ║
║   ──────────────────────→                                     ║
║   Заяц добежит до конца, черепаха будет В СЕРЕДИНЕ!          ║
║                                                               ║
║   Если дорожка зациклена:                                     ║
║   ┌──────────────────┐                                        ║
║   ↓                  │                                        ║
║   ○ → ○ → ○ → ○ → ○ ─┘                                        ║
║   Заяц догонит черепаху! (они встретятся внутри цикла)       ║
║                                                               ║
╚══════════════════════════════════════════════════════════════╝
```

### Применение 1: Найти середину списка

```
[1] → [2] → [3] → [4] → [5] → null

Start:
 S
 F
[1] → [2] → [3] → [4] → [5] → null

Step 1 (S+1, F+2):
       S
             F
[1] → [2] → [3] → [4] → [5] → null

Step 2 (S+1, F+2):
             S
                         F
[1] → [2] → [3] → [4] → [5] → null

F.next == null → СТОП!
S указывает на [3] — СЕРЕДИНА!
```

### Применение 2: Обнаружить цикл

```
[1] → [2] → [3] → [4] → [5]
              ↑           │
              └───────────┘

Start: S=1, F=1

Step 1: S=2, F=3
Step 2: S=3, F=5
Step 3: S=4, F=4  ← ВСТРЕТИЛИСЬ!

Если S == F внутри цикла → ЦИКЛ ЕСТЬ!
```

### Применение 3: Найти начало цикла

```
После встречи внутри цикла:

1. Сбросить один указатель на HEAD
2. Оба двигаются по 1 шагу
3. Где встретятся = начало цикла!

Математика: A + 2B + C = 2(A + B), значит A = C
(A = расстояние до цикла, C = расстояние от встречи до начала цикла)
```

---

## 8. Распространённые ошибки

### Ошибка 1: Null Pointer Dereference

**Неправильно:**
```kotlin
// Не проверили что head может быть null!
fun printFirst(head: ListNode?) {
    println(head.value)  // CRASH если head == null!
}
```

**Правильно:**
```kotlin
fun printFirst(head: ListNode?) {
    if (head == null) {
        println("List is empty")
        return
    }
    println(head.value)
}
```

### Ошибка 2: Потеря указателя при удалении

**Неправильно:**
```kotlin
// Хотим удалить curr
prev.next = curr.next  // OK
curr = curr.next       // ОШИБКА! curr уже "потерян", memory leak
```

**Правильно:**
```kotlin
// Сначала сохраняем следующий узел
val next = curr.next
prev.next = next  // Пропускаем curr
// В языках с ручным управлением памятью: delete curr
curr = next       // Переходим дальше
```

### Ошибка 3: Неправильный порядок при reverse

**Неправильно:**
```kotlin
curr.next = prev  // Развернули...
curr = curr.next  // ОШИБКА! curr.next уже == prev!
                  // Бесконечный цикл!
```

**Правильно:**
```kotlin
val next = curr.next  // СНАЧАЛА сохраняем!
curr.next = prev      // Потом разворачиваем
prev = curr
curr = next           // Используем сохранённое значение
```

### Ошибка 4: Забыли edge cases

**Неправильно:**
```kotlin
fun findMiddle(head: ListNode): ListNode {
    var slow = head
    var fast = head
    while (fast.next != null) {  // Что если head == null?
        slow = slow.next
        fast = fast.next.next    // Что если fast.next.next == null?
    }
    return slow
}
```

**Правильно:**
```kotlin
fun findMiddle(head: ListNode?): ListNode? {
    if (head == null) return null  // Edge case: empty

    var slow = head
    var fast = head
    while (fast?.next != null) {   // Безопасная проверка
        slow = slow?.next
        fast = fast.next?.next     // Безопасный доступ
    }
    return slow
}
```

### Чеклист Edge Cases

```
□ Пустой список (head == null)
□ Один элемент (head.next == null)
□ Два элемента
□ Нечётная/чётная длина
□ Цикл в списке
□ Операции с head
□ Операции с tail
□ Дубликаты
```

---

## 9. Реализация

### Singly Linked List

#### Kotlin

```kotlin
// Узел: содержит значение и указатель на следующий
// Почему nullable next? Последний узел указывает в никуда
class ListNode<T>(var value: T) {
    var next: ListNode<T>? = null
}

class SinglyLinkedList<T> {
    // head — точка входа в список
    private var head: ListNode<T>? = null
    private var size: Int = 0

    // O(1): Просто меняем указатели, не сдвигаем элементы
    fun addFirst(value: T) {
        val newNode = ListNode(value)
        newNode.next = head  // Новый узел указывает на старый head
        head = newNode       // Теперь head — это новый узел
        size++
    }

    // O(n): Нужно пройти до конца, чтобы найти tail
    // Можно оптимизировать до O(1), храня tail pointer
    fun addLast(value: T) {
        val newNode = ListNode(value)
        if (head == null) {
            head = newNode
        } else {
            // Идём до последнего узла
            var current = head
            while (current?.next != null) {
                current = current.next
            }
            current?.next = newNode
        }
        size++
    }

    // O(1): Просто перекидываем head на следующий
    fun removeFirst(): T? {
        val removed = head?.value
        head = head?.next
        if (removed != null) size--
        return removed
    }

    // O(n): Нужно пройти до нужного индекса
    // Это главный недостаток linked list!
    fun get(index: Int): T? {
        if (index < 0 || index >= size) return null
        var current = head
        repeat(index) { current = current?.next }
        return current?.value
    }

    fun size(): Int = size
}
```

#### Java

```java
class ListNode<T> {
    T value;
    ListNode<T> next;

    ListNode(T value) {
        this.value = value;
    }
}

class SinglyLinkedList<T> {
    private ListNode<T> head;
    private int size;

    // O(1)
    public void addFirst(T value) {
        ListNode<T> newNode = new ListNode<>(value);
        newNode.next = head;
        head = newNode;
        size++;
    }

    // O(n) - можно оптимизировать с tail pointer
    public void addLast(T value) {
        ListNode<T> newNode = new ListNode<>(value);
        if (head == null) {
            head = newNode;
        } else {
            ListNode<T> current = head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = newNode;
        }
        size++;
    }

    // O(1)
    public T removeFirst() {
        if (head == null) return null;
        T removed = head.value;
        head = head.next;
        size--;
        return removed;
    }

    // O(n)
    public T get(int index) {
        if (index < 0 || index >= size) return null;
        ListNode<T> current = head;
        for (int i = 0; i < index; i++) {
            current = current.next;
        }
        return current.value;
    }

    public int size() { return size; }
}
```

#### Python

```python
class ListNode:
    def __init__(self, value):
        self.value = value
        self.next = None  # Указатель на следующий (или None)


class SinglyLinkedList:
    def __init__(self):
        self.head = None
        self._size = 0

    # O(1)
    def add_first(self, value):
        new_node = ListNode(value)
        new_node.next = self.head
        self.head = new_node
        self._size += 1

    # O(n) - но можно O(1) с tail
    def add_last(self, value):
        new_node = ListNode(value)
        if not self.head:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node
        self._size += 1

    # O(1)
    def remove_first(self):
        if not self.head:
            return None
        removed = self.head.value
        self.head = self.head.next
        self._size -= 1
        return removed

    # O(n) - главный минус linked list
    def get(self, index):
        if index < 0 or index >= self._size:
            return None
        current = self.head
        for _ in range(index):
            current = current.next
        return current.value

    def size(self):
        return self._size
```

### Reverse Linked List

#### Kotlin

```kotlin
// Итеративный способ: O(n) время, O(1) память
// Три указателя: prev, curr, next
fun reverseList(head: ListNode<Int>?): ListNode<Int>? {
    var prev: ListNode<Int>? = null  // Предыдущий (изначально null)
    var curr = head                   // Текущий

    while (curr != null) {
        val next = curr.next  // СНАЧАЛА сохраняем следующий!
        curr.next = prev      // Разворачиваем стрелку
        prev = curr           // Двигаем prev вперёд
        curr = next           // Двигаем curr вперёд
    }

    return prev  // prev теперь указывает на новый head
}
```

#### Java

```java
public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;

    while (curr != null) {
        ListNode next = curr.next;  // Сохраняем
        curr.next = prev;           // Разворачиваем
        prev = curr;                // Двигаем
        curr = next;
    }

    return prev;
}
```

#### Python

```python
def reverse_list(head):
    prev = None
    curr = head

    while curr:
        next_node = curr.next  # Сохраняем!
        curr.next = prev       # Разворачиваем
        prev = curr            # Двигаем
        curr = next_node

    return prev
```

---

## 10. Сложность операций

| Операция | Singly | Doubly | С Tail Pointer |
|----------|--------|--------|----------------|
| Access by index | O(n) | O(n) | O(n) |
| Search | O(n) | O(n) | O(n) |
| Insert at head | **O(1)** | **O(1)** | **O(1)** |
| Insert at tail | O(n) | **O(1)** | **O(1)** |
| Insert in middle | O(n)* | O(n)* | O(n)* |
| Delete at head | **O(1)** | **O(1)** | **O(1)** |
| Delete at tail | O(n) | **O(1)** | **O(1)**† |
| Delete in middle | O(n)* | O(n)* | O(n)* |

*O(1) если уже есть указатель на предыдущий узел
†Требует doubly linked

### Память

| Тип | Память на узел |
|-----|----------------|
| Singly | data + 1 pointer (8 bytes на 64-bit) |
| Doubly | data + 2 pointers (16 bytes на 64-bit) |

**Сравнение с Array:** Linked List использует в 2-3 раза больше памяти (из-за указателей).

---

## 11. Практика

### Вопросы на понимание (без кода)

1. **Почему вставка в начало linked list — O(1), а в начало массива — O(n)?**
   <details><summary>Ответ</summary>

   В linked list мы просто создаём новый узел и меняем 2 указателя (new.next = head, head = new). В массиве нужно сдвинуть ВСЕ элементы на одну позицию вправо, чтобы освободить место для нового.
   </details>

2. **Когда doubly linked list лучше singly?**
   <details><summary>Ответ</summary>

   Когда нужно двигаться в обе стороны (browser history), или когда нужно O(1) удаление с конца (LRU cache), или когда нужно быстро удалить узел, имея только указатель на него.
   </details>

3. **Почему fast/slow pointers находят середину списка?**
   <details><summary>Ответ</summary>

   Fast двигается в 2 раза быстрее. Когда fast дойдёт до конца (пройдя n шагов), slow будет на n/2 — ровно посередине.
   </details>

4. **Почему при reverse важно сохранить next ПЕРЕД изменением curr.next?**
   <details><summary>Ответ</summary>

   Потому что curr.next — единственная ссылка на следующий узел. Если мы сначала изменим curr.next = prev, мы потеряем доступ к остатку списка.
   </details>

5. **Зачем нужен dummy/sentinel node?**
   <details><summary>Ответ</summary>

   Чтобы избежать особых случаев (edge cases) для операций с head. С dummy node голова списка всегда существует (dummy.next), и код становится проще.
   </details>

### Задачи для закрепления

| # | Задача | Сложность | Паттерн | Ссылка |
|---|--------|-----------|---------|--------|
| 1 | Reverse Linked List | Easy | In-place reversal | [LeetCode 206](https://leetcode.com/problems/reverse-linked-list/) |
| 2 | Linked List Cycle | Easy | Fast/Slow | [LeetCode 141](https://leetcode.com/problems/linked-list-cycle/) |
| 3 | Merge Two Sorted Lists | Easy | Dummy node | [LeetCode 21](https://leetcode.com/problems/merge-two-sorted-lists/) |
| 4 | Middle of the Linked List | Easy | Fast/Slow | [LeetCode 876](https://leetcode.com/problems/middle-of-the-linked-list/) |
| 5 | Remove Nth Node From End | Medium | Two pointers gap | [LeetCode 19](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) |
| 6 | Linked List Cycle II | Medium | Floyd's algorithm | [LeetCode 142](https://leetcode.com/problems/linked-list-cycle-ii/) |
| 7 | Reorder List | Medium | Find middle + Reverse + Merge | [LeetCode 143](https://leetcode.com/problems/reorder-list/) |
| 8 | Palindrome Linked List | Medium | Fast/Slow + Reverse | [LeetCode 234](https://leetcode.com/problems/palindrome-linked-list/) |
| 9 | Add Two Numbers | Medium | Carry tracking | [LeetCode 2](https://leetcode.com/problems/add-two-numbers/) |
| 10 | Merge K Sorted Lists | Hard | Divide & Conquer | [LeetCode 23](https://leetcode.com/problems/merge-k-sorted-lists/) |
| 11 | Reverse Nodes in k-Group | Hard | In-place reversal | [LeetCode 25](https://leetcode.com/problems/reverse-nodes-in-k-group/) |
| 12 | LRU Cache | Medium | Doubly linked + HashMap | [LeetCode 146](https://leetcode.com/problems/lru-cache/) |

### Порядок решения

1. **Начни с:** Reverse Linked List, Linked List Cycle — базовые паттерны
2. **Затем:** Middle of List, Merge Two Lists — fast/slow и dummy node
3. **2 указателя:** Remove Nth From End, Cycle II — усложнения
4. **Комбинации:** Palindrome, Reorder List — несколько техник вместе
5. **Продвинутый:** Merge K Lists, LRU Cache — интеграция с другими структурами

---

## 12. Мифы и заблуждения

| Миф | Реальность |
|-----|-----------|
| "Linked List всегда лучше для вставки/удаления" | **Только если знаешь позицию.** Поиск позиции = O(n). Для маленьких данных массив быстрее из-за cache locality даже при O(n) сдвигах. |
| "Linked List экономит память" | **Наоборот!** Каждый узел хранит 1-2 указателя (8-16 байт). Для int это 2-4x overhead. ArrayList компактнее. |
| "O(1) вставка = быстрая вставка" | **O(1) не значит быстро.** Cache miss при переходе между узлами стоит 100-200 циклов CPU. Array с O(n) может быть быстрее на практике. |
| "Doubly linked list = 2x медленнее singly" | **Нет, почти так же.** Дополнительный указатель незначительно влияет на скорость, но даёт O(1) удаление с конца. |
| "Linked List нужен для Stack и Queue" | **Не обязательно.** `ArrayDeque` в Java быстрее для обоих случаев. Linked List полезен когда нужен O(1) insert/delete в середине. |
| "Нельзя использовать binary search на linked list" | **Технически можно, но нет смысла.** Доступ к среднему элементу = O(n), поэтому общая сложность O(n log n) хуже линейного поиска O(n). |
| "Circular linked list опасен — зациклится" | **Только если нет терминального условия.** Правильный код проверяет: `while (curr != head)` или использует счётчик. |
| "Linked List устарел, никто не использует" | **Неверно!** LRU Cache (HashMap + Doubly Linked), Linux kernel (intrusive linked lists), Memory allocators, Skip lists в Redis. |

---

## 13. CS-фундамент

| CS-концепция | Как применяется в Linked Lists |
|--------------|-------------------------------|
| **Указатели/Ссылки** | Основа linked list — каждый узел хранит адрес следующего. Pointer arithmetic, dereferencing, null checks. |
| **Динамическая память** | Узлы выделяются в heap через malloc/new. Память не контактная, в отличие от массива. Требует явного освобождения в C/C++. |
| **Sequential Access** | Linked List = последовательная структура. Нет random access, нужно идти по цепочке. Это определяет O(n) доступ по индексу. |
| **Cache Locality** | Узлы разбросаны в памяти → много cache misses. CPU кэш загружает блоками, но linked list не использует это преимущество. |
| **Space-Time Trade-off** | Doubly linked тратит 2x памяти на указатели, но получает O(1) удаление. Tail pointer + O(n) память = O(1) вставка в конец. |
| **Рекурсивные структуры** | Linked List — рекурсивная структура: List = Node + List. Многие алгоритмы (reverse, merge) элегантны в рекурсивной форме. |
| **Sentinel/Dummy Pattern** | Добавление фиктивного узла упрощает edge cases (пустой список, удаление head). Паттерн из systems programming. |

---

## 14. Связанные темы

### Prerequisites (изучить ДО этого материала)
- [[big-o-complexity]] — понимание сложности O(1) vs O(n)
- [[arrays-strings]] — для сравнения и понимания trade-offs

### Эта тема открывает (изучить ПОСЛЕ)
- [[stacks-queues]] — реализуются на базе linked list
- [[trees-binary]] — деревья = связанные узлы с 2 указателями
- [[graphs]] — графы обобщают идею связанных узлов

### Связанные паттерны
- [[two-pointers-pattern]] — fast/slow и другие вариации
- [[dfs-bfs-patterns]] — обход структур на узлах

---

## Связь с другими темами

**[[stacks-queues]]** --- стеки и очереди часто реализуются через linked list: стек --- через singly linked list с push/pop на голове за O(1), очередь --- через singly linked list с указателем на хвост (enqueue в хвост, dequeue с головы). Хотя на практике ArrayDeque обычно предпочтительнее из-за cache locality, linked list реализация остаётся важной для понимания фундаментальных абстракций и часто спрашивается на собеседованиях.

**[[trees-binary]]** --- деревья обобщают идею связного списка: один указатель next превращается в два указателя left и right. Узел linked list хранит `val + next`, узел бинарного дерева --- `val + left + right`. Многие техники из linked lists (рекурсивный обход, dummy node, pointer manipulation) напрямую переносятся на деревья. Reverse linked list и invert binary tree --- структурно аналогичные задачи.

**[[graphs]]** --- граф является обобщением связного списка: каждый узел может указывать на произвольное число соседей (adjacency list --- это массив linked lists). Linked list --- это граф-путь (path graph), дерево --- связный ациклический граф, а общий граф допускает циклы и произвольную степень вершин. Понимание указателей и обхода в linked list --- фундамент для работы с графовыми структурами.

---

## 15. Источники

| # | Источник | Тип | Что взято |
|---|----------|-----|-----------|
| 1 | [Tech Interview Handbook - Linked List](https://www.techinterviewhandbook.org/algorithms/linked-list/) | Guide | Interview techniques, corner cases |
| 2 | [VisuAlgo - Linked List](https://visualgo.net/en/list) | Interactive | Visual animations |
| 3 | [DEV.to - Master Linked Lists](https://dev.to/coder_studios/master-linked-lists-the-complete-beginners-guide-with-real-world-and-technical-examples-20h6) | Tutorial | Train analogy, real-world examples |
| 4 | [freeCodeCamp - How Linked Lists Work](https://www.freecodecamp.org/news/how-linked-lists-work/) | Tutorial | Beginner explanation |
| 5 | [GeeksforGeeks - Floyd's Algorithm](https://www.geeksforgeeks.org/dsa/floyds-cycle-finding-algorithm/) | Reference | Fast/slow pointer math |
| 6 | [DEV.to - Visual Guide to Reversing](https://dev.to/jacobjzhang/a-visual-guide-to-reversing-a-linked-list-161e) | Tutorial | Step-by-step reverse |
| 7 | [HappyCoders - Array vs Linked List](https://www.happycoders.eu/algorithms/array-vs-linked-list/) | Analysis | Cache locality, performance |

### Книги

- **Cormen, Leiserson, Rivest & Stein (2009). "Introduction to Algorithms."** --- глава 10: linked lists как элементарная структура данных, sentinels, реализация с doubly linked list
- **Sedgewick & Wayne (2011). "Algorithms."** --- linked lists с детальным анализом performance vs arrays, итераторы и generic-реализация на Java
- **Knuth (1997). "The Art of Computer Programming, Vol. 1: Fundamental Algorithms."** --- фундаментальный анализ связных структур: singly/doubly/circular linked lists, memory allocation, garbage collection

*Исследование проведено: 2025-12-29*

---

## Проверь себя

> [!question]- Почему удаление узла из середины singly linked list требует знания предыдущего узла?
> В singly linked list каждый узел имеет только ссылку next. Чтобы удалить узел, нужно перенаправить next предыдущего узла на следующий за удаляемым. Без доступа к предыдущему узлу это невозможно. В doubly linked list эта проблема решена наличием prev ссылки.

> [!question]- Тебе нужно определить, есть ли цикл в связном списке, используя O(1) памяти. Какой подход ты выберешь?
> Fast-Slow Pointers (алгоритм Флойда): медленный указатель двигается на 1 шаг, быстрый на 2. Если есть цикл, они обязательно встретятся. Если быстрый дойдёт до null -- цикла нет. O(n) время, O(1) память.

> [!question]- В каких реальных системах используются связные списки и почему?
> LRU Cache (doubly linked list + HashMap), файловые системы (цепочки блоков), undo/redo в редакторах, управление свободной памятью (free list). Во всех случаях критична O(1) вставка/удаление при известной позиции.

> [!question]- Почему массивы обычно быстрее связных списков, несмотря на O(1) вставку/удаление у последних?
> Cache locality: элементы массива в непрерывной памяти загружаются целой cache line. Узлы списка разбросаны по heap, каждое обращение -- cache miss. На практике разница может быть в 10-100 раз для последовательного обхода.

---

## Ключевые карточки

Какие типы связных списков существуют?
?
Singly Linked List (next), Doubly Linked List (next + prev), Circular Linked List (последний узел указывает на первый). Каждый тип подходит для разных задач.

Какова сложность операций singly linked list?
?
Insert в начало: O(1). Insert в конец: O(n) без tail, O(1) с tail. Search: O(n). Delete по значению: O(n). Access по индексу: O(n).

Что такое алгоритм Флойда для обнаружения цикла?
?
Два указателя: slow (шаг 1) и fast (шаг 2). Если цикл есть, они встретятся. Для нахождения начала цикла: после встречи сбрасываем slow на head и двигаем оба по 1 шагу -- встретятся в начале цикла.

Как развернуть связный список за O(n) время и O(1) память?
?
Итеративно: три указателя (prev, curr, next). На каждом шаге: next = curr.next, curr.next = prev, prev = curr, curr = next. В конце prev -- новый head.

Чем doubly linked list лучше singly?
?
Удаление узла за O(1) при наличии ссылки на узел (есть prev). Обход в обе стороны. Используется в LRU Cache, где нужно быстро удалять и перемещать элементы.

Когда стоит использовать связный список вместо массива?
?
Частые вставки/удаления в начало или середину. Неизвестный заранее размер данных. Реализация стека/очереди. Но на практике ArrayList часто быстрее из-за cache locality.

---

## Куда дальше

| Направление | Куда | Зачем |

|-------------|------|-------|

| Следующий шаг | [[data-structures/stacks-queues]] | Структуры данных на основе списков |

| Углубиться | [[patterns/fast-slow-pointers-pattern]] | Главный паттерн работы со списками |

| Смежная тема | [[data-structures/trees-binary]] | Деревья как расширение идеи узлов и ссылок |

| Обзор | [[cs-fundamentals-overview]] | Вернуться к карте раздела |


*Обновлено: 2026-01-06*
*Отчёт: [[docs/research/2025-12-29-linked-lists-teaching.md]]*

---

*Обновлено: 2026-01-06 — добавлены педагогические секции (интуиция указателей, типичные проблемы, ментальные модели)*

---

[[arrays-strings|← Arrays & Strings]] | [[cs-fundamentals-overview|CS Fundamentals MOC]] | [[stacks-queues|Stacks & Queues →]]
