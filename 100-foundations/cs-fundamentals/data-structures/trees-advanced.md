---
title: "Продвинутые деревья: AVL и красно-чёрные деревья"
created: 2026-02-09
modified: 2026-02-13
type: deep-dive
status: published
tags:
  - topic/cs-fundamentals
  - type/deep-dive
  - level/advanced
  - interview
related:
  - "[[trees-binary]]"
  - "[[graphs]]"
prerequisites:
  - "[[trees-binary]]"
  - "[[big-o-complexity]]"
  - "[[recursion-fundamentals]]"

reading_time: 45
difficulty: 7
study_status: not_started
mastery: 0
last_reviewed:
next_review:
---

# Advanced Trees: AVL & Red-Black Trees

## TL;DR

Self-balancing BST гарантируют O(log n) для всех операций. **AVL**: строже сбалансирован (высота ≤ 1.44 log n), лучше для read-heavy. **Red-Black**: меньше ротаций при insert/delete, лучше для write-heavy. Red-Black используется в std::map (C++), TreeMap (Java), Linux kernel.

---

## Интуиция

### Аналогия 1: AVL как педантичный библиотекарь

```
AVL TREE = ПЕДАНТИЧНЫЙ БИБЛИОТЕКАРЬ:

"Полки должны быть ИДЕАЛЬНО сбалансированы!"
Разница высоты ≤ 1 для КАЖДОГО узла.

Добавляем книгу → полка перекосилась?
→ НЕМЕДЛЕННО перестроить! (ротация)
→ Возможно несколько ротаций

Результат: Идеальный поиск, но много перестановок.
Хорошо для: библиотеки с частым поиском, редким добавлением.
```

### Аналогия 2: Red-Black как расслабленный менеджер

```
RED-BLACK = МЕНЕДЖЕР С ГИБКИМИ ПРАВИЛАМИ:

"Пока дерево примерно сбалансировано — ОК!"
Правила через цвета: красный родитель → чёрные дети.

Добавляем сотрудника → небольшой дисбаланс?
→ Может, просто перекрасим? (дёшево)
→ Ротация только если совсем плохо

Результат: Меньше перестановок, чуть хуже поиск.
Хорошо для: часто меняющейся команды.
```

---

## Частые ошибки

### Ошибка 1: Забыть обновить высоту после ротации

**СИМПТОМ:** Неправильный balance factor, лишние ротации

```kotlin
// НЕПРАВИЛЬНО:
fun rotateRight(y: Node): Node {
    val x = y.left!!
    y.left = x.right
    x.right = y
    return x  // высоты не обновлены!
}

// ПРАВИЛЬНО:
fun rotateRight(y: Node): Node {
    val x = y.left!!
    y.left = x.right
    x.right = y
    y.updateHeight()  // сначала нижний узел
    x.updateHeight()  // потом верхний
    return x
}
```

### Ошибка 2: Путать LL/LR/RL/RR ротации

**СИМПТОМ:** Дерево не балансируется

```
ВЫБОР РОТАЦИИ по Balance Factor:

BF > 1 (левый перевес):
  BF(left) >= 0 → LL → rotateRight(node)
  BF(left) < 0  → LR → rotateLeft(left), rotateRight(node)

BF < -1 (правый перевес):
  BF(right) <= 0 → RR → rotateLeft(node)
  BF(right) > 0  → RL → rotateRight(right), rotateLeft(node)
```

### Ошибка 3: Не сохранять родителя в Red-Black

**СИМПТОМ:** Fixup не может подняться к корню

```kotlin
// НЕПРАВИЛЬНО: узел без ссылки на родителя
class Node(val key: Int, var color: Color, var left: Node?, var right: Node?)

// ПРАВИЛЬНО: нужен parent для fixup
class Node(val key: Int, var color: Color,
           var left: Node?, var right: Node?, var parent: Node?)
```

---

## Ментальные модели

### Модель 1: "AVL строже, Red-Black гибче"

```
СРАВНЕНИЕ ВЫСОТЫ:

AVL:       h ≤ 1.44 * log₂(n)   ← строгий баланс
Red-Black: h ≤ 2 * log₂(n)      ← допускает перекос

ПОСЛЕДСТВИЯ:

            AVL             Red-Black
Search      Быстрее         Чуть медленнее
Insert      1-2 ротации     ≤2 ротации
Delete      O(log n) рот.   ≤3 ротации
Use case    Read-heavy      Write-heavy
```

### Модель 2: "Red-Black = 2-3-4 дерево в маскировке"

```
Red-Black эквивалентен 2-3-4 дереву:

Чёрный узел с красными детьми = 3-node или 4-node

     B           [R-B-R]
    / \    =     2-3-4
   R   R          node

Правила Red-Black — это правила 2-3-4, переформулированные для бинарного дерева.
```

---

## Зачем это нужно?

### Деградация BST: от дерева к списку

Чтобы по-настоящему оценить сбалансированные деревья, нужно понять, ПОЧЕМУ обычное BST ломается. BST (Binary Search Tree) обещает O(log n) поиск, вставку и удаление. Но это обещание держится только при одном условии: дерево должно быть примерно симметричным. Как только баланс нарушается, производительность деградирует.

Представьте библиотеку, где книги расставлены по алфавиту. Если полки равномерно заполнены, найти нужную книгу легко: идёте в середину, потом в нужную половину, потом в четверть -- за log n шагов добираетесь до цели. Но что если все книги стоят на одной полке, одна за другой, слева направо? Тогда поиск превращается в перебор: вы идёте от первой книги до нужной, проверяя каждую. Это и есть деградация BST.

```
ДЕГРАДАЦИЯ BST — от дерева к связному списку:

Вставляем: 1, 2, 3, 4, 5 (отсортированные данные)

     1                   Шаг 1: корень
      \
       2                 Шаг 2: 2 > 1, идём вправо
        \
         3               Шаг 3: всё вправо и вправо
          \
           4
            \
             5

Высота = n - 1 = 4 (для 5 элементов)
Search = O(n) вместо O(log n)!

Для сравнения, СБАЛАНСИРОВАННОЕ дерево тех же элементов:

         3
        / \
       2   4
      /     \
     1       5

Высота = 2 (для 5 элементов)
Search = O(log n) = O(2)
```

Проблема не академическая. На практике данные часто приходят частично или полностью отсортированными: временные метки, последовательные ID, алфавитные записи. Без механизма балансировки BST превращается в связный список, и все операции становятся O(n).

> **Ключевая идея:** Балансировка -- это страховка от худшего случая. Мы платим небольшую цену (дополнительные операции при вставке/удалении) за гарантию, что дерево НИКОГДА не деградирует до списка.

Мы разобрали ПОЧЕМУ нужна балансировка. Теперь посмотрим на два главных подхода: AVL и Red-Black.

---

### Историческая справка

| Год | Событие |
|-----|---------|
| 1962 | Адельсон-Вельский и Ландис публикуют AVL-дерево -- первое самобалансирующееся BST |
| 1972 | Рудольф Байер изобретает "symmetric binary B-tree" -- предшественника Red-Black |
| 1978 | Леонидас Гибас и Роберт Седжвик формулируют красно-чёрное дерево в современном виде |
| 2008 | Седжвик предлагает Left-Leaning Red-Black Trees -- упрощённую реализацию |

AVL-дерево появилось раньше и долгое время считалось стандартом. Но Red-Black оказалось практичнее: меньше ротаций при модификациях, что критично для операционных систем и стандартных библиотек. Именно поэтому std::map в C++, TreeMap в Java и планировщик задач в Linux kernel используют Red-Black, а не AVL.

---

## AVL Tree

### Определение

**AVL Tree** — BST, где для каждого узла разница высот левого и правого поддерева ≤ 1.

```
Balance Factor = height(left) - height(right)
Valid: -1, 0, +1
```

### Визуализация

```
Сбалансированное AVL:        Несбалансированное (BF = 2):
       10 (BF=0)                    10 (BF=2)
      /  \                         /
     5    15 (BF=0)               5 (BF=1)
    / \   / \                    /
   3   7 12  20                 3 (BF=0)
                               /
                              1  ← нарушает баланс
```

### Четыре типа ротаций

#### 1. Left-Left (LL) — Single Right Rotation

```
Проблема:             Решение (Right Rotate):
    30 (BF=2)              20
   /                      /  \
  20 (BF=1)              10   30
 /
10

Code:
fun rightRotate(y: Node): Node {
    val x = y.left
    val T2 = x.right

    x.right = y
    y.left = T2

    updateHeight(y)
    updateHeight(x)
    return x
}
```

#### 2. Right-Right (RR) — Single Left Rotation

```
Проблема:             Решение (Left Rotate):
10 (BF=-2)                 20
  \                       /  \
   20 (BF=-1)            10   30
     \
      30
```

#### 3. Left-Right (LR) — Double Rotation

```
Проблема:             Шаг 1 (Left Rotate 10):    Шаг 2 (Right Rotate 30):
    30 (BF=2)              30                          20
   /                      /                           /  \
  10 (BF=-1)             20                          10   30
    \                   /
     20                10
```

#### 4. Right-Left (RL) — Double Rotation

```
Проблема:             Шаг 1 (Right Rotate 30):   Шаг 2 (Left Rotate 10):
10 (BF=-2)                 10                          20
  \                          \                        /  \
   30 (BF=1)                  20                     10   30
  /                             \
 20                              30
```

### Реализация AVL (Kotlin)

```kotlin
class AVLTree {
    data class Node(
        var key: Int,
        var left: Node? = null,
        var right: Node? = null,
        var height: Int = 1
    )

    private var root: Node? = null

    private fun height(node: Node?): Int = node?.height ?: 0

    private fun balanceFactor(node: Node?): Int =
        height(node?.left) - height(node?.right)

    private fun updateHeight(node: Node) {
        node.height = 1 + maxOf(height(node.left), height(node.right))
    }

    /**
     * ПРАВЫЙ ПОВОРОТ — используется при LL дисбалансе
     *
     *       y                x
     *      / \              / \
     *     x   T3    →     T1   y
     *    / \                  / \
     *   T1  T2              T2  T3
     *
     * Результат: x становится новым корнем, y уходит вправо
     */
    private fun rightRotate(y: Node): Node {
        val x = y.left!!
        val T2 = x.right

        x.right = y
        y.left = T2

        updateHeight(y)
        updateHeight(x)
        return x
    }

    /**
     * ЛЕВЫЙ ПОВОРОТ — используется при RR дисбалансе
     *
     *     x                  y
     *    / \                / \
     *   T1  y      →       x  T3
     *      / \            / \
     *     T2  T3        T1  T2
     *
     * Результат: y становится новым корнем, x уходит влево
     */
    private fun leftRotate(x: Node): Node {
        val y = x.right!!
        val T2 = y.left

        y.left = x
        x.right = T2

        updateHeight(x)
        updateHeight(y)
        return y
    }

    /**
     * БАЛАНСИРОВКА — вызывается после каждой вставки/удаления
     *
     * Проверяем 4 случая дисбаланса:
     * - LL: левый-левый → один правый поворот
     * - LR: левый-правый → левый + правый повороты
     * - RR: правый-правый → один левый поворот
     * - RL: правый-левый → правый + левый повороты
     */
    private fun balance(node: Node): Node {
        updateHeight(node)
        val bf = balanceFactor(node)

        // LL Case
        if (bf > 1 && balanceFactor(node.left) >= 0) {
            return rightRotate(node)
        }

        // LR Case
        if (bf > 1 && balanceFactor(node.left) < 0) {
            node.left = leftRotate(node.left!!)
            return rightRotate(node)
        }

        // RR Case
        if (bf < -1 && balanceFactor(node.right) <= 0) {
            return leftRotate(node)
        }

        // RL Case
        if (bf < -1 && balanceFactor(node.right) > 0) {
            node.right = rightRotate(node.right!!)
            return leftRotate(node)
        }

        return node
    }

    fun insert(key: Int) {
        root = insertRec(root, key)
    }

    private fun insertRec(node: Node?, key: Int): Node {
        if (node == null) return Node(key)

        when {
            key < node.key -> node.left = insertRec(node.left, key)
            key > node.key -> node.right = insertRec(node.right, key)
            else -> return node  // Дубликаты игнорируем
        }

        // ВАЖНО: балансировка происходит на ОБРАТНОМ пути рекурсии!
        // Сначала вставляем элемент вглубь, потом при "всплытии"
        // проверяем и исправляем баланс каждого предка
        return balance(node)
    }
}
```

---

## Red-Black Tree: глубокое погружение

### Почему именно Red-Black?

Мы уже видели, что AVL-дерево хорошо решает проблему балансировки. Зачем тогда другая структура? Ответ: AVL-дерево слишком строгое. При каждом удалении элемента оно может потребовать O(log n) ротаций -- потому что требует абсолютного баланса (разница высот максимум 1). В системах, где модификации происходят миллионы раз в секунду (ядро ОС, базы данных), эта цена слишком высока.

Red-Black дерево ослабляет требования: оно допускает высоту до 2 * log n (вместо 1.44 * log n у AVL). Это чуть хуже для поиска, но ГОРАЗДО лучше для модификаций: максимум 2 ротации при вставке, максимум 3 при удалении. Не O(log n) ротаций, а фиксированная константа.

Представьте двух архитекторов. Первый (AVL) требует, чтобы здание было ИДЕАЛЬНО симметричным. Каждый раз, когда вы пристраиваете комнату, он заставляет перестраивать половину здания. Второй (Red-Black) говорит: "Здание должно быть ПРИМЕРНО симметричным. Небольшой перекос допустим, главное -- не больше чем в два раза." При этом перестройка минимальна: подвинул пару стен, перекрасил пару дверей.

### Определение

**Red-Black Tree** -- BST, в котором каждый узел окрашен в красный или чёрный цвет, а набор правил окраски гарантирует, что высота дерева не превысит 2 * log(n + 1).

> **Ключевая идея:** Цвета -- это не произвольное украшение. Это способ кодировать структуру 2-3-4 дерева в виде бинарного дерева. Красный узел -- это узел, "склеенный" со своим родителем в один узел 2-3-4 дерева.

---

### Пять свойств Red-Black Tree: ПОЧЕМУ именно они

Пять свойств RB-дерева кажутся произвольными, пока не понимаешь, ЧТО каждое из них гарантирует. Разберём каждое:

```
ПЯТЬ СВОЙСТВ RED-BLACK TREE:

1. Каждый узел КРАСНЫЙ или ЧЁРНЫЙ
2. Корень ВСЕГДА ЧЁРНЫЙ
3. Каждый лист (NIL-sentinel) ЧЁРНЫЙ
4. Если узел КРАСНЫЙ, оба его ребёнка ЧЁРНЫЕ
5. Все пути от любого узла до его листьев содержат
   ОДИНАКОВОЕ число ЧЁРНЫХ узлов (black-height)
```

**Свойство 1** -- просто определяет пространство состояний. Каждый узел имеет дополнительный бит информации: цвет. Это минимальное дополнение к BST.

**Свойство 2** (корень чёрный) -- техническое. Оно упрощает алгоритмы: если после вставки корень стал красным, мы просто перекрашиваем его в чёрный. Это единственное свойство, которое можно нарушить и мгновенно починить.

**Свойство 3** (NIL-листья чёрные) -- тонкое, но критичное. Мы считаем, что у каждого "настоящего" узла, у которого нет ребёнка, есть невидимый чёрный NIL-узел. Зачем? Чтобы свойство 5 работало единообразно. Без NIL-узлов пришлось бы отдельно обрабатывать краевые случаи.

**Свойство 4** (нет двух красных подряд) -- ключевое ограничение. Оно означает, что на любом пути от корня до листа красные узлы "разбавлены" чёрными. Красный узел -- это "бонусный" узел, приклеенный к чёрному родителю. Два красных подряд -- это "тройное склеивание", которое выходит за рамки 2-3-4 дерева.

**Свойство 5** (одинаковая чёрная высота) -- САМОЕ ВАЖНОЕ. Именно оно гарантирует баланс. Если все пути имеют одинаковое количество чёрных узлов, то самый длинный путь не может быть больше чем вдвое длиннее самого короткого.

---

### Почему свойства 4 и 5 вместе гарантируют O(log n)

Это центральная теорема Red-Black деревьев. Разберём её пошагово.

Пусть black-height (чёрная высота) дерева = bh. Тогда:

- **Самый короткий путь** от корня до листа содержит только чёрные узлы. Его длина = bh.
- **Самый длинный путь** чередует красные и чёрные узлы (потому что два красных подряд запрещены свойством 4). Его длина = 2 * bh.

Следовательно: высота дерева h <= 2 * bh.

Теперь нужно связать bh с количеством узлов n. По индукции можно доказать (CLRS, теорема 13.1), что поддерево с корнем в узле x содержит как минимум 2^bh(x) - 1 внутренних узлов. Для корня это даёт:

```
n >= 2^bh - 1
log(n + 1) >= bh
h <= 2 * bh <= 2 * log(n + 1)

ВЫВОД: Высота RB-дерева = O(log n)
       Все операции (search, insert, delete) = O(log n)
```

Аналогия: представьте автостраду, где "чёрные" участки -- это обязательные километры, а "красные" -- дополнительные. Правило: после каждого красного участка ОБЯЗАТЕЛЬНО идёт чёрный. Тогда дорога максимум вдвое длиннее, чем если бы были только чёрные участки.

---

### Вставка в Red-Black Tree: пошаговый разбор

Вставка в RB-дерево происходит в два этапа: стандартная BST-вставка, а затем "починка" (fixup) нарушенных свойств. Новый узел ВСЕГДА красный -- и вот почему: если мы вставим чёрный узел, мы нарушим свойство 5 (чёрная высота изменится на одном из путей). Красный узел не меняет чёрную высоту, но может нарушить свойство 4 (два красных подряд). Свойство 4 легче починить -- для этого нужны только перекраски и максимум 2 ротации.

Разберём три случая fixup (когда родитель красный -- иначе нарушения нет):

**Case 1: Дядя красный -- "перекрасить и подняться"**

Это самый простой случай. Если и родитель, и дядя красные, мы можем перекрасить их обоих в чёрный, а дедушку в красный. Это "проталкивает" проблему вверх по дереву, не меняя чёрную высоту.

```
CASE 1: Дядя красный → ПЕРЕКРАСКА

До:                        После:
        G(B)                      G(R) ← может нарушать выше
       /   \                     /   \
     P(R)   U(R)   →          P(B)   U(B)
    /                         /
  N(R) ← новый              N(R)

Что произошло:
- P и U стали чёрными → чёрная высота их поддеревьев +1
- G стал красным → чёрная высота G не изменилась (сбалансировали)
- Но G теперь красный! Если родитель G тоже красный → повторяем fixup для G
- В худшем случае поднимаемся до корня → O(log n) перекрасок, 0 ротаций
```

Аналогия: в многоэтажном здании пожарная тревога на первом этаже. Вместо того чтобы перестраивать здание, мы "передаём тревогу" наверх. Каждый этаж обрабатывает её за O(1), и максимум log n этажей.

**Case 2: Дядя чёрный, узел "внутри" -- "выровнять и перейти к Case 3"**

Если новый узел -- правый ребёнок левого родителя (или наоборот), он находится "внутри" поддерева. Одна ротация приводит его в "внешнюю" позицию, после чего применяется Case 3.

```
CASE 2: Дядя чёрный, узел ВНУТРИ → РОТАЦИЯ к Case 3

До:                    После ротации (становится Case 3):
      G(B)                    G(B)
     /   \                   /   \
   P(R)   U(B)     →      N(R)   U(B)
     \                    /
     N(R)               P(R)

Левая ротация вокруг P:
- N и P поменялись ролями
- Теперь N -- "внешний" узел (левый ребёнок левого родителя)
- Переходим к Case 3
```

**Case 3: Дядя чёрный, узел "снаружи" -- "ротация + перекраска"**

Финальный случай. Одна ротация плюс перекраска полностью восстанавливают все свойства.

```
CASE 3: Дядя чёрный, узел СНАРУЖИ → РОТАЦИЯ + ПЕРЕКРАСКА

До:                     После:
      G(B)                    P(B)
     /   \                   /   \
   P(R)   U(B)    →       N(R)   G(R)
  /                                \
N(R)                               U(B)

Правая ротация вокруг G + перекраска:
- P становится корнем поддерева (чёрный)
- G уходит вправо (красный)
- Чёрная высота СОХРАНЕНА
- ВСЕ свойства восстановлены
- ГОТОВО (не нужно подниматься выше)
```

> **Ключевой вывод:** Вставка в RB-дерево требует максимум O(log n) перекрасок и максимум 2 ротации. Ротации -- O(1) каждая. Суммарная сложность: O(log n), причём основная работа -- это перекраски, а не ротации.

---

### Пошаговый пример вставки

Построим RB-дерево, вставляя элементы 10, 20, 30, 15, 25:

```
ШАГ 1: Вставка 10
  10(B)                ← корень всегда чёрный (свойство 2)

ШАГ 2: Вставка 20
  10(B)
    \
    20(R)              ← новый узел красный, родитель чёрный → OK

ШАГ 3: Вставка 30     ← НАРУШЕНИЕ! 20(R) → 30(R) — два красных подряд
  10(B)                Дядя = NIL = чёрный, узел снаружи → Case 3
    \
    20(R)              Левая ротация вокруг 10 + перекраска:
      \
      30(R)

  Результат:
      20(B)
     /    \
   10(R)  30(R)        ← все свойства соблюдены

ШАГ 4: Вставка 15
      20(B)
     /    \
   10(R)  30(R)
     \
     15(R)             ← НАРУШЕНИЕ! 10(R) → 15(R)
                       Дядя 30 КРАСНЫЙ → Case 1: перекрасить

  Результат после перекраски:
      20(B)            ← остаётся чёрным (корень)
     /    \
   10(B)  30(B)        ← перекрасили в чёрный
     \
     15(R)             ← OK, родитель теперь чёрный

ШАГ 5: Вставка 25
      20(B)
     /    \
   10(B)  30(B)
     \    /
    15(R) 25(R)        ← родитель 30 чёрный → нет нарушения → OK

ФИНАЛЬНОЕ ДЕРЕВО:
         20(B)
        /    \
     10(B)   30(B)
       \     /
      15(R) 25(R)
```

---

### Red-Black Tree в промышленных системах

Red-Black деревья -- не просто теоретическая конструкция. Они лежат в основе критических систем:

**Java TreeMap и TreeSet.** Когда вы пишете `TreeMap<String, Integer>()` в Java, под капотом создаётся Red-Black дерево. Все операции `put()`, `get()`, `remove()` работают за O(log n). Метод `firstKey()` находит минимум, `lastKey()` -- максимум, `subMap()` возвращает view на диапазон. Всё это возможно благодаря BST-свойству + гарантии O(log n) высоты.

**C++ std::map и std::set.** Стандарт C++ не указывает конкретную реализацию, но требует O(log n) для insert/find/erase и амортизированный O(1) для итерации. На практике все основные реализации (libstdc++, libc++, MSVC) используют Red-Black деревья.

**Linux Completely Fair Scheduler (CFS).** Планировщик задач в ядре Linux использует RB-дерево для организации процессов по "виртуальному времени". Процесс с наименьшим виртуальным временем (самый "обделённый" CPU) находится в левом конце дерева и получает процессорное время следующим. Вставка и удаление процессов -- O(log n), что критично для систем с тысячами процессов.

**Linux epoll.** Механизм мониторинга файловых дескрипторов в Linux использует RB-дерево для хранения зарегистрированных дескрипторов. Это обеспечивает O(log n) поиск при добавлении и удалении дескрипторов.

---

### Распространённые заблуждения

**Заблуждение 1: "Red-Black медленнее AVL для поиска"**

Технически да, максимальная высота RB-дерева (2 log n) больше AVL (1.44 log n). Но на практике разница минимальна. Для n = 1 000 000 максимальная высота AVL = ~29, RB = ~40. Но реальные RB-деревья редко достигают максимальной высоты. Средняя высота обоих -- примерно 1.0 * log n. Различие в несколько сравнений исчезает на фоне cache miss'ов и других аппаратных факторов.

**Заблуждение 2: "Красный и чёрный цвета -- произвольный выбор"**

Гибас и Седжвик выбрали цвета потому, что статья была напечатана на лазерном принтере Xerox, который хорошо печатал красный и чёрный. В оригинальной работе Байера узлы назывались "горизонтальные" и "вертикальные" связи.

**Заблуждение 3: "Red-Black деревья сложнее AVL"**

С точки зрения кода вставки -- да, fixup RB-дерева имеет больше случаев. Но удаление в AVL-дереве сложнее, чем в RB. А если использовать Left-Leaning Red-Black Trees (Седжвик, 2008), реализация становится значительно проще -- всего около 40 строк кода.

---

### Визуализация

```
        8(B)
       /    \
     4(R)    12(R)
    /  \     /   \
  2(B) 6(B) 10(B) 14(B)
```

### Операции вставки

```
Новый узел всегда КРАСНЫЙ (кроме корня)

Case 1: Дядя красный → Перекрасить
        G(B)             G(R)
       /   \            /   \
      P(R)  U(R)  →   P(B)  U(B)
     /                /
    N(R)             N(R)

Case 2: Дядя чёрный, узел внутри → Ротация к Case 3
        G(B)             G(B)
       /   \            /   \
      P(R)  U(B)  →   N(R)  U(B)
        \             /
        N(R)        P(R)

Case 3: Дядя чёрный, узел снаружи → Ротация + перекраска
        G(B)             P(B)
       /   \            /   \
      P(R)  U(B)  →   N(R)  G(R)
     /                        \
    N(R)                      U(B)
```

### Реализация Red-Black (Kotlin)

```kotlin
class RedBlackTree {
    enum class Color { RED, BLACK }

    data class Node(
        var key: Int,
        var color: Color = Color.RED,
        var left: Node? = null,
        var right: Node? = null,
        var parent: Node? = null
    )

    private var root: Node? = null
    // NIL — это "страж" (sentinel), общий для всех листьев
    // Вместо null используем специальный ЧЁРНЫЙ узел
    // Это упрощает код: не нужно проверять на null везде
    private val NIL = Node(0, Color.BLACK)

    private fun leftRotate(x: Node) {
        val y = x.right ?: return
        x.right = y.left

        y.left?.parent = x
        y.parent = x.parent

        when {
            x.parent == null -> root = y
            x == x.parent?.left -> x.parent?.left = y
            else -> x.parent?.right = y
        }

        y.left = x
        x.parent = y
    }

    private fun rightRotate(y: Node) {
        val x = y.left ?: return
        y.left = x.right

        x.right?.parent = y
        x.parent = y.parent

        when {
            y.parent == null -> root = x
            y == y.parent?.right -> y.parent?.right = x
            else -> y.parent?.left = x
        }

        x.right = y
        y.parent = x
    }

    fun insert(key: Int) {
        val newNode = Node(key)

        // ШАГ 1: Стандартная BST вставка
        // Находим место для нового узла и вставляем
        var y: Node? = null
        var x = root

        while (x != null) {
            y = x
            x = if (key < x.key) x.left else x.right
        }

        newNode.parent = y
        when {
            y == null -> root = newNode
            key < y.key -> y.left = newNode
            else -> y.right = newNode
        }

        // ШАГ 2: Восстанавливаем свойства RB-дерева
        // Новый узел КРАСНЫЙ, это может нарушить свойство 4
        // (два красных узла подряд запрещены)
        fixInsert(newNode)
    }

    private fun fixInsert(node: Node) {
        var z = node

        // Пока родитель КРАСНЫЙ — есть нарушение свойства 4:
        // "Оба ребёнка красного узла должны быть чёрными"
        // Мы только что вставили красный узел под красным родителем!
        while (z.parent?.color == Color.RED) {
            if (z.parent == z.parent?.parent?.left) {
                val uncle = z.parent?.parent?.right

                if (uncle?.color == Color.RED) {
                    // Case 1: Дядя красный
                    z.parent?.color = Color.BLACK
                    uncle.color = Color.BLACK
                    z.parent?.parent?.color = Color.RED
                    z = z.parent?.parent ?: break
                } else {
                    if (z == z.parent?.right) {
                        // Case 2: Узел внутри
                        z = z.parent ?: break
                        leftRotate(z)
                    }
                    // Case 3: Узел снаружи
                    z.parent?.color = Color.BLACK
                    z.parent?.parent?.color = Color.RED
                    z.parent?.parent?.let { rightRotate(it) }
                }
            } else {
                // Симметричный случай (parent — правый ребёнок)
                val uncle = z.parent?.parent?.left

                if (uncle?.color == Color.RED) {
                    z.parent?.color = Color.BLACK
                    uncle.color = Color.BLACK
                    z.parent?.parent?.color = Color.RED
                    z = z.parent?.parent ?: break
                } else {
                    if (z == z.parent?.left) {
                        z = z.parent ?: break
                        rightRotate(z)
                    }
                    z.parent?.color = Color.BLACK
                    z.parent?.parent?.color = Color.RED
                    z.parent?.parent?.let { leftRotate(it) }
                }
            }
        }

        // ВАЖНО: корень всегда ЧЁРНЫЙ!
        // Это свойство 2 RB-дерева.
        // После всех манипуляций корень мог стать красным — исправляем
        root?.color = Color.BLACK
    }
}
```

---

## Сравнение AVL vs Red-Black

| Критерий | AVL | Red-Black |
|----------|-----|-----------|
| Баланс | Строгий (|BF| ≤ 1) | Relaxed (черная высота) |
| Высота | ≤ 1.44 log n | ≤ 2 log n |
| Поиск | Немного быстрее | Немного медленнее |
| Вставка | До 2 ротаций + перебалансировка | До 2 ротаций |
| Удаление | До O(log n) ротаций | До 3 ротаций |
| Память | Меньше (только height) | Больше (color + parent) |
| Использование | Databases, lookup-heavy | std::map, TreeMap, kernels |

### Когда что использовать

```
AVL Tree:
✓ Много поисков, мало изменений
✓ Критична минимальная высота
✓ Примеры: индексы в базах данных, словари

Red-Black Tree:
✓ Частые вставки/удаления
✓ Нужен баланс между всеми операциями
✓ Примеры: std::map, TreeMap, scheduler в Linux
```

---

## Сложность операций

| Операция | AVL | Red-Black | Обычный BST |
|----------|-----|-----------|-------------|
| Search | O(log n) | O(log n) | O(n) worst |
| Insert | O(log n) | O(log n) | O(n) worst |
| Delete | O(log n) | O(log n) | O(n) worst |
| Min/Max | O(log n) | O(log n) | O(n) worst |
| Space | O(n) | O(n) | O(n) |

---

## Практика

### Концептуальные вопросы

1. **Почему новый узел в RB-дереве красный?**
   - Чёрный нарушил бы свойство 5 (разное число чёрных на путях)
   - Красный может нарушить только свойство 4 (красный родитель)
   - Свойство 4 легче исправить

2. **Почему AVL лучше для поиска?**
   - Меньшая высота = меньше сравнений
   - 1.44 log n vs 2 log n

3. **Почему RB используется в стандартных библиотеках?**
   - Меньше ротаций при модификациях
   - Более предсказуемое поведение
   - Проще реализация удаления

### Связанные задачи

- Реализация самобалансирующегося дерева
- Validate BST with balance check
- Найти k-й элемент в BST
- Merge two BSTs

---

## Связь с другими темами

**[[trees-binary]]** -- базовые BST-операции (поиск, вставка, удаление) являются фундаментом. Без понимания рекурсивного спуска по BST невозможно понять, почему балансировка добавляет только O(log n) дополнительной работы. Читайте BST перед этим материалом.

**[[segment-tree]]** -- дерево отрезков использует ту же идею бинарного разбиения, но для других задач (range queries). Понимание ротаций в AVL/RB помогает понять, почему сбалансированные деревья используются как основа для более сложных структур.

**B-Trees** -- обобщение Red-Black деревьев на более высокий порядок ветвления. Каждый узел B-дерева содержит от t до 2t ключей. Red-Black дерево -- это по сути 2-3-4 дерево (B-дерево порядка 4), закодированное как бинарное дерево. Понимание RB-деревьев значительно упрощает понимание B-деревьев, которые используются в файловых системах и базах данных.

**[[graphs]]** -- деревья являются частным случаем графов (связный ациклический граф). Многие алгоритмы на графах (Kruskal, поиск LCA) используют сбалансированные деревья как вспомогательные структуры данных.

---

## Источники и дальнейшее чтение

- **Cormen, T. et al. (2009). Introduction to Algorithms (CLRS), Chapter 13: Red-Black Trees.** -- Каноническое изложение с полными доказательствами всех свойств, включая теорему о высоте. Обязательно для глубокого понимания.

- **Sedgewick, R. (2008). Left-Leaning Red-Black Trees.** -- Упрощённая реализация RB-деревьев с только одним вариантом (левонаклонные красные связи). Код значительно проще, чем классический CLRS. Доступно на сайте Princeton.

- **Sedgewick, R. & Wayne, K. (2011). Algorithms, 4th Edition.** -- Глава 3.3 объясняет связь между 2-3 деревьями и Red-Black деревьями с отличными визуализациями. Более доступно, чем CLRS.

- **Adelson-Velsky, G. & Landis, E. (1962). An algorithm for the organization of information.** -- Оригинальная статья по AVL-деревьям. Историческая ценность -- первое самобалансирующееся дерево.

---


---

## Проверь себя

> [!question]- Почему Red-Black дерево используется в std::map и TreeMap, а не AVL?
> Red-Black дерево делает меньше ротаций при вставке/удалении (максимум 2-3), тогда как AVL может потребовать ротации на каждом уровне от листа до корня. Для write-heavy нагрузок (map с частыми вставками) это даёт преимущество. AVL строже сбалансировано и быстрее для read-heavy задач.

> [!question]- Как 5 свойств Red-Black дерева гарантируют O(log n) высоту?
> Свойство 4 (нет двух красных подряд) и свойство 5 (одинаковое число чёрных на каждом пути) вместе гарантируют, что самый длинный путь не более чем вдвое длиннее самого короткого. Это ограничивает высоту до 2*log(n+1), что даёт O(log n).

> [!question]- В каком сценарии AVL-дерево предпочтительнее Red-Black?
> Когда операций чтения значительно больше, чем записи. AVL строже сбалансировано (разница высот поддеревьев <= 1), что даёт высоту <= 1.44*log(n) против 2*log(n) у Red-Black. Для dictionary lookup или read-only данных AVL быстрее.

---

## Ключевые карточки

Что такое AVL-дерево?
?
Самобалансирующееся BST, где разница высот левого и правого поддеревьев (balance factor) любого узла не превышает 1. Гарантирует высоту <= 1.44*log(n). Балансировка через ротации после каждой вставки/удаления.

Какие 5 свойств Red-Black дерева?
?
1) Каждый узел красный или чёрный. 2) Корень чёрный. 3) Все nil-листья чёрные. 4) Красный узел имеет только чёрных детей. 5) Одинаковое число чёрных узлов на каждом пути от корня к листу.

Какие виды ротаций используются в AVL?
?
Left rotation, Right rotation, Left-Right (double), Right-Left (double). Выбор зависит от balance factor: LL-case (right rotation), RR-case (left rotation), LR-case и RL-case (двойные ротации).

Когда выбрать AVL, а когда Red-Black?
?
AVL: read-heavy нагрузка, нужна минимальная высота, поиск критичен. Red-Black: write-heavy нагрузка, частые вставки/удаления, используется в стандартных библиотеках (TreeMap, std::map).

Где используются Red-Black деревья в реальных системах?
?
Java TreeMap/TreeSet, C++ std::map/std::set, Linux kernel (планировщик CFS, управление vm_area), HashMap в Java 8+ (длинные цепочки коллизий переключаются на Red-Black Tree).

---

## Куда дальше

| Направление | Куда | Зачем |

|-------------|------|-------|

| Следующий шаг | [[data-structures/heaps-priority-queues]] | Другой вид бинарного дерева со своими свойствами |

| Углубиться | [[data-structures/segment-tree]] | Деревья для range queries |

| Смежная тема | [[data-structures/hash-tables]] | Сравнение упорядоченных деревьев и хеш-таблиц |

| Обзор | [[cs-fundamentals-overview]] | Вернуться к карте раздела |


*Последнее обновление: 2026-02-10 -- Добавлена глубокая теория Red-Black деревьев: деградация BST (почему балансировка нужна), разбор 5 свойств (почему именно они гарантируют O(log n)), пошаговая вставка с ASCII-диаграммами, использование в TreeMap/std::map/Linux kernel, историческая справка, распространённые заблуждения*
