---
title: "ĞŸĞµÑ€ĞµĞ±Ğ¾Ñ€ Ñ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ğ¾Ğ¼ (Backtracking)"
created: 2025-12-30
modified: 2026-02-13
type: deep-dive
status: published
difficulty: intermediate
confidence: high
cs-foundations:
  - depth-first-search
  - state-space-tree
  - constraint-satisfaction
  - pruning-optimization
  - recursive-enumeration
  - implicit-tree-traversal
prerequisites:
  - "[[recursion-fundamentals]]"
  - "[[trees-binary]]"
  - "[[dfs-bfs-patterns]]"
tags:
  - topic/cs-fundamentals
  - type/deep-dive
  - level/intermediate
  - interview
related:
  - "[[dynamic-programming]]"
  - "[[greedy-algorithms]]"
  - "[[graphs]]"

reading_time: 84
difficulty: 5
study_status: not_started
mastery: 0
last_reviewed:
next_review:
---

# Backtracking

## TL;DR

Backtracking explores all possible solutions by incrementally building candidates and abandoning them ("backtracking") when they violate constraints. Core pattern: **Choose â†’ Explore â†’ Unchoose**. Solves subsets, permutations, combinations, N-Queens, Sudoku. Exponential time complexity O(2^n) or O(n!) but pruning reduces search space dramatically.

---

## Ğ§Ğ°ÑÑ‚ÑŒ 1: Ğ˜Ğ½Ñ‚ÑƒĞ¸Ñ†Ğ¸Ñ Ğ±ĞµĞ· ĞºĞ¾Ğ´Ğ°

> **Ğ¦ĞµĞ»ÑŒ:** Ğ¿Ğ¾Ğ½ÑÑ‚ÑŒ Ğ˜Ğ”Ğ•Ğ® Backtracking Ğ´Ğ¾ Ğ»ÑĞ±Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ´Ğ°. Ğ•ÑĞ»Ğ¸ Ñ‚Ñ‹ Ğ¿Ğ¾Ğ½Ğ¸Ğ¼Ğ°ĞµÑˆÑŒ ÑÑ‚Ğ¸ Ğ°Ğ½Ğ°Ğ»Ğ¾Ğ³Ğ¸Ğ¸ â€” Ñ‚Ñ‹ ÑƒĞ¶Ğµ Ğ¿Ğ¾Ğ½Ğ¸Ğ¼Ğ°ĞµÑˆÑŒ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½.

### Ğ¢Ñ‹ ÑƒĞ¶Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑˆÑŒ Backtracking ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ğ´ĞµĞ½ÑŒ

| Ğ¡Ğ¸Ñ‚ÑƒĞ°Ñ†Ğ¸Ñ | ĞšĞ°Ğº Ñ‚Ñ‹ ÑÑ‚Ğ¾ Ğ´ĞµĞ»Ğ°ĞµÑˆÑŒ | Ğ­Ğ»ĞµĞ¼ĞµĞ½Ñ‚ Backtracking |
|----------|-------------------|----------------------|
| **Ğ˜Ğ´Ñ‘ÑˆÑŒ Ğ¿Ğ¾ Ğ»Ğ°Ğ±Ğ¸Ñ€Ğ¸Ğ½Ñ‚Ñƒ** | Ğ£Ğ¿Ñ‘Ñ€ÑÑ Ğ² Ñ‚ÑƒĞ¿Ğ¸Ğº â†’ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑˆÑŒÑÑ Ğº Ñ€Ğ°Ğ·Ğ²Ğ¸Ğ»ĞºĞµ â†’ Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµÑˆÑŒ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¹ Ğ¿ÑƒÑ‚ÑŒ | ĞšĞ»Ğ°ÑÑĞ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ backtrack |
| **Ğ ĞµÑˆĞ°ĞµÑˆÑŒ ÑÑƒĞ´Ğ¾ĞºÑƒ** | ĞŸĞ¾ÑÑ‚Ğ°Ğ²Ğ¸Ğ» Ñ†Ğ¸Ñ„Ñ€Ñƒ â†’ Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ¾ÑˆĞ»Ğ° â†’ ÑÑ‚Ñ‘Ñ€ â†’ Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ğ» Ğ´Ñ€ÑƒĞ³ÑƒÑ | Choose-Unchoose |
| **Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°ĞµÑˆÑŒ Ğ¿Ğ°Ğ·Ğ»** | ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ğ¸Ğ» Ğ´ĞµÑ‚Ğ°Ğ»ÑŒ â†’ Ğ½Ğµ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´Ğ¸Ñ‚ â†’ Ğ¾Ñ‚Ğ»Ğ¾Ğ¶Ğ¸Ğ» â†’ Ğ²Ğ·ÑĞ» Ğ´Ñ€ÑƒĞ³ÑƒÑ | Constraint checking |
| **ĞŸĞ»Ğ°Ğ½Ğ¸Ñ€ÑƒĞµÑˆÑŒ Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚** | Ğ­Ñ‚Ğ¾Ñ‚ Ğ¿ÑƒÑ‚ÑŒ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ´Ğ»Ğ¸Ğ½Ğ½Ñ‹Ğ¹ â†’ Ğ¾Ñ‚ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ÑÑÑŒ â†’ Ğ¸Ñ‰Ñƒ ĞºĞ¾Ñ€Ğ¾Ñ‡Ğµ | Pruning |
| **ĞŸĞ¸ÑˆĞµÑˆÑŒ ĞºĞ¾Ğ´ Ñ IDE** | ĞĞ²Ñ‚Ğ¾Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶Ğ¸Ğ»Ğ¾ â†’ Ğ½Ğµ Ñ‚Ğ¾ â†’ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ğ» â†’ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ» Ğ´Ñ€ÑƒĞ³Ğ¾Ğµ | Explore-Undo |

### ĞĞ½Ğ°Ğ»Ğ¾Ğ³Ğ¸Ñ 1: Ğ›Ğ°Ğ±Ğ¸Ñ€Ğ¸Ğ½Ñ‚ Ñ Ğ¼ĞµĞ»Ğ¾Ğ¼

```
Ğ¢Ñ‹ Ğ² Ğ»Ğ°Ğ±Ğ¸Ñ€Ğ¸Ğ½Ñ‚Ğµ. Ğ£ Ñ‚ĞµĞ±Ñ Ğ² Ñ€ÑƒĞºĞµ Ğ¼ĞµĞ».

Ğ¨Ğ°Ğ³ 1: ĞĞ° ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¹ Ñ€Ğ°Ğ·Ğ²Ğ¸Ğ»ĞºĞµ ĞĞ¢ĞœĞ•Ğ§ĞĞ•Ğ¨Ğ¬ Ğ¼ĞµĞ»Ğ¾Ğ¼ Ğ¾Ñ‚ĞºÑƒĞ´Ğ° Ğ¿Ñ€Ğ¸ÑˆÑ‘Ğ»
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ S â”€â”€â†’ â—¯ â”€â”€â†’ â—¯ â”€â”€â†’ X   â”‚
       â”‚       â”‚       â†‘ Ñ‚ÑƒĞ¿Ğ¸Ğº!â”‚
       â”‚       â”‚       â”‚       â”‚
       â”‚       â””â”€â”€â†’ â—¯ â”€â”˜       â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       ĞœĞµÑ‚ĞºĞ° Ğ¼ĞµĞ»Ğ¾Ğ¼ = "Ğ·Ğ°Ğ¿Ğ¾Ğ¼Ğ½Ğ¸Ğ» Ğ¿ÑƒÑ‚ÑŒ"

Ğ¨Ğ°Ğ³ 2: Ğ£Ğ¿Ñ‘Ñ€ÑÑ Ğ² Ñ‚ÑƒĞ¿Ğ¸Ğº â†’ Ğ˜Ğ”ĞĞ¨Ğ¬ ĞĞĞ—ĞĞ” Ğ¿Ğ¾ Ğ¼ĞµÑ‚ĞºĞ°Ğ¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ S â”€â”€â†’ â—¯ â”€â”€â† â—¯ â†â”€â”€ X   â”‚
       â”‚       â”‚   Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚     â”‚
       â”‚       â†“               â”‚
       â”‚       â—¯ â”€â”€â†’ ...       â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ğ¨Ğ°Ğ³ 3: ĞĞ° Ñ€Ğ°Ğ·Ğ²Ğ¸Ğ»ĞºĞµ Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµÑˆÑŒ Ğ”Ğ Ğ£Ğ“ĞĞ™ Ğ¿ÑƒÑ‚ÑŒ

Ğ¨Ğ°Ğ³ 4: ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€ÑĞµÑˆÑŒ Ğ¿Ğ¾ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´Ñ‘ÑˆÑŒ Ğ²Ñ‹Ñ…Ğ¾Ğ´

ĞœĞµĞ» = Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ñ‹Ğ¹ call stack
Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ = backtrack
Ğ Ğ°Ğ·Ğ²Ğ¸Ğ»ĞºĞ° = for loop
```

**ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ ÑÑ‚Ğ¾ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚:** Ğ¢Ñ‹ ĞĞ˜ĞšĞĞ“Ğ”Ğ Ğ½Ğµ Ğ·Ğ°Ğ±ÑƒĞ´ĞµÑˆÑŒ, Ğ³Ğ´Ğµ Ğ±Ñ‹Ğ». ĞœĞµĞ» (call stack) Ğ¿Ğ¾Ğ¼Ğ½Ğ¸Ñ‚ Ğ²ĞµÑÑŒ Ğ¿ÑƒÑ‚ÑŒ. ĞšĞ¾Ğ³Ğ´Ğ° Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑˆÑŒÑÑ â€” ÑÑ‚Ğ¸Ñ€Ğ°ĞµÑˆÑŒ Ğ¼ĞµÑ‚ĞºÑƒ (unchoose).

### ĞĞ½Ğ°Ğ»Ğ¾Ğ³Ğ¸Ñ 2: ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ğ¾Ñ‡Ğ½Ğ°Ñ Ğ² Ğ¼Ğ°Ğ³Ğ°Ğ·Ğ¸Ğ½Ğµ

```
Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ°: Ğ¡Ğ¾Ğ±Ñ€Ğ°Ñ‚ÑŒ outfit Ğ¸Ğ· N Ğ²ĞµÑ‰ĞµĞ¹

                    Ğ“ĞĞ Ğ”Ğ•Ğ ĞĞ‘
        â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
        â”‚ ğŸ‘”  â”‚ ğŸ‘•  â”‚ ğŸ‘–  â”‚ ğŸ‘—  â”‚ ğŸ‘Ÿ  â”‚
        â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜

ĞŸÑ€Ğ¾Ñ†ĞµÑÑ:
1. Ğ’Ğ«Ğ‘Ğ˜Ğ ĞĞ® Ñ€ÑƒĞ±Ğ°ÑˆĞºÑƒ (choose)        â†’ ĞĞ°Ğ´ĞµĞ²Ğ°Ñ ğŸ‘”
2. Ğ¡ĞœĞĞ¢Ğ Ğ® Ğ² Ğ·ĞµÑ€ĞºĞ°Ğ»Ğ¾ (explore)      â†’ ĞĞµ Ğ½Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑÑ?
3. Ğ¡ĞĞ˜ĞœĞĞ® Ñ€ÑƒĞ±Ğ°ÑˆĞºÑƒ (unchoose)       â†’ ĞšĞ»Ğ°Ğ´Ñƒ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ğ¾
4. Ğ’Ğ«Ğ‘Ğ˜Ğ ĞĞ® Ğ´Ñ€ÑƒĞ³ÑƒÑ (next choice)    â†’ ĞĞ°Ğ´ĞµĞ²Ğ°Ñ ğŸ‘•
5. ...Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ÑÑ...

ĞšĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¸:
  ğŸ‘” + ğŸ‘– = âŒ (Ğ½Ğµ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´Ğ¸Ñ‚)
  ğŸ‘” + ğŸ‘— = âŒ (Ğ½Ğµ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´Ğ¸Ñ‚)
  ğŸ‘• + ğŸ‘– = âœ… (Ğ½Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑÑ!)
  ...
```

**ĞšĞ»ÑÑ‡ĞµĞ²Ğ¾Ğ¹ Ğ¿Ñ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿:** ĞŸĞ¾ÑĞ»Ğµ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€ĞºĞ¸ ĞĞ‘Ğ¯Ğ—ĞĞ¢Ğ•Ğ›Ğ¬ĞĞ Ğ²ĞµÑˆĞ°ĞµÑˆÑŒ Ğ²ĞµÑ‰ÑŒ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ğ¾ (unchoose). Ğ˜Ğ½Ğ°Ñ‡Ğµ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ°Ñ ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ñ Ğ±ÑƒĞ´ĞµÑ‚ Ğ½ĞµĞ¿Ğ¾Ğ»Ğ½Ğ¾Ğ¹!

### ĞĞ½Ğ°Ğ»Ğ¾Ğ³Ğ¸Ñ 3: Ğ”ĞµÑ€ĞµĞ²Ğ¾ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹

```
Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ°: Ğ’Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ° Ğ¸Ğ· [A, B]

ĞšĞ°Ğ¶Ğ´Ñ‹Ğ¹ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚: "Ğ‘Ñ€Ğ°Ñ‚ÑŒ Ğ¸Ğ»Ğ¸ Ğ½Ğµ Ğ±Ñ€Ğ°Ñ‚ÑŒ?"

                     []
                    /  \
            Ğ’Ğ·ÑÑ‚ÑŒ A?
               /  \
             [A]   []
            /  \   / \
    Ğ’Ğ·ÑÑ‚ÑŒ B?
          /\   /\
      [A,B][A][B][]

Ğ›Ğ¸ÑÑ‚ÑŒÑ = Ğ²ÑĞµ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ñ‹Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ!

Backtracking = ĞĞ±Ñ…Ğ¾Ğ´ Ğ´ĞµÑ€ĞµĞ²Ğ° Ğ²Ğ³Ğ»ÑƒĞ±ÑŒ (DFS):
1. Ğ˜Ğ´Ñ‘Ğ¼ Ğ²Ğ»ĞµĞ²Ğ¾ â†’ [A] â†’ Ğ²Ğ»ĞµĞ²Ğ¾ â†’ [A,B] â†’ Ğ›Ğ˜Ğ¡Ğ¢ĞĞš! Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ğ»Ğ¸.
2. â† ĞĞ°Ğ·Ğ°Ğ´ Ğº [A] â†’ Ğ²Ğ¿Ñ€Ğ°Ğ²Ğ¾ â†’ [A] â†’ Ğ›Ğ˜Ğ¡Ğ¢ĞĞš! Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ğ»Ğ¸.
3. â† â† ĞĞ°Ğ·Ğ°Ğ´ Ğº [] â†’ Ğ²Ğ¿Ñ€Ğ°Ğ²Ğ¾ â†’ [] â†’ Ğ²Ğ»ĞµĞ²Ğ¾ â†’ [B] â†’ ...
```

**Ğ“Ğ»Ğ°Ğ²Ğ½Ğ°Ñ Ğ¸Ğ´ĞµÑ:** Backtracking Ğ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ’Ğ¡Ğ• Ğ²ĞµÑ‚Ğ²Ğ¸ Ğ´ĞµÑ€ĞµĞ²Ğ° Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹, Ğ½Ğ¾ ÑƒĞ¼ĞµĞµÑ‚ Ğ¾Ñ‚ÑĞµĞºĞ°Ñ‚ÑŒ (prune) Ğ·Ğ°Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¾ Ğ¿Ğ»Ğ¾Ñ…Ğ¸Ğµ Ğ²ĞµÑ‚Ğ²Ğ¸.

### Ğ§Ğ¸ÑĞ»Ğ¾Ğ²Ğ¾Ğ¹ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€ Ğ‘Ğ•Ğ— ĞºĞ¾Ğ´Ğ°

**Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ°:** ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ²ÑĞµ ÑĞ¿Ğ¾ÑĞ¾Ğ±Ñ‹ Ñ€Ğ°Ğ·Ğ¼ĞµĞ½ÑÑ‚ÑŒ 5 Ñ€ÑƒĞ±Ğ»ĞµĞ¹ Ğ¼Ğ¾Ğ½ĞµÑ‚Ğ°Ğ¼Ğ¸ [1, 2, 5].

```
ĞĞ°Ñ‡Ğ¸Ğ½Ğ°ĞµĞ¼ Ñ ÑÑƒĞ¼Ğ¼Ñ‹ = 0, Ñ†ĞµĞ»ÑŒ = 5

                    sum=0
                   /  |  \
               +1   +2   +5
               /    |     \
           sum=1  sum=2  sum=5 âœ“ â†’ [5]
           / | \   / | \
         +1 +2 +5 +1 +2 +5
         /   |   \
      sum=2 sum=3 sum=6 âœ— (Ğ¿Ñ€ĞµĞ²Ñ‹ÑĞ¸Ğ»Ğ¸!)
             ...

ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ²ÑĞµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ:
[5]
[2, 2, 1] Ğ¸Ğ»Ğ¸ [2, 1, 2] Ğ¸Ğ»Ğ¸ [1, 2, 2]
[2, 1, 1, 1] Ğ¸Ğ»Ğ¸ [1, 2, 1, 1] Ğ¸Ğ»Ğ¸ ...
[1, 1, 1, 1, 1]

Pruning: ĞµÑĞ»Ğ¸ sum > 5 â†’ ĞĞ• Ğ¸Ğ´Ñ‘Ğ¼ Ğ´Ğ°Ğ»ÑŒÑˆĞµ Ğ¿Ğ¾ ÑÑ‚Ğ¾Ğ¹ Ğ²ĞµÑ‚ĞºĞµ!
```

### Ğ¤Ğ¾Ñ€Ğ¼ÑƒĞ»Ğ° Choose â†’ Explore â†’ Unchoose

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                            â”‚
â”‚  for ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹_Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚ in Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ_Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ñ‹:                 â”‚
â”‚                                                            â”‚
â”‚      â”Œâ”€ CHOOSE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚      â”‚ â€¢ Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚ Ğ² Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ            â”‚   â”‚
â”‚      â”‚ â€¢ ĞŸĞ¾Ğ¼ĞµÑ‚Ğ¸Ñ‚ÑŒ ĞºĞ°Ğº Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹                   â”‚   â”‚
â”‚      â”‚ â€¢ Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ                            â”‚   â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                          â†“                                 â”‚
â”‚      â”Œâ”€ EXPLORE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚      â”‚ â€¢ Ğ ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ğ¾ Ğ²Ñ‹Ğ·Ğ²Ğ°Ñ‚ÑŒ ÑĞµĞ±Ñ                       â”‚   â”‚
â”‚      â”‚ â€¢ Ğ˜ÑÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²ÑĞµ Ğ¿ÑƒÑ‚Ğ¸ Ñ ÑÑ‚Ğ¸Ğ¼ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ¾Ğ¼           â”‚   â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                          â†“                                 â”‚
â”‚      â”Œâ”€ UNCHOOSE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚      â”‚ â€¢ Ğ£Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚ Ğ¸Ğ· Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ            â”‚   â”‚
â”‚      â”‚ â€¢ Ğ¡Ğ½ÑÑ‚ÑŒ Ğ¿Ğ¾Ğ¼ĞµÑ‚ĞºÑƒ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ                   â”‚   â”‚
â”‚      â”‚ â€¢ Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ ĞºĞ°Ğº Ğ±Ñ‹Ğ»Ğ¾                    â”‚   â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞ˜ Ğ’ĞĞ–ĞĞ: Ğ±ĞµĞ· UNCHOOSE Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼ ĞĞ• Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚!
```

---

## Ğ§Ğ°ÑÑ‚ÑŒ 2: ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ Backtracking Ğ±Ñ‹Ğ²Ğ°ĞµÑ‚ ÑĞ»Ğ¾Ğ¶ĞµĞ½?

### Ğ¡ Ñ‡ĞµĞ¼ Ğ±Ğ¾Ñ€ÑÑ‚ÑÑ Ğ½Ğ¾Ğ²Ğ¸Ñ‡ĞºĞ¸

| ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ° | ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ Ğ²Ğ¾Ğ·Ğ½Ğ¸ĞºĞ°ĞµÑ‚ | ĞšĞ°Ğº Ğ¿Ñ€ĞµĞ¾Ğ´Ğ¾Ğ»ĞµÑ‚ÑŒ |
|----------|------------------|----------------|
| **Ğ—Ğ°Ğ±Ñ‹Ğ²Ğ°ÑÑ‚ unchoose** | ĞšĞ°Ğ¶ĞµÑ‚ÑÑ, Ñ‡Ñ‚Ğ¾ "Ğ¸ Ñ‚Ğ°Ğº ÑÑ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚" | ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ¾: ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ choose Ğ”ĞĞ›Ğ–Ğ•Ğ Ğ¸Ğ¼ĞµÑ‚ÑŒ unchoose |
| **ĞŸĞµÑ€ĞµĞ´Ğ°ÑÑ‚ ÑÑÑ‹Ğ»ĞºÑƒ Ğ²Ğ¼ĞµÑÑ‚Ğ¾ ĞºĞ¾Ğ¿Ğ¸Ğ¸** | `result.add(current)` â€” Ğ²ÑĞµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ğ¾Ğ´Ğ¸Ğ½Ğ°ĞºĞ¾Ğ²Ñ‹Ğµ! | Ğ’ÑĞµĞ³Ğ´Ğ° `result.add(current.toList())` |
| **ĞŸÑƒÑ‚Ğ°ÑÑ‚ subsets/permutations** | Ğ Ğ°Ğ·Ğ½Ñ‹Ğµ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ñ start index Ğ¸ used[] | Subsets: `start = i+1`. Permutations: `used[]` |
| **ĞĞµ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ñ‚ÑŒ base case** | ĞšĞ¾Ğ³Ğ´Ğ° Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒÑÑ Ğ½ĞµĞ¾Ñ‡ĞµĞ²Ğ¸Ğ´Ğ½Ğ¾ | "Ğ§Ñ‚Ğ¾ ÑĞ²Ğ»ÑĞµÑ‚ÑÑ Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¼ Ñ€ĞµÑˆĞµĞ½Ğ¸ĞµĞ¼?" |
| **ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ°ÑÑ‚ pruning** | ĞĞ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚, Ğ½Ğ¾ Ğ¾Ñ‡ĞµĞ½ÑŒ Ğ¼ĞµĞ´Ğ»ĞµĞ½Ğ½Ğ¾ | Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ñ€Ğ°Ğ½Ğ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ |

### Ğ“Ğ»Ğ°Ğ²Ğ½Ğ°Ñ ÑĞ»Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ: Ğ¢Ñ€Ğ¸ Ğ¿Ğ¾Ñ…Ğ¾Ğ¶Ğ¸Ñ…, Ğ½Ğ¾ Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ĞšĞĞœĞ‘Ğ˜ĞĞĞ¢ĞĞ ĞĞ«Ğ• Ğ—ĞĞ”ĞĞ§Ğ˜                      â”‚
â”‚                          â”‚                                  â”‚
â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚      â”‚                   â”‚                   â”‚              â”‚
â”‚  SUBSETS            PERMUTATIONS        COMBINATIONS        â”‚
â”‚  (Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ°)     (Ğ¿ĞµÑ€ĞµÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸)      (ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¸)        â”‚
â”‚                                                             â”‚
â”‚  â€¢ ĞŸĞ¾Ñ€ÑĞ´Ğ¾Ğº ĞĞ• Ğ²Ğ°Ğ¶ĞµĞ½   â€¢ ĞŸĞ¾Ñ€ÑĞ´Ğ¾Ğº Ğ’ĞĞ–Ğ•Ğ     â€¢ ĞŸĞ¾Ñ€ÑĞ´Ğ¾Ğº ĞĞ• Ğ²Ğ°Ğ¶ĞµĞ½â”‚
â”‚  â€¢ ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ±Ñ€Ğ°Ñ‚ÑŒ        â€¢ Ğ’Ğ¡Ğ• ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹      â€¢ Ğ Ğ¾Ğ²Ğ½Ğ¾ k ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²
â”‚    Ğ»ÑĞ±Ğ¾Ğµ ĞºĞ¾Ğ»-Ğ²Ğ¾         Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ Ğ±Ñ‹Ñ‚ÑŒ                         â”‚
â”‚                                                             â”‚
â”‚  {1,2} = {2,1}        [1,2] â‰  [2,1]      C(n,k)            â”‚
â”‚                                                             â”‚
â”‚  start = i + 1        used[] Ğ¼Ğ°ÑÑĞ¸Ğ²      start = i + 1      â”‚
â”‚                                           + size == k       â”‚
â”‚                                                             â”‚
â”‚  2^n Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹          n! Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹         C(n,k) Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ ÑÑ‚Ğ¾ Ğ¿ÑƒÑ‚Ğ°ĞµÑ‚:** Ğ¡Ñ‚ÑƒĞ´ĞµĞ½Ñ‚ Ğ²Ğ¸Ğ´Ğ¸Ñ‚ "backtracking" Ğ¸ Ğ´ÑƒĞ¼Ğ°ĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ğ¾Ğ´Ğ¸Ğ½ ÑˆĞ°Ğ±Ğ»Ğ¾Ğ½ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ´Ğ»Ñ Ğ²ÑĞµÑ…. ĞĞ¾ Ğ¾Ñ‚Ğ»Ğ¸Ñ‡Ğ¸Ñ ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡Ğ½Ñ‹!

### Ğ¢Ğ¸Ğ¿Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ Ñ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ°Ğ¼Ğ¸

#### ĞÑˆĞ¸Ğ±ĞºĞ° 1: Ğ—Ğ°Ğ±Ñ‹Ğ»Ğ¸ unchoose

```
âŒ ĞĞ•ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ:
fun backtrack(start: Int) {
    result.add(current.toList())
    for (i in start until nums.size) {
        current.add(nums[i])     // Choose
        backtrack(i + 1)         // Explore
        // â† Ğ—ĞĞ‘Ğ«Ğ›Ğ˜ UNCHOOSE!
    }
}

Ğ§Ñ‚Ğ¾ Ğ¿Ñ€Ğ¾Ğ¸ÑÑ…Ğ¾Ğ´Ğ¸Ñ‚:
backtrack(0): current = []
  i=0: current = [1]
  backtrack(1): current = [1]
    i=1: current = [1, 2]
    backtrack(2): current = [1, 2]
      i=2: current = [1, 2, 3]  â† Ğ½Ğ°ĞºĞ°Ğ¿Ğ»Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ!
      backtrack(3): ... current Ğ²ÑÑ‘ ĞµÑ‰Ñ‘ [1, 2, 3]
    // Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚, Ğ½Ğ¾ current = [1, 2, 3] â† ĞŸĞ ĞĞ‘Ğ›Ğ•ĞœĞ!
    i=2: current = [1, 2, 3, 3] â† Ğ”Ğ£Ğ‘Ğ›Ğ¬!

âœ… ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ:
fun backtrack(start: Int) {
    result.add(current.toList())
    for (i in start until nums.size) {
        current.add(nums[i])                     // Choose
        backtrack(i + 1)                         // Explore
        current.removeAt(current.lastIndex)      // UNCHOOSE!
    }
}
```

#### ĞÑˆĞ¸Ğ±ĞºĞ° 2: ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‡Ğ° ÑÑÑ‹Ğ»ĞºĞ¸ Ğ²Ğ¼ĞµÑÑ‚Ğ¾ ĞºĞ¾Ğ¿Ğ¸Ğ¸

```
âŒ ĞĞ•ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ:
result.add(current)  // Ğ’Ğ¡Ğ• Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ ÑƒĞºĞ°Ğ·Ñ‹Ğ²Ğ°ÑÑ‚ Ğ½Ğ° ĞĞ”Ğ˜Ğ ÑĞ¿Ğ¸ÑĞ¾Ğº!

ĞŸĞ¾ÑˆĞ°Ğ³Ğ¾Ğ²Ñ‹Ğ¹ trace:
Step 1: current = [1], result.add(current) â†’ result = [[1]]
Step 2: current = [1, 2], result.add(current) â†’ result = [[1,2], [1,2]]
        â† ĞĞ‘Ğ ĞĞ¢Ğ˜Ğ¢Ğ• Ğ’ĞĞ˜ĞœĞĞĞ˜Ğ•: Ğ¿ĞµÑ€Ğ²Ğ°Ñ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ¢ĞĞ–Ğ• Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ğ»Ğ°ÑÑŒ!
Step 3: current = [], result = [[], [], []]
        â† Ğ’ ĞºĞ¾Ğ½Ñ†Ğµ Ğ’Ğ¡Ğ• Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ğ¿ÑƒÑÑ‚Ñ‹Ğµ!

ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ? Ğ’ÑĞµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ â€” ÑÑÑ‹Ğ»ĞºĞ¸ Ğ½Ğ° ĞĞ”Ğ˜Ğ Ğ˜ Ğ¢ĞĞ¢ Ğ–Ğ• Ğ¾Ğ±ÑŠĞµĞºÑ‚ current.

âœ… ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ:
result.add(current.toList())  // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ ĞšĞĞŸĞ˜Ğ®

// Ğ˜Ğ»Ğ¸ Ğ² Java:
result.add(new ArrayList<>(current));
```

#### ĞÑˆĞ¸Ğ±ĞºĞ° 3: ĞĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ start index Ğ´Ğ»Ñ Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ğ·Ğ°Ğ´Ğ°Ñ‡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                              â”‚
â”‚  SUBSETS / COMBINATIONS:                                     â”‚
â”‚                                                              â”‚
â”‚    for (i in start until n)        â† Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°ĞµĞ¼ Ñ start        â”‚
â”‚        backtrack(i + 1)            â† Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‘Ğ¼ i + 1          â”‚
â”‚                                                              â”‚
â”‚  ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ? Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ½Ğµ Ğ±Ñ€Ğ°Ñ‚ÑŒ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ›Ğ•Ğ’Ğ•Ğ• Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾.              â”‚
â”‚  [1,2] Ğ¸ [2,1] â€” ÑÑ‚Ğ¾ ĞĞ”ĞĞ Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ¾!                      â”‚
â”‚                                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  PERMUTATIONS:                                               â”‚
â”‚                                                              â”‚
â”‚    for (i in 0 until n)            â† Ğ’Ğ¡Ğ•Ğ“Ğ”Ğ Ñ 0              â”‚
â”‚        if (used[i]) continue       â† Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ
â”‚        used[i] = true              â”‚
â”‚        backtrack()                 â”‚
â”‚        used[i] = false             â”‚
â”‚                                                              â”‚
â”‚  ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ? [1,2] Ğ¸ [2,1] â€” ÑÑ‚Ğ¾ Ğ ĞĞ—ĞĞ«Ğ• Ğ¿ĞµÑ€ĞµÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸!            â”‚
â”‚  ĞĞ¾ Ğ¾Ğ´Ğ¸Ğ½ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ğ²Ğ°Ğ¶Ğ´Ñ‹.                 â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ĞÑˆĞ¸Ğ±ĞºĞ° 4: Ğ—Ğ°Ğ±Ñ‹Ğ»Ğ¸ Ğ¾Ñ‚ÑĞ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ğ»Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ğ¾Ğ²

```
nums = [1, 2, 1]  â† ĞµÑÑ‚ÑŒ Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ñ‹

âŒ Ğ‘Ğ•Ğ— Ğ¡ĞĞ Ğ¢Ğ˜Ğ ĞĞ’ĞšĞ˜:
ĞŸĞ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ°: [], [1], [1,2], [1,2,1], [1,1], [2], [2,1], [1]
                 â†‘                            â†‘         â†‘
              Ğ´ÑƒĞ±Ğ»ÑŒ [1]                   Ğ´ÑƒĞ±Ğ»ÑŒ [1,2]  Ğ´ÑƒĞ±Ğ»ÑŒ [1]

âœ… ĞŸĞĞ¡Ğ›Ğ• Ğ¡ĞĞ Ğ¢Ğ˜Ğ ĞĞ’ĞšĞ˜ nums = [1, 1, 2]:
+ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ğµ if (i > start && nums[i] == nums[i-1]) continue

ĞŸĞ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ°: [], [1], [1,1], [1,1,2], [1,2], [2]
                        â†‘
                 Ğ²Ñ‚Ğ¾Ñ€Ğ¾Ğ¹ 1 Ñ€Ğ°Ğ·Ñ€ĞµÑˆÑ‘Ğ½ Ğ½Ğ° Ğ“Ğ›Ğ£Ğ‘ĞĞšĞĞœ ÑƒÑ€Ğ¾Ğ²Ğ½Ğµ,
                 Ğ½Ğ¾ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½ Ğ½Ğ° Ğ¢ĞĞœ Ğ–Ğ• ÑƒÑ€Ğ¾Ğ²Ğ½Ğµ
```

### Ğ§Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°ĞµÑ‚ backtracking Ğ¼ĞµĞ´Ğ»ĞµĞ½Ğ½Ñ‹Ğ¼?

```
Ğ‘ĞµĞ· pruning (Ğ½Ğ°Ğ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ¿ĞµÑ€ĞµĞ±Ğ¾Ñ€):
N-Queens n=8:  Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ~8^8 = 16,777,216 Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹
Sudoku:        Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ~9^81 Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹ (Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ°Ñ‚Ğ¾Ğ¼Ğ¾Ğ² Ğ²Ğ¾ Ğ²ÑĞµĞ»ĞµĞ½Ğ½Ğ¾Ğ¹!)

Ğ¡ pruning (ÑƒĞ¼Ğ½Ñ‹Ğ¹ backtracking):
N-Queens n=8:  Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ~15,000 Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹ (Ğ² 1000 Ñ€Ğ°Ğ· Ğ¼ĞµĞ½ÑŒÑˆĞµ!)
Sudoku:        Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾ < 10,000 Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¾Ğº

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Ğ­Ğ¤Ğ¤Ğ•ĞšĞ¢ PRUNING                          â”‚
â”‚                                                            â”‚
â”‚    Ğ‘Ğ•Ğ— PRUNING              â”‚      Ğ¡ PRUNING              â”‚
â”‚                             â”‚                              â”‚
â”‚         â—¯                   â”‚          â—¯                   â”‚
â”‚       / | \                 â”‚        / | \                 â”‚
â”‚      â—¯  â—¯  â—¯                â”‚       â—¯  âœ—  â—¯               â”‚
â”‚     /|\ |\ |\               â”‚      /|\    |\               â”‚
â”‚    â—¯â—¯â—¯ â—¯â—¯ â—¯â—¯â—¯              â”‚     â—¯â—¯âœ—    â—¯âœ—               â”‚
â”‚    ... Ğ²ÑÑ‘ Ğ¸ÑÑĞ»ĞµĞ´ÑƒĞµÑ‚ÑÑ      â”‚     ... Ğ¾Ñ‚ÑĞµÑ‡Ñ‘Ğ½Ğ½Ñ‹Ğµ Ğ½Ğµ        â”‚
â”‚                             â”‚         Ğ¸ÑÑĞ»ĞµĞ´ÑƒÑÑ‚ÑÑ          â”‚
â”‚                             â”‚                              â”‚
â”‚  Ğ’Ñ€ĞµĞ¼Ñ: O(b^d)              â”‚  Ğ’Ñ€ĞµĞ¼Ñ: O(b^(d/2)) Ğ¸Ğ»Ğ¸ Ğ»ÑƒÑ‡ÑˆĞµ â”‚
â”‚                             â”‚                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Ğ§Ğ°ÑÑ‚ÑŒ 3: ĞœĞµĞ½Ñ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸ Ğ´Ğ»Ñ Backtracking

### ĞœĞ¾Ğ´ĞµĞ»ÑŒ 1: "Ğ”ĞµÑ€ĞµĞ²Ğ¾ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹" (State Space Tree)

```
Ğ˜Ğ´ĞµÑ: ĞšĞ°Ğ¶Ğ´Ğ¾Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ â€” ÑÑ‚Ğ¾ Ğ¿ÑƒÑ‚ÑŒ Ğ¾Ñ‚ ĞºĞ¾Ñ€Ğ½Ñ Ğ´Ğ¾ Ğ»Ğ¸ÑÑ‚Ğ°

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                            â”‚
â”‚                        ĞšĞĞ Ğ•ĞĞ¬ []                           â”‚
â”‚                      (Ğ¿ÑƒÑÑ‚Ğ¾Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ)                      â”‚
â”‚                      /      |      \                       â”‚
â”‚                    /        |        \                     â”‚
â”‚              Ğ’Ñ‹Ğ±Ğ¾Ñ€ 1    Ğ’Ñ‹Ğ±Ğ¾Ñ€ 2    Ğ’Ñ‹Ğ±Ğ¾Ñ€ 3                 â”‚
â”‚                /            |            \                 â”‚
â”‚             [A]           [B]           [C]                â”‚
â”‚            / | \         / | \         / | \               â”‚
â”‚          ...  ...       ...  ...       ...  ...            â”‚
â”‚                                                            â”‚
â”‚     Ğ›Ğ˜Ğ¡Ğ¢Ğ¬Ğ¯ = ĞŸĞ¾Ğ»Ğ½Ñ‹Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ Ğ¸Ğ»Ğ¸ Ñ‚ÑƒĞ¿Ğ¸ĞºĞ¸                     â”‚
â”‚                                                            â”‚
â”‚     Backtracking = DFS Ğ¿Ğ¾ ÑÑ‚Ğ¾Ğ¼Ñƒ Ğ´ĞµÑ€ĞµĞ²Ñƒ                     â”‚
â”‚     Pruning = ĞÑ‚ÑĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€ĞµĞ²ÑŒĞµĞ²                        â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ĞšĞ¾Ğ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ: Ğ’ÑĞµĞ³Ğ´Ğ°! Ğ­Ñ‚Ğ¾ Ñ„ÑƒĞ½Ğ´Ğ°Ğ¼ĞµĞ½Ñ‚Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ¼Ğ¾Ğ´ĞµĞ»ÑŒ.
ĞœĞ°Ğ½Ñ‚Ñ€Ğ°: "Ğ˜Ğ´Ñƒ Ğ²Ğ³Ğ»ÑƒĞ±ÑŒ, Ğ·Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°Ñ Ğ»Ğ¸ÑÑ‚ÑŒÑ, Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ÑÑÑŒ"
```

### ĞœĞ¾Ğ´ĞµĞ»ÑŒ 2: "Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ ÑĞ»Ğ¾Ñ‚Ğ¾Ğ²" (Slot Filling)

```
Ğ˜Ğ´ĞµÑ: Ğ ĞµÑˆĞµĞ½Ğ¸Ğµ = Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ñ‹Ğµ ÑĞ»Ğ¾Ñ‚Ñ‹, backtracking = Ğ¿ĞµÑ€ĞµÑÑ‚Ğ°Ğ²Ğ»ÑĞµĞ¼

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                            â”‚
â”‚  Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ°: ĞŸĞµÑ€ĞµÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° [1, 2, 3]                            â”‚
â”‚                                                            â”‚
â”‚  Ğ¡Ğ»Ğ¾Ñ‚Ñ‹:  [ _ ] [ _ ] [ _ ]                                 â”‚
â”‚                                                            â”‚
â”‚  Ğ¨Ğ°Ğ³ 1:  [ 1 ] [ _ ] [ _ ]   â† Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ğ»Ğ¸ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ ÑĞ»Ğ¾Ñ‚       â”‚
â”‚  Ğ¨Ğ°Ğ³ 2:  [ 1 ] [ 2 ] [ _ ]   â† Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ğ»Ğ¸ Ğ²Ñ‚Ğ¾Ñ€Ğ¾Ğ¹           â”‚
â”‚  Ğ¨Ğ°Ğ³ 3:  [ 1 ] [ 2 ] [ 3 ]   â† Ğ“ĞĞ¢ĞĞ’Ğ! Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ğ»Ğ¸ [1,2,3]   â”‚
â”‚                                                            â”‚
â”‚  Backtrack: [ 1 ] [ 2 ] [ _ ] â† ÑƒĞ±Ñ€Ğ°Ğ»Ğ¸ 3                   â”‚
â”‚  (Ğ½ĞµÑ‡ĞµĞ³Ğ¾ Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ)                                        â”‚
â”‚                                                            â”‚
â”‚  Backtrack: [ 1 ] [ _ ] [ _ ] â† ÑƒĞ±Ñ€Ğ°Ğ»Ğ¸ 2                   â”‚
â”‚  Ğ¨Ğ°Ğ³:      [ 1 ] [ 3 ] [ _ ] â† Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ğ»Ğ¸ 3              â”‚
â”‚  Ğ¨Ğ°Ğ³:      [ 1 ] [ 3 ] [ 2 ] â† Ğ“ĞĞ¢ĞĞ’Ğ! Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ğ»Ğ¸ [1,3,2]   â”‚
â”‚                                                            â”‚
â”‚  ...Ğ¸ Ñ‚Ğ°Ğº Ğ´Ğ°Ğ»ĞµĞµ...                                         â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ĞšĞ¾Ğ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ: Permutations, N-Queens, Sudoku
ĞœĞ°Ğ½Ñ‚Ñ€Ğ°: "Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ÑÑ ÑĞ»Ğ¾Ñ‚ â†’ Ğ¸Ğ´Ñƒ Ğ´Ğ°Ğ»ÑŒÑˆĞµ â†’ Ğ¾Ñ‡Ğ¸Ñ‰Ğ°Ñ ÑĞ»Ğ¾Ñ‚"
```

### ĞœĞ¾Ğ´ĞµĞ»ÑŒ 3: "Ğ’ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ/Ğ˜ÑĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ" (Include/Exclude)

```
Ğ˜Ğ´ĞµÑ: Ğ”Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ° Ğ´Ğ²Ğ° Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ğ° â€” Ğ²Ğ·ÑÑ‚ÑŒ Ğ¸Ğ»Ğ¸ Ğ½Ğµ Ğ²Ğ·ÑÑ‚ÑŒ

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                            â”‚
â”‚  ĞŸĞ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ° [A, B, C]:                                   â”‚
â”‚                                                            â”‚
â”‚                      []                                    â”‚
â”‚                    /    \                                  â”‚
â”‚              Ğ’Ğ—Ğ¯Ğ¢Ğ¬ A    ĞĞ• Ğ‘Ğ ĞĞ¢Ğ¬ A                         â”‚
â”‚                /    \       /    \                         â”‚
â”‚             [A]     []     ...                             â”‚
â”‚            /   \   /   \                                   â”‚
â”‚       Ğ’Ğ—Ğ¯Ğ¢Ğ¬ B  ĞĞ•Ğ¢ B                                       â”‚
â”‚         /  \    /  \                                       â”‚
â”‚      [A,B] [A] [B]  []                                     â”‚
â”‚       ...                                                  â”‚
â”‚                                                            â”‚
â”‚  ĞšĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ğ¿ÑƒÑ‚ÑŒ = Ğ¾Ğ´Ğ½Ğ¾ Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ¾                           â”‚
â”‚  Ğ’ÑĞµĞ³Ğ¾ Ğ¿ÑƒÑ‚ĞµĞ¹ = 2^n (Ğ´Ğ»Ñ n ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²)                       â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ĞšĞ¾Ğ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ: Subsets, Combination Sum
ĞœĞ°Ğ½Ñ‚Ñ€Ğ°: "Ğ‘ĞµÑ€Ñƒ â€” Ğ½Ğµ Ğ±ĞµÑ€Ñƒ"
```

### ĞœĞ¾Ğ´ĞµĞ»ÑŒ 4: "Constraint Propagation" (Ğ´Ğ»Ñ ÑĞ»Ğ¾Ğ¶Ğ½Ñ‹Ñ… Ğ·Ğ°Ğ´Ğ°Ñ‡)

```
Ğ˜Ğ´ĞµÑ: ĞšĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ğ²Ñ‹Ğ±Ğ¾Ñ€ ĞĞ“Ğ ĞĞĞ˜Ğ§Ğ˜Ğ’ĞĞ•Ğ¢ Ğ±ÑƒĞ´ÑƒÑ‰Ğ¸Ğµ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ñ‹

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                            â”‚
â”‚  N-Queens: ĞŸĞ¾ÑÑ‚Ğ°Ğ²Ğ¸Ğ»Ğ¸ Ñ„ĞµÑ€Ğ·Ñ Ğ² (0, 1)                        â”‚
â”‚                                                            â”‚
â”‚    0   1   2   3                                           â”‚
â”‚  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”                                         â”‚
â”‚ 0â”‚ âœ— â”‚ â™› â”‚ âœ— â”‚ âœ— â”‚  â† ÑÑ‚Ñ€Ğ¾ĞºĞ° 0 Ğ·Ğ°Ğ½ÑÑ‚Ğ°                      â”‚
â”‚  â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤                                         â”‚
â”‚ 1â”‚ âœ— â”‚ âœ— â”‚ âœ— â”‚   â”‚  â† Ğ´Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»Ğ¸ Ğ·Ğ°Ğ½ÑÑ‚Ñ‹                     â”‚
â”‚  â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤                                         â”‚
â”‚ 2â”‚   â”‚ âœ— â”‚   â”‚ âœ— â”‚                                         â”‚
â”‚  â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤                                         â”‚
â”‚ 3â”‚   â”‚ âœ— â”‚   â”‚   â”‚  â† ÑÑ‚Ğ¾Ğ»Ğ±ĞµÑ† 1 Ğ·Ğ°Ğ½ÑÑ‚                      â”‚
â”‚  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜                                         â”‚
â”‚                                                            â”‚
â”‚  âœ— = Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ ĞºĞ»ĞµÑ‚ĞºĞ¸ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ°                â”‚
â”‚                                                            â”‚
â”‚  Pruning: Ğ½Ğµ Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ âœ— ĞºĞ»ĞµÑ‚ĞºĞ¸ Ğ²Ğ¾Ğ¾Ğ±Ñ‰Ğµ!                      â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ĞšĞ¾Ğ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ: N-Queens, Sudoku, Scheduling
ĞœĞ°Ğ½Ñ‚Ñ€Ğ°: "Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµÑ‚ â†’ Ğ¼ĞµĞ½ÑŒÑˆĞµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑÑ‚ÑŒ"
```

### Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸ Ğ¿Ğ¾ Ñ‚Ğ¸Ğ¿Ñƒ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸

| Ğ¢Ğ¸Ğ¿ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸ | Ğ›ÑƒÑ‡ÑˆĞ°Ñ Ğ¼Ğ¾Ğ´ĞµĞ»ÑŒ | ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ |
|------------|---------------|--------|
| Subsets | Include/Exclude | Ğ‘Ğ¸Ğ½Ğ°Ñ€Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ±Ğ¾Ñ€ Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ° |
| Permutations | Slot Filling | Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾ Ğ¾Ñ‡ĞµÑ€ĞµĞ´Ğ¸ |
| Combinations | Ğ”ĞµÑ€ĞµĞ²Ğ¾ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹ | Ğ¡Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼ Ğ´Ğ¾ k ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ² |
| N-Queens, Sudoku | Constraint Propagation | ĞœĞ½Ğ¾Ğ³Ğ¾ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ğ¹ |
| Graph paths | Ğ”ĞµÑ€ĞµĞ²Ğ¾ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹ + visited | DFS Ñ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ğ¾Ğ¼ |

### Ğ£Ğ½Ğ¸Ğ²ĞµÑ€ÑĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ‡ĞµĞºĞ»Ğ¸ÑÑ‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ĞŸĞ•Ğ Ğ•Ğ” ĞĞĞŸĞ˜Ğ¡ĞĞĞ˜Ğ•Ğœ ĞšĞĞ”Ğ                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â–¡ 1. Ğ§Ñ‚Ğ¾ ÑĞ²Ğ»ÑĞµÑ‚ÑÑ ĞŸĞĞ›ĞĞ«Ğœ Ğ Ğ•Ğ¨Ğ•ĞĞ˜Ğ•Ğœ? (base case)             â”‚
â”‚       â€¢ Subsets: Ğ»ÑĞ±Ğ¾Ğµ Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ                    â”‚
â”‚       â€¢ Permutations: current.size == n                     â”‚
â”‚       â€¢ Combinations: current.size == k                     â”‚
â”‚                                                             â”‚
â”‚  â–¡ 2. ĞšĞ°ĞºĞ¸Ğµ Ğ’Ğ«Ğ‘ĞĞ Ğ« Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹ Ğ½Ğ° ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¼ ÑˆĞ°Ğ³Ğµ?                 â”‚
â”‚       â€¢ Subsets: ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹ Ğ¾Ñ‚ start Ğ´Ğ¾ ĞºĞ¾Ğ½Ñ†Ğ°                 â”‚
â”‚       â€¢ Permutations: Ğ²ÑĞµ Ğ½ĞµĞ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹         â”‚
â”‚       â€¢ N-Queens: Ğ²ÑĞµ ÑÑ‚Ğ¾Ğ»Ğ±Ñ†Ñ‹ Ğ² Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¹ ÑÑ‚Ñ€Ğ¾ĞºĞµ              â”‚
â”‚                                                             â”‚
â”‚  â–¡ 3. ĞšĞ°ĞºĞ¸Ğµ ĞĞ“Ğ ĞĞĞ˜Ğ§Ğ•ĞĞ˜Ğ¯ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑÑ‚ÑŒ?                    â”‚
â”‚       â€¢ Subsets: Ğ½ĞµÑ‚ (Ğ²ÑĞµ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ½Ñ‹)                          â”‚
â”‚       â€¢ Permutations: ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ½Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½                â”‚
â”‚       â€¢ N-Queens: ÑÑ‚Ğ¾Ğ»Ğ±ĞµÑ† Ğ¸ Ğ´Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»Ğ¸ ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ½Ñ‹              â”‚
â”‚                                                             â”‚
â”‚  â–¡ 4. ĞšĞ°Ğº ĞĞ¢ĞšĞĞ¢Ğ˜Ğ¢Ğ¬ Ğ²Ñ‹Ğ±Ğ¾Ñ€?                                   â”‚
â”‚       â€¢ Subsets: removeAt(lastIndex)                        â”‚
â”‚       â€¢ Permutations: removeAt + used[i] = false            â”‚
â”‚       â€¢ N-Queens: board[row][col] = '.' + Ğ¾ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ¸Ñ‚ÑŒ cols   â”‚
â”‚                                                             â”‚
â”‚  â–¡ 5. Ğ•ÑÑ‚ÑŒ Ğ»Ğ¸ Ğ”Ğ£Ğ‘Ğ›Ğ˜ĞšĞĞ¢Ğ« Ğ² input?                            â”‚
â”‚       â€¢ Ğ•ÑĞ»Ğ¸ Ğ´Ğ°: ÑĞ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ + skip same-level duplicates   â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Ğ—Ğ°Ñ‡ĞµĞ¼ ÑÑ‚Ğ¾ Ğ½ÑƒĞ¶Ğ½Ğ¾?

**Ğ ĞµĞ°Ğ»ÑŒĞ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°:**

ĞŸÑ€ĞµĞ´ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğ»Ğ¾Ğ¼ĞºÑƒ Sudoku. ĞÑƒĞ¶Ğ½Ğ¾ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ 81 ĞºĞ»ĞµÑ‚ĞºÑƒ Ñ†Ğ¸Ñ„Ñ€Ğ°Ğ¼Ğ¸ 1-9 Ñ‚Ğ°Ğº, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ ĞºĞ°Ğ¶Ğ´Ğ°Ñ ÑÑ‚Ñ€Ğ¾ĞºĞ°, ÑÑ‚Ğ¾Ğ»Ğ±ĞµÑ† Ğ¸ 3x3 Ğ±Ğ»Ğ¾Ğº ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ğ»Ğ¸ Ğ²ÑĞµ Ñ†Ğ¸Ñ„Ñ€Ñ‹ Ñ€Ğ¾Ğ²Ğ½Ğ¾ Ğ¿Ğ¾ Ğ¾Ğ´Ğ½Ğ¾Ğ¼Ñƒ Ñ€Ğ°Ğ·Ñƒ. ĞšĞ°Ğº Ñ€ĞµÑˆĞ¸Ñ‚ÑŒ?

ĞŸĞµÑ€ĞµĞ±Ğ¾Ñ€ Ğ²ÑĞµÑ… ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¹: 9^81 â‰ˆ 10^77 â€” Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ°Ñ‚Ğ¾Ğ¼Ğ¾Ğ² Ğ²Ğ¾ Ğ’ÑĞµĞ»ĞµĞ½Ğ½Ğ¾Ğ¹!
Backtracking Ñ pruning: Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾ Ñ€ĞµÑˆĞ°ĞµÑ‚ Ğ·Ğ° Ğ¼Ğ¸Ğ»Ğ»Ğ¸ÑĞµĞºÑƒĞ½Ğ´Ñ‹, Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑÑ ~10000 ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğ¹.

**Ğ“Ğ´Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ:**

| ĞĞ±Ğ»Ğ°ÑÑ‚ÑŒ | ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ | ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ |
|---------|------------|--------|
| Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğ»Ğ¾Ğ¼ĞºĞ¸ | Sudoku, N-Queens, ĞºÑ€Ğ¾ÑÑĞ²Ğ¾Ñ€Ğ´Ñ‹ | ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ñ€ĞµÑˆĞ°Ñ‚ĞµĞ»Ğ¸ |
| ĞšĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ‚Ğ¾Ñ€Ñ‹ | Parsing, type inference | ĞŸĞ¾Ğ¸ÑĞº Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ñ€Ğ°Ğ·Ğ±Ğ¾Ñ€Ğ° |
| Ğ˜Ğ˜ | Ğ˜Ğ³Ñ€Ñ‹, Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ | Ğ¨Ğ°Ñ…Ğ¼Ğ°Ñ‚Ñ‹, Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ |
| ĞšÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ³Ñ€Ğ°Ñ„Ğ¸Ñ | Constraint satisfaction | SAT solvers |
| Ğ‘Ğ¸Ğ¾Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸ĞºĞ° | Sequence alignment | ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾Ñ…Ğ¾Ğ¶Ğ¸Ñ… Ğ³ĞµĞ½Ğ¾Ğ² |
| Scheduling | Resource allocation | Ğ Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ ÑĞºĞ·Ğ°Ğ¼ĞµĞ½Ğ¾Ğ² |

**Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°:**
- Sudoku-Ñ€ĞµÑˆĞ°Ñ‚ĞµĞ»Ğ¸ Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğµ backtracking Ñ€ĞµÑˆĞ°ÑÑ‚ 99.9% Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğ»Ğ¾Ğ¼Ğ¾Ğº Ğ·Ğ° <1 ÑĞµĞºÑƒĞ½Ğ´Ñ‹
- SAT solvers Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑÑ‚ backtracking Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ hardware Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½Ğ¾Ğ²
- N-Queens Ñ n=100 â€” Ğ¼Ğ¸Ğ»Ğ»Ğ¸Ğ¾Ğ½Ñ‹ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹, Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ñ‹Ñ… Ğ·Ğ° ÑĞµĞºÑƒĞ½Ğ´Ñ‹ Ñ pruning

---

## Prerequisites

| Ğ¢ĞµĞ¼Ğ° | Ğ—Ğ°Ñ‡ĞµĞ¼ Ğ½ÑƒĞ¶Ğ½Ğ¾ | Ğ“Ğ´Ğµ Ğ¸Ğ·ÑƒÑ‡Ğ¸Ñ‚ÑŒ |
|------|-------------|-------------|
| Recursion | Backtracking = Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ñ + Ğ¾Ñ‚ĞºĞ°Ñ‚ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ | [[recursion-fundamentals]] |
| Trees | State space = Ğ½ĞµÑĞ²Ğ½Ğ¾Ğµ Ğ´ĞµÑ€ĞµĞ²Ğ¾, Ğ¾Ğ±Ñ…Ğ¾Ğ´ DFS | [[trees-binary]] |
| DFS | Backtracking = Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ DFS Ñ pruning | [[dfs-bfs-patterns]] |
| **CS: State Space** | ĞŸĞ¾Ğ½Ğ¸Ğ¼Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾ÑÑ‚Ñ€Ğ°Ğ½ÑÑ‚Ğ²Ğ° Ğ²ÑĞµÑ… Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ñ‹Ñ… Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹ | Ğ¢ĞµĞ¾Ñ€Ğ¸Ñ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğ¾Ğ² |
| **CS: Constraint Satisfaction** | Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ğ¹ Ğ¸ Ğ¸Ñ… Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° | CSP Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹ |

---

## Ğ§Ñ‚Ğ¾ ÑÑ‚Ğ¾ Ñ‚Ğ°ĞºĞ¾Ğµ?

### ĞĞ±ÑŠÑÑĞ½ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ 5-Ğ»ĞµÑ‚Ğ½ĞµĞ³Ğ¾

ĞŸÑ€ĞµĞ´ÑÑ‚Ğ°Ğ²ÑŒ Ğ»Ğ°Ğ±Ğ¸Ñ€Ğ¸Ğ½Ñ‚. Ğ¢Ñ‹ Ğ¸Ğ´Ñ‘ÑˆÑŒ Ğ²Ğ¿ĞµÑ€Ñ‘Ğ´, Ğ¿Ğ¾ĞºĞ° Ğ½Ğµ ÑƒĞ¿Ñ‘Ñ€ÑÑ Ğ² Ñ‚ÑƒĞ¿Ğ¸Ğº. Ğ¢Ğ¾Ğ³Ğ´Ğ° Ñ‚Ñ‹ **Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑˆÑŒÑÑ Ğ½Ğ°Ğ·Ğ°Ğ´** Ğº Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ¹ Ñ€Ğ°Ğ·Ğ²Ğ¸Ğ»ĞºĞµ Ğ¸ Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµÑˆÑŒ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¹ Ğ¿ÑƒÑ‚ÑŒ.

```
Ğ¡Ñ‚Ğ°Ñ€Ñ‚ â†’ â—¯ â†’ â—¯ â†’ âœ— Ñ‚ÑƒĞ¿Ğ¸Ğº!
         â†“
         â†© Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚
         â†“
Ğ¡Ñ‚Ğ°Ñ€Ñ‚ â†’ â—¯ â†’ â—¯ â†’ â—¯ â†’ Ğ’Ñ‹Ñ…Ğ¾Ğ´! âœ“
```

Backtracking â€” ÑÑ‚Ğ¾ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ ÑĞ¿Ğ¾ÑĞ¾Ğ± Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ’Ğ¡Ğ• Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ñ‹Ğµ Ğ¿ÑƒÑ‚Ğ¸, Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ÑÑÑŒ ĞºĞ¾Ğ³Ğ´Ğ° Ğ¿ÑƒÑ‚ÑŒ Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ Ğ½ĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¼.

### Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ

**Backtracking** â€” Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ Ğ·Ğ°Ğ´Ğ°Ñ‡ Ğ¿ÑƒÑ‚Ñ‘Ğ¼ Ğ¿Ğ¾ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ¸Ñ ĞºĞ°Ğ½Ğ´Ğ¸Ğ´Ğ°Ñ‚Ğ¾Ğ² Ğ½Ğ° Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ Ğ¸Ğ½ĞºÑ€ĞµĞ¼ĞµĞ½Ñ‚Ğ°Ğ»ÑŒĞ½Ğ¾, Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¾Ğ¹ ("Ğ¾Ñ‚ĞºĞ°Ñ‚Ğ¾Ğ¼") Ñ‡Ğ°ÑÑ‚Ğ¸Ñ‡Ğ½Ñ‹Ñ… Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ½Ğµ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ¿Ñ€Ğ¸Ğ²ĞµÑÑ‚Ğ¸ Ğº Ğ´Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ğ¾Ğ¼Ñƒ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ¼Ñƒ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ.

**ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ ÑĞ²Ğ¾Ğ¹ÑÑ‚Ğ²Ğ°:**
- **Ğ˜Ğ½ĞºÑ€ĞµĞ¼ĞµĞ½Ñ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ğ¾ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ¸Ğµ**: Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ ÑÑ‚Ñ€Ğ¾Ğ¸Ñ‚ÑÑ Ğ¿Ğ¾ Ğ¾Ğ´Ğ½Ğ¾Ğ¼Ñƒ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ñƒ Ğ·Ğ° Ñ€Ğ°Ğ·
- **Pruning (Ğ¾Ñ‚ÑĞµÑ‡ĞµĞ½Ğ¸Ğµ)**: Ğ²ĞµÑ‚Ğ²Ğ¸, Ğ½Ğ°Ñ€ÑƒÑˆĞ°ÑÑ‰Ğ¸Ğµ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ñ, Ğ¾Ñ‚Ğ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ÑÑ‚ÑÑ
- **ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ¿ĞµÑ€ĞµĞ±Ğ¾Ñ€**: Ğ¸ÑÑĞ»ĞµĞ´ÑƒÑÑ‚ÑÑ Ğ²ÑĞµ Ğ´Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¸

**ĞĞ±Ñ‰Ğ°Ñ ÑÑ…ĞµĞ¼Ğ°:**
```
BACKTRACK(state):
    if is_solution(state):
        output(state)
        return

    for choice in get_choices(state):
        if is_valid(choice):
            make_choice(choice)      # Choose
            BACKTRACK(state)         # Explore
            undo_choice(choice)      # Unchoose
```

---

## Ğ¢ĞµÑ€Ğ¼Ğ¸Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ñ

| Ğ¢ĞµÑ€Ğ¼Ğ¸Ğ½ | ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ | ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ |
|--------|-------------|--------|
| **State** | Ğ¢ĞµĞºÑƒÑ‰ĞµĞµ Ñ‡Ğ°ÑÑ‚Ğ¸Ñ‡Ğ½Ğ¾Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ | Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ñ‹Ğµ ĞºĞ»ĞµÑ‚ĞºĞ¸ Sudoku |
| **Choice** | Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ´Ğ»Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ | Ğ¦Ğ¸Ñ„Ñ€Ğ° 1-9 Ğ´Ğ»Ñ ĞºĞ»ĞµÑ‚ĞºĞ¸ |
| **Constraint** | ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ğµ Ğ½Ğ° Ğ´Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ñ‹Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ | Ğ¦Ğ¸Ñ„Ñ€Ñ‹ Ğ½Ğµ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ÑÑÑ‚ÑÑ Ğ² ÑÑ‚Ñ€Ğ¾ĞºĞµ |
| **Pruning** | ĞÑ‚ÑĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ½ĞµĞ´Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ñ‹Ñ… Ğ²ĞµÑ‚Ğ²ĞµĞ¹ | ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞº ÑƒĞ¶Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğ¹ Ñ†Ğ¸Ñ„Ñ€Ñ‹ |
| **Backtrack** | ĞÑ‚ĞºĞ°Ñ‚ Ğº Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰ĞµĞ¼Ñƒ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ | Ğ¡Ñ‚ĞµÑ€ĞµÑ‚ÑŒ Ñ†Ğ¸Ñ„Ñ€Ñƒ, Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ñ€ÑƒĞ³ÑƒÑ |
| **Search Tree** | Ğ”ĞµÑ€ĞµĞ²Ğ¾ Ğ²ÑĞµÑ… Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ñ‹Ñ… Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ¾Ğ² | ĞšĞ°Ğ¶Ğ´Ğ°Ñ Ğ²ĞµÑ‚Ğ²ÑŒ â€” Ğ¾Ğ´Ğ¸Ğ½ Ğ²Ñ‹Ğ±Ğ¾Ñ€ |
| **Leaf** | ĞšĞ¾Ğ½ĞµÑ‡Ğ½Ğ¾Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ (Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ Ğ¸Ğ»Ğ¸ Ñ‚ÑƒĞ¿Ğ¸Ğº) | Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ğ°Ñ Ğ´Ğ¾ÑĞºĞ° |

---

## ĞšĞ°Ğº ÑÑ‚Ğ¾ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚?

### Ğ”ĞµÑ€ĞµĞ²Ğ¾ Ğ¿Ğ¾Ğ¸ÑĞºĞ° (Search Tree)

```
                    Subsets of [1,2,3]
                          []
                    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
                 include 1    exclude 1
                  [1]           []
              â”Œâ”€â”€â”€â”´â”€â”€â”€â”     â”Œâ”€â”€â”€â”´â”€â”€â”€â”
          [1,2]     [1]    [2]      []
          â”Œâ”€â”´â”€â”   â”Œâ”€â”´â”€â”  â”Œâ”€â”´â”€â”   â”Œâ”€â”´â”€â”
       [1,2,3][1,2][1,3][1][2,3][2] [3] []

    Ğ’ÑĞµ Ğ»Ğ¸ÑÑ‚ÑŒÑ â€” Ğ´Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ñ‹Ğµ Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ°!
```

### Choose â†’ Explore â†’ Unchoose

```
Ğ¨Ğ°Ğ³ 1: Choose     path = [1]        // Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ğ»Ğ¸ 1
Ğ¨Ğ°Ğ³ 2: Explore    backtrack()       // Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ·Ğ¾Ğ²
Ğ¨Ğ°Ğ³ 3: Unchoose   path = []         // ÑƒĞ±Ñ€Ğ°Ğ»Ğ¸ 1, Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ Ğ´Ğ°Ğ»ÑŒÑˆĞµ
```

---

## Subsets (LeetCode 78)

### ĞŸĞ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ°

Ğ”Ğ°Ğ½ Ğ¼Ğ°ÑÑĞ¸Ğ² ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ñ… Ñ‡Ğ¸ÑĞµĞ», Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ²ÑĞµ Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ°.

### Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ

```
nums = [1, 2, 3]

                     []
              /              \
          [1]                 []
        /     \            /      \
    [1,2]     [1]       [2]       []
    /   \    /   \     /   \    /    \
[1,2,3][1,2][1,3][1][2,3] [2]  [3]   []

Result: [[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]
```

### Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ (Kotlin) â€” Ñ Ğ¿Ğ¾Ğ´Ñ€Ğ¾Ğ±Ğ½Ñ‹Ğ¼ Ğ¾Ğ±ÑŠÑÑĞ½ĞµĞ½Ğ¸ĞµĞ¼

```kotlin
fun subsets(nums: IntArray): List<List<Int>> {
    // result â€” ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ´Ğ»Ñ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ’Ğ¡Ğ•Ğ¥ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²
    // ĞšĞ°Ğ¶Ğ´Ğ¾Ğµ Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ¾ â€” ÑÑ‚Ğ¾ List<Int>
    val result = mutableListOf<List<Int>>()

    // current â€” Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ ÑÑ‚Ñ€Ğ¾ÑÑ‰ĞµĞµÑÑ Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ¾
    // ĞœÑ‹ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¸ ÑƒĞ±Ğ¸Ñ€Ğ°ĞµĞ¼ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹ Ğ² Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞµ Ğ¾Ğ±Ñ…Ğ¾Ğ´Ğ°
    val current = mutableListOf<Int>()

    // Ğ ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµĞ±Ğ¾Ñ€Ğ° Ğ²ÑĞµÑ… Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²
    // start â€” Ñ ĞºĞ°ĞºĞ¾Ğ³Ğ¾ Ğ¸Ğ½Ğ´ĞµĞºÑĞ° Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°ĞµĞ¼ Ñ€Ğ°ÑÑĞ¼Ğ°Ñ‚Ñ€Ğ¸Ğ²Ğ°Ñ‚ÑŒ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹
    // Ğ­Ñ‚Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ¾Ñ‚Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ñ‹: [1,2] Ğ¸ [2,1] â€” Ğ¾Ğ´Ğ½Ğ¾ Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ¾
    fun backtrack(start: Int) {
        // Ğ’ĞĞ–ĞĞ: ĞºĞ°Ğ¶Ğ´Ğ¾Ğµ Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ â€” Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ½Ğ¾Ğµ Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ¾!
        // Ğ”Ğ°Ğ¶Ğµ Ğ¿ÑƒÑÑ‚Ğ¾Ğµ [] â€” ÑÑ‚Ğ¾ Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ¾ Ğ»ÑĞ±Ğ¾Ğ³Ğ¾ Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ°
        // toList() ÑĞ¾Ğ·Ğ´Ğ°Ñ‘Ñ‚ ĞšĞĞŸĞ˜Ğ®, Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼Ñƒ Ñ‡Ñ‚Ğ¾ current Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑÑ Ğ´Ğ°Ğ»ÑŒÑˆĞµ
        result.add(current.toList())

        // ĞŸĞµÑ€ĞµĞ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ²ÑĞµ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹ Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°Ñ Ñ start
        // i in start until nums.size Ğ¾Ğ·Ğ½Ğ°Ñ‡Ğ°ĞµÑ‚: start, start+1, ..., nums.size-1
        for (i in start until nums.size) {
            // Ğ¨ĞĞ“ 1: Ğ’Ğ«Ğ‘Ğ˜Ğ ĞĞ•Ğœ (Choose)
            // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ nums[i] Ğ² Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ¾
            current.add(nums[i])

            // Ğ¨ĞĞ“ 2: Ğ˜Ğ¡Ğ¡Ğ›Ğ•Ğ”Ğ£Ğ•Ğœ (Explore)
            // Ğ ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ğ¾ ÑÑ‚Ñ€Ğ¾Ğ¸Ğ¼ Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ° Ñ ÑÑ‚Ğ¸Ğ¼ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ¼
            // ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‘Ğ¼ i+1, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ½Ğµ Ğ±Ñ€Ğ°Ñ‚ÑŒ Ñ‚Ğ¾Ñ‚ Ğ¶Ğµ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€Ğ½Ğ¾
            // Ğ¸ Ğ½Ğµ Ğ±Ñ€Ğ°Ñ‚ÑŒ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹ ÑĞ»ĞµĞ²Ğ° (Ğ¾Ğ½Ğ¸ ÑƒĞ¶Ğµ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ñ‹)
            backtrack(i + 1)

            // Ğ¨ĞĞ“ 3: ĞĞ¢ĞšĞĞ¢Ğ«Ğ’ĞĞ•Ğœ (Unchoose / Backtrack)
            // Ğ£Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğ¹ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚
            // Ğ­Ñ‚Ğ¾ ĞšĞ›Ğ®Ğ§Ğ•Ğ’ĞĞ™ Ğ¼Ğ¾Ğ¼ĞµĞ½Ñ‚ backtracking!
            // Ğ‘ĞµĞ· ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ¼Ñ‹ Ğ±Ñ‹ Ğ½Ğ°ĞºĞ°Ğ¿Ğ»Ğ¸Ğ²Ğ°Ğ»Ğ¸ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹ Ğ±ĞµÑĞºĞ¾Ğ½ĞµÑ‡Ğ½Ğ¾
            current.removeAt(current.lastIndex)
        }
    }

    // ĞĞ°Ñ‡Ğ¸Ğ½Ğ°ĞµĞ¼ Ñ Ğ¸Ğ½Ğ´ĞµĞºÑĞ° 0 â€” Ñ€Ğ°ÑÑĞ¼Ğ°Ñ‚Ñ€Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ²ÑĞµ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹
    backtrack(0)
    return result
}

// ĞŸĞĞ¨ĞĞ“ĞĞ’Ğ«Ğ™ Ğ ĞĞ—Ğ‘ĞĞ  Ğ´Ğ»Ñ nums = [1, 2, 3]:
//
// backtrack(0), current = []
//   â†’ result = [[]]
//   â†’ i=0: current.add(1) â†’ current = [1]
//       backtrack(1), current = [1]
//         â†’ result = [[], [1]]
//         â†’ i=1: current.add(2) â†’ current = [1,2]
//             backtrack(2), current = [1,2]
//               â†’ result = [[], [1], [1,2]]
//               â†’ i=2: current.add(3) â†’ current = [1,2,3]
//                   backtrack(3) â€” Ğ²Ñ‹Ñ…Ğ¾Ğ´ Ğ·Ğ° Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ñƒ, Ğ½Ğ¸Ñ‡ĞµĞ³Ğ¾ Ğ½Ğµ Ğ´ĞµĞ»Ğ°ĞµÑ‚
//                   â†’ result = [[], [1], [1,2], [1,2,3]]
//                 current.remove(3) â†’ current = [1,2]
//             current.remove(2) â†’ current = [1]
//         â†’ i=2: current.add(3) â†’ current = [1,3]
//             backtrack(3)
//               â†’ result = [..., [1,3]]
//             current.remove(3) â†’ current = [1]
//       current.remove(1) â†’ current = []
//   â†’ i=1: current.add(2) â†’ current = [2]
//       ... Ğ¸ Ñ‚Ğ°Ğº Ğ´Ğ°Ğ»ĞµĞµ
//
// Ğ˜Ñ‚Ğ¾Ğ³Ğ¾Ğ²Ñ‹Ğ¹ result: [[], [1], [1,2], [1,2,3], [1,3], [2], [2,3], [3]]
```

### Java

```java
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    List<Integer> current = new ArrayList<>();
    backtrack(nums, 0, current, result);
    return result;
}

private void backtrack(int[] nums, int start, List<Integer> current, List<List<Integer>> result) {
    result.add(new ArrayList<>(current));

    for (int i = start; i < nums.length; i++) {
        current.add(nums[i]);          // Choose
        backtrack(nums, i + 1, current, result);  // Explore
        current.remove(current.size() - 1);  // Unchoose
    }
}
```

### Python

```python
def subsets(nums: list[int]) -> list[list[int]]:
    result = []
    current = []

    def backtrack(start: int):
        result.append(current[:])  # Add copy of current

        for i in range(start, len(nums)):
            current.append(nums[i])  # Choose
            backtrack(i + 1)          # Explore
            current.pop()             # Unchoose

    backtrack(0)
    return result
```

---

## Permutations (LeetCode 46)

### ĞŸĞ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ°

Ğ”Ğ°Ğ½ Ğ¼Ğ°ÑÑĞ¸Ğ² ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ñ… Ñ‡Ğ¸ÑĞµĞ», Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ²ÑĞµ Ğ¿ĞµÑ€ĞµÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸.

### Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ

```
nums = [1, 2, 3]

Level 0:          []
              /    |    \
Level 1:    [1]   [2]   [3]
           / \   / \   / \
Level 2: [1,2][1,3][2,1][2,3][3,1][3,2]
           |    |    |    |    |    |
Level 3: [1,2,3][1,3,2][2,1,3][2,3,1][3,1,2][3,2,1]
```

### Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ (Kotlin) â€” Ñ Ğ¿Ğ¾Ğ´Ñ€Ğ¾Ğ±Ğ½Ñ‹Ğ¼ Ğ¾Ğ±ÑŠÑÑĞ½ĞµĞ½Ğ¸ĞµĞ¼

```kotlin
fun permute(nums: IntArray): List<List<Int>> {
    // result â€” ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ´Ğ»Ñ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ²ÑĞµÑ… Ğ¿ĞµÑ€ĞµÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¾Ğº
    val result = mutableListOf<List<Int>>()

    // current â€” Ñ‚ĞµĞºÑƒÑ‰Ğ°Ñ ÑÑ‚Ñ€Ğ¾ÑÑ‰Ğ°ÑÑÑ Ğ¿ĞµÑ€ĞµÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ°
    val current = mutableListOf<Int>()

    // used â€” Ğ¼Ğ°ÑÑĞ¸Ğ² Ñ„Ğ»Ğ°Ğ³Ğ¾Ğ²: used[i] = true ĞµÑĞ»Ğ¸ nums[i] ÑƒĞ¶Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½
    // Ğ—ĞĞ§Ğ•Ğœ: Ğ’ Ğ¿ĞµÑ€ĞµÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞµ ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ²ÑÑ‚Ñ€ĞµÑ‡Ğ°ĞµÑ‚ÑÑ Ğ ĞĞ’ĞĞ ĞĞ”Ğ˜Ğ Ñ€Ğ°Ğ·
    // Ğ‘ĞµĞ· ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ¼Ğ°ÑÑĞ¸Ğ²Ğ° Ğ¼Ñ‹ Ğ¼Ğ¾Ğ³Ğ»Ğ¸ Ğ±Ñ‹ Ğ²Ğ·ÑÑ‚ÑŒ Ğ¾Ğ´Ğ¸Ğ½ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ´Ğ²Ğ°Ğ¶Ğ´Ñ‹
    val used = BooleanArray(nums.size)

    fun backtrack() {
        // Ğ£Ğ¡Ğ›ĞĞ’Ğ˜Ğ• Ğ—ĞĞ’Ğ•Ğ Ğ¨Ğ•ĞĞ˜Ğ¯:
        // Ğ•ÑĞ»Ğ¸ current ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ ÑÑ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¶Ğµ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ², ÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ² nums â€”
        // Ğ¼Ñ‹ ÑĞ¾Ğ±Ñ€Ğ°Ğ»Ğ¸ Ğ¿Ğ¾Ğ»Ğ½ÑƒÑ Ğ¿ĞµÑ€ĞµÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºÑƒ
        if (current.size == nums.size) {
            // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞšĞĞŸĞ˜Ğ® (toList()), Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼Ñƒ Ñ‡Ñ‚Ğ¾ current Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑÑ
            result.add(current.toList())
            return  // Ğ’Ñ‹Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ¸Ğ· ÑÑ‚Ğ¾Ğ¹ Ğ²ĞµÑ‚ĞºĞ¸ Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ğ¸
        }

        // ĞŸĞµÑ€ĞµĞ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ’Ğ¡Ğ• ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹ Ğ¼Ğ°ÑÑĞ¸Ğ²Ğ° (Ğ² Ğ¾Ñ‚Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ğ¾Ñ‚ subsets!)
        // ĞŸĞ¾Ñ‚Ğ¾Ğ¼Ñƒ Ñ‡Ñ‚Ğ¾ Ğ² Ğ¿ĞµÑ€ĞµÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞµ Ğ¿Ğ¾Ñ€ÑĞ´Ğ¾Ğº Ğ²Ğ°Ğ¶ĞµĞ½: [1,2] â‰  [2,1]
        for (i in nums.indices) {
            // ĞŸĞ ĞĞŸĞ£Ğ¡ĞšĞĞ•Ğœ ÑƒĞ¶Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹
            // Ğ‘ĞµĞ· ÑÑ‚Ğ¾Ğ¹ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ¼Ñ‹ Ğ±Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ»Ğ¸ [1,1,1] Ğ´Ğ»Ñ nums=[1,2,3]
            if (used[i]) continue

            // Ğ¨ĞĞ“ 1: Ğ’Ğ«Ğ‘Ğ˜Ğ ĞĞ•Ğœ
            current.add(nums[i])     // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ² Ğ¿ĞµÑ€ĞµÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºÑƒ
            used[i] = true           // ĞŸĞ¾Ğ¼ĞµÑ‡Ğ°ĞµĞ¼ ĞºĞ°Ğº Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹

            // Ğ¨ĞĞ“ 2: Ğ˜Ğ¡Ğ¡Ğ›Ğ•Ğ”Ğ£Ğ•Ğœ
            // Ğ ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ğ¾ Ğ´Ğ¾ÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¿ĞµÑ€ĞµÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºÑƒ
            backtrack()

            // Ğ¨ĞĞ“ 3: ĞĞ¢ĞšĞĞ¢Ğ«Ğ’ĞĞ•Ğœ
            current.removeAt(current.lastIndex)  // Ğ£Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚
            used[i] = false                       // Ğ¡Ğ½Ğ¸Ğ¼Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ¼ĞµÑ‚ĞºÑƒ
            // Ğ¢ĞµĞ¿ĞµÑ€ÑŒ ÑÑ‚Ğ¾Ñ‚ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ ÑĞ½Ğ¾Ğ²Ğ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½ Ğ´Ğ»Ñ Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ğ²ĞµÑ‚Ğ¾Ğº
        }
    }

    backtrack()
    return result
}

// ĞŸĞĞ¨ĞĞ“ĞĞ’Ğ«Ğ™ Ğ ĞĞ—Ğ‘ĞĞ  Ğ´Ğ»Ñ nums = [1, 2]:
//
// backtrack(), current = [], used = [F, F]
//   â†’ i=0: used[0]=F â†’ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ 1
//     current = [1], used = [T, F]
//     backtrack()
//       â†’ i=0: used[0]=T â†’ ĞŸĞ ĞĞŸĞ£Ğ¡ĞšĞĞ•Ğœ (ÑƒĞ¶Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½)
//       â†’ i=1: used[1]=F â†’ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ 2
//         current = [1, 2], used = [T, T]
//         backtrack()
//           current.size == 2 == nums.size â†’ result.add([1,2])
//         Ğ¾Ñ‚ĞºĞ°Ñ‚: current = [1], used = [T, F]
//     Ğ¾Ñ‚ĞºĞ°Ñ‚: current = [], used = [F, F]
//   â†’ i=1: used[1]=F â†’ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ 2
//     current = [2], used = [F, T]
//     backtrack()
//       â†’ i=0: used[0]=F â†’ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ 1
//         current = [2, 1], used = [T, T]
//         backtrack()
//           current.size == 2 â†’ result.add([2,1])
//         Ğ¾Ñ‚ĞºĞ°Ñ‚: current = [2], used = [F, T]
//       â†’ i=1: used[1]=T â†’ ĞŸĞ ĞĞŸĞ£Ğ¡ĞšĞĞ•Ğœ
//     Ğ¾Ñ‚ĞºĞ°Ñ‚: current = [], used = [F, F]
//
// Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚: [[1,2], [2,1]]
```

### ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ: Swap Ğ²Ğ¼ĞµÑÑ‚Ğ¾ used[]

```kotlin
fun permuteSwap(nums: IntArray): List<List<Int>> {
    val result = mutableListOf<List<Int>>()

    fun backtrack(start: Int) {
        if (start == nums.size) {
            result.add(nums.toList())
            return
        }

        for (i in start until nums.size) {
            // Choose: swap nums[start] with nums[i]
            swap(nums, start, i)

            // Explore
            backtrack(start + 1)

            // Unchoose: swap back
            swap(nums, start, i)
        }
    }

    backtrack(0)
    return result
}

fun swap(arr: IntArray, i: Int, j: Int) {
    val temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}
```

---

## Combinations (LeetCode 77)

### ĞŸĞ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ°

Ğ”Ğ°Ğ½Ñ‹ n Ğ¸ k, Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ²ÑĞµ ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¸ k Ñ‡Ğ¸ÑĞµĞ» Ğ¸Ğ· [1..n].

### Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ

```
n = 4, k = 2

                       []
         /       /      \       \
       [1]     [2]      [3]     [4]
      / | \    / \        \
   [1,2][1,3][1,4][2,3][2,4] [3,4]

Result: [[1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]
```

### Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ (Kotlin)

```kotlin
fun combine(n: Int, k: Int): List<List<Int>> {
    val result = mutableListOf<List<Int>>()
    val current = mutableListOf<Int>()

    fun backtrack(start: Int) {
        // ĞĞ°ÑˆĞ»Ğ¸ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ½ÑƒÑ ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ñ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ° k â€” ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼
        if (current.size == k) {
            result.add(current.toList())
            return
        }

        // PRUNING (Ğ¾Ñ‚ÑĞµÑ‡ĞµĞ½Ğ¸Ğµ): Ğ½ÑƒĞ¶Ğ½Ğ¾ ĞµÑ‰Ñ‘ (k - current.size) ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²
        // Ğ•ÑĞ»Ğ¸ Ğ¾ÑÑ‚Ğ°Ğ²ÑˆĞ¸Ñ…ÑÑ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ² Ğ¼ĞµĞ½ÑŒÑˆĞµ, Ñ‡ĞµĞ¼ Ğ½ÑƒĞ¶Ğ½Ğ¾ â€” Ğ½Ğµ Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°ĞµĞ¼
        // ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: k=3, current=[1], start=5, n=5 â†’ Ğ½ÑƒĞ¶Ğ½Ğ¾ 2, Ğ¾ÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ 1 â†’ skip
        val remaining = k - current.size
        for (i in start..n - remaining + 1) {
            current.add(i)       // Choose â€” Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ² Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ñ
            backtrack(i + 1)     // Explore â€” Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ğ¾ Ğ¸Ñ‰ĞµĞ¼ Ğ´Ğ°Ğ»ÑŒÑˆĞµ
            current.removeAt(current.lastIndex)  // Unchoose â€” Ğ¾Ñ‚ĞºĞ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ²Ñ‹Ğ±Ğ¾Ñ€
        }
    }

    backtrack(1)
    return result
}
```

---

## Combination Sum (LeetCode 39)

### ĞŸĞ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ°

Ğ”Ğ°Ğ½ Ğ¼Ğ°ÑÑĞ¸Ğ² ĞºĞ°Ğ½Ğ´Ğ¸Ğ´Ğ°Ñ‚Ğ¾Ğ² (ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ñ…) Ğ¸ target. ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ²ÑĞµ ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¸, Ğ´Ğ°ÑÑ‰Ğ¸Ğµ target. ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ñ€Ğ°Ğ·.

### Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ

```
candidates = [2, 3, 6, 7], target = 7

                    []  sum=0
           /     /      \      \
        [2]    [3]     [6]    [7] âœ“
       / | \     |       |
   [2,2][2,3][2,6>7][3,3][6+3>7]
    / | \    |
[2,2,2][2,2,3âœ“]...

Results: [[2,2,3], [7]]
```

### Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ (Kotlin)

```kotlin
fun combinationSum(candidates: IntArray, target: Int): List<List<Int>> {
    val result = mutableListOf<List<Int>>()
    val current = mutableListOf<Int>()

    fun backtrack(start: Int, remaining: Int) {
        // remaining == 0 â†’ ÑÑƒĞ¼Ğ¼Ğ° Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¹ ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ñ€Ğ°Ğ²Ğ½Ğ° target
        if (remaining == 0) {
            result.add(current.toList())
            return
        }

        // PRUNING: ĞµÑĞ»Ğ¸ remaining < 0, ÑÑƒĞ¼Ğ¼Ğ° ÑƒĞ¶Ğµ Ğ¿Ñ€ĞµĞ²Ñ‹ÑĞ¸Ğ»Ğ° target
        // ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°Ñ‚ÑŒ Ğ±ĞµÑÑĞ¼Ñ‹ÑĞ»ĞµĞ½Ğ½Ğ¾ (Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ² Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑƒĞ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ñ‚ ÑÑƒĞ¼Ğ¼Ñƒ)
        if (remaining < 0) return

        for (i in start until candidates.size) {
            current.add(candidates[i])  // Choose â€” Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞºĞ°Ğ½Ğ´Ğ¸Ğ´Ğ°Ñ‚Ğ°

            // Ğ’ĞĞ–ĞĞ: Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‘Ğ¼ i, Ğ° ĞĞ• i+1!
            // ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ? ĞŸĞ¾Ñ‚Ğ¾Ğ¼Ñƒ Ñ‡Ñ‚Ğ¾ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞĞ•Ğ¡ĞšĞĞ›Ğ¬ĞšĞ Ğ ĞĞ—
            // Ğ•ÑĞ»Ğ¸ Ğ±Ñ‹ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ±Ñ‹Ğ»Ğ¾ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ÑÑ‚ÑŒ â€” Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ»Ğ¸ Ğ±Ñ‹ i+1
            backtrack(i, remaining - candidates[i])  // Explore

            current.removeAt(current.lastIndex)  // Unchoose â€” Ğ¾Ñ‚ĞºĞ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼
        }
    }

    backtrack(0, target)
    return result
}
```

---

## Subsets II (Ñ Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ğ°Ğ¼Ğ¸) (LeetCode 90)

### ĞŸĞ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ°

ĞœĞ°ÑÑĞ¸Ğ² Ğ¼Ğ¾Ğ¶ĞµÑ‚ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ñ‹. Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ²ÑĞµ ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ°.

### ĞšĞ»ÑÑ‡ĞµĞ²Ğ°Ñ Ğ¸Ğ´ĞµÑ: Skip duplicates

```kotlin
fun subsetsWithDup(nums: IntArray): List<List<Int>> {
    // Ğ’ĞĞ–ĞĞ: ÑĞ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ñ‹ Ğ±Ñ‹Ğ»Ğ¸ Ñ€ÑĞ´Ğ¾Ğ¼!
    // [1, 2, 1] â†’ [1, 1, 2] â€” Ñ‚ĞµĞ¿ĞµÑ€ÑŒ Ğ¾Ğ´Ğ¸Ğ½Ğ°ĞºĞ¾Ğ²Ñ‹Ğµ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹ ÑĞ¾ÑĞµĞ´ÑÑ‚Ğ²ÑƒÑÑ‚
    nums.sort()
    val result = mutableListOf<List<Int>>()
    val current = mutableListOf<Int>()

    fun backtrack(start: Int) {
        result.add(current.toList())

        for (i in start until nums.size) {
            // ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ñ‹ ĞĞ ĞĞ”ĞĞĞœ Ğ£Ğ ĞĞ’ĞĞ• Ğ´ĞµÑ€ĞµĞ²Ğ° Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹
            // Ğ£ÑĞ»Ğ¾Ğ²Ğ¸Ğµ: i > start Ğ˜ nums[i] == nums[i-1]
            //
            // ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ i > start? Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ½Ğ° Ğ ĞĞ—ĞĞ«Ğ¥ ÑƒÑ€Ğ¾Ğ²Ğ½ÑÑ… Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ñ‹ Ğ´Ğ¾Ğ¿ÑƒÑĞºĞ°Ğ»Ğ¸ÑÑŒ
            // ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: [1, 1, 2] â†’ Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ¾ [1, 1] Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ½Ğ¾!
            // ĞĞ¾ Ğ¼Ñ‹ Ğ½Ğµ Ñ…Ğ¾Ñ‚Ğ¸Ğ¼ Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ [1, 2] Ğ´Ğ²Ğ°Ğ¶Ğ´Ñ‹ (Ğ¾Ñ‚ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ¹ Ğ¸ Ğ²Ñ‚Ğ¾Ñ€Ğ¾Ğ¹ 1)
            if (i > start && nums[i] == nums[i - 1]) continue

            current.add(nums[i])
            backtrack(i + 1)
            current.removeAt(current.lastIndex)
        }
    }

    backtrack(0)
    return result
}
```

---

## N-Queens (LeetCode 51)

### ĞŸĞ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ°

Ğ Ğ°ÑÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ n Ñ„ĞµÑ€Ğ·ĞµĞ¹ Ğ½Ğ° Ğ´Ğ¾ÑĞºĞµ nÃ—n Ñ‚Ğ°Ğº, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ½Ğ¸ Ğ¾Ğ´Ğ¸Ğ½ Ğ½Ğµ Ğ°Ñ‚Ğ°ĞºĞ¾Ğ²Ğ°Ğ» Ğ´Ñ€ÑƒĞ³Ğ¾Ğ³Ğ¾.

### Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ

```
n = 4

Solution 1:        Solution 2:
. Q . .            . . Q .
. . . Q            Q . . .
Q . . .            . . . Q
. . Q .            . Q . .

Ğ¤ĞµÑ€Ğ·Ğ¸ Ğ°Ñ‚Ğ°ĞºÑƒÑÑ‚ Ğ¿Ğ¾ Ğ³Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»Ğ¸, Ğ²ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»Ğ¸ Ğ¸ Ğ´Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ÑĞ¼.
```

### Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ (Kotlin) â€” Ñ Ğ¿Ğ¾Ğ´Ñ€Ğ¾Ğ±Ğ½Ñ‹Ğ¼ Ğ¾Ğ±ÑŠÑÑĞ½ĞµĞ½Ğ¸ĞµĞ¼

```kotlin
fun solveNQueens(n: Int): List<List<String>> {
    // result â€” ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ²ÑĞµÑ… Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ½Ñ‹Ñ… Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹
    // ĞšĞ°Ğ¶Ğ´Ğ¾Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ â€” ÑÑ‚Ğ¾ ÑĞ¿Ğ¸ÑĞ¾Ğº ÑÑ‚Ñ€Ğ¾Ğº, Ğ¿Ñ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ»ÑÑÑ‰Ğ¸Ñ… Ğ´Ğ¾ÑĞºÑƒ
    val result = mutableListOf<List<String>>()

    // board â€” Ğ´Ğ¾ÑĞºĞ° nÃ—n, Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ğ°Ñ Ñ‚Ğ¾Ñ‡ĞºĞ°Ğ¼Ğ¸ ('.')
    // 'Q' Ğ±ÑƒĞ´ĞµÑ‚ Ğ¾Ğ·Ğ½Ğ°Ñ‡Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ñ„ĞµÑ€Ğ·Ñ
    val board = Array(n) { CharArray(n) { '.' } }

    // ĞĞ¢Ğ¡Ğ›Ğ•Ğ–Ğ˜Ğ’ĞĞĞ˜Ğ• ĞĞ¢ĞĞšĞ£Ğ•ĞœĞ«Ğ¥ ĞŸĞĞ—Ğ˜Ğ¦Ğ˜Ğ™:
    // Ğ’Ğ¼ĞµÑÑ‚Ğ¾ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ²ÑĞµÑ… 8 Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğ¹, Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ 3 Ğ¼Ğ°ÑÑĞ¸Ğ²Ğ°

    // cols[i] = true, ĞµÑĞ»Ğ¸ Ğ² ÑÑ‚Ğ¾Ğ»Ğ±Ñ†Ğµ i ÑƒĞ¶Ğµ ĞµÑÑ‚ÑŒ Ñ„ĞµÑ€Ğ·ÑŒ
    val cols = BooleanArray(n)

    // diag1 â€” Ğ´Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»Ğ¸ "ÑĞ²ĞµÑ€Ñ…Ñƒ-ÑĞ»ĞµĞ²Ğ° Ğ²Ğ½Ğ¸Ğ·-Ğ²Ğ¿Ñ€Ğ°Ğ²Ğ¾" (â†˜)
    // ĞĞ° Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ğ´Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»Ğ¸ row - col = const
    // Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ: Ğ¾Ñ‚ -(n-1) Ğ´Ğ¾ +(n-1), ÑĞ´Ğ²Ğ¸Ğ³Ğ°ĞµĞ¼ Ğ½Ğ° (n-1) â†’ Ğ´Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½ [0, 2n-2]
    val diag1 = BooleanArray(2 * n - 1)

    // diag2 â€” Ğ´Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»Ğ¸ "ÑĞ²ĞµÑ€Ñ…Ñƒ-ÑĞ¿Ñ€Ğ°Ğ²Ğ° Ğ²Ğ½Ğ¸Ğ·-Ğ²Ğ»ĞµĞ²Ğ¾" (â†™)
    // ĞĞ° Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ğ´Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»Ğ¸ row + col = const
    // Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ: Ğ¾Ñ‚ 0 Ğ´Ğ¾ 2(n-1) â†’ Ğ´Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½ [0, 2n-2]
    val diag2 = BooleanArray(2 * n - 1)

    // Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ñ€Ğ°Ğ·Ğ¼ĞµÑ‰ĞµĞ½Ğ¸Ñ Ñ„ĞµÑ€Ğ·ĞµĞ¹
    // row â€” Ñ‚ĞµĞºÑƒÑ‰Ğ°Ñ ÑÑ‚Ñ€Ğ¾ĞºĞ°, ĞºÑƒĞ´Ğ° Ğ¿Ñ‹Ñ‚Ğ°ĞµĞ¼ÑÑ Ğ¿Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ñ„ĞµÑ€Ğ·Ñ
    // Ğ˜Ğ”Ğ•Ğ¯: Ğ² ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ¾ĞºĞµ ÑÑ‚Ğ°Ğ²Ğ¸Ğ¼ Ñ€Ğ¾Ğ²Ğ½Ğ¾ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ñ„ĞµÑ€Ğ·Ñ
    fun backtrack(row: Int) {
        // Ğ£Ğ¡Ğ›ĞĞ’Ğ˜Ğ• Ğ—ĞĞ’Ğ•Ğ Ğ¨Ğ•ĞĞ˜Ğ¯: Ğ²ÑĞµ n Ñ„ĞµÑ€Ğ·ĞµĞ¹ Ñ€Ğ°ÑÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ñ‹
        if (row == n) {
            // ĞŸÑ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·ÑƒĞµĞ¼ Ğ´Ğ¾ÑĞºÑƒ Ğ² ÑĞ¿Ğ¸ÑĞ¾Ğº ÑÑ‚Ñ€Ğ¾Ğº Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼
            result.add(board.map { String(it) })
            return
        }

        // ĞŸÑ€Ğ¾Ğ±ÑƒĞµĞ¼ Ğ¿Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ñ„ĞµÑ€Ğ·Ñ Ğ² ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ ÑÑ‚Ğ¾Ğ»Ğ±ĞµÑ† Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¹ ÑÑ‚Ñ€Ğ¾ĞºĞ¸
        for (col in 0 until n) {
            // Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ Ğ¸Ğ½Ğ´ĞµĞºÑÑ‹ Ğ´Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ĞµĞ¹ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ (row, col)
            val d1 = row - col + n - 1  // Ğ”Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒ â†˜
            val d2 = row + col          // Ğ”Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒ â†™

            // PRUNING (Ğ¾Ñ‚ÑĞµÑ‡ĞµĞ½Ğ¸Ğµ): Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ°Ñ‚Ğ°ĞºÑƒĞµĞ¼Ğ° Ğ»Ğ¸ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
            // Ğ•ÑĞ»Ğ¸ ÑÑ‚Ğ¾Ğ»Ğ±ĞµÑ† Ğ¸Ğ»Ğ¸ Ğ¾Ğ´Ğ½Ğ° Ğ¸Ğ· Ğ´Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ĞµĞ¹ Ğ·Ğ°Ğ½ÑÑ‚Ğ° â€” ĞŸĞ ĞĞŸĞ£Ğ¡ĞšĞĞ•Ğœ
            if (cols[col] || diag1[d1] || diag2[d2]) continue

            // Ğ¨ĞĞ“ 1: Ğ’Ğ«Ğ‘Ğ˜Ğ ĞĞ•Ğœ â€” ÑÑ‚Ğ°Ğ²Ğ¸Ğ¼ Ñ„ĞµÑ€Ğ·Ñ
            board[row][col] = 'Q'    // Ğ¤ĞµÑ€Ğ·ÑŒ Ğ½Ğ° Ğ´Ğ¾ÑĞºĞµ
            cols[col] = true         // Ğ¡Ñ‚Ğ¾Ğ»Ğ±ĞµÑ† Ñ‚ĞµĞ¿ĞµÑ€ÑŒ Ğ·Ğ°Ğ½ÑÑ‚
            diag1[d1] = true         // Ğ”Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒ â†˜ Ğ·Ğ°Ğ½ÑÑ‚Ğ°
            diag2[d2] = true         // Ğ”Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒ â†™ Ğ·Ğ°Ğ½ÑÑ‚Ğ°

            // Ğ¨ĞĞ“ 2: Ğ˜Ğ¡Ğ¡Ğ›Ğ•Ğ”Ğ£Ğ•Ğœ â€” Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ¸Ğ¼ Ğº ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ¹ ÑÑ‚Ñ€Ğ¾ĞºĞµ
            backtrack(row + 1)

            // Ğ¨ĞĞ“ 3: ĞĞ¢ĞšĞĞ¢Ğ«Ğ’ĞĞ•Ğœ â€” ÑƒĞ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ñ„ĞµÑ€Ğ·Ñ
            board[row][col] = '.'    // ĞÑ‡Ğ¸Ñ‰Ğ°ĞµĞ¼ ĞºĞ»ĞµÑ‚ĞºÑƒ
            cols[col] = false        // ĞÑĞ²Ğ¾Ğ±Ğ¾Ğ¶Ğ´Ğ°ĞµĞ¼ ÑÑ‚Ğ¾Ğ»Ğ±ĞµÑ†
            diag1[d1] = false        // ĞÑĞ²Ğ¾Ğ±Ğ¾Ğ¶Ğ´Ğ°ĞµĞ¼ Ğ´Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒ â†˜
            diag2[d2] = false        // ĞÑĞ²Ğ¾Ğ±Ğ¾Ğ¶Ğ´Ğ°ĞµĞ¼ Ğ´Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒ â†™
        }
    }

    // ĞĞ°Ñ‡Ğ¸Ğ½Ğ°ĞµĞ¼ Ñ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ (row = 0)
    backtrack(0)
    return result
}

// Ğ’Ğ˜Ğ—Ğ£ĞĞ›Ğ˜Ğ—ĞĞ¦Ğ˜Ğ¯ Ğ”Ğ˜ĞĞ“ĞĞĞĞ›Ğ•Ğ™ Ğ´Ğ»Ñ n=4:
//
//    col:  0   1   2   3
// row 0:  [0] [1] [2] [3]   â† diag1 (row-col+3): 3,4,5,6
// row 1:  [4] [5] [6] [7]                       2,3,4,5
// row 2:  [8] [9] [10][11]                      1,2,3,4
// row 3:  [12][13][14][15]                      0,1,2,3
//
//    col:  0   1   2   3
// row 0:  [0] [1] [2] [3]   â† diag2 (row+col): 0,1,2,3
// row 1:  [4] [5] [6] [7]                      1,2,3,4
// row 2:  [8] [9] [10][11]                     2,3,4,5
// row 3:  [12][13][14][15]                     3,4,5,6
//
// ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ (1,2)
// diag1 = 1 - 2 + 3 = 2 (Ğ´Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒ â†˜ Ñ‡ĞµÑ€ĞµĞ· ĞºĞ»ĞµÑ‚ĞºĞ¸ (0,1), (1,2), (2,3))
// diag2 = 1 + 2 = 3 (Ğ´Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒ â†™ Ñ‡ĞµÑ€ĞµĞ· ĞºĞ»ĞµÑ‚ĞºĞ¸ (0,3), (1,2), (2,1), (3,0))
```

### Ğ”Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¸Ğ½Ğ´ĞµĞºÑÑ‹

```
Ğ”Ğ»Ñ Ğ´Ğ¾ÑĞºĞ¸ nÃ—n:
- Ğ”Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒ â†˜ (row - col): Ğ¾Ñ‚ -(n-1) Ğ´Ğ¾ +(n-1)
  Ğ¡Ğ´Ğ²Ğ¸Ğ³Ğ°ĞµĞ¼ Ğ½Ğ° (n-1): Ğ¸Ğ½Ğ´ĞµĞºÑ = row - col + n - 1
  Ğ”Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½: [0, 2n-2]

- Ğ”Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒ â†™ (row + col): Ğ¾Ñ‚ 0 Ğ´Ğ¾ 2(n-1)
  Ğ˜Ğ½Ğ´ĞµĞºÑ = row + col
  Ğ”Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½: [0, 2n-2]
```

---

## Sudoku Solver (LeetCode 37)

### Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ (Kotlin) â€” Ñ Ğ¿Ğ¾Ğ´Ñ€Ğ¾Ğ±Ğ½Ñ‹Ğ¼ Ğ¾Ğ±ÑŠÑÑĞ½ĞµĞ½Ğ¸ĞµĞ¼

```kotlin
fun solveSudoku(board: Array<CharArray>) {
    // Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ñ€ĞµÑˆĞ°Ñ‚ĞµĞ»ÑŒ â€” Ğ¾Ğ½ Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€ÑƒĞµÑ‚ board Ğ½Ğ° Ğ¼ĞµÑÑ‚Ğµ
    solve(board)
}

// Ğ ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ Sudoku
// Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ true ĞµÑĞ»Ğ¸ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾, false ĞµÑĞ»Ğ¸ Ğ½ÑƒĞ¶ĞµĞ½ Ğ¾Ñ‚ĞºĞ°Ñ‚
fun solve(board: Array<CharArray>): Boolean {
    // Ğ˜Ñ‰ĞµĞ¼ Ğ¿ĞµÑ€Ğ²ÑƒÑ Ğ¿ÑƒÑÑ‚ÑƒÑ ĞºĞ»ĞµÑ‚ĞºÑƒ ('.')
    // ĞŸÑ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ¿Ğ¾ Ğ²ÑĞµĞ¼ ĞºĞ»ĞµÑ‚ĞºĞ°Ğ¼ Ğ´Ğ¾ÑĞºĞ¸ 9Ã—9
    for (row in 0 until 9) {
        for (col in 0 until 9) {
            // ĞĞ°ÑˆĞ»Ğ¸ Ğ¿ÑƒÑÑ‚ÑƒÑ ĞºĞ»ĞµÑ‚ĞºÑƒ â€” Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ
            if (board[row][col] == '.') {
                // ĞŸÑ€Ğ¾Ğ±ÑƒĞµĞ¼ Ğ¿Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ ĞºĞ°Ğ¶Ğ´ÑƒÑ Ñ†Ğ¸Ñ„Ñ€Ñƒ Ğ¾Ñ‚ 1 Ğ´Ğ¾ 9
                for (digit in '1'..'9') {
                    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ»Ğ¸ Ğ¿Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑÑ‚Ñƒ Ñ†Ğ¸Ñ„Ñ€Ñƒ
                    if (isValid(board, row, col, digit)) {
                        // Ğ¨ĞĞ“ 1: Ğ’Ğ«Ğ‘Ğ˜Ğ ĞĞ•Ğœ â€” ÑÑ‚Ğ°Ğ²Ğ¸Ğ¼ Ñ†Ğ¸Ñ„Ñ€Ñƒ
                        board[row][col] = digit

                        // Ğ¨ĞĞ“ 2: Ğ˜Ğ¡Ğ¡Ğ›Ğ•Ğ”Ğ£Ğ•Ğœ â€” Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ Ñ€ĞµÑˆĞ¸Ñ‚ÑŒ Ğ´Ğ°Ğ»ÑŒÑˆĞµ
                        // Ğ•ÑĞ»Ğ¸ solve() Ğ²ĞµÑ€Ğ½ÑƒĞ» true â€” Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾!
                        // Ğ¡Ñ€Ğ°Ğ·Ñƒ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ true, Ğ½Ğµ Ğ¾Ñ‚ĞºĞ°Ñ‚Ñ‹Ğ²Ğ°Ñ
                        if (solve(board)) return true

                        // Ğ¨ĞĞ“ 3: ĞĞ¢ĞšĞĞ¢Ğ«Ğ’ĞĞ•Ğœ â€” ĞµÑĞ»Ğ¸ Ğ½Ğµ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ»Ğ¾ÑÑŒ
                        // Ğ­Ñ‚Ğ° Ñ†Ğ¸Ñ„Ñ€Ğ° Ğ½Ğµ Ğ¿Ñ€Ğ¸Ğ²ĞµĞ»Ğ° Ğº Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ, Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ Ğ´Ñ€ÑƒĞ³ÑƒÑ
                        board[row][col] = '.'
                    }
                }
                // ĞŸĞµÑ€ĞµĞ±Ñ€Ğ°Ğ»Ğ¸ Ğ²ÑĞµ Ñ†Ğ¸Ñ„Ñ€Ñ‹ 1-9, Ğ½Ğ¸ Ğ¾Ğ´Ğ½Ğ° Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ¾ÑˆĞ»Ğ°
                // Ğ—Ğ½Ğ°Ñ‡Ğ¸Ñ‚ Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ±Ñ‹Ğ»Ğ° Ñ€Ğ°Ğ½ÑŒÑˆĞµ â€” Ğ½ÑƒĞ¶ĞµĞ½ Ğ¾Ñ‚ĞºĞ°Ñ‚
                // Ğ’ĞĞ–ĞĞ: Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ false, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ÑÑ‰Ğ¸Ğ¹ ĞºĞ¾Ğ´ Ğ¾Ñ‚ĞºĞ°Ñ‚Ğ¸Ğ»ÑÑ
                return false
            }
        }
    }
    // ĞĞµ Ğ½Ğ°ÑˆĞ»Ğ¸ Ğ½Ğ¸ Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹ ĞºĞ»ĞµÑ‚ĞºĞ¸ â€” Ğ´Ğ¾ÑĞºĞ° Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ°!
    // Sudoku Ñ€ĞµÑˆĞµĞ½Ğ¾, Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ true
    return true
}

// ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ°: Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ»Ğ¸ Ğ¿Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ digit Ğ² Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ (row, col)?
fun isValid(board: Array<CharArray>, row: Int, col: Int, digit: Char): Boolean {
    // ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ 1: Ğ² ÑÑ‚Ñ€Ğ¾ĞºĞµ Ğ½ĞµÑ‚ Ñ‚Ğ°ĞºĞ¾Ğ¹ Ğ¶Ğµ Ñ†Ğ¸Ñ„Ñ€Ñ‹
    for (c in 0 until 9) {
        if (board[row][c] == digit) return false
    }

    // ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ 2: Ğ² ÑÑ‚Ğ¾Ğ»Ğ±Ñ†Ğµ Ğ½ĞµÑ‚ Ñ‚Ğ°ĞºĞ¾Ğ¹ Ğ¶Ğµ Ñ†Ğ¸Ñ„Ñ€Ñ‹
    for (r in 0 until 9) {
        if (board[r][col] == digit) return false
    }

    // ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ 3: Ğ² Ğ±Ğ»Ğ¾ĞºĞµ 3Ã—3 Ğ½ĞµÑ‚ Ñ‚Ğ°ĞºĞ¾Ğ¹ Ğ¶Ğµ Ñ†Ğ¸Ñ„Ñ€Ñ‹
    // ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ»ĞµĞ²Ñ‹Ğ¹ Ğ²ĞµÑ€Ñ…Ğ½Ğ¸Ğ¹ ÑƒĞ³Ğ¾Ğ» Ğ±Ğ»Ğ¾ĞºĞ°
    // row/3 Ğ´Ğ°Ñ‘Ñ‚ Ğ½Ğ¾Ğ¼ĞµÑ€ Ğ±Ğ»Ğ¾ĞºĞ° (0, 1 Ğ¸Ğ»Ğ¸ 2), ÑƒĞ¼Ğ½Ğ¾Ğ¶Ğ°ĞµĞ¼ Ğ½Ğ° 3 â†’ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾ Ğ±Ğ»Ğ¾ĞºĞ°
    val boxRow = (row / 3) * 3  // 0â†’0, 3â†’3, 6â†’6
    val boxCol = (col / 3) * 3

    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ²ÑĞµ 9 ĞºĞ»ĞµÑ‚Ğ¾Ğº Ğ±Ğ»Ğ¾ĞºĞ°
    for (r in boxRow until boxRow + 3) {
        for (c in boxCol until boxCol + 3) {
            if (board[r][c] == digit) return false
        }
    }

    // Ğ’ÑĞµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ¿Ñ€Ğ¾Ğ¹Ğ´ĞµĞ½Ñ‹ â€” Ñ†Ğ¸Ñ„Ñ€Ñƒ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ
    return true
}

// ĞŸĞĞ¨ĞĞ“ĞĞ’Ğ«Ğ™ Ğ ĞĞ—Ğ‘ĞĞ  Ğ½Ğ° ÑƒĞ¿Ñ€Ğ¾Ñ‰Ñ‘Ğ½Ğ½Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğµ (2Ã—2):
//
// Ğ”Ğ¾ÑĞºĞ°:   .  2      ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ°: Ğ² ÑÑ‚Ñ€Ğ¾ĞºĞµ Ğ¸ ÑÑ‚Ğ¾Ğ»Ğ±Ñ†Ğµ
//          3  .      Ğ½Ğµ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ Ğ±Ñ‹Ñ‚ÑŒ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€Ğ¾Ğ²
//
// solve() Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ (0,0) = '.'
//   â†’ digit='1': isValid? Ğ½ĞµÑ‚ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€Ğ¾Ğ² â†’ ÑÑ‚Ğ°Ğ²Ğ¸Ğ¼ 1
//     Ğ”Ğ¾ÑĞºĞ°:   1  2
//              3  .
//     â†’ solve() Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ (1,1) = '.'
//       â†’ digit='1': Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑ‚Ğ¾Ğ»Ğ±ĞµÑ† 1 â€” Ğ½ĞµÑ‚ 1 âœ“
//                   Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑ‚Ñ€Ğ¾ĞºÑƒ 1 â€” Ğ½ĞµÑ‚ 1 âœ“
//         ÑÑ‚Ğ°Ğ²Ğ¸Ğ¼ 1, Ğ½Ğ¾ ÑÑ‚Ğ¾ Ğ½ĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾ (Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ Ğ±Ñ‹Ñ‚ÑŒ 4)
//         â†’ solve() â€” Ğ¿ÑƒÑÑ‚Ñ‹Ñ… ĞºĞ»ĞµÑ‚Ğ¾Ğº Ğ½ĞµÑ‚ â†’ return true!
//     Ğ ĞµÑˆĞµĞ½Ğ¸Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾ (Ñ…Ğ¾Ñ‚Ñ Ğ² Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Sudoku Ğ±Ñ‹Ğ»Ğ¾ Ğ±Ñ‹ 4)
```

---

## Word Search (LeetCode 79)

### ĞŸĞ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ°

Ğ”Ğ°Ğ½Ğ° Ğ´Ğ¾ÑĞºĞ° Ñ Ğ±ÑƒĞºĞ²Ğ°Ğ¼Ğ¸ Ğ¸ ÑĞ»Ğ¾Ğ²Ğ¾. ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ, Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ»Ğ¸ ÑĞ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑĞ»Ğ¾Ğ²Ğ¾, Ğ´Ğ²Ğ¸Ğ³Ğ°ÑÑÑŒ Ğ¿Ğ¾ ÑĞ¾ÑĞµĞ´Ğ½Ğ¸Ğ¼ ĞºĞ»ĞµÑ‚ĞºĞ°Ğ¼.

### Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ (Kotlin) â€” Ñ Ğ¿Ğ¾Ğ´Ñ€Ğ¾Ğ±Ğ½Ñ‹Ğ¼ Ğ¾Ğ±ÑŠÑÑĞ½ĞµĞ½Ğ¸ĞµĞ¼

```kotlin
fun exist(board: Array<CharArray>, word: String): Boolean {
    val rows = board.size           // ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ ÑÑ‚Ñ€Ğ¾Ğº Ğ² ÑĞµÑ‚ĞºĞµ
    val cols = board[0].size        // ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ ÑÑ‚Ğ¾Ğ»Ğ±Ñ†Ğ¾Ğ²

    // Ğ ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ°
    // row, col â€” Ñ‚ĞµĞºÑƒÑ‰Ğ°Ñ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ² ÑĞµÑ‚ĞºĞµ
    // index â€” ĞºĞ°ĞºĞ¾Ğ¹ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ» ÑĞ»Ğ¾Ğ²Ğ° Ğ¸Ñ‰ĞµĞ¼ (0, 1, 2, ...)
    fun backtrack(row: Int, col: Int, index: Int): Boolean {
        // Ğ£Ğ¡Ğ›ĞĞ’Ğ˜Ğ• Ğ£Ğ¡ĞŸĞ•Ğ¥Ğ: Ğ²ÑĞµ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ‹ ÑĞ»Ğ¾Ğ²Ğ° Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹
        // index == word.length Ğ¾Ğ·Ğ½Ğ°Ñ‡Ğ°ĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ğ¼Ñ‹ Ğ¿Ñ€Ğ¾ÑˆĞ»Ğ¸ Ğ²ÑĞµ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ‹ [0..length-1]
        if (index == word.length) return true

        // ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ Ğ“Ğ ĞĞĞ˜Ğ¦: Ğ½Ğµ Ğ²Ñ‹ÑˆĞ»Ğ¸ Ğ»Ğ¸ Ğ·Ğ° Ğ¿Ñ€ĞµĞ´ĞµĞ»Ñ‹ ÑĞµÑ‚ĞºĞ¸?
        if (row < 0 || row >= rows || col < 0 || col >= cols) return false

        // ĞŸĞ ĞĞ’Ğ•Ğ ĞšĞ Ğ¡Ğ˜ĞœĞ’ĞĞ›Ğ: ÑĞ¾Ğ²Ğ¿Ğ°Ğ´Ğ°ĞµÑ‚ Ğ»Ğ¸ Ñ‚ĞµĞºÑƒÑ‰Ğ°Ñ ĞºĞ»ĞµÑ‚ĞºĞ° Ñ Ğ½ÑƒĞ¶Ğ½Ñ‹Ğ¼ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ¼?
        if (board[row][col] != word[index]) return false

        // Ğ¨ĞĞ“ 1: Ğ’Ğ«Ğ‘Ğ˜Ğ ĞĞ•Ğœ â€” Ğ¿Ğ¾Ğ¼ĞµÑ‡Ğ°ĞµĞ¼ ĞºĞ»ĞµÑ‚ĞºÑƒ ĞºĞ°Ğº Ğ¿Ğ¾ÑĞµÑ‰Ñ‘Ğ½Ğ½ÑƒÑ
        // Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ¾Ñ€Ğ¸Ğ³Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ», Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼ Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ
        val temp = board[row][col]
        // Ğ—Ğ°Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ½Ğ° '#' â€” ÑĞ¿ĞµÑ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¼Ğ°Ñ€ĞºĞµÑ€ "ÑƒĞ¶Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ°"
        // Ğ­Ñ‚Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ¾Ñ‚Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€Ğ½Ğ¾Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ¾Ğ¹ Ğ¶Ğµ ĞºĞ»ĞµÑ‚ĞºĞ¸
        board[row][col] = '#'

        // Ğ¨ĞĞ“ 2: Ğ˜Ğ¡Ğ¡Ğ›Ğ•Ğ”Ğ£Ğ•Ğœ â€” Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ Ğ²ÑĞµ 4 Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ
        // Ğ˜Ñ‰ĞµĞ¼ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ» (index + 1) Ğ² ÑĞ¾ÑĞµĞ´Ğ½Ğ¸Ñ… ĞºĞ»ĞµÑ‚ĞºĞ°Ñ…
        // || Ğ¾Ğ·Ğ½Ğ°Ñ‡Ğ°ĞµÑ‚: ĞµÑĞ»Ğ¸ Ñ…Ğ¾Ñ‚Ñ Ğ±Ñ‹ Ğ¾Ğ´Ğ½Ğ¾ Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ â€” Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ true
        val found = backtrack(row + 1, col, index + 1) ||  // Ğ’Ğ½Ğ¸Ğ·
                    backtrack(row - 1, col, index + 1) ||  // Ğ’Ğ²ĞµÑ€Ñ…
                    backtrack(row, col + 1, index + 1) ||  // Ğ’Ğ¿Ñ€Ğ°Ğ²Ğ¾
                    backtrack(row, col - 1, index + 1)     // Ğ’Ğ»ĞµĞ²Ğ¾

        // Ğ¨ĞĞ“ 3: ĞĞ¢ĞšĞĞ¢Ğ«Ğ’ĞĞ•Ğœ â€” Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¾Ñ€Ğ¸Ğ³Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»
        // Ğ’ĞĞ–ĞĞ: Ğ´Ğ°Ğ¶Ğµ ĞµÑĞ»Ğ¸ Ğ½Ğ°ÑˆĞ»Ğ¸ ÑĞ»Ğ¾Ğ²Ğ¾, Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ´Ğ¾ÑĞºÑƒ
        // Ğ´Ğ»Ñ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğ¹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ñ… Ğ¿Ğ¾Ğ¸ÑĞºĞ¾Ğ²
        board[row][col] = temp

        return found
    }

    // ĞŸÑ€Ğ¾Ğ±ÑƒĞµĞ¼ Ğ½Ğ°Ñ‡Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ¸ÑĞº Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¹ ĞºĞ»ĞµÑ‚ĞºĞ¸ ÑĞµÑ‚ĞºĞ¸
    // Ğ¡Ğ»Ğ¾Ğ²Ğ¾ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°Ñ‚ÑŒÑÑ Ğ³Ğ´Ğµ ÑƒĞ³Ğ¾Ğ´Ğ½Ğ¾
    for (row in 0 until rows) {
        for (col in 0 until cols) {
            // Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ¿Ğ¾Ğ¸ÑĞº Ñ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ (row, col), Ğ¸Ñ‰ĞµĞ¼ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ» 0
            if (backtrack(row, col, 0)) return true
        }
    }

    // ĞŸĞµÑ€ĞµĞ±Ñ€Ğ°Ğ»Ğ¸ Ğ²ÑĞµ ÑÑ‚Ğ°Ñ€Ñ‚Ğ¾Ğ²Ñ‹Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ â€” ÑĞ»Ğ¾Ğ²Ğ¾ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾
    return false
}

// ĞŸĞĞ¨ĞĞ“ĞĞ’Ğ«Ğ™ Ğ ĞĞ—Ğ‘ĞĞ :
// board = [['A','B'],      word = "AB"
//          ['C','D']]
//
// ĞĞ°Ñ‡Ğ¸Ğ½Ğ°ĞµĞ¼ Ñ (0,0):
//   backtrack(0, 0, 0)
//     board[0][0]='A' == word[0]='A' âœ“
//     temp = 'A', board[0][0] = '#'
//     ĞŸÑ€Ğ¾Ğ±ÑƒĞµĞ¼ 4 Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ index=1:
//       (1,0): board[1][0]='C' != word[1]='B' â†’ false
//       (-1,0): Ğ²Ñ‹Ñ…Ğ¾Ğ´ Ğ·Ğ° Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹ â†’ false
//       (0,1): board[0][1]='B' == word[1]='B' âœ“
//         index=2 == word.length=2 â†’ return true!
//     found = true
//     board[0][0] = 'A' (Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ğ»Ğ¸)
//   return true
//
// Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚: true (ÑĞ»Ğ¾Ğ²Ğ¾ "AB" Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾)
```

---

## Generate Parentheses (LeetCode 22)

### ĞŸĞ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ°

Ğ¡Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²ÑĞµ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¸ n Ğ¿Ğ°Ñ€ ÑĞºĞ¾Ğ±Ğ¾Ğº.

### Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ (Kotlin) â€” Ñ Ğ¿Ğ¾Ğ´Ñ€Ğ¾Ğ±Ğ½Ñ‹Ğ¼ Ğ¾Ğ±ÑŠÑÑĞ½ĞµĞ½Ğ¸ĞµĞ¼

```kotlin
fun generateParenthesis(n: Int): List<String> {
    val result = mutableListOf<String>()  // Ğ’ÑĞµ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ½Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¸
    val current = StringBuilder()          // Ğ¢ĞµĞºÑƒÑ‰Ğ°Ñ ÑÑ‚Ñ€Ğ¾ÑÑ‰Ğ°ÑÑÑ ÑÑ‚Ñ€Ğ¾ĞºĞ°

    // open â€” ÑĞºĞ¾Ğ»ÑŒĞºĞ¾ '(' ÑƒĞ¶Ğµ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ğ»Ğ¸
    // close â€” ÑĞºĞ¾Ğ»ÑŒĞºĞ¾ ')' ÑƒĞ¶Ğµ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ğ»Ğ¸
    fun backtrack(open: Int, close: Int) {
        // Ğ£Ğ¡Ğ›ĞĞ’Ğ˜Ğ• Ğ—ĞĞ’Ğ•Ğ Ğ¨Ğ•ĞĞ˜Ğ¯: Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ»Ğ¸ Ğ²ÑĞµ ÑĞºĞ¾Ğ±ĞºĞ¸
        // n Ğ¿Ğ°Ñ€ = 2n ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²
        if (current.length == 2 * n) {
            result.add(current.toString())
            return
        }

        // ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ 1: Ğ¼Ğ¾Ğ¶ĞµĞ¼ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ '(' ĞµÑĞ»Ğ¸ ĞµÑ‰Ñ‘ Ğ½Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ»Ğ¸ Ğ²ÑĞµ n
        // ĞÑ‚ĞºÑ€Ñ‹Ğ²Ğ°ÑÑ‰Ğ¸Ñ… ÑĞºĞ¾Ğ±Ğ¾Ğº Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ n
        if (open < n) {
            current.append('(')           // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ '('
            backtrack(open + 1, close)    // open ÑƒĞ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ğ»ÑÑ Ğ½Ğ° 1
            current.deleteCharAt(current.lastIndex)  // ĞÑ‚ĞºĞ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼
        }

        // ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ 2: Ğ¼Ğ¾Ğ¶ĞµĞ¼ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ')' Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞµÑĞ»Ğ¸ close < open
        // Ğ­Ñ‚Ğ¾ ĞšĞ›Ğ®Ğ§Ğ•Ğ’ĞĞ• Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ½Ğ¾ÑÑ‚Ğ¸!
        // Ğ•ÑĞ»Ğ¸ close >= open, Ñ‚Ğ¾ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑÑ ")(" â€” Ğ½ĞµĞ²Ğ°Ğ»Ğ¸Ğ´Ğ½Ğ°Ñ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ
        // ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: "((" â†’ open=2, close=0 â†’ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ')'
        //         "()" â†’ open=1, close=1 â†’ ĞĞ•Ğ›Ğ¬Ğ—Ğ¯ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ')' ÑĞ½Ğ°Ñ‡Ğ°Ğ»Ğ°
        if (close < open) {
            current.append(')')           // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ')'
            backtrack(open, close + 1)    // close ÑƒĞ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ğ»ÑÑ Ğ½Ğ° 1
            current.deleteCharAt(current.lastIndex)  // ĞÑ‚ĞºĞ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼
        }
    }

    // ĞĞ°Ñ‡Ğ¸Ğ½Ğ°ĞµĞ¼ Ñ Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ¾ĞºĞ¸, 0 Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… Ğ¸ 0 Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ…
    backtrack(0, 0)
    return result
}

// ĞŸĞĞ¨ĞĞ“ĞĞ’Ğ«Ğ™ Ğ ĞĞ—Ğ‘ĞĞ  Ğ´Ğ»Ñ n=2:
//
// backtrack(0, 0), current = ""
//   open < n (0 < 2) â†’ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ '('
//   backtrack(1, 0), current = "("
//     open < n (1 < 2) â†’ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ '('
//     backtrack(2, 0), current = "(("
//       open >= n â†’ ĞĞ• Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ '('
//       close < open (0 < 2) â†’ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ')'
//       backtrack(2, 1), current = "(()"
//         close < open (1 < 2) â†’ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ')'
//         backtrack(2, 2), current = "(())"
//           length == 4 == 2*n â†’ result.add("(())")
//         Ğ¾Ñ‚ĞºĞ°Ñ‚ â†’ current = "(()"
//       Ğ¾Ñ‚ĞºĞ°Ñ‚ â†’ current = "(("
//     Ğ¾Ñ‚ĞºĞ°Ñ‚ â†’ current = "("
//     close < open (0 < 1) â†’ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ')'
//     backtrack(1, 1), current = "()"
//       open < n â†’ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ '('
//       backtrack(2, 1), current = "()(")
//         close < open â†’ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ')'
//         backtrack(2, 2), current = "()()"
//           result.add("()()")
//         ...
//
// Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚: ["(())", "()()"]
```

---

## Letter Combinations of a Phone Number (LeetCode 17)

### Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ (Kotlin)

```kotlin
fun letterCombinations(digits: String): List<String> {
    if (digits.isEmpty()) return emptyList()

    val mapping = mapOf(
        '2' to "abc", '3' to "def", '4' to "ghi", '5' to "jkl",
        '6' to "mno", '7' to "pqrs", '8' to "tuv", '9' to "wxyz"
    )

    val result = mutableListOf<String>()
    val current = StringBuilder()

    fun backtrack(index: Int) {
        if (index == digits.length) {
            result.add(current.toString())
            return
        }

        val letters = mapping[digits[index]]!!
        for (letter in letters) {
            current.append(letter)       // Choose
            backtrack(index + 1)         // Explore
            current.deleteCharAt(current.lastIndex)  // Unchoose
        }
    }

    backtrack(0)
    return result
}
```

---

## Ğ¡Ğ»Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹

| ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ° | Time | Space | ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹ |
|----------|------|-------|---------------------|
| Subsets | O(n Ã— 2^n) | O(n) | 2^n |
| Permutations | O(n Ã— n!) | O(n) | n! |
| Combinations C(n,k) | O(k Ã— C(n,k)) | O(k) | C(n,k) |
| N-Queens | O(n!) | O(n) | ~n!/c^n |
| Sudoku | O(9^(81)) worst | O(1) | 1 (usually) |

### Ğ’Ğ»Ğ¸ÑĞ½Ğ¸Ğµ Pruning

```
Ğ‘ĞµĞ· pruning (brute force):
N-Queens n=8: ~8^8 = 16M Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¾Ğº

Ğ¡ pruning:
N-Queens n=8: ~15K Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¾Ğº (Ğ² 1000 Ñ€Ğ°Ğ· Ğ¼ĞµĞ½ÑŒÑˆĞµ!)
```

---

## Ğ Ğ°ÑĞ¿Ñ€Ğ¾ÑÑ‚Ñ€Ğ°Ğ½Ñ‘Ğ½Ğ½Ñ‹Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸

### 1. Ğ—Ğ°Ğ±Ñ‹Ğ»Ğ¸ unchoose (backtrack)

```kotlin
// âŒ WRONG: No unchoose
fun backtrack() {
    for (i in start until n) {
        current.add(nums[i])  // Choose
        backtrack(i + 1)      // Explore
        // Missing: current.removeAt(current.lastIndex)
    }
}

// âœ… CORRECT: Always unchoose
fun backtrack() {
    for (i in start until n) {
        current.add(nums[i])
        backtrack(i + 1)
        // ĞĞ‘Ğ¯Ğ—ĞĞ¢Ğ•Ğ›Ğ¬ĞĞ: Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ!
        // Ğ‘ĞµĞ· ÑÑ‚Ğ¾Ğ³Ğ¾ current Ğ±ÑƒĞ´ĞµÑ‚ Ğ½Ğ°ĞºĞ°Ğ¿Ğ»Ğ¸Ğ²Ğ°Ñ‚ÑŒ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹
        // Ğ¸ Ğ¿Ğ¾ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğµ Ğ²ĞµÑ‚ĞºĞ¸ Ğ´ĞµÑ€ĞµĞ²Ğ° Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ "Ğ¼ÑƒÑĞ¾Ñ€"
        current.removeAt(current.lastIndex)
    }
}
```

### 2. ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‡Ğ° ÑÑÑ‹Ğ»ĞºĞ¸ Ğ²Ğ¼ĞµÑÑ‚Ğ¾ ĞºĞ¾Ğ¿Ğ¸Ğ¸

```kotlin
// âŒ WRONG: Adding reference
result.add(current)  // All entries point to same list!

// âœ… CORRECT: Add a copy
result.add(current.toList())
// or in Java:
result.add(new ArrayList<>(current));
```

### 3. ĞĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ start index

```kotlin
// âŒ WRONG for subsets/combinations
backtrack(0)  // Starts from 0 every time â†’ duplicates!

// âœ… CORRECT: Start from current position
backtrack(i + 1)  // Subsets/Combinations: avoid reusing earlier elements

// But for permutations with used[] array:
for (i in 0 until n) {  // Start from 0, use 'used' to track
    if (used[i]) continue
    // ...
}
```

### 4. ĞĞµ ÑĞ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ»Ğ¸ Ğ¿ĞµÑ€ĞµĞ´ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¾Ğ¹ Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ğ¾Ğ²

```kotlin
// âŒ WRONG: Duplicate handling without sort
fun subsetsWithDup(nums: IntArray): List<List<Int>> {
    // nums might be [1, 2, 1]
    // Skip logic won't work!
    for (i in start until nums.size) {
        if (i > start && nums[i] == nums[i-1]) continue
        // ...
    }
}

// âœ… CORRECT: Sort first
fun subsetsWithDup(nums: IntArray): List<List<Int>> {
    // ĞŸĞ¾ÑĞ»Ğµ ÑĞ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¸: [1, 1, 2] â€” Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ñ‹ Ñ‚ĞµĞ¿ĞµÑ€ÑŒ Ñ€ÑĞ´Ğ¾Ğ¼
    // Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ñ‚Ğ°Ğº ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ğµ nums[i] == nums[i-1] Ğ±ÑƒĞ´ĞµÑ‚ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ!
    nums.sort()
    // ...
}
```

### 5. ĞœĞ¾Ğ´Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ board Ğ±ĞµĞ· Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ

```kotlin
// âŒ WRONG: Board not restored
fun backtrack(...) {
    board[row][col] = 'Q'
    backtrack(...)
    // Missing restore!
}

// âœ… CORRECT: Always restore
fun backtrack(...) {
    board[row][col] = 'Q'
    backtrack(...)
    // ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§ĞĞ: Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ ĞºĞ»ĞµÑ‚ĞºÑƒ!
    // Ğ‘ĞµĞ· ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ´Ğ¾ÑĞºĞ° "Ğ·Ğ°Ğ³Ñ€ÑĞ·Ğ½Ğ¸Ñ‚ÑÑ" Ñ„ĞµÑ€Ğ·ÑĞ¼Ğ¸ Ğ¸Ğ· Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰Ğ¸Ñ… Ğ¿Ğ¾Ğ¿Ñ‹Ñ‚Ğ¾Ğº
    // Ğ¸ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğµ Ğ²ĞµÑ‚ĞºĞ¸ Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ Ğ½ĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ
    board[row][col] = '.'
}
```

---

## Backtracking vs Recursion vs DP

```
                    TECHNIQUE COMPARISON
                           â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                      â”‚                      â”‚
Recursion            Backtracking          Dynamic Programming
    â”‚                      â”‚                      â”‚
"Divide and          "Explore all           "Solve subproblems
 solve"              valid paths"           with memoization"
    â”‚                      â”‚                      â”‚
No undo              Choose+Undo            Cache results
    â”‚                      â”‚                      â”‚
Tree traversal       Constraint             Overlapping
Merge sort           satisfaction           subproblems
    â”‚                      â”‚                      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
             Use BACKTRACKING when:
             - Need ALL solutions
             - Constraint satisfaction
             - Search space is tree-like
             - Pruning is effective
```

---

## ĞŸÑ€Ğ°ĞºÑ‚Ğ¸ĞºĞ°

### ĞšĞ¾Ğ½Ñ†ĞµĞ¿Ñ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹

1. **Ğ’ Ñ‡Ñ‘Ğ¼ Ñ€Ğ°Ğ·Ğ½Ğ¸Ñ†Ğ° Ğ¼ĞµĞ¶Ğ´Ñƒ backtracking Ğ¸ brute force?**

   *ĞÑ‚Ğ²ĞµÑ‚:* Backtracking Ğ¾Ñ‚ÑĞµĞºĞ°ĞµÑ‚ (prune) Ğ²ĞµÑ‚Ğ²Ğ¸, Ğ½Ğ°Ñ€ÑƒÑˆĞ°ÑÑ‰Ğ¸Ğµ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ñ, Ğ½Ğµ Ğ¸ÑÑĞ»ĞµĞ´ÑƒÑ Ğ¸Ñ… Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ. Brute force Ğ¿ĞµÑ€ĞµĞ±Ğ¸Ñ€Ğ°ĞµÑ‚ Ğ’Ğ¡Ğ• Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ñ‹.

2. **ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ Ğ²Ğ°Ğ¶ĞµĞ½ Ğ¿Ğ¾Ñ€ÑĞ´Ğ¾Ğº choose/explore/unchoose?**

   *ĞÑ‚Ğ²ĞµÑ‚:* Choose Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€ÑƒĞµÑ‚ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ¿ĞµÑ€ĞµĞ´ Ñ€ĞµĞºÑƒÑ€ÑĞ¸ĞµĞ¹. Explore Ğ¸ÑÑĞ»ĞµĞ´ÑƒĞµÑ‚ ÑÑ‚Ğ¾ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ. Unchoose Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµÑ‚ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ´Ğ»Ñ ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ¹ Ğ¸Ñ‚ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ñ†Ğ¸ĞºĞ»Ğ°.

3. **ĞšĞ°Ğº Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ñ‹ Ğ² Ğ¼Ğ°ÑÑĞ¸Ğ²Ğµ?**

   *ĞÑ‚Ğ²ĞµÑ‚:* (1) ĞÑ‚ÑĞ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¼Ğ°ÑÑĞ¸Ğ². (2) ĞĞ° Ğ¾Ğ´Ğ½Ğ¾Ğ¼ ÑƒÑ€Ğ¾Ğ²Ğ½Ğµ Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ğ¸ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°Ñ‚ÑŒ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹, Ñ€Ğ°Ğ²Ğ½Ñ‹Ğµ Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰ĞµĞ¼Ñƒ: `if (i > start && nums[i] == nums[i-1]) continue`.

4. **ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ N-Queens Ğ¸Ğ¼ĞµĞµÑ‚ ÑĞ»Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ O(n!), Ğ° Ğ½Ğµ O(n^n)?**

   *ĞÑ‚Ğ²ĞµÑ‚:* Pruning! ĞĞ° ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¼ ÑƒÑ€Ğ¾Ğ²Ğ½Ğµ Ğ¸ÑĞºĞ»ÑÑ‡Ğ°ÑÑ‚ÑÑ ÑÑ‚Ğ¾Ğ»Ğ±Ñ†Ñ‹ Ğ¸ Ğ´Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»Ğ¸ Ñ ÑƒĞ¶Ğµ Ğ¿Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğ¼Ğ¸ Ñ„ĞµÑ€Ğ·ÑĞ¼Ğ¸, Ñ‡Ñ‚Ğ¾ ÑĞ¾ĞºÑ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ñ‹ Ğ¾Ñ‚ n Ğ´Ğ¾ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ½Ğ¾ n-1, n-2, ... â†’ n!.

### LeetCode Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸

#### Easy-Medium
- **78. Subsets** â€” Ğ±Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ template
- **46. Permutations** â€” Ñ used[]
- **77. Combinations** â€” Ñ start index
- **22. Generate Parentheses** â€” constraint-based
- **17. Letter Combinations of Phone Number** â€” mapping + backtrack

#### Medium
- **39. Combination Sum** â€” ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ÑÑ‚ÑŒ
- **40. Combination Sum II** â€” ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ÑÑ‚ÑŒ
- **90. Subsets II** â€” Ñ Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ğ°Ğ¼Ğ¸
- **47. Permutations II** â€” Ñ Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ğ°Ğ¼Ğ¸
- **79. Word Search** â€” grid traversal
- **131. Palindrome Partitioning** â€” string backtracking

#### Hard
- **51. N-Queens** â€” classic constraint satisfaction
- **37. Sudoku Solver** â€” complex constraints
- **52. N-Queens II** â€” counting solutions
- **212. Word Search II** â€” Trie + backtracking

---

## ĞœĞ¸Ñ„Ñ‹ Ğ¸ Ğ·Ğ°Ğ±Ğ»ÑƒĞ¶Ğ´ĞµĞ½Ğ¸Ñ

| ĞœĞ¸Ñ„ | Ğ ĞµĞ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ |
|-----|-----------|
| "Backtracking = brute force" | **ĞĞµÑ‚!** Brute force Ğ¿ĞµÑ€ĞµĞ±Ğ¸Ñ€Ğ°ĞµÑ‚ Ğ’Ğ¡Ğ• Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ñ‹. Backtracking Ñ pruning Ğ¾Ñ‚ÑĞµĞºĞ°ĞµÑ‚ Ñ†ĞµĞ»Ñ‹Ğµ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€ĞµĞ²ÑŒÑ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ½Ğµ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ¿Ñ€Ğ¸Ğ²ĞµÑÑ‚Ğ¸ Ğº Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ. N-Queens n=8: brute force ~16M Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¾Ğº, backtracking ~15K. |
| "Backtracking Ğ²ÑĞµĞ³Ğ´Ğ° ÑĞºÑĞ¿Ğ¾Ğ½ĞµĞ½Ñ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹" | **Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ pruning.** Ğ¥Ğ¾Ñ‚Ñ worst-case O(2^n) Ğ¸Ğ»Ğ¸ O(n!), ÑÑ„Ñ„ĞµĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğµ pruning Ğ¼Ğ¾Ğ¶ĞµÑ‚ ÑĞ¾ĞºÑ€Ğ°Ñ‚Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ¸ÑĞº Ğ² 1000+ Ñ€Ğ°Ğ·. Sudoku Ñ Ñ…Ğ¾Ñ€Ğ¾ÑˆĞ¸Ğ¼ pruning Ñ€ĞµÑˆĞ°ĞµÑ‚ÑÑ Ğ·Ğ° Ğ¼Ğ¸Ğ»Ğ»Ğ¸ÑĞµĞºÑƒĞ½Ğ´Ñ‹. |
| "ĞĞµĞ»ÑŒĞ·Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ backtracking Ğ´Ğ»Ñ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸" | **ĞœĞ¾Ğ¶Ğ½Ğ¾!** Branch and Bound = backtracking + Ğ¾Ñ‚ÑĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ Ğ¾Ñ†ĞµĞ½ĞºĞµ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼ÑƒĞ¼Ğ°. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ Ğ² TSP, Knapsack. ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ, Ğ° Ğ½Ğµ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ğ¾Ğµ. |
| "ĞŸĞ¾Ñ€ÑĞ´Ğ¾Ğº Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ¾Ğ² Ğ½Ğµ Ğ²Ğ°Ğ¶ĞµĞ½" | **ĞÑ‡ĞµĞ½ÑŒ Ğ²Ğ°Ğ¶ĞµĞ½!** Heuristics Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, MRV â€” Minimum Remaining Values) Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ´Ñ€Ğ°Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ ÑƒÑĞºĞ¾Ñ€Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ¸ÑĞº. Ğ’ Sudoku Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°Ñ‚ÑŒ Ñ ĞºĞ»ĞµÑ‚Ğ¾Ğº Ñ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼Ğ¾Ğ¼ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ğ¾Ğ² â€” Ğ² Ñ€Ğ°Ğ·Ñ‹ Ğ±Ñ‹ÑÑ‚Ñ€ĞµĞµ. |
| "Backtracking Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ‚Ğ¾Ñ€Ğ¸ĞºĞ¸" | **ĞĞµÑ‚!** Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ Ğ² Ğ¿Ğ°Ñ€ÑĞµÑ€Ğ°Ñ… (Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ñ‹Ğ¹ ÑĞ¿ÑƒÑĞº), type inference ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ‚Ğ¾Ñ€Ğ¾Ğ², Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸ Ğ˜Ğ˜, Ğ±Ğ¸Ğ¾Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸ĞºĞµ (sequence alignment), SAT solvers. |
| "Unchoose Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ ĞµÑĞ»Ğ¸ Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‘Ğ¼ ĞºĞ¾Ğ¿Ğ¸Ñ" | **Trade-off.** ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ state Ğ½Ğ° ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¼ ÑˆĞ°Ğ³Ğµ = O(n) Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğ¹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ğ¸ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸. ĞœÑƒÑ‚Ğ°Ñ†Ğ¸Ñ + unchoose = O(1). Ğ”Ğ»Ñ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¸Ñ… state Ğ¼ÑƒÑ‚Ğ°Ñ†Ğ¸Ñ ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡Ğ½Ğ°. |
| "Backtracking Ğ¸ DP Ñ€ĞµÑˆĞ°ÑÑ‚ Ğ¾Ğ´Ğ½Ğ¸ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸" | **Ğ Ğ°Ğ·Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´Ñ‹.** Backtracking â€” Ğ²ÑĞµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ, DFS Ğ¿Ğ¾ Ğ´ĞµÑ€ĞµĞ²Ñƒ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğ¹. DP â€” Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ, ĞºÑÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ´Ğ·Ğ°Ğ´Ğ°Ñ‡. Subsets Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¾Ğ±Ğ¾Ğ¸Ğ¼Ğ¸ ÑĞ¿Ğ¾ÑĞ¾Ğ±Ğ°Ğ¼Ğ¸, Ğ½Ğ¾ Sudoku â€” Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ backtracking. |
| "Ğ ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ Ğ²ÑĞµĞ³Ğ´Ğ° Ğ»ÑƒÑ‡ÑˆĞµ Ğ¸Ñ‚ĞµÑ€Ğ°Ñ‚Ğ¸Ğ²Ğ½Ğ¾Ğ¹" | **ĞĞµ Ğ²ÑĞµĞ³Ğ´Ğ°.** Ğ˜Ñ‚ĞµÑ€Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹ backtracking Ñ explicit stack Ğ¸Ğ·Ğ±ĞµĞ³Ğ°ĞµÑ‚ stack overflow Ğ´Ğ»Ñ Ğ³Ğ»ÑƒĞ±Ğ¾ĞºĞ¸Ñ… Ğ´ĞµÑ€ĞµĞ²ÑŒĞµĞ². Ğ”Ğ»Ñ n > 10000 Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ñ Ğ¼Ğ¾Ğ¶ĞµÑ‚ ÑƒĞ¿Ğ°ÑÑ‚ÑŒ. |

---

## CS-Ñ„ÑƒĞ½Ğ´Ğ°Ğ¼ĞµĞ½Ñ‚

| CS-ĞºĞ¾Ğ½Ñ†ĞµĞ¿Ñ†Ğ¸Ñ | ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ğ² Backtracking |
|--------------|---------------------------|
| **State Space Tree** | Backtracking ÑÑ‚Ñ€Ğ¾Ğ¸Ñ‚ Ğ½ĞµÑĞ²Ğ½Ğ¾Ğµ Ğ´ĞµÑ€ĞµĞ²Ğ¾, Ğ³Ğ´Ğµ ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ ÑƒĞ·ĞµĞ» = Ñ‡Ğ°ÑÑ‚Ğ¸Ñ‡Ğ½Ğ¾Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ, ĞºĞ°Ğ¶Ğ´Ğ¾Ğµ Ñ€ĞµĞ±Ñ€Ğ¾ = Ğ²Ñ‹Ğ±Ğ¾Ñ€. Ğ›Ğ¸ÑÑ‚ÑŒÑ = Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ Ğ¸Ğ»Ğ¸ Ñ‚ÑƒĞ¿Ğ¸ĞºĞ¸. Ğ Ğ°Ğ·Ğ¼ĞµÑ€ Ğ´ĞµÑ€ĞµĞ²Ğ° Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚ ÑĞ»Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ. |
| **Depth-First Search (DFS)** | Backtracking = DFS Ğ¿Ğ¾ state space tree. Ğ˜Ğ´Ñ‘Ğ¼ Ğ²Ğ³Ğ»ÑƒĞ±ÑŒ Ğ´Ğ¾ Ğ»Ğ¸ÑÑ‚Ğ° Ğ¸Ğ»Ğ¸ Ğ½Ğ°Ñ€ÑƒÑˆĞµĞ½Ğ¸Ñ constraint, Ğ·Ğ°Ñ‚ĞµĞ¼ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ÑÑ. Pre-order: choose, in-order: explore, post-order: unchoose. |
| **Pruning (ĞÑ‚ÑĞµÑ‡ĞµĞ½Ğ¸Ğµ)** | ĞšĞ»ÑÑ‡ĞµĞ²Ğ°Ñ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ: Ğ½Ğµ Ğ¸ÑÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€ĞµĞ²ÑŒÑ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ½Ğµ Ğ¼Ğ¾Ğ³ÑƒÑ‚ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ. Ğ¤Ğ¾Ñ€Ğ¼Ñ‹: constraint propagation, bound checking, symmetry breaking. ĞŸÑ€ĞµĞ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ O(n^n) Ğ² O(n!). |
| **Constraint Satisfaction Problem (CSP)** | Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ: Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ, Ğ´Ğ¾Ğ¼ĞµĞ½Ñ‹ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹, Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ñ. Backtracking â€” Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ CSP. Sudoku, N-Queens, scheduling â€” ĞºĞ»Ğ°ÑÑĞ¸Ñ‡ĞµÑĞºĞ¸Ğµ CSP. |
| **Branch and Bound** | Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ğµ backtracking Ğ´Ğ»Ñ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸: Ğ¾Ñ‚ÑĞµĞºĞ°ĞµĞ¼ Ğ²ĞµÑ‚Ğ²Ğ¸, Ğ³Ğ´Ğµ Ğ¾Ñ†ĞµĞ½ĞºĞ° (bound) Ñ…ÑƒĞ¶Ğµ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ»ÑƒÑ‡ÑˆĞµĞ³Ğ¾ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ. ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ÑĞµÑ‚ÑÑ Ğ² TSP, integer programming. |
| **Implicit vs Explicit Trees** | Backtracking Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ñ implicit tree â€” Ğ´ĞµÑ€ĞµĞ²Ğ¾ Ğ½Ğµ ÑÑ‚Ñ€Ğ¾Ğ¸Ñ‚ÑÑ Ğ·Ğ°Ñ€Ğ°Ğ½ĞµĞµ, Ğ° Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ²Ğ¾ Ğ²Ñ€ĞµĞ¼Ñ Ğ¾Ğ±Ñ…Ğ¾Ğ´Ğ°. Ğ­ĞºĞ¾Ğ½Ğ¾Ğ¼Ğ¸Ñ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸: O(depth) Ğ²Ğ¼ĞµÑÑ‚Ğ¾ O(Ğ²ÑĞµÑ… ÑƒĞ·Ğ»Ğ¾Ğ²). |

---

## Ğ¡Ğ²ÑĞ·Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ‚ĞµĞ¼Ñ‹

### Prerequisites (Ñ‡Ñ‚Ğ¾ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ·Ğ½Ğ°Ñ‚ÑŒ Ğ´Ğ¾)
- [Recursion](./recursion.md) â€” Ğ¾ÑĞ½Ğ¾Ğ²Ğ° backtracking
- [DFS](../patterns/dfs-bfs-patterns.md) â€” ÑÑ…Ğ¾Ğ¶Ğ¸Ğ¹ Ğ¾Ğ±Ñ…Ğ¾Ğ´ Ğ´ĞµÑ€ĞµĞ²Ğ°
- [Arrays](../data-structures/arrays.md) â€” Ğ¼Ğ°Ğ½Ğ¸Ğ¿ÑƒĞ»ÑÑ†Ğ¸Ğ¸ Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸

### Ğ§Ñ‚Ğ¾ Ğ¾Ñ‚ĞºÑ€Ñ‹Ğ²Ğ°ĞµÑ‚ (Ğ¸Ğ·ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾ÑĞ»Ğµ)
- [Dynamic Programming](./dynamic-programming.md) â€” ĞºĞ¾Ğ³Ğ´Ğ° Ğ¿Ğ¾Ğ´Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸ Ğ¿ĞµÑ€ĞµĞºÑ€Ñ‹Ğ²Ğ°ÑÑ‚ÑÑ
- [Graph Algorithms](./graph-advanced.md) â€” Ğ¿Ğ¾Ğ¸ÑĞº Ğ¿ÑƒÑ‚ĞµĞ¹
- [Bit Manipulation](../patterns/bit-manipulation.md) â€” Ğ°Ğ»ÑŒÑ‚ĞµÑ€Ğ½Ğ°Ñ‚Ğ¸Ğ²Ğ° Ğ´Ğ»Ñ subsets

---

## Ğ˜ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸ĞºĞ¸

1. [Labuladong - Backtracking Template](https://labuladong.online/algo/en/essential-technique/permutation-combination-subset-all-in-one/) â€” Comprehensive guide
2. [AlgoMonster - Backtracking](https://algo.monster/problems/backtracking) â€” Problems and patterns
3. [Hello Algo - Backtracking](https://www.hello-algo.com/en/chapter_backtracking/backtracking_algorithm/) â€” Visualization
4. [Wikipedia - Backtracking](https://en.wikipedia.org/wiki/Backtracking) â€” Theory
5. [LeetCode Discuss - Backtracking Guide](https://leetcode.com/discuss/post/3799395/Exploring-Backtracking:-Your-Path-to-Tackling-Complex-Algorithmic-Challenges/) â€” Problem list
6. [Shadecoder - Backtracking 2025](https://www.shadecoder.com/topics/what-is-backtracking-a-practical-guide-for-2025) â€” Modern relevance
7. [Hello Interview - Backtracking Overview](https://www.hellointerview.com/learn/code/backtracking/overview) â€” Interview prep
8. [GeeksforGeeks - Top 20 Backtracking Questions](https://www.geeksforgeeks.org/dsa/top-20-backtracking-algorithm-interview-questions/) â€” Interview questions
9. [DEV.to - Amazon Interview Backtracking](https://dev.to/devcorner/day-19-the-backtracking-pattern-amazon-interview-series-4c97) â€” Big Tech patterns
10. [AlgoMap - Recursive Backtracking](https://algomap.io/lessons/recursive-backtracking) â€” Step-by-step tutorial

---

## ĞĞ°Ğ²Ğ¸Ğ³Ğ°Ñ†Ğ¸Ñ

â† ĞŸÑ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰Ğ°Ñ: [[dynamic-programming|Dynamic Programming]]
â†’ Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ°Ñ: [[greedy-algorithms|Greedy Algorithms]]
â†‘ Ğ’Ğ²ĞµÑ€Ñ…: [[_moc-algorithms|Algorithms MOC]]


---

## ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒ ÑĞµĞ±Ñ

> [!question]- ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ backtracking ÑÑ„Ñ„ĞµĞºÑ‚Ğ¸Ğ²Ğ½ĞµĞµ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ³Ğ¾ Ğ¿ĞµÑ€ĞµĞ±Ğ¾Ñ€Ğ°?
> Backtracking Ğ¾Ñ‚ÑĞµĞºĞ°ĞµÑ‚ (pruning) Ğ²ĞµÑ‚Ğ²Ğ¸ Ğ´ĞµÑ€ĞµĞ²Ğ° Ğ¿Ğ¾Ğ¸ÑĞºĞ°, ĞºĞ°Ğº Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ğ±Ğ½Ğ°Ñ€ÑƒĞ¶Ğ¸Ğ²Ğ°ĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ğ¿ÑƒÑ‚ÑŒ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¿Ñ€Ğ¸Ğ²ĞµÑÑ‚Ğ¸ Ğº Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ. ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ¿ĞµÑ€ĞµĞ±Ğ¾Ñ€ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚ Ğ²ÑĞµ 2^n Ğ¸Ğ»Ğ¸ n! ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¹. Pruning Ğ¼Ğ¾Ğ¶ĞµÑ‚ ÑĞ¾ĞºÑ€Ğ°Ñ‚Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ¸ÑĞº Ğ½Ğ° Ğ¿Ğ¾Ñ€ÑĞ´ĞºĞ¸, Ñ…Ğ¾Ñ‚Ñ worst case Ğ¾ÑÑ‚Ğ°Ñ‘Ñ‚ÑÑ ÑĞºÑĞ¿Ğ¾Ğ½ĞµĞ½Ñ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¼.

> [!question]- ĞšĞ°Ğº Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²ÑĞµ Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ° Ñ‡ĞµÑ€ĞµĞ· backtracking?
> ĞĞ° ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¼ ÑˆĞ°Ğ³Ğµ Ğ´Ğ»Ñ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ° i Ğ´Ğ²Ğ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ°: Ğ²ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ¸Ğ»Ğ¸ Ğ½Ğµ Ğ²ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ. Ğ”ĞµÑ€ĞµĞ²Ğ¾ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹ Ğ±Ğ¸Ğ½Ğ°Ñ€Ğ½Ğ¾Ğµ Ğ³Ğ»ÑƒĞ±Ğ¸Ğ½Ñ‹ n. Backtracking: Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚, Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ğ¾ ÑÑ‚Ñ€Ğ¾Ğ¸Ğ¼ Ğ´Ğ°Ğ»ÑŒÑˆĞµ, ÑƒĞ±Ğ¸Ñ€Ğ°ĞµĞ¼ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ (backtrack). Ğ’ÑĞµĞ³Ğ¾ 2^n Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ², ĞºĞ°Ğ¶Ğ´Ğ¾Ğµ Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ·Ğ° O(n).

> [!question]- ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ Ğ²Ğ°Ğ¶Ğ½Ğ¾ Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°Ñ‚ÑŒ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»Ğµ Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ°?
> Backtracking Ğ¾Ğ·Ğ½Ğ°Ñ‡Ğ°ĞµÑ‚ 'Ğ¾Ñ‚ĞºĞ°Ñ‚': Ğ¿Ğ¾ÑĞ»Ğµ Ğ¸ÑÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğº Ñ‚Ğ¾Ñ‡ĞºĞµ Ğ´Ğ¾ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ°, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ°Ğ»ÑŒÑ‚ĞµÑ€Ğ½Ğ°Ñ‚Ğ¸Ğ²Ñƒ. Ğ‘ĞµĞ· Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ½Ğ°ĞºĞ°Ğ¿Ğ»Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ Ğ¸ Ğ´Ğ°Ñ‘Ñ‚ Ğ½ĞµĞ²ĞµÑ€Ğ½Ñ‹Ğµ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹. Ğ­Ñ‚Ğ¾ Ñ„ÑƒĞ½Ğ´Ğ°Ğ¼ĞµĞ½Ñ‚Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ñ€Ğ°Ğ·Ğ½Ğ¸Ñ†Ğ° Ğ¼ĞµĞ¶Ğ´Ñƒ backtracking Ğ¸ Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾Ğ¹ Ñ€ĞµĞºÑƒÑ€ÑĞ¸ĞµĞ¹.

---

## ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ ĞºĞ°Ñ€Ñ‚Ğ¾Ñ‡ĞºĞ¸

Ğ§Ñ‚Ğ¾ Ñ‚Ğ°ĞºĞ¾Ğµ Backtracking?
?
Ğ ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ¿ĞµÑ€ĞµĞ±Ğ¾Ñ€ Ñ Ğ¾Ñ‚ÑĞµÑ‡ĞµĞ½Ğ¸ĞµĞ¼: ÑÑ‚Ñ€Ğ¾Ğ¸Ğ¼ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑˆĞ°Ğ³Ğ¾Ğ²Ğ¾, Ğ½Ğ° ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¼ ÑˆĞ°Ğ³Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ñ, Ğ¿Ñ€Ğ¸ Ğ½Ğ°Ñ€ÑƒÑˆĞµĞ½Ğ¸Ğ¸ -- Ğ¾Ñ‚ĞºĞ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ÑÑ (backtrack) Ğ¸ Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¹ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚. Ğ¨Ğ°Ğ±Ğ»Ğ¾Ğ½: choose -> explore -> unchoose.

ĞšĞ°ĞºĞ¸Ğµ Ñ‚Ñ€Ğ¸ ĞºĞ»Ğ°ÑÑĞ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸ Ñ€ĞµÑˆĞ°ÑÑ‚ÑÑ Backtracking?
?
Subsets (Ğ²ÑĞµ Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ°, 2^n), Permutations (Ğ²ÑĞµ Ğ¿ĞµÑ€ĞµÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸, n!), Combinations (C(n,k)). Ğ’ÑĞµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑÑ‚ Ğ¾Ğ´Ğ¸Ğ½ ÑˆĞ°Ğ±Ğ»Ğ¾Ğ½: Ğ²Ñ‹Ğ±Ğ¾Ñ€ -> Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ñ -> Ğ¾Ñ‚ĞºĞ°Ñ‚. Ğ Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ°ÑÑ‚ÑÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑƒÑĞ»Ğ¾Ğ²Ğ¸ÑĞ¼Ğ¸ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ°.

Ğ§Ñ‚Ğ¾ Ñ‚Ğ°ĞºĞ¾Ğµ pruning Ğ² backtracking?
?
ĞÑ‚ÑĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ²ĞµÑ‚Ğ²ĞµĞ¹ Ğ´ĞµÑ€ĞµĞ²Ğ° Ğ¿Ğ¾Ğ¸ÑĞºĞ°, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ·Ğ°Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¾ Ğ½Ğµ Ğ´Ğ°Ğ´ÑƒÑ‚ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ. ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: Ğ² N-Queens, ĞµÑĞ»Ğ¸ Ğ´Ğ²Ğµ Ñ„ĞµÑ€Ğ·Ñ Ğ°Ñ‚Ğ°ĞºÑƒÑÑ‚ Ğ´Ñ€ÑƒĞ³ Ğ´Ñ€ÑƒĞ³Ğ°, Ğ¿Ñ€ĞµĞºÑ€Ğ°Ñ‰Ğ°ĞµĞ¼ Ğ¸ÑÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ÑÑ‚Ğ¾Ğ¹ Ğ²ĞµÑ‚Ğ²Ğ¸. Pruning Ğ½Ğµ Ğ¼ĞµĞ½ÑĞµÑ‚ worst case, Ğ½Ğ¾ Ğ´Ñ€Ğ°Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ ÑƒÑĞºĞ¾Ñ€ÑĞµÑ‚ average case.

ĞšĞ°ĞºĞ¾Ğ¹ ÑˆĞ°Ğ±Ğ»Ğ¾Ğ½ backtracking?
?
function backtrack(path, choices): if isComplete(path) -> addResult. for choice in choices: if isValid(choice) -> path.add(choice), backtrack(path, remaining), path.remove(choice). Ğ¢Ñ€Ğ¸ ĞºĞ»ÑÑ‡ĞµĞ²Ñ‹Ñ… Ğ¼Ğ¾Ğ¼ĞµĞ½Ñ‚Ğ°: check, choose, unchoose.

Ğ§ĞµĞ¼ backtracking Ğ¾Ñ‚Ğ»Ğ¸Ñ‡Ğ°ĞµÑ‚ÑÑ Ğ¾Ñ‚ DFS?
?
DFS -- Ğ¾Ğ±Ñ…Ğ¾Ğ´ Ğ³Ñ€Ğ°Ñ„Ğ°/Ğ´ĞµÑ€ĞµĞ²Ğ°, Ğ¿Ğ¾ÑĞµÑ‰Ğ°ĞµÑ‚ Ğ²ÑĞµ ÑƒĞ·Ğ»Ñ‹. Backtracking -- Ğ¿Ğ¾Ğ¸ÑĞº Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ Ğ² Ğ´ĞµÑ€ĞµĞ²Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹ Ñ Ğ¾Ñ‚ÑĞµÑ‡ĞµĞ½Ğ¸ĞµĞ¼. DFS -- Ğ±Ğ°Ğ·Ğ¾Ğ²Ğ°Ñ Ñ‚ĞµÑ…Ğ½Ğ¸ĞºĞ°, backtracking Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ DFS + pruning + state management Ğ´Ğ»Ñ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ‚Ğ¾Ñ€Ğ½Ñ‹Ñ… Ğ·Ğ°Ğ´Ğ°Ñ‡.

---

## ĞšÑƒĞ´Ğ° Ğ´Ğ°Ğ»ÑŒÑˆĞµ

| ĞĞ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ | ĞšÑƒĞ´Ğ° | Ğ—Ğ°Ñ‡ĞµĞ¼ |
|-------------|------|-------|
| Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ ÑˆĞ°Ğ³ | [[algorithms/divide-and-conquer]] | Ğ”Ñ€ÑƒĞ³Ğ¾Ğ¹ Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ |
| Ğ£Ğ³Ğ»ÑƒĞ±Ğ¸Ñ‚ÑŒÑÑ | [[algorithms/graph-advanced]] | ĞŸÑ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğµ Ğ³Ñ€Ğ°Ñ„Ğ¾Ğ²Ñ‹Ğµ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ñ‹ |
| Ğ¡Ğ¼ĞµĞ¶Ğ½Ğ°Ñ Ñ‚ĞµĞ¼Ğ° | [[algorithms/dynamic-programming]] | DP ĞºĞ¾Ğ³Ğ´Ğ° Ğ¿Ğ¾Ğ´Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸ Ğ¿ĞµÑ€ĞµĞºÑ€Ñ‹Ğ²Ğ°ÑÑ‚ÑÑ |
| ĞĞ±Ğ·Ğ¾Ñ€ | [[cs-fundamentals-overview]] | Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒÑÑ Ğº ĞºĞ°Ñ€Ñ‚Ğµ Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğ° |

*ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾: 2026-01-06*
