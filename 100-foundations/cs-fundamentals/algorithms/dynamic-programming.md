---
title: "Динамическое программирование"
created: 2025-12-29
modified: 2026-02-13
type: deep-dive
status: published
difficulty: intermediate
confidence: high
cs-foundations:
  - overlapping-subproblems
  - optimal-substructure
  - memoization-caching
  - tabulation-iteration
  - state-space-design
  - recurrence-relations
prerequisites:
  - "[[recursion-fundamentals]]"
  - "[[big-o-complexity]]"
teaches:
  - overlapping-subproblems
  - optimal-substructure
  - memoization
  - tabulation
  - state-design
  - dp-patterns
unlocks:
  - "[[dp-optimization]]"
  - "[[graph-advanced]]"
  - "[[dp-patterns]]"
tags:
  - topic/cs-fundamentals
  - type/deep-dive
  - level/intermediate
  - interview
related:
  - "[[dp-optimization]]"
  - "[[dp-patterns]]"
  - "[[recursion-fundamentals]]"

reading_time: 86
difficulty: 6
study_status: not_started
mastery: 0
last_reviewed:
next_review:
---

# Dynamic Programming

> **TL;DR:** Dynamic Programming — способ ускорить решение задач в миллионы раз, сохраняя ответы на подзадачи вместо их повторного вычисления. Два подхода: memoization (рекурсия + кэш) и tabulation (итеративное заполнение таблицы). Ключевой инсайт: если видишь повторяющиеся вычисления — это кандидат для DP.

---

## Часть 1: Интуиция без кода

### Аналогия 1: Домино

Представь, что ты выстраиваешь домино в ряд:

```
┌───┐ ┌───┐ ┌───┐ ┌───┐ ┌───┐
│ 1 │ │ 2 │ │ 3 │ │ 4 │ │ 5 │
└───┘ └───┘ └───┘ └───┘ └───┘
  ↓     ↓     ↓     ↓     ↓
Толкни первую — упадут все!
```

**Как это связано с DP?**

Чтобы узнать, упадёт ли 100-я костяшка:
1. Нужно знать, упадёт ли 99-я
2. Для 99-й — упадёт ли 98-я
3. ...и так до первой!

**DP работает так же:**
- Большая задача (упадёт ли 100-я?) зависит от меньшей (упадёт ли 99-я?)
- Зная ответ на меньшую задачу, мгновенно получаем ответ на большую
- Не нужно каждый раз проверять всю цепочку с начала!

### Аналогия 2: Записная книжка школьника

Представь школьника, которого спрашивают:

```
Учитель: "Сколько будет 2 + 3?"
Ученик:  (считает на пальцах) "5!"

Учитель: "А сколько будет (2 + 3) + 7?"

НАИВНЫЙ УЧЕНИК:
  - "Сколько 2 + 3?" (считает снова)
  - "5! Теперь 5 + 7..." (считает)
  - "12!"

УМНЫЙ УЧЕНИК:
  - Записывает в тетрадь: "2 + 3 = 5"
  - "5 + 7 = 12!" (не пересчитывал 2 + 3!)
```

**DP — это "умный ученик":**
- Решил подзадачу → записал ответ
- Нужен тот же ответ? Посмотрел в записи!
- Не делает одну работу дважды

### Аналогия 3: GPS-навигатор

Ты едешь из Москвы в Владивосток:

```
Москва ─────→ Новосибирск ─────→ Владивосток
        (путь A)           (путь B)
```

**Вопрос:** Какой кратчайший путь Москва → Владивосток?

**Ответ DP:** Если я знаю:
- Кратчайший путь Москва → Новосибирск (3,400 км)
- Кратчайший путь Новосибирск → Владивосток (4,100 км)

То кратчайший путь через Новосибирск = 3,400 + 4,100 = 7,500 км

**Ключевая идея:** Часть оптимального пути — тоже оптимальный путь!
Это называется **optimal substructure**.

### Когда DP применим? (простой тест)

```
┌─────────────────────────────────────────────────────────────────┐
│                    ТЕСТ: НУЖЕН ЛИ DP?                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Вопрос 1: Можно разбить на подзадачи?                         │
│  ─────────────────────────────────────                         │
│  Пример: fib(5) = fib(4) + fib(3)                              │
│                                                                 │
│  Вопрос 2: Подзадачи ПОВТОРЯЮТСЯ?                              │
│  ─────────────────────────────────                             │
│  Пример: fib(3) нужен и для fib(5), и для fib(4)               │
│  → ДА → DP ПОМОЖЕТ!                                            │
│                                                                 │
│  Вопрос 3: Оптимум строится из оптимумов?                      │
│  ─────────────────────────────────────────                     │
│  Пример: Кратчайший путь A→C через B =                         │
│          кратчайший A→B + кратчайший B→C                       │
│  → ДА → DP ДАСТ ПРАВИЛЬНЫЙ ОТВЕТ!                              │
│                                                                 │
│  ✅ Все три "да"? → ИСПОЛЬЗУЙ DP!                               │
│  ❌ Нет повторений? → Обычная рекурсия достаточна               │
│  ❌ Оптимум НЕ из оптимумов? → Попробуй другой подход           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Часть 2: Почему DP бывает сложен?

### Главная причина: DP — это способ МЫШЛЕНИЯ, не алгоритм

```
┌─────────────────────────────────────────────────────────────────┐
│                  КЛЮЧЕВОЕ ОСОЗНАНИЕ                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Сортировка — это АЛГОРИТМ:                                    │
│  "Возьми массив, переставь элементы по возрастанию"            │
│  → Чёткие шаги, всегда одинаковые                              │
│                                                                 │
│  DP — это СПОСОБ МЫШЛЕНИЯ:                                     │
│  "Раздели задачу на подзадачи, запомни ответы"                 │
│  → Как именно делить? Какие подзадачи? Не сказано!             │
│                                                                 │
│  ПОЭТОМУ:                                                       │
│  - Изучить "алгоритм DP" = невозможно (его нет!)               │
│  - Нужно ПРАКТИКОВАТЬСЯ в разных задачах                       │
│  - Каждая задача требует своего "дизайна состояний"            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Исследование ACM: Где студенты ошибаются

По данным исследования ACM SIGCSE (2018), **75% студентов** испытывают трудности с DP.

**Топ-5 ошибок:**

| # | Ошибка | Почему возникает | Как избежать |
|---|--------|------------------|--------------|
| 1 | **Неправильное определение состояния** | Не понимают, какие параметры нужны | Спроси: "Что однозначно определяет подзадачу?" |
| 2 | **Путают DP с жадным алгоритмом** | Оба дают "оптимум", но по-разному | DP: смотрит на ВСЕ варианты. Greedy: берёт первый "хороший" |
| 3 | **Неправильный порядок итерации** | Не понимают зависимости между состояниями | Нарисуй DAG зависимостей: A→B значит A считается ДО B |
| 4 | **Забывают базовые случаи** | Думают о рекурсии, не о границах | Всегда начинай с вопроса: "Что я знаю при n=0? n=1?" |
| 5 | **Пишут сразу оптимизированный код** | Пытаются "сэкономить время" | FAST метод: сначала brute force → memo → tabulation |

### Почему "увидеть DP" так сложно?

**Проблема 1: Нет визуальной подсказки**

```
Сортировка:
[5, 2, 8, 1] → Очевидно нужна сортировка!

DP:
"Найти минимальное количество монет для суммы 11"
→ Ничего не подсказывает о DP!
→ Нужно МЫСЛЕННО представить дерево подзадач
```

**Проблема 2: Состояние не всегда очевидно**

```
Пример: House Robber
"Грабитель не может грабить соседние дома"

❌ НЕПРАВИЛЬНОЕ состояние:
dp[i] = максимум если ограбить дом i
Проблема: не учитывает, что было до этого!

✅ ПРАВИЛЬНОЕ состояние:
dp[i] = максимум если рассмотреть дома 0..i
(независимо от того, грабим ли дом i)
```

**Проблема 3: Переход (transition) требует инсайта**

```
Coin Change: монеты [1, 2, 5], сумма 11

❌ Начинающий думает:
"Как выбрать монеты?"
"Может, взять самую большую?"
→ Застревает в "жадном" мышлении

✅ DP-мышление:
"Если я знаю min монет для 10, 9, 6...
 то для 11 = min(dp[10], dp[9], dp[6]) + 1"
→ Сводим к уже решённым подзадачам!
```

### Типичные ловушки в коде

**Ловушка 1: Off-by-one в размере массива**

```kotlin
// ❌ ОШИБКА
val dp = IntArray(n)  // Индексы 0..n-1
dp[n] = result  // IndexOutOfBoundsException!

// ✅ ПРАВИЛЬНО
val dp = IntArray(n + 1)  // Индексы 0..n
dp[n] = result  // OK!
```

**Ловушка 2: Неправильное значение "невозможно"**

```kotlin
// ❌ ОШИБКА: используем 0 как "невозможно"
val dp = IntArray(n + 1) { 0 }
// Проблема: 0 может быть валидным ответом!

// ✅ ПРАВИЛЬНО: используем значение, которое точно невозможно
val dp = IntArray(n + 1) { Int.MAX_VALUE }
// или
val dp = IntArray(n + 1) { amount + 1 }  // для Coin Change
```

**Ловушка 3: Неправильный порядок циклов в 2D DP**

```kotlin
// 0/1 Knapsack: каждый предмет можно взять ОДИН раз

// ❌ ОШИБКА: итерация по весу ВО ВНЕШНЕМ цикле
for (w in 1..capacity) {
    for (item in items) {
        // Один предмет может быть взят несколько раз!
    }
}

// ✅ ПРАВИЛЬНО: предметы во внешнем цикле
for (item in items) {
    for (w in capacity downTo item.weight) {
        // Каждый предмет рассматривается один раз
    }
}
```

### Почему важно следовать FAST методу?

```
┌─────────────────────────────────────────────────────────────────┐
│                    FAST МЕТОД: ПОЧЕМУ ОН РАБОТАЕТ               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  F — Find first solution (brute force)                         │
│      ↓                                                          │
│      Помогает ПОНЯТЬ задачу, не думая об оптимизации           │
│      Если не можешь написать brute force — ты не понял задачу! │
│                                                                 │
│  A — Analyze solution                                           │
│      ↓                                                          │
│      Нарисуй дерево вызовов                                     │
│      ВИДИШЬ повторы? → Это кандидат для мемоизации!            │
│      НЕ ВИДИШЬ? → DP не нужен, brute force достаточен          │
│                                                                 │
│  S — Subproblem caching                                         │
│      ↓                                                          │
│      Добавь HashMap/Array для кэша                              │
│      Теперь это Top-Down DP!                                    │
│      ПРОВЕРЬ: решение работает? Сложность улучшилась?          │
│                                                                 │
│  T — Turn around                                                │
│      ↓                                                          │
│      Преврати рекурсию в цикл                                   │
│      Убери риск stack overflow                                  │
│      Оптимизируй память (rolling array)                         │
│                                                                 │
│  ПОЧЕМУ В ТАКОМ ПОРЯДКЕ?                                        │
│  - Каждый шаг строится на предыдущем                           │
│  - Ошибка на раннем этапе = легко найти                        │
│  - Пропуск шага = сложные баги в финальном коде                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Часть 3: Ментальные модели для DP

### Модель 1: "Дерево с повторами" (Tree with Overlaps)

**Суть:** Визуализируй вызовы рекурсии как дерево. Если видишь одинаковые узлы — это overlapping subproblems.

```
                      fib(5)
                     /      \
                fib(4)      fib(3)   ←── Повтор!
               /    \       /    \
          fib(3)  fib(2) fib(2) fib(1)  ←── Ещё повторы!
          /   \
     fib(2) fib(1)

ПРАВИЛО:
- Уникальные узлы = сколько подзадач решать
- Повторяющиеся узлы = сколько работы экономит DP
```

**Когда использовать:**
- На этапе анализа (шаг A в FAST)
- Чтобы понять, нужен ли DP вообще
- Чтобы оценить сложность

**ASCII-шаблон для рисования:**

```
Шаблон для любой задачи:

            solve(n)
           /        \
      solve(n-1)  solve(n-2)
         / \          / \
       ...  ...    ...  ...

Обведи повторяющиеся узлы — это экономия DP!
```

### Модель 2: "Таблица зависимостей" (Dependency Table)

**Суть:** Представь DP как заполнение таблицы, где каждая ячейка зависит от других.

```
Fibonacci: dp[i] зависит от dp[i-1] и dp[i-2]

┌─────────────────────────────────────────────────┐
│  i:     0     1     2     3     4     5         │
│         ↓     ↓                                  │
│ dp[i]:  0  →  1  →  1  →  2  →  3  →  5         │
│                     ↑     ↑     ↑     ↑         │
│              зависит от двух предыдущих         │
└─────────────────────────────────────────────────┘

Coin Change: dp[amount] зависит от dp[amount - coin]

┌─────────────────────────────────────────────────┐
│ amount:  0   1   2   3   4   5   6   7          │
│ dp:      0   1   1   2   2   1   2   2          │
│              ↑   ↑       ↑                       │
│              │   │       │                       │
│              └───┴───────┴── зависит от -1,-2,-5│
└─────────────────────────────────────────────────┘
```

**Когда использовать:**
- Для Bottom-Up реализации
- Чтобы определить порядок заполнения
- Чтобы найти возможность оптимизации памяти

**Ключевой вопрос:** "От каких ячеек зависит текущая?"
- Зависит от предыдущей строки → можно хранить только 2 строки
- Зависит только от левых ячеек → можно заполнять слева направо

### Модель 3: "Выбор на каждом шаге" (Decision at Each Step)

**Суть:** Представь каждое состояние как точку принятия решения.

```
House Robber: На каждом доме решаем — грабить или нет?

Дом:       [2]    [7]    [9]    [3]    [1]
            │      │      │      │      │
            ▼      ▼      ▼      ▼      ▼
Выбор:   грабить грабить грабить грабить грабить
         или нет или нет или нет или нет или нет

dp[i] = max(
    dp[i-1],           // НЕ грабим дом i
    dp[i-2] + nums[i]  // ГРАБИМ дом i (тогда i-1 пропускаем!)
)
```

```
0/1 Knapsack: Для каждого предмета решаем — брать или нет?

Предмет:   [A]     [B]     [C]     [D]
            │       │       │       │
            ▼       ▼       ▼       ▼
Выбор:    взять   взять   взять   взять
          или нет или нет или нет или нет

dp[i][w] = max(
    dp[i-1][w],              // НЕ берём предмет i
    dp[i-1][w-wi] + vi       // БЕРЁМ предмет i
)
```

**Когда использовать:**
- Для задач "взять/не взять"
- 0/1 Knapsack и его вариации
- House Robber, Coin Change (variations)

**Паттерн перехода:**

```
dp[текущее состояние] = лучший_результат_из(
    вариант_1: не делаем действие → переход из dp[...]
    вариант_2: делаем действие → переход из dp[...] + выгода
)
```

### Модель 4: "Сборка из кубиков" (Building Blocks)

**Суть:** Большая задача собирается из маленьких готовых "кубиков".

```
LCS (Longest Common Subsequence):

Строки: "ABCD" и "AEBD"

        ""   A   E   B   D
    ┌────┬────┬────┬────┬────┐
 "" │ 0  │ 0  │ 0  │ 0  │ 0  │  ← База: пустая строка
    ├────┼────┼────┼────┼────┤
 A  │ 0  │ 1  │ 1  │ 1  │ 1  │  ← Строим ряд за рядом
    ├────┼────┼────┼────┼────┤
 B  │ 0  │ 1  │ 1  │ 2  │ 2  │  ← Каждая ячейка =
    ├────┼────┼────┼────┼────┤     "кубик" из соседей
 C  │ 0  │ 1  │ 1  │ 2  │ 2  │
    ├────┼────┼────┼────┼────┤
 D  │ 0  │ 1  │ 1  │ 2  │ 3  │  ← ОТВЕТ!
    └────┴────┴────┴────┴────┘

Правило сборки:
- Символы совпали? → диагональ + 1 (добавляем в LCS)
- Не совпали? → max(сверху, слева) (берём лучшее без текущих)
```

**Когда использовать:**
- Для 2D DP (две строки, два массива)
- LCS, Edit Distance, Grid problems
- Когда нужно сравнивать/сопоставлять

### Какую модель выбрать?

```
┌────────────────────────────────────────────────────────────────┐
│                    ВЫБОР МОДЕЛИ                                │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  "Дерево с повторами"                                          │
│  └── Когда: Анализ задачи, проверка "нужен ли DP?"            │
│  └── Пример: Fibonacci, любая рекурсия                         │
│                                                                │
│  "Таблица зависимостей"                                        │
│  └── Когда: Реализация Bottom-Up, оптимизация памяти          │
│  └── Пример: Coin Change, Climbing Stairs                      │
│                                                                │
│  "Выбор на каждом шаге"                                        │
│  └── Когда: Задачи "взять/не взять", бинарный выбор           │
│  └── Пример: House Robber, 0/1 Knapsack                        │
│                                                                │
│  "Сборка из кубиков"                                           │
│  └── Когда: 2D DP, сравнение строк/массивов                   │
│  └── Пример: LCS, Edit Distance, Unique Paths                  │
│                                                                │
│  💡 СОВЕТ: Используй несколько моделей для одной задачи!       │
│     - "Дерево" для понимания                                   │
│     - "Таблица" для реализации                                 │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Визуальный гайд: От задачи к DP-решению

```
ЭТАП 1: Распознать DP
─────────────────────────────────────────────────────────────────
Вопрос: "Минимум/максимум/количество способов?"
        "Можно разбить на подзадачи?"
        "Подзадачи повторяются?"
           ↓
        ВСЕ ДА → DP подходит!

ЭТАП 2: Определить состояние
─────────────────────────────────────────────────────────────────
Вопрос: "Что ОДНОЗНАЧНО определяет подзадачу?"
           ↓
        Ответ → Это параметры dp[...][...]

        Примеры:
        - Fibonacci: номер числа → dp[n]
        - Knapsack: предмет + вес → dp[i][w]
        - LCS: позиции в строках → dp[i][j]

ЭТАП 3: Найти переход
─────────────────────────────────────────────────────────────────
Вопрос: "Как получить dp[текущее] из dp[предыдущих]?"
           ↓
        Ответ → Рекуррентное соотношение

        Шаблон:
        dp[i] = f(dp[i-1], dp[i-2], ...)

        Примеры:
        - Fibonacci: dp[i] = dp[i-1] + dp[i-2]
        - Coin Change: dp[a] = min(dp[a-coin]) + 1
        - Knapsack: dp[i][w] = max(dp[i-1][w], dp[i-1][w-wi]+vi)

ЭТАП 4: Определить базу
─────────────────────────────────────────────────────────────────
Вопрос: "Что известно БЕЗ вычислений?"
           ↓
        Ответ → Base cases

        Примеры:
        - Fibonacci: dp[0] = 0, dp[1] = 1
        - Coin Change: dp[0] = 0 (для суммы 0 нужно 0 монет)
        - Knapsack: dp[0][w] = 0 (нет предметов → нет ценности)

ЭТАП 5: Реализовать
─────────────────────────────────────────────────────────────────
        Memoization (Top-Down)     Tabulation (Bottom-Up)
        ─────────────────────     ──────────────────────
        1. Рекурсивная функция    1. Создать массив dp
        2. Проверка кэша          2. Заполнить базовые случаи
        3. Вычисление + сохранение 3. Цикл по состояниям
        4. Return из кэша         4. Return dp[n]
```

---

## Prerequisites

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| Recursion | DP Top-Down = рекурсия + мемоизация, нужно понимать base case и recursive case | [[recursion-fundamentals]] |
| Big O Notation | Понимание зачем оптимизировать O(2^n) → O(n) | [[big-o-complexity]] |
| Arrays | Tabulation использует массивы для хранения состояний | [[arrays-strings]] |
| **CS: Mathematical Induction** | DP = программирование мат. индукции: база + индукционный шаг | Дискретная математика |
| **CS: Recurrence Relations** | Анализ DP через рекуррентные соотношения T(n) = T(n-1) + O(1) | Алгоритмический анализ |

---

## 1. Зачем это нужно?

### Представьте ситуацию

Вы программист, и начальник даёт задачу:

> "Вычисли 50-е число Фибоначчи"

Вы пишете простую рекурсию:

```
fib(n) = fib(n-1) + fib(n-2)
fib(50) = fib(49) + fib(48)
        = fib(48) + fib(47) + fib(47) + fib(46)
        ...
```

**Запускаете... и ждёте.**

5 минут... 10 минут... компьютер всё считает.

**Почему так долго?**

### Проблема в числах

```
РЕКУРСИЯ БЕЗ ОПТИМИЗАЦИИ:

fib(50) требует примерно 2^50 операций
2^50 ≈ 1,125,899,906,842,624 (квадриллион!)

Если компьютер делает 1 миллиард операций в секунду:
1,125,899,906,842,624 / 1,000,000,000 = 1,125,899 секунд
≈ 13 ДНЕЙ непрерывных вычислений!
```

А теперь с Dynamic Programming:

```
С DYNAMIC PROGRAMMING:

fib(50) требует ровно 50 операций

50 / 1,000,000,000 = 0.00000005 секунд
≈ МГНОВЕННО
```

| Подход | Операций | Время |
|--------|----------|-------|
| Наивная рекурсия | 2^50 ≈ 10^15 | ~13 дней |
| Dynamic Programming | 50 | ~0.00005 мс |

**Разница: в 22 ТРИЛЛИОНА раз быстрее!**

### Почему рекурсия такая медленная?

```
                       fib(5)
                      /      \
                 fib(4)      fib(3)    ← fib(3) вычисляется
                /    \       /    \       ДВАЖДЫ!
           fib(3)  fib(2) fib(2) fib(1)
           /   \
      fib(2) fib(1)

Посмотрите на это дерево:
- fib(3) вычисляется 2 раза
- fib(2) вычисляется 3 раза
- fib(1) вычисляется 5 раз

Мы делаем ОДНУ И ТУ ЖЕ работу снова и снова!
```

**Идея DP:** Зачем вычислять одно и то же дважды? Вычислил один раз — **запомни результат!**

---

## 2. Что это такое?

### Объяснение для 5-летнего

**Представь, что ты собираешь пазл:**

```
╔═══════════════════════════════════════════════════╗
║                                                   ║
║   Пазл из 100 частей                              ║
║                                                   ║
║   ┌───┬───┬───┬───┬───┐                          ║
║   │ ✓ │ ✓ │ ✓ │ ? │ ? │  ← Ты уже собрал часть   ║
║   ├───┼───┼───┼───┼───┤                          ║
║   │ ✓ │ ✓ │ ? │ ? │ ? │                          ║
║   └───┴───┴───┴───┴───┘                          ║
║                                                   ║
║   Мама спрашивает: "Покажи, как ты собирал       ║
║   верхний левый угол?"                           ║
║                                                   ║
║   ТЫ НЕ РАЗБИРАЕШЬ ЕГО, ЧТОБЫ ПОКАЗАТЬ!          ║
║   Ты говоришь: "Вот, уже собран!"                ║
║                                                   ║
╚═══════════════════════════════════════════════════╝
```

**Dynamic Programming — это когда ты:**
1. Решаешь маленькую часть задачи
2. **Запоминаешь ответ** (не разбираешь пазл обратно!)
3. Используешь готовый ответ для следующих частей

### Ещё одна аналогия: лестница

```
Как подняться на 5-ю ступеньку?

        ┌─────┐
        │  5  │ ← Хочу сюда!
      ┌─┴─────┴─┐
      │    4    │ ← Сначала узнай, как дойти сюда
    ┌─┴─────────┴─┐
    │      3      │ ← Но для 4-й нужна 3-я...
  ┌─┴─────────────┴─┐
  │        2        │ ← А для 3-й нужна 2-я...
┌─┴─────────────────┴─┐
│          1          │ ← А для 2-й нужна 1-я!
└─────────────────────┘

Идея DP:
1. Узнай как добраться до ступеньки 1 (легко!)
2. Используй это, чтобы узнать как до 2
3. Используй это, чтобы узнать как до 3
4. ... и так далее до 5!
```

### Постепенное усложнение

**Уровень 1 (интуиция):**

> DP — это когда ты не переделываешь то, что уже сделал.
> Решил подзадачу? Запомни ответ и используй его.

**Уровень 2 (программирование):**

> DP применим, когда:
> 1. Задачу можно разбить на меньшие подзадачи
> 2. Эти подзадачи **повторяются** (overlapping)
> 3. Из оптимальных решений подзадач можно собрать оптимальное решение всей задачи

**Уровень 3 (формальное определение):**

> Dynamic Programming — метод оптимизации, основанный на принципе **сохранения результатов подзадач** для избежания повторных вычислений. Требует наличия двух свойств: **overlapping subproblems** (перекрывающиеся подзадачи) и **optimal substructure** (оптимальная подструктура).

---

## 3. Два ключевых свойства

### Свойство 1: Overlapping Subproblems (Перекрывающиеся подзадачи)

**Простыми словами:** Одна и та же подзадача встречается много раз.

**Визуализация на примере Fibonacci:**

```
Вычисляем fib(5):

                        fib(5)
                       /      \
                  fib(4)      fib(3)      ←─┐
                 /    \       /    \         │
            fib(3)  fib(2) fib(2) fib(1)     │ fib(3) вычисляется
            /   \                             │ ДВА раза!
       fib(2) fib(1)                       ←─┘

Подсчитаем вызовы:
┌─────────┬─────────────┐
│ Функция │ Сколько раз │
├─────────┼─────────────┤
│ fib(5)  │     1       │
│ fib(4)  │     1       │
│ fib(3)  │     2       │  ← Повтор!
│ fib(2)  │     3       │  ← Повтор!
│ fib(1)  │     5       │  ← Повтор!
│ fib(0)  │     3       │  ← Повтор!
└─────────┴─────────────┘

ВСЕГО: 15 вызовов для fib(5)
БЕЗ ПОВТОРОВ нужно было бы только 6!
```

**Если подзадачи повторяются — DP поможет.**

### Свойство 2: Optimal Substructure (Оптимальная подструктура)

**Простыми словами:** Оптимальное решение всей задачи состоит из оптимальных решений подзадач.

**Аналогия: кратчайший путь**

```
Ты хочешь доехать из Seattle в Los Angeles.

Seattle ──────────────────────────────→ Los Angeles
         кратчайший путь = 1,135 миль

Этот путь проходит через Portland:

Seattle ────→ Portland ────→ Los Angeles
         175 миль    960 миль

ВОПРОС: Какой кратчайший путь Portland → Los Angeles?
ОТВЕТ:  ТОТ ЖЕ САМЫЙ! 960 миль.

ПОЧЕМУ?
Если бы существовал БОЛЕЕ короткий путь Portland → LA,
скажем 900 миль, то:
Seattle → Portland → LA = 175 + 900 = 1,075 миль

Это КОРОЧЕ, чем 1,135 миль!
Значит, 1,135 не был бы кратчайшим. ПРОТИВОРЕЧИЕ!

ВЫВОД: Часть кратчайшего пути — тоже кратчайший путь.
Это и есть OPTIMAL SUBSTRUCTURE.
```

**Если оптимальное решение строится из оптимальных подрешений — DP применим.**

### Проверка: подходит ли задача для DP?

```
┌─────────────────────────────────────────────────────────┐
│                    ЧЕКЛИСТ ДЛЯ DP                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  □ Можно ли разбить на подзадачи?                      │
│    → Да: продолжаем                                     │
│    → Нет: DP не подходит                                │
│                                                         │
│  □ Подзадачи повторяются? (overlapping)                │
│    → Да: DP поможет!                                    │
│    → Нет: обычная рекурсия достаточна                   │
│                                                         │
│  □ Оптимум из оптимумов? (optimal substructure)        │
│    → Да: DP гарантирует правильный ответ                │
│    → Нет: возможно, нужен другой подход (greedy?)       │
│                                                         │
│  Если ВСЕ три ДА → используй DP!                        │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 4. Два подхода к DP

### Top-Down: Memoization (Сверху вниз)

**Идея:** Пиши рекурсию как обычно, но **запоминай результаты**.

```
Аналогия: Записная книжка

Ты решаешь fib(5):
1. fib(5) = fib(4) + fib(3)
2. Считаешь fib(4)... записываешь в книжку: "fib(4) = 3"
3. Считаешь fib(3)... НО ПОДОЖДИ!
4. Смотришь в книжку — fib(3) уже был при вычислении fib(4)!
5. Читаешь: "fib(3) = 2" ← НЕ ВЫЧИСЛЯЕШЬ ЗАНОВО!
```

**Визуализация процесса:**

```
Шаг 1: Вызов fib(5)
┌───────────────────────────────────────────────────┐
│ Книжка: { }  (пустая)                             │
│ Вычисляем fib(5) = fib(4) + fib(3)               │
│ Нужен fib(4)...                                   │
└───────────────────────────────────────────────────┘

Шаг 2: Вычисление fib(4)
┌───────────────────────────────────────────────────┐
│ Книжка: { }                                       │
│ Вычисляем fib(4) = fib(3) + fib(2)               │
│ ... рекурсивно считаем ...                        │
│ Результат: fib(4) = 3                             │
│ Записываем в книжку!                              │
│ Книжка: { 4: 3 }                                  │
└───────────────────────────────────────────────────┘

Шаг 3: Вычисление fib(3) для fib(5)
┌───────────────────────────────────────────────────┐
│ Книжка: { 4: 3, 3: 2, 2: 1, 1: 1, 0: 0 }         │
│ Нужен fib(3)...                                   │
│ Смотрим в книжку: ЕСТЬ! fib(3) = 2               │
│ НЕ ВЫЧИСЛЯЕМ ЗАНОВО!                              │
└───────────────────────────────────────────────────┘

Шаг 4: Результат
┌───────────────────────────────────────────────────┐
│ fib(5) = fib(4) + fib(3) = 3 + 2 = 5             │
│ Всего уникальных вычислений: 6 (вместо 15!)       │
└───────────────────────────────────────────────────┘
```

### Bottom-Up: Tabulation (Снизу вверх)

**Идея:** Начни с малого и **заполняй таблицу** шаг за шагом.

```
Аналогия: Строить дом с фундамента

Нельзя построить крышу без стен.
Нельзя построить стены без фундамента.

1. Сначала фундамент (base case)
2. Потом стены (промежуточные значения)
3. Потом крыша (ответ)
```

**Визуализация процесса:**

```
Вычисляем fib(5) снизу вверх:

Шаг 0: База
┌───┬───┬───┬───┬───┬───┐
│ 0 │ 1 │ ? │ ? │ ? │ ? │
└───┴───┴───┴───┴───┴───┘
  0   1   2   3   4   5

"Мы знаем, что fib(0) = 0 и fib(1) = 1"

Шаг 1: Вычисляем fib(2) = fib(1) + fib(0) = 1 + 0 = 1
┌───┬───┬───┬───┬───┬───┐
│ 0 │ 1 │ 1 │ ? │ ? │ ? │
└───┴───┴───┴───┴───┴───┘
  0   1   2   3   4   5

Шаг 2: Вычисляем fib(3) = fib(2) + fib(1) = 1 + 1 = 2
┌───┬───┬───┬───┬───┬───┐
│ 0 │ 1 │ 1 │ 2 │ ? │ ? │
└───┴───┴───┴───┴───┴───┘
  0   1   2   3   4   5

Шаг 3: Вычисляем fib(4) = fib(3) + fib(2) = 2 + 1 = 3
┌───┬───┬───┬───┬───┬───┐
│ 0 │ 1 │ 1 │ 2 │ 3 │ ? │
└───┴───┴───┴───┴───┴───┘
  0   1   2   3   4   5

Шаг 4: Вычисляем fib(5) = fib(4) + fib(3) = 3 + 2 = 5
┌───┬───┬───┬───┬───┬───┐
│ 0 │ 1 │ 1 │ 2 │ 3 │ 5 │  ← ОТВЕТ!
└───┴───┴───┴───┴───┴───┘
  0   1   2   3   4   5
```

### Сравнение подходов

| Критерий | Memoization (Top-Down) | Tabulation (Bottom-Up) |
|----------|------------------------|------------------------|
| **Направление** | От большого к малому | От малого к большому |
| **Реализация** | Рекурсия + HashMap/Array | Цикл for + массив |
| **Что вычисляет** | Только нужные подзадачи | Все подзадачи подряд |
| **Stack Overflow?** | Риск при большом n | Нет риска |
| **Оптимизация памяти** | Сложнее | Легче (rolling array) |
| **Когда лучше** | Нужны не все подзадачи | Нужны все подзадачи |
| **Для новичков** | Проще думать | Быстрее работает |

**Совет:** Начни с memoization (легче написать), затем преврати в tabulation (быстрее работает).

---

## 5. Терминология

| Термин | Простое объяснение | Формальное определение |
|--------|-------------------|------------------------|
| **State (Состояние)** | "Где я сейчас нахожусь в задаче?" Параметры, которые меняются | Минимальный набор переменных, однозначно определяющий подзадачу |
| **Transition (Переход)** | "Как мне перейти из одного состояния в другое?" Формула связи | Рекуррентное соотношение между dp[i] и dp[j] для j < i |
| **Base Case (База)** | "С чего начать?" Известные значения | Начальные условия, не зависящие от других состояний |
| **Memoization** | "Записная книжка" — записал ответ, не забудешь | Top-down DP с кэшированием результатов рекурсии |
| **Tabulation** | "Заполнение таблицы" снизу вверх | Bottom-up DP с итеративным заполнением массива |
| **Overlapping Subproblems** | "Одно и то же считается много раз" | Свойство, когда одни подзадачи встречаются неоднократно |
| **Optimal Substructure** | "Оптимум из оптимумов" | Свойство, когда оптимальное решение состоит из оптимальных подрешений |

---

## 6. FAST Method: Как решать DP задачи

Это пошаговый фреймворк для решения любой DP задачи:

```
┌─────────────────────────────────────────────────────────┐
│                      FAST METHOD                         │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  F — Find first solution                                │
│      Напиши ПРОСТУЮ рекурсию (brute force).             │
│      Не думай об оптимизации!                           │
│                                                         │
│  A — Analyze solution                                   │
│      Нарисуй дерево вызовов.                            │
│      Есть ли повторяющиеся узлы? (overlapping)          │
│                                                         │
│  S — Subproblem caching                                 │
│      Добавь мемоизацию (кэш) для повторяющихся вызовов. │
│      Теперь это Top-Down DP!                            │
│                                                         │
│  T — Turn around                                        │
│      Преврати в Bottom-Up (tabulation).                 │
│      Оптимизируй память если нужно.                     │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Пример: Climbing Stairs (LeetCode 70)

**Задача:** Ты можешь подняться на 1 или 2 ступеньки за раз. Сколько способов подняться на n-ю ступеньку?

#### F — Find first solution (Brute Force)

```
Рассуждения:
- Чтобы попасть на ступеньку n, я мог прийти с (n-1) или с (n-2)
- Значит, способов добраться до n = способов до (n-1) + способов до (n-2)

Это... Fibonacci!
```

```kotlin
// F: Brute Force (МЕДЛЕННО!)
fun climbStairs(n: Int): Int {
    if (n <= 2) return n
    return climbStairs(n - 1) + climbStairs(n - 2)
}
```

#### A — Analyze solution

```
Дерево вызовов для n = 5:

                  climb(5)
                 /        \
            climb(4)      climb(3)   ← climb(3) повторяется!
            /    \         /    \
       climb(3) climb(2) climb(2) climb(1)
       /    \
  climb(2) climb(1)

Сложность: O(2^n) — ОЧЕНЬ ПЛОХО!
```

#### S — Subproblem caching (Memoization)

```kotlin
// S: Добавляем кэш
fun climbStairs(n: Int): Int {
    val memo = IntArray(n + 1) { -1 }
    return climbMemo(n, memo)
}

private fun climbMemo(n: Int, memo: IntArray): Int {
    // База
    if (n <= 2) return n

    // Уже вычисляли? Возвращаем из кэша!
    if (memo[n] != -1) return memo[n]

    // Вычисляем и СОХРАНЯЕМ
    memo[n] = climbMemo(n - 1, memo) + climbMemo(n - 2, memo)
    return memo[n]
}
```

#### T — Turn around (Tabulation)

```kotlin
// T: Bottom-Up
fun climbStairs(n: Int): Int {
    if (n <= 2) return n

    val dp = IntArray(n + 1)
    dp[1] = 1  // 1 способ до 1-й ступеньки
    dp[2] = 2  // 2 способа до 2-й ступеньки

    for (i in 3..n) {
        dp[i] = dp[i - 1] + dp[i - 2]
    }

    return dp[n]
}
```

#### Бонус: Оптимизация памяти

```kotlin
// Нам нужны только 2 предыдущих значения!
fun climbStairs(n: Int): Int {
    if (n <= 2) return n

    var prev2 = 1  // dp[i-2]
    var prev1 = 2  // dp[i-1]

    for (i in 3..n) {
        val curr = prev1 + prev2
        prev2 = prev1
        prev1 = curr
    }

    return prev1
}
```

**Итоговая сложность:**
- Время: O(n)
- Память: O(1)

---

## 7. Пошаговый разбор: Coin Change

**Задача:** Даны монеты [1, 2, 5]. Какое минимальное количество монет нужно, чтобы набрать сумму 11?

### Шаг 1: Определи состояние

```
Вопрос: Что однозначно определяет подзадачу?
Ответ:  Текущая сумма, которую нужно набрать

State: dp[amount] = минимальное количество монет для суммы amount
```

### Шаг 2: Найди переход (transition)

```
Вопрос: Как связаны состояния?

Если я хочу набрать сумму 11:
- Использую монету 1: осталось набрать 10, т.е. dp[10] + 1
- Использую монету 2: осталось набрать 9, т.е. dp[9] + 1
- Использую монету 5: осталось набрать 6, т.е. dp[6] + 1

Выбираю МИНИМУМ!

Transition: dp[amount] = min(dp[amount - coin] + 1) для всех coin
```

### Шаг 3: Определи базу

```
Base Case:
- dp[0] = 0  (для суммы 0 нужно 0 монет)
- dp[negative] = невозможно
```

### Шаг 4: Заполни таблицу

```
Монеты: [1, 2, 5]
Сумма:  11

Инициализация (∞ = невозможно):
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
│ 0 │ ∞ │ ∞ │ ∞ │ ∞ │ ∞ │ ∞ │ ∞ │ ∞ │ ∞ │ ∞ │ ∞ │
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
  0   1   2   3   4   5   6   7   8   9  10  11

Заполняем для каждой суммы:

amount = 1:
  coin 1: dp[0] + 1 = 1  ← БЕРЁМ
  coin 2: dp[-1] = ∞
  coin 5: dp[-4] = ∞
  dp[1] = 1

amount = 2:
  coin 1: dp[1] + 1 = 2
  coin 2: dp[0] + 1 = 1  ← БЕРЁМ
  coin 5: dp[-3] = ∞
  dp[2] = 1

...продолжаем...

Финальная таблица:
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
│ 0 │ 1 │ 1 │ 2 │ 2 │ 1 │ 2 │ 2 │ 3 │ 3 │ 2 │ 3 │
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
  0   1   2   3   4   5   6   7   8   9  10  11
                                            ↑
                                        ОТВЕТ: 3

Решение: 11 = 5 + 5 + 1 (3 монеты)
```

---

## 8. Сложность операций

### Типичные сложности DP

| Тип DP | Время | Память | Примеры |
|--------|-------|--------|---------|
| **1D DP** | O(n) | O(n) → O(1) | Fibonacci, Climbing Stairs |
| **2D DP** | O(n×m) | O(n×m) → O(m) | LCS, Edit Distance, 0/1 Knapsack |
| **Interval DP** | O(n³) | O(n²) | Burst Balloons, Matrix Chain |
| **Bitmask DP** | O(2^n × n) | O(2^n) | TSP, Subset problems |

### Почему такая сложность?

**1D DP (Fibonacci):**
```
dp[i] зависит от dp[i-1] и dp[i-2]
→ Заполняем n ячеек
→ Каждая за O(1)
→ Итого: O(n)

Память: нужны только 2 предыдущих значения → O(1)
```

**2D DP (LCS):**
```
dp[i][j] зависит от dp[i-1][j-1], dp[i-1][j], dp[i][j-1]
→ Таблица n×m
→ Каждая ячейка за O(1)
→ Итого: O(n×m)

Память: нужна только предыдущая строка → O(m)
```

---

## 9. Реализация

### Пример 1: Fibonacci (1D DP)

#### Kotlin

```kotlin
// Memoization: Top-Down (рекурсия + кэш)
// Почему HashMap? Гибкий доступ, но можно IntArray для скорости
fun fibMemo(n: Int, memo: MutableMap<Int, Long> = mutableMapOf()): Long {
    // База: известные значения, не требующие вычислений
    if (n <= 1) return n.toLong()

    // Уже считали? Возвращаем из кэша — избегаем повторной работы
    memo[n]?.let { return it }

    // Вычисляем и СОХРАНЯЕМ — ключевая идея мемоизации
    return (fibMemo(n - 1, memo) + fibMemo(n - 2, memo)).also {
        memo[n] = it
    }
}

// Tabulation: Bottom-Up (итерация + массив)
// Почему цикл? Нет риска stack overflow, быстрее за счёт отсутствия overhead рекурсии
fun fibTab(n: Int): Long {
    if (n <= 1) return n.toLong()

    // Почему размер n+1? Индексы от 0 до n включительно
    val dp = LongArray(n + 1)
    dp[0] = 0  // База: fib(0) = 0
    dp[1] = 1  // База: fib(1) = 1

    // Заполняем слева направо — каждое значение зависит от двух предыдущих
    for (i in 2..n) {
        dp[i] = dp[i - 1] + dp[i - 2]
    }

    return dp[n]
}

// Space Optimized: O(1) память
// Почему только 2 переменные? dp[i] зависит ТОЛЬКО от dp[i-1] и dp[i-2]
fun fibOptimized(n: Int): Long {
    if (n <= 1) return n.toLong()

    var prev2 = 0L  // dp[i-2]
    var prev1 = 1L  // dp[i-1]

    for (i in 2..n) {
        val curr = prev1 + prev2
        prev2 = prev1  // Сдвигаем "окно"
        prev1 = curr
    }

    return prev1
}
```

#### Java

```java
// Memoization: Top-Down
public long fibMemo(int n, Map<Integer, Long> memo) {
    if (n <= 1) return n;

    if (memo.containsKey(n)) {
        return memo.get(n);
    }

    long result = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);
    memo.put(n, result);
    return result;
}

// Tabulation: Bottom-Up
public long fibTab(int n) {
    if (n <= 1) return n;

    long[] dp = new long[n + 1];
    dp[0] = 0;
    dp[1] = 1;

    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
}

// Space Optimized
public long fibOptimized(int n) {
    if (n <= 1) return n;

    long prev2 = 0, prev1 = 1;

    for (int i = 2; i <= n; i++) {
        long curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }

    return prev1;
}
```

#### Python

```python
from functools import lru_cache

# Memoization: Top-Down с декоратором
# Почему lru_cache? Python автоматически кэширует результаты
@lru_cache(maxsize=None)
def fib_memo(n: int) -> int:
    if n <= 1:
        return n
    return fib_memo(n - 1) + fib_memo(n - 2)

# Tabulation: Bottom-Up
def fib_tab(n: int) -> int:
    if n <= 1:
        return n

    dp = [0] * (n + 1)
    dp[0], dp[1] = 0, 1

    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]

    return dp[n]

# Space Optimized
def fib_optimized(n: int) -> int:
    if n <= 1:
        return n

    prev2, prev1 = 0, 1

    for _ in range(2, n + 1):
        prev2, prev1 = prev1, prev1 + prev2

    return prev1
```

### Пример 2: Coin Change (Unbounded Knapsack)

#### Kotlin

```kotlin
fun coinChange(coins: IntArray, amount: Int): Int {
    // dp[i] = минимальное количество монет для суммы i
    // Почему amount + 1? Это значение "невозможно" (нельзя набрать больше amount монетами номиналом ≥ 1)
    val dp = IntArray(amount + 1) { amount + 1 }
    dp[0] = 0  // База: для суммы 0 нужно 0 монет

    // Почему итерация вперёд? Unbounded = можно использовать монету много раз
    for (coin in coins) {
        for (a in coin..amount) {
            // Берём минимум: не использовать эту монету ИЛИ использовать
            dp[a] = minOf(dp[a], dp[a - coin] + 1)
        }
    }

    return if (dp[amount] > amount) -1 else dp[amount]
}
```

#### Java

```java
public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;

    for (int coin : coins) {
        for (int a = coin; a <= amount; a++) {
            dp[a] = Math.min(dp[a], dp[a - coin] + 1);
        }
    }

    return dp[amount] > amount ? -1 : dp[amount];
}
```

#### Python

```python
def coin_change(coins: list[int], amount: int) -> int:
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for a in range(coin, amount + 1):
            dp[a] = min(dp[a], dp[a - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1
```

---

## 10. Распространённые ошибки

### Ошибка 1: "DP — это алгоритм"

**Неправильно:**
```
"Использую алгоритм DP для решения этой задачи"
```

**Почему неправильно:**

DP — это не алгоритм, а **способ мышления**. Это техника оптимизации, которую можно применить к разным алгоритмам.

**Правильно:**
```
"Вижу повторяющиеся подзадачи — применю мемоизацию для оптимизации"
```

### Ошибка 2: Сразу писать оптимальное решение

**Неправильно:**
```kotlin
// Сразу пытаемся написать Bottom-Up с оптимизацией памяти
fun solution(n: Int): Int {
    var prev2 = ...
    var prev1 = ...
    // Путаемся в индексах, получаем WA
}
```

**Почему неправильно:**

Сложно правильно определить transition и base cases без простой версии.

**Правильно:**
```kotlin
// 1. Сначала brute force рекурсия
// 2. Добавляем мемоизацию
// 3. Переписываем в tabulation с полным массивом
// 4. ТОЛЬКО ПОТОМ оптимизируем память
```

### Ошибка 3: Неправильное состояние

**Неправильно:**
```kotlin
// 0/1 Knapsack: храним только сумму
dp[weight] = maxValue
// ОШИБКА: забыли учесть какие предметы уже взяли!
```

**Почему неправильно:**

Состояние должно однозначно определять подзадачу. Если забыли параметр — решение будет неверным.

**Правильно:**
```kotlin
// Состояние: (текущий предмет, оставшийся вес)
dp[item][weight] = maxValue
```

### Ошибка 4: Неправильный порядок итерации в Knapsack

**Неправильно:**
```kotlin
// 0/1 Knapsack с итерацией ВПЕРЁД
for (w in weight..capacity) {  // ОШИБКА!
    dp[w] = maxOf(dp[w], dp[w - weight] + value)
}
// Один и тот же предмет может использоваться несколько раз!
```

**Почему неправильно:**

При итерации вперёд мы используем уже обновлённые значения → предмет берётся много раз.

**Правильно:**
```kotlin
// 0/1 Knapsack: итерация НАЗАД
for (w in capacity downTo weight) {  // Правильно!
    dp[w] = maxOf(dp[w], dp[w - weight] + value)
}
// Используем старые значения → предмет берётся максимум 1 раз
```

### Ошибка 5: Забыть базовые случаи

**Неправильно:**
```kotlin
fun fib(n: Int): Int {
    val dp = IntArray(n + 1)
    // Забыли dp[0] = 0, dp[1] = 1!
    for (i in 2..n) {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]  // Всегда 0!
}
```

**Правильно:**

Всегда начинай с вопроса: **"Что я знаю при i = 0?"**

---

## 11. Когда использовать

### Используй DP, когда:

1. **Задача про оптимизацию** — "минимум", "максимум", "количество способов"
2. **Есть повторяющиеся подзадачи** — нарисуй дерево рекурсии и посмотри
3. **Optimal substructure** — оптимум состоит из оптимумов подзадач
4. **Можно разбить на подзадачи** — задача "собирается" из меньших частей

**Сигнальные слова в условии:**
- "Минимальное количество..."
- "Максимальная прибыль..."
- "Сколько способов..."
- "Можно ли достичь..."
- "Найти оптимальный..."

### НЕ используй DP, когда:

1. **Нет повторяющихся подзадач**
   - Лучше: обычная рекурсия или Divide & Conquer

2. **Greedy работает** (локальный оптимум = глобальный)
   - Лучше: [[greedy-algorithms]]

3. **Нужны все варианты, а не только оптимум**
   - Лучше: [[backtracking]]

4. **Граф с отрицательными циклами**
   - DP может зациклиться

### Сравнение с альтернативами

| Критерий | DP | Greedy | Backtracking | Divide & Conquer |
|----------|-----|--------|--------------|------------------|
| Повторяющиеся подзадачи | Да | - | - | Нет |
| Гарантирует оптимум | Да | Не всегда | Да (перебор) | Да |
| Когда использовать | Оптимизация | Локальный оптимум = глобальный | Все варианты | Независимые подзадачи |
| Пример | Coin Change | Activity Selection | N-Queens | Merge Sort |

---

## 12. Прогрессия обучения

```
УРОВЕНЬ 1: Понять идею (1D DP)
├── Fibonacci (классика)
├── Climbing Stairs (вариация Fibonacci)
└── House Robber (первый "настоящий" DP)

УРОВЕНЬ 2: 1D DP задачи
├── Maximum Subarray (Kadane)
├── Coin Change (unbounded knapsack)
└── Longest Increasing Subsequence

УРОВЕНЬ 3: 2D DP задачи
├── Unique Paths (grid DP)
├── 0/1 Knapsack
└── Longest Common Subsequence

УРОВЕНЬ 4: Комплексные паттерны
├── Edit Distance
├── Burst Balloons (interval DP)
├── Stock Problems (state machine)
└── Word Break (string partition)

УРОВЕНЬ 5: Продвинутый DP
├── Bitmask DP (TSP, N ≤ 20)
├── DP on Trees
└── DP Optimization (Convex Hull Trick)
```

---

## 13. Практика

### Вопросы на понимание (без кода)

1. **Что такое overlapping subproblems?**
   <details><summary>Ответ</summary>

   Это когда при решении задачи одна и та же подзадача вычисляется многократно. Например, в Fibonacci fib(3) вычисляется и для fib(5), и для fib(4). DP помогает избежать повторных вычислений, сохраняя результаты.
   </details>

2. **Чем отличается memoization от tabulation?**
   <details><summary>Ответ</summary>

   - **Memoization (Top-Down):** Рекурсия + кэш. Начинаем с большой задачи, спускаемся к меньшим. Вычисляем только нужные подзадачи.
   - **Tabulation (Bottom-Up):** Цикл + массив. Начинаем с базовых случаев, поднимаемся к ответу. Вычисляем все подзадачи.
   </details>

3. **Почему в 0/1 Knapsack итерация идёт в обратном порядке?**
   <details><summary>Ответ</summary>

   При прямой итерации `dp[w - weight]` уже содержит обновлённое значение этой же итерации, поэтому предмет может быть взят несколько раз. При обратной итерации мы используем значения предыдущей итерации, гарантируя, что предмет берётся максимум один раз.
   </details>

4. **Когда Greedy лучше, чем DP?**
   <details><summary>Ответ</summary>

   Когда локально оптимальный выбор гарантирует глобально оптимальное решение. Greedy проще и быстрее (обычно O(n log n)), но работает не для всех задач. Пример: Activity Selection — greedy работает; Coin Change с произвольными номиналами — нет.
   </details>

5. **Как определить, нужен 1D или 2D массив?**
   <details><summary>Ответ</summary>

   Количество измерений = количество изменяющихся параметров состояния.
   - 1 параметр (например, позиция в массиве) → 1D DP
   - 2 параметра (позиции в двух строках) → 2D DP
   - 3 параметра → 3D DP (редко)
   </details>

### Задачи для закрепления

| # | Задача | Сложность | Паттерн | Ссылка |
|---|--------|-----------|---------|--------|
| 1 | Climbing Stairs | Easy | Fibonacci | [LeetCode 70](https://leetcode.com/problems/climbing-stairs/) |
| 2 | House Robber | Medium | Decision | [LeetCode 198](https://leetcode.com/problems/house-robber/) |
| 3 | Maximum Subarray | Medium | Kadane | [LeetCode 53](https://leetcode.com/problems/maximum-subarray/) |
| 4 | Coin Change | Medium | Unbounded Knapsack | [LeetCode 322](https://leetcode.com/problems/coin-change/) |
| 5 | Longest Increasing Subsequence | Medium | LIS | [LeetCode 300](https://leetcode.com/problems/longest-increasing-subsequence/) |
| 6 | Longest Common Subsequence | Medium | LCS | [LeetCode 1143](https://leetcode.com/problems/longest-common-subsequence/) |
| 7 | Unique Paths | Medium | Grid | [LeetCode 62](https://leetcode.com/problems/unique-paths/) |
| 8 | Edit Distance | Medium | Edit Distance | [LeetCode 72](https://leetcode.com/problems/edit-distance/) |
| 9 | Partition Equal Subset Sum | Medium | 0/1 Knapsack | [LeetCode 416](https://leetcode.com/problems/partition-equal-subset-sum/) |
| 10 | Word Break | Medium | String Partition | [LeetCode 139](https://leetcode.com/problems/word-break/) |
| 11 | Best Time to Buy/Sell Stock III | Hard | State Machine | [LeetCode 123](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/) |
| 12 | Burst Balloons | Hard | Interval DP | [LeetCode 312](https://leetcode.com/problems/burst-balloons/) |

---

## Мифы и заблуждения

| Миф | Реальность |
|-----|-----------|
| "DP — это алгоритм" | **DP — это техника оптимизации, не алгоритм.** Это способ мышления о задачах с overlapping subproblems. Можно применить к разным алгоритмам: поиск путей, подсчёт комбинаций, оптимизация. |
| "Memoization и DP — одно и то же" | **Memoization — это техника кэширования, одна из реализаций DP.** DP включает и tabulation (bottom-up), которая не использует рекурсию вообще. |
| "DP всегда оптимальнее других подходов" | **Не всегда!** Greedy быстрее для задач, где локальный оптимум = глобальный. DP имеет overhead на память. Для n < 20 brute force может быть достаточен. |
| "Нужно сразу писать tabulation" | **Нет!** FAST метод: сначала brute force рекурсия → добавить memo → только потом табуляция. Сразу писать tabulation — источник ошибок. |
| "2D DP всегда требует O(n×m) памяти" | **Можно оптимизировать до O(m)!** Если dp[i] зависит только от dp[i-1], храним только 1-2 предыдущих строки (rolling array technique). |
| "DP решает все задачи оптимизации" | **Нет!** DP требует overlapping subproblems И optimal substructure. Для задач без этих свойств (например, некоторые графовые) DP не подходит. |
| "Состояние = параметры рекурсии" | **Почти, но не всегда.** Иногда нужны дополнительные параметры (флаги, счётчики), которые не очевидны из условия. State design — ключевой навык. |
| "DP задачи на интервью всегда о массивах" | **Нет!** DP применим к строкам (edit distance), графам (shortest paths), деревьям (tree DP), множествам (bitmask DP). Массивы — лишь частный случай. |

---

## CS-фундамент

| CS-концепция | Применение в Dynamic Programming |
|--------------|----------------------------------|
| **Overlapping Subproblems** | Ключевое свойство: одна подзадача решается многократно. Без overlapping DP не нужен — достаточно обычной рекурсии. Визуализация: дерево рекурсии с повторяющимися узлами. |
| **Optimal Substructure** | Оптимальное решение задачи содержит оптимальные решения подзадач. Пример: кратчайший путь A→C через B содержит кратчайшие пути A→B и B→C. Без этого свойства DP не даёт оптимум. |
| **Memoization (Top-Down)** | Кэширование результатов рекурсивных вызовов. HashMap или Array. Ленивое вычисление: считаем только нужные подзадачи. Trade-off: overhead рекурсии vs простота реализации. |
| **Tabulation (Bottom-Up)** | Итеративное заполнение таблицы от базовых случаев к ответу. Вычисляем ВСЕ подзадачи. Преимущество: нет stack overflow, легче оптимизировать память. |
| **State Space** | Множество всех возможных состояний задачи. dp[i] или dp[i][j] — точки в этом пространстве. Размер state space = time complexity DP решения. |
| **Recurrence Relation** | Формула связи между состояниями: dp[i] = f(dp[i-1], dp[i-2], ...). Это "сердце" DP. Правильный recurrence = правильное решение. Master Theorem для анализа сложности. |

---

### Порядок решения

1. **Начни с:** Climbing Stairs, House Robber — почувствуй идею DP
2. **Затем:** Coin Change, Maximum Subarray — классические 1D паттерны
3. **2D DP:** LCS, Edit Distance, Unique Paths — работа с двумя измерениями
4. **Продвинутый:** Burst Balloons, Stock III — interval DP и state machine

---

## 14. Связанные темы

### Prerequisites (изучить ДО этого материала)
- [[recursion-fundamentals]] — мемоизация строится поверх рекурсии
- [[big-o-complexity]] — понимание зачем оптимизировать время

### Эта тема открывает (изучить ПОСЛЕ)
- [[dp-patterns]] — 20 паттернов DP для интервью
- [[dp-optimization]] — Convex Hull Trick, Divide & Conquer DP
- [[graph-advanced]] — Bellman-Ford, Floyd-Warshall используют DP

### Связанные паттерны
- [[greedy-algorithms]] — альтернатива когда локальный оптимум = глобальный
- [[backtracking]] — когда нужны все варианты, а не только оптимум

---

## 15. Связь с другими темами

**[[dp-optimization]]** — после освоения базового динамического программирования, техники оптимизации позволяют решать задачи, которые иначе не укладываются в ограничения по времени. Knuth's optimization сокращает O(n^3) до O(n^2) для определённого класса задач, divide-and-conquer optimization работает с монотонными функциями перехода, а Convex Hull Trick оптимизирует линейные рекуррентности. Изучать оптимизации стоит только после уверенного владения базовым DP и решения 30+ задач.

**[[dp-patterns]]** — конкретные шаблоны DP-задач, которые покрывают большинство интервью-задач: knapsack (0/1 и unbounded), Longest Common Subsequence (LCS), Longest Increasing Subsequence (LIS), edit distance, interval DP, state machine DP (stock problems). Знание паттернов позволяет быстро распознавать тип задачи и применять соответствующий подход. Рекомендуется изучать паттерны параллельно с решением задач из каждой категории.

**[[recursion-fundamentals]]** — рекурсия является фундаментом динамического программирования. Любая DP-задача начинается с рекурсивного решения: определение base case, формулировка рекуррентного соотношения, построение дерева вызовов. Top-down DP (мемоизация) — это буквально рекурсия с кэшем. Без уверенного владения рекурсией невозможно правильно определить состояние и переход в DP. Рекурсию необходимо изучить ДО перехода к динамическому программированию.

---

## 16. Источники

### Книги
- **Cormen, Leiserson, Rivest & Stein (2009). "Introduction to Algorithms (CLRS)."** — каноническая глава по динамическому программированию; формальное изложение optimal substructure и overlapping subproblems; разбор задач rod cutting, matrix chain multiplication, LCS с доказательствами корректности
- **Bellman (1957). "Dynamic Programming."** — оригинальная работа Ричарда Беллмана, автора метода и самого термина "dynamic programming"; историческое и теоретическое значение; принцип оптимальности Беллмана изложен из первых рук
- **Skiena (2008). "The Algorithm Design Manual."** — практический подход к DP с акцентом на распознавание паттернов; "War Stories" показывают реальное применение DP в индустрии; отличное дополнение к теоретическому CLRS

### Онлайн-ресурсы

| # | Источник | Тип | Что взято |
|---|----------|-----|-----------|
| 1 | [Stack Overflow Blog - Complete Beginners Guide to DP](https://stackoverflow.blog/2022/01/31/the-complete-beginners-guide-to-dynamic-programming/) | Tutorial | Аналогии, пошаговый подход |
| 2 | [freeCodeCamp - FAST Method](https://www.freecodecamp.org/news/follow-these-steps-to-solve-any-dynamic-programming-interview-problem-cc98e508cd0e/) | Guide | FAST framework |
| 3 | [GeeksforGeeks - Steps to Solve DP](https://www.geeksforgeeks.org/dsa/solve-dynamic-programming-problem/) | Tutorial | State Design Framework |
| 4 | [Baeldung - Tabulation vs Memoization](https://www.baeldung.com/cs/tabulation-vs-memoization) | Comparison | Сравнение подходов |
| 5 | [Tech Interview Handbook - DP](https://www.techinterviewhandbook.org/algorithms/dynamic-programming/) | Guide | Паттерны, сложности |
| 6 | [MIT OCW 6.006 - Dynamic Programming](https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-spring-2020/) | Academic | Формальные определения |
| 7 | [ACM - Student Misconceptions in DP](https://dl.acm.org/doi/abs/10.1145/3159450.3159528) | Research | Почему студенты ошибаются |

*Исследование проведено: 2025-12-29*
*Отчёты: [[docs/research/2025-12-29-dynamic-programming.md]], [[docs/research/2025-12-29-dynamic-programming-teaching.md]]*

**Дополнительные источники (2024-2025):**
- [Medium - Beginner's Guide to DP](https://medium.com/@jason_qiu/the-beginners-guide-to-dynamic-programming-38fa1053f152) — интуиция и визуализация
- [EnjoyAlgorithms - Top-Down vs Bottom-Up](https://medium.com/enjoy-algorithm/top-down-vs-bottom-up-approach-in-dynamic-programming-53b917bfbe0) — сравнение подходов
- [LockedInAI - 10 DP Patterns](https://www.lockedinai.com/blog/dynamic-programming-interview-patterns-success) — паттерны для интервью
- [AlgoCademy - Mastering DP](https://algocademy.com/blog/mastering-dynamic-programming-strategies-for-coding-interviews/) — стратегии для собеседований
- [Codefinity - DP Overview](https://codefinity.com/blog/Overview-of-Dynamic-Programming) — общий обзор

---

## Навигация

← Предыдущая: [[recursion-fundamentals|Recursion Fundamentals]]
→ Следующая: [[backtracking|Backtracking]]
↑ Вверх: [[_moc-algorithms|Algorithms MOC]]


---

## Проверь себя

> [!question]- Почему DP применим только к задачам с оптимальной подструктурой и перекрывающимися подзадачами?
> Оптимальная подструктура означает, что оптимальное решение большой задачи строится из оптимальных решений подзадач. Перекрывающиеся подзадачи означают, что одни и те же подзадачи решаются многократно. Без первого -- нет рекуррентного соотношения. Без второго -- мемоизация не даёт выигрыша.

> [!question]- Тебе дана задача: найти минимальное число монет для суммы amount. Как определить состояние DP?
> Состояние dp[i] = минимальное число монет для суммы i. Переход: dp[i] = min(dp[i - coin] + 1) для каждого coin. Базовый случай: dp[0] = 0. Это 1D DP с O(amount * coins) сложностью. Состояние однозначно определяет подзадачу.

> [!question]- Почему bottom-up DP обычно эффективнее top-down с мемоизацией?
> Bottom-up: нет overhead рекурсии (call stack), можно оптимизировать память (хранить только предыдущую строку), предсказуемый порядок вычислений (cache-friendly). Top-down: проще реализовать, вычисляет только нужные подзадачи, но overhead стека и хеш-таблицы.

---

## Ключевые карточки

Какие два условия применимости DP?
?
1) Оптимальная подструктура: решение задачи через оптимальные решения подзадач. 2) Перекрывающиеся подзадачи: одни подзадачи решаются многократно. Без обоих условий DP не даёт преимущества.

Какие классические паттерны DP существуют?
?
1D Linear (Climbing Stairs, House Robber), Knapsack (0/1, unbounded), LCS/LIS (longest common/increasing subsequence), Grid DP (unique paths, min path sum), Interval DP (matrix chain), Tree DP, Bitmask DP (TSP).

Как определить состояние DP?
?
Состояние должно однозначно описывать подзадачу. Спроси: что нужно знать, чтобы решить оставшуюся часть задачи? Обычно это индекс + какой-то ресурс (вес, сумма, предыдущий выбор).

Что такое оптимизация по памяти в DP?
?
Если dp[i] зависит только от dp[i-1] (или нескольких предыдущих), можно хранить не всю таблицу, а только нужные строки/значения. Fibonacci: O(n) -> O(1). 2D Grid DP: O(n*m) -> O(m).

Чем DP отличается от Greedy?
?
DP рассматривает все подзадачи и гарантирует оптимальное решение. Greedy делает локально оптимальный выбор на каждом шаге без пересмотра. Greedy быстрее, но работает только для задач с greedy choice property (не всегда).

---

## Куда дальше

| Направление | Куда | Зачем |
|-------------|------|-------|
| Следующий шаг | [[algorithms/greedy-algorithms]] | Жадные алгоритмы как альтернатива DP |
| Углубиться | [[algorithms/dp-optimization]] | Оптимизации DP: CHT, divide and conquer |
| Смежная тема | [[patterns/dp-patterns]] | Паттерны DP для интервью |
| Обзор | [[cs-fundamentals-overview]] | Вернуться к карте раздела |

*Обновлено: 2026-01-06 (добавлены педагогические секции: интуиция, почему сложно, ментальные модели)*
