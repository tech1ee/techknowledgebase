---
title: "Паттерн битовых манипуляций (Bit Manipulation)"
created: 2025-12-29
modified: 2026-02-13
type: deep-dive
status: published
difficulty: intermediate
confidence: high
cs-foundations:
  - binary-representation
  - bitwise-operations
  - xor-properties
  - bitmask-subsets
  - twos-complement
prerequisites:
  - "[[big-o-complexity]]"
  - "[[arrays-strings]]"
tags:
  - topic/cs-fundamentals
  - type/deep-dive
  - level/intermediate
  - pattern
  - interview
related:
  - "[[dp-patterns]]"
reading_time: 53
difficulty: 5
study_status: not_started
mastery: 0
last_reviewed:
next_review:
---

# Bit Manipulation Pattern

## TL;DR

Bit Manipulation использует побитовые операции для эффективного решения задач. **Ключевые трюки: XOR для уникальных элементов, n & (n-1) для очистки младшего бита, bitmask для подмножеств**. Превращает O(n) операции в O(1). Оптимально для: поиска уникальных элементов, подсчёта битов, subset enumeration, compact state representation.

---

## Часть 1: Интуиция без кода

### Аналогия 1: Волшебный ластик (XOR)

Представь волшебный ластик, который работает по особому правилу:
- Если нарисовать что-то один раз — оно появится
- Если нарисовать то же самое ещё раз — оно исчезнет!

```
Доска в начале: [пусто]

Рисуем "кошку":       [кошка]
Рисуем "собаку":      [кошка, собака]
Рисуем "кошку":       [собака]       ← кошка исчезла!
Рисуем "собаку":      [пусто]        ← собака исчезла!

Это XOR! Любое число XOR само с собой = 0 (исчезает)
```

**Задача:** В классе все дети пришли парами, кроме одного. Как найти его?

```
Дети: [Петя, Маша, Коля, Маша, Петя]

Применяем волшебный ластик (XOR):
0 XOR Петя = Петя
Петя XOR Маша = ???
??? XOR Коля = ???
??? XOR Маша = ??? (Маша исчезла!)
??? XOR Петя = Коля (Петя исчез!)

Остался только Коля — он без пары!
```

---

### Аналогия 2: Кодовый замок с выключателями

```
Сейф с 8 выключателями (8 битов = 1 байт):

Позиция:  7  6  5  4  3  2  1  0
Замок:   [⬜][⬛][⬛][⬜][⬛][⬜][⬛][⬛]
          0   1   1   0   1   0   1   1   = 107

⬛ = включён (1)
⬜ = выключен (0)

Операции над замком:
```

**OR (|) — "Включить выключатель":**
```
Хотим включить выключатель #4:

Замок:    01101011
Маска:    00010000  (1 в позиции 4)
          --------
Результат: 01111011  (бит 4 теперь = 1)
```

**AND (&) — "Проверить выключатель":**
```
Хотим узнать, включён ли выключатель #3:

Замок:    01101011
Маска:    00001000  (1 в позиции 3)
          --------
Результат: 00001000  (не 0 = был включён!)
```

**XOR (^) — "Переключить":**
```
Хотим переключить выключатель #1:

Замок:    01101011
Маска:    00000010  (1 в позиции 1)
          --------
Результат: 01101001  (бит 1 изменился с 1 на 0)
```

---

### Аналогия 3: Степени двойки — "одиночки"

Степени двойки особенные — у них ровно один "включённый" бит:

```
1  = 00000001  (одна единица в позиции 0)
2  = 00000010  (одна единица в позиции 1)
4  = 00000100  (одна единица в позиции 2)
8  = 00001000  (одна единица в позиции 3)
16 = 00010000  (одна единица в позиции 4)
...

А вот НЕ степени двойки:
3  = 00000011  (две единицы)
6  = 00000110  (две единицы)
7  = 00000111  (три единицы)
```

**Как проверить степень двойки?**

Трюк `n & (n-1)`:

```
n = 8:     00001000
n-1 = 7:   00000111  (все биты после единицы стали 1)
           --------
n & (n-1): 00000000 = 0  ✓ Степень двойки!

n = 6:     00000110
n-1 = 5:   00000101
           --------
n & (n-1): 00000100 ≠ 0  ✗ Не степень двойки!
```

**Почему работает?** n-1 "ломает" младший бит и всё после него. AND обнуляет эти изменения. Если остался 0 — была только одна единица.

---

### Аналогия 4: Подмножества как контрольный список

```
Собираемся в поход. Есть 4 вещи: [фонарик, палатка, спички, вода]

Каждую вещь можно взять (1) или не взять (0).
Это создаёт 2^4 = 16 вариантов сборов:

Маска  Двоичное  Что берём
─────  ────────  ─────────────────────────
  0      0000    ничего
  1      0001    вода
  2      0010    спички
  3      0011    спички + вода
  4      0100    палатка
  5      0101    палатка + вода
  6      0110    палатка + спички
  7      0111    палатка + спички + вода
  8      1000    фонарик
  9      1001    фонарик + вода
 10      1010    фонарик + спички
 11      1011    фонарик + спички + вода
 12      1100    фонарик + палатка
 13      1101    фонарик + палатка + вода
 14      1110    фонарик + палатка + спички
 15      1111    всё!

Любое подмножество = число от 0 до 2^n - 1
```

---

### Численный пример: Single Number пошагово

```
Массив: [2, 3, 2, 4, 4]
Найти: элемент, который встречается один раз

Переводим в двоичный:
2 = 010
3 = 011
2 = 010
4 = 100
4 = 100

XOR всех элементов:

Шаг 1: 000 XOR 010 = 010
Шаг 2: 010 XOR 011 = 001
Шаг 3: 001 XOR 010 = 011  (ещё одна 2 — пара обнулилась частично)
Шаг 4: 011 XOR 100 = 111
Шаг 5: 111 XOR 100 = 011  (пара четвёрок обнулилась)

Результат: 011 = 3 ✓

Почему работает:
- 2 XOR 2 = 0 (пары обнуляются)
- 4 XOR 4 = 0 (пары обнуляются)
- 3 XOR 0 = 3 (уникальный остаётся)
```

---

### Как считать единицы: трюк Кернигана

```
n = 13 = 1101 (три единицы)

Итерация 1:
  n:     1101
  n-1:   1100
  n & (n-1): 1100  ← убрали младшую 1
  count = 1

Итерация 2:
  n:     1100
  n-1:   1011
  n & (n-1): 1000  ← убрали следующую 1
  count = 2

Итерация 3:
  n:     1000
  n-1:   0111
  n & (n-1): 0000  ← убрали последнюю 1
  count = 3

n = 0, выходим. Ответ: 3 единицы

Сложность: O(k), где k — количество единиц, а не O(32)!
```

---

## Часть 2: Почему это сложно

### Типичные ошибки студентов

#### Ошибка 1: Приоритет операторов

```kotlin
// ❌ НЕПРАВИЛЬНО — & имеет МЕНЬШИЙ приоритет чем ==
if (n & 1 == 0)  // Парсится как: n & (1 == 0) = n & false = 0

// В Java/Kotlin это даст ошибку компиляции
// В C/C++ это тихо неправильно работает!

// ✅ ПРАВИЛЬНО — всегда ставь скобки
if ((n and 1) == 0)

СИМПТОМ: Условие всегда false или всегда true
РЕШЕНИЕ: ВСЕГДА оборачивай битовые операции в скобки
```

#### Ошибка 2: Знаковый vs беззнаковый сдвиг

```kotlin
// Для положительных чисел — одинаково
val a = 8 shr 1   // = 4
val b = 8 ushr 1  // = 4

// Для ОТРИЦАТЕЛЬНЫХ — критично разные!
val n = -8  // = 11111111111111111111111111111000 (32 бита)

n shr 1   // = -4 (11111111111111111111111111111100)
          // Знаковый сдвиг: копирует старший бит (1)

n ushr 1  // = 2147483644 (01111111111111111111111111111100)
          // Беззнаковый сдвиг: вставляет 0

СИМПТОМ: Неожиданные значения при работе с отрицательными числами
РЕШЕНИЕ: Используй ushr когда нужен беззнаковый сдвиг
```

#### Ошибка 3: Переполнение при сдвиге

```kotlin
// ❌ НЕПРАВИЛЬНО — 1 это Int, сдвиг на 32 даёт 1 (не 2^32!)
val mask = 1 shl 32  // = 1 (переполнение!)
// В Java/Kotlin: 1 << 32 эквивалентно 1 << (32 % 32) = 1 << 0 = 1

// ✅ ПРАВИЛЬНО — используй Long
val mask = 1L shl 32  // = 4294967296

// Или для больших масок:
val fullMask = (1 shl n) - 1  // Все n битов = 1
// Но если n = 32, получится -1 (все биты Int = 1), что может быть OK

СИМПТОМ: Маска неожиданно маленькая
РЕШЕНИЕ: Используй 1L для Long или проверяй границы
```

#### Ошибка 4: Забыли проверить n > 0 для степени двойки

```kotlin
// ❌ НЕПРАВИЛЬНО
fun isPowerOfTwo(n: Int) = (n and (n - 1)) == 0
// 0 & (-1) = 0 & 0xFFFFFFFF = 0, но 0 — НЕ степень двойки!

// ✅ ПРАВИЛЬНО
fun isPowerOfTwo(n: Int) = n > 0 && (n and (n - 1)) == 0

СИМПТОМ: isPowerOfTwo(0) возвращает true
РЕШЕНИЕ: Всегда добавляй проверку n > 0
```

#### Ошибка 5: Инициализация XOR внутри цикла

```kotlin
// ❌ НЕПРАВИЛЬНО — result сбрасывается каждую итерацию!
for (num in nums) {
    var result = 0  // Внутри цикла!
    result = result xor num
}
// result недоступен снаружи и всегда = последнему числу

// ✅ ПРАВИЛЬНО
var result = 0  // Снаружи цикла!
for (num in nums) {
    result = result xor num
}

СИМПТОМ: XOR не "накапливает" результат
РЕШЕНИЕ: Инициализируй переменную ДО цикла
```

#### Ошибка 6: Путаница с позициями битов

```kotlin
// Биты нумеруются СПРАВА НАЛЕВО, начиная с 0:
// Число 13 = 1101
//            ^^^^
//            3210  ← позиции

// ❌ НЕПРАВИЛЬНО — путаница с направлением
val num = 13  // 1101
val bit3 = (num shr 3) and 1  // = 1 (бит в позиции 3, слева)
// Не путай "3-й бит слева" и "бит в позиции 3"!

// ✅ ПРАВИЛЬНО — понимай что позиция 0 = СПРАВА
// 1101 = 8 + 4 + 0 + 1 = 13
//        ^   ^       ^
//        3   2       0  (позиции где биты = 1)

fun getBit(n: Int, pos: Int) = (n shr pos) and 1
// getBit(13, 0) = 1  (младший бит)
// getBit(13, 1) = 0
// getBit(13, 2) = 1
// getBit(13, 3) = 1  (старший из установленных)

СИМПТОМ: Получаешь не тот бит, который ожидал
РЕШЕНИЕ: Помни: позиция 0 = LSB (справа), позиция растёт влево
```

---

## Часть 3: Ментальные модели

### Модель 1: "Биты как выключатели"

```
Число — это панель с выключателями

Число 13 = 1101:

   [ON] [ON] [OFF] [ON]
    8    4    2     1
   ───────────────────
         = 13

AND (&): оба выключателя должны быть ON → ON
OR (|):  хотя бы один ON → ON
XOR (^): ровно один ON → ON (иначе OFF)
NOT (~): переключить все

Это помогает визуализировать:
- Маска 0100 "выбирает" только 3-й выключатель
- n | mask "включает" биты из маски
- n & mask "проверяет" биты из маски
```

### Модель 2: "XOR как отмена"

```
XOR = "умный переключатель"

Свойства:
- A ^ A = 0  (любое число отменяет само себя)
- A ^ 0 = A  (ноль ничего не меняет)
- Порядок не важен (коммутативно и ассоциативно)

Применение к массиву [1, 2, 1, 3, 2]:
1 ^ 2 ^ 1 ^ 3 ^ 2
= (1 ^ 1) ^ (2 ^ 2) ^ 3  ← группируем пары
= 0 ^ 0 ^ 3
= 3

Пары "отменяются", остаётся уникальный!
```

### Модель 3: "n & (n-1) убивает младшего"

```
Визуализация трюка:

n = 12:    1100
n-1 = 11:  1011   ← младший бит 1 "распался" в цепочку единиц
           ----
AND:       1000   ← младший бит исчез!

Почему n-1 так работает:
- Вычитание 1 "занимает" единицу из младшего установленного бита
- Этот бит становится 0
- Все биты правее него становятся 1
- AND очищает все эти изменённые биты

Применения:
- isPowerOfTwo: если осталось 0, была одна единица
- countBits: повторяем пока не станет 0
- Fenwick Tree: навигация по дереву
```

### Модель 4: "Маска как трафарет"

```
Маска — это трафарет для работы с битами

      ┌─────────────────────────┐
      │  Исходное число: 1011   │
      │  Маска:          0110   │
      └─────────────────────────┘

AND с маской — "вырезает" биты под трафаретом:
1011 & 0110 = 0010 (только биты 1 и 2)

OR с маской — "закрашивает" биты под трафаретом:
1011 | 0110 = 1111 (биты 1 и 2 теперь точно 1)

XOR с маской — "переключает" биты под трафаретом:
1011 ^ 0110 = 1101 (биты 1 и 2 переключились)

Популярные маски:
- 0001 (1 << 0) — младший бит
- 1111 ((1 << 4) - 1) — младшие 4 бита
- 0100 (1 << 2) — конкретный бит
```

### Модель 5: "Подмножества как двоичный счётчик"

```
Множество из n элементов → 2^n подмножеств → числа от 0 до 2^n-1

Элементы: {A, B, C} (n=3)

Счёт от 0 до 7 автоматически даёт все подмножества:

0 = 000 → { }
1 = 001 → { C }
2 = 010 → { B }
3 = 011 → { B, C }
4 = 100 → { A }
5 = 101 → { A, C }
6 = 110 → { A, B }
7 = 111 → { A, B, C }

Проверка: i-й элемент в подмножестве?
→ (mask >> i) & 1 == 1

for mask in 0..<(1 << n):
    for i in 0..<n:
        if (mask >> i) & 1:
            добавить элемент[i]
```

---

## Зачем это нужно?

**Реальная проблема:**

Найти единственный уникальный элемент в массиве из 1 миллиона чисел, где все остальные встречаются дважды. Наивный подход с HashMap: O(n) времени, O(n) памяти. XOR: O(n) времени, O(1) памяти!

**Где используется:**

| Область | Применение | Пример |
|---------|------------|--------|
| Криптография | XOR cipher | Шифрование |
| Сети | IP masking | CIDR расчёты |
| Графика | Pixel manipulation | Alpha blending |
| Embedded | Hardware flags | Register manipulation |
| Games | State compression | Chess positions |
| Компиляторы | Optimization | Strength reduction |

**Статистика:**
- 5-10% задач на интервью используют bit manipulation
- Single Number — одна из самых популярных Easy задач
- Bitmask DP — продвинутая техника для NP задач

---

## Prerequisites (Что нужно знать)

| Тема | Зачем нужно | Где изучить |
|------|-------------|-------------|
| **Двоичная система** | Биты — основа всех операций | Основы CS |
| **Побитовые операции** | AND, OR, XOR, NOT, shifts | Основы программирования |
| **Big O нотация** | O(1) vs O(n) для bit tricks | [[big-o-complexity]] |
| **CS: Two's Complement** | Представление отрицательных чисел | Компьютерная арифметика |
| **CS: XOR Properties** | a^a=0, a^0=a, коммутативность | Булева алгебра |

---

## Что это такое?

### Объяснение для 5-летнего

Представь выключатели света. Каждый может быть ON (1) или OFF (0).

```
Комната с 4 лампами:
[ON, OFF, ON, ON] = 1011 в двоичном = 11 в десятичном

Включить лампу #1 (вторую справа):
1011 | 0010 = 1011 (уже была включена)

Выключить лампу #0 (крайнюю справа):
1011 & 1110 = 1010

Переключить лампу #2:
1011 ^ 0100 = 1111
```

### Формальное определение

**Bit Manipulation** — техника работы с данными на уровне отдельных битов с помощью побитовых операций.

**Базовые операции:**

```
AND (&):  1 & 1 = 1, иначе 0    — оба бита = 1
OR  (|):  0 | 0 = 0, иначе 1    — хотя бы один = 1
XOR (^):  разные = 1, одинаковые = 0
NOT (~):  инверсия всех битов
<< :      сдвиг влево (умножение на 2)
>> :      сдвиг вправо (деление на 2)
```

**Ключевые свойства XOR:**
```
a ^ 0 = a        (нейтральный элемент)
a ^ a = 0        (самообращение)
a ^ b ^ a = b    (отмена)
a ^ b = b ^ a    (коммутативность)
```

---

## Терминология

| Термин | Определение | Пример |
|--------|-------------|--------|
| **LSB** | Least Significant Bit (младший) | В 1010 это 0 |
| **MSB** | Most Significant Bit (старший) | В 1010 это 1 |
| **Set bit** | Бит = 1 | В 1010: биты 1 и 3 |
| **Clear bit** | Бит = 0 | В 1010: биты 0 и 2 |
| **Bitmask** | Число для выбора определённых битов | 0011 выбирает биты 0,1 |
| **Popcount** | Количество единичных битов | popcount(1010) = 2 |
| **Two's complement** | Представление отрицательных чисел | -x = ~x + 1 |

---

## Как это работает?

### Essential Bit Tricks

```
1. Проверить чётность:
   n & 1 == 0  →  чётное
   n & 1 == 1  →  нечётное

2. Проверить степень двойки:
   n > 0 && (n & (n-1)) == 0
   Работает: степени 2 имеют ровно 1 бит

3. Получить младший установленный бит:
   n & (-n)
   Пример: 1010 & 0110 = 0010

4. Очистить младший установленный бит:
   n & (n-1)
   Пример: 1010 & 1001 = 1000

5. Подсчитать биты (Brian Kernighan):
   count = 0
   while n > 0:
       n = n & (n-1)
       count++

6. XOR всех элементов для поиска уникального:
   result = 0
   for x in arr: result ^= x
```

**Визуализация n & (n-1):**

```
n = 12 = 1100
n-1 = 11 = 1011
n & (n-1) = 1000 = 8

1100
1011 &
----
1000

Младший бит (0100) очистился!
```

### Single Number Pattern

```
Массив: [4, 1, 2, 1, 2]
Найти: единственный элемент, который встречается один раз

XOR всех элементов:
4 ^ 1 ^ 2 ^ 1 ^ 2
= 4 ^ (1 ^ 1) ^ (2 ^ 2)
= 4 ^ 0 ^ 0
= 4

Работает, потому что:
- x ^ x = 0 (пары обнуляются)
- x ^ 0 = x (уникальный остаётся)
```

### Single Number III (два уникальных)

```
Массив: [1, 2, 1, 3, 2, 5]
Найти: два уникальных элемента (3 и 5)

Шаг 1: XOR всех
1^2^1^3^2^5 = 3^5 = 011^101 = 110 = 6

Шаг 2: Найти различающийся бит
diff = 6, младший бит = 6 & (-6) = 010 = 2

Шаг 3: Разделить на две группы по этому биту
Группа с битом 1: [2, 3, 2] → XOR = 3
Группа с битом 0: [1, 1, 5] → XOR = 5

Ответ: [3, 5]
```

### Bitmask для подмножеств

```
Множество: {a, b, c}
Все подмножества через bitmask (0 до 2^3-1):

mask = 000 → {}
mask = 001 → {c}
mask = 010 → {b}
mask = 011 → {b, c}
mask = 100 → {a}
mask = 101 → {a, c}
mask = 110 → {a, b}
mask = 111 → {a, b, c}

Проверка: элемент i в подмножестве?
(mask >> i) & 1 == 1
```

---

## Сложность операций

| Операция | Time | Space | Примечание |
|----------|------|-------|------------|
| Basic bit op | O(1) | O(1) | AND, OR, XOR, NOT, shifts |
| Popcount | O(log n) или O(1) | O(1) | Hardware instruction |
| Single Number | O(n) | O(1) | XOR всех |
| All subsets | O(2^n) | O(1) | Bitmask iteration |
| Bitmask DP | O(2^n × n) | O(2^n) | Subset DP |

---

## Реализация

### Essential Bit Operations (Kotlin)

```kotlin
object BitOps {
    /**
     * Проверка чётности через последний бит
     *
     * МАТЕМАТИКА:
     * - В двоичной системе чётные числа заканчиваются на 0
     * - Нечётные числа заканчиваются на 1
     * - n AND 1 извлекает последний бит
     *
     * ПОШАГОВЫЙ ПРИМЕР (n = 6):
     * 6 в двоичном:  110
     * 1 в двоичном:  001
     * 6 AND 1 =      000 = 0 → чётное ✓
     *
     * ПОШАГОВЫЙ ПРИМЕР (n = 7):
     * 7 в двоичном:  111
     * 1 в двоичном:  001
     * 7 AND 1 =      001 = 1 → нечётное ✓
     */
    fun isEven(n: Int): Boolean = n and 1 == 0

    /**
     * Проверка степени двойки через n & (n-1)
     *
     * КЛЮЧЕВАЯ ИДЕЯ:
     * - Степени 2 имеют ровно один бит = 1: 1, 2, 4, 8... = 1, 10, 100, 1000...
     * - n-1 инвертирует все биты от младшего 1 до конца
     * - n & (n-1) очищает этот единственный бит
     *
     * ПОШАГОВЫЙ ПРИМЕР (n = 8, степень 2):
     * 8 в двоичном:     1000
     * 7 в двоичном:     0111
     * 8 AND 7 =         0000 = 0 ✓ степень 2
     *
     * ПОШАГОВЫЙ ПРИМЕР (n = 6, не степень 2):
     * 6 в двоичном:     0110
     * 5 в двоичном:     0101
     * 6 AND 5 =         0100 = 4 ≠ 0 ✗ не степень 2
     *
     * n > 0 нужно, потому что 0 не является степенью 2
     */
    fun isPowerOfTwo(n: Int): Boolean = n > 0 && (n and (n - 1)) == 0

    /**
     * Изоляция младшего установленного бита через n & -n
     *
     * МАТЕМАТИКА TWO'S COMPLEMENT:
     * - -n = ~n + 1 (инвертируем все биты и прибавляем 1)
     * - При инверсии и +1 все биты до младшей 1 становятся 0
     * - Сама младшая 1 остаётся 1, остальные инвертируются
     * - AND сохраняет только эту одну 1
     *
     * ПОШАГОВЫЙ ПРИМЕР (n = 12):
     *  12 в двоичном: 01100
     * ~12:            10011
     * ~12 + 1 = -12:  10100
     * 12 AND (-12):   00100 = 4 (младший установленный бит)
     *
     * ПРИМЕНЕНИЕ:
     * - Fenwick Tree использует это для навигации
     * - Быстрое нахождение LSB (Least Significant Bit)
     */
    fun lowestSetBit(n: Int): Int = n and -n

    /**
     * Очистка младшего установленного бита через n & (n-1)
     *
     * МЕХАНИЗМ:
     * n-1 "занимает" единицу из младшего установленного бита
     * - Младший бит становится 0
     * - Все биты правее него становятся 1
     * - AND с n оставляет только биты левее
     *
     * ПОШАГОВЫЙ ПРИМЕР (n = 12):
     * 12 в двоичном: 1100
     * 11 в двоичном: 1011
     * 12 AND 11 =    1000 = 8 (очистили бит в позиции 2)
     *
     * Этот трюк — основа алгоритма Брайана Кернигана
     */
    fun clearLowestSetBit(n: Int): Int = n and (n - 1)

    /**
     * Подсчёт единичных битов — алгоритм Брайана Кернигана
     *
     * ИДЕЯ:
     * - n & (n-1) очищает ровно один бит за итерацию
     * - Количество итераций = количество единиц
     * - Сложность O(k), где k — число единиц, не O(32)!
     *
     * ПОШАГОВЫЙ ПРИМЕР (n = 11, двоичное 1011):
     * Итерация 1: 1011 & 1010 = 1010, count = 1
     * Итерация 2: 1010 & 1001 = 1000, count = 2
     * Итерация 3: 1000 & 0111 = 0000, count = 3
     * Результат: 3 единицы
     *
     * АЛЬТЕРНАТИВА: Integer.bitCount(n) использует hardware popcount
     */
    fun countSetBits(n: Int): Int {
        var count = 0
        var num = n
        while (num != 0) {
            num = num and (num - 1)
            count++
        }
        return count
    }

    /**
     * Получение бита в позиции pos
     *
     * МЕХАНИЗМ:
     * 1. n shr pos — сдвигаем нужный бит в позицию 0
     * 2. AND 1 — изолируем этот бит
     *
     * ПОШАГОВЫЙ ПРИМЕР (n = 13, pos = 2):
     * 13 в двоичном: 1101
     * 13 shr 2:      0011
     * 0011 AND 0001: 0001 = 1 (бит в позиции 2 = 1)
     */
    fun getBit(n: Int, pos: Int): Int = (n shr pos) and 1

    fun setBit(n: Int, pos: Int): Int = n or (1 shl pos)

    fun clearBit(n: Int, pos: Int): Int = n and (1 shl pos).inv()

    fun toggleBit(n: Int, pos: Int): Int = n xor (1 shl pos)
}
```

### Single Number (Kotlin)

```kotlin
/**
 * Найти единственный уникальный элемент (остальные встречаются по 2 раза)
 *
 * СВОЙСТВА XOR, которые делают это возможным:
 * 1. a XOR a = 0 — любое число XOR с собой даёт 0
 * 2. a XOR 0 = a — XOR с нулём не меняет число
 * 3. Коммутативность: a XOR b = b XOR a
 * 4. Ассоциативность: (a XOR b) XOR c = a XOR (b XOR c)
 *
 * ПОШАГОВЫЙ ПРИМЕР (nums = [4, 1, 2, 1, 2]):
 * result = 0
 * result XOR 4 = 4
 * result XOR 1 = 4 XOR 1 = 5
 * result XOR 2 = 5 XOR 2 = 7
 * result XOR 1 = 7 XOR 1 = 6  (единица "отменилась")
 * result XOR 2 = 6 XOR 2 = 4  (двойка "отменилась")
 *
 * Результат: 4 — уникальный элемент
 *
 * ПОЧЕМУ РАБОТАЕТ:
 * - Пары элементов XOR'ят друг друга в 0
 * - Уникальный элемент XOR'ится с 0 и остаётся
 * - Порядок не важен благодаря коммутативности
 */
fun singleNumber(nums: IntArray): Int {
    var result = 0
    for (num in nums) {
        result = result xor num
    }
    return result
}
```

### Single Number II — каждый элемент 3 раза, один 1 раз (Kotlin)

```kotlin
/**
 * Найти уникальный элемент, когда остальные встречаются по 3 раза
 *
 * ИДЕЯ: Конечный автомат для подсчёта битов по модулю 3
 *
 * СОСТОЯНИЯ для каждого бита:
 * - (ones=0, twos=0) → бит встретился 0 раз (mod 3)
 * - (ones=1, twos=0) → бит встретился 1 раз (mod 3)
 * - (ones=0, twos=1) → бит встретился 2 раза (mod 3)
 * - После 3 раз → возвращаемся в (0,0)
 *
 * ПЕРЕХОДЫ:
 * Если приходит бит 1:
 * (0,0) → (1,0) → (0,1) → (0,0) → ...
 *
 * ФОРМУЛЫ:
 * ones = (ones XOR num) AND (NOT twos)
 *   → XOR добавляет/убирает бит
 *   → AND NOT twos: не добавляем в ones, если уже в twos
 *
 * twos = (twos XOR num) AND (NOT ones)
 *   → Аналогично, но для twos
 *   → AND NOT ones: не добавляем в twos, если уже в (новых) ones
 *
 * ПОШАГОВЫЙ ПРИМЕР (nums = [2, 2, 3, 2]):
 * 2 = 10, 3 = 11
 *
 * Начало: ones=00, twos=00
 *
 * num=2 (10):
 *   ones = (00 XOR 10) AND NOT(00) = 10 AND 11 = 10
 *   twos = (00 XOR 10) AND NOT(10) = 10 AND 01 = 00
 *   → ones=10, twos=00 (бит 1 встретился 1 раз)
 *
 * num=2 (10):
 *   ones = (10 XOR 10) AND NOT(00) = 00 AND 11 = 00
 *   twos = (00 XOR 10) AND NOT(00) = 10 AND 11 = 10
 *   → ones=00, twos=10 (бит 1 встретился 2 раза)
 *
 * num=3 (11):
 *   ones = (00 XOR 11) AND NOT(10) = 11 AND 01 = 01
 *   twos = (10 XOR 11) AND NOT(01) = 01 AND 10 = 00
 *   → ones=01, twos=00
 *
 * num=2 (10):
 *   ones = (01 XOR 10) AND NOT(00) = 11 AND 11 = 11
 *   twos = (00 XOR 10) AND NOT(11) = 10 AND 00 = 00
 *   → ones=11? Нет, пересчитаем...
 *   Упс, нужно пересчитать. На самом деле бит 1 от двойки
 *   встретился 3 раза → сбросился. Бит 0 от тройки = 1 раз.
 *
 * Результат: ones = 3 (уникальный элемент)
 */
fun singleNumber2(nums: IntArray): Int {
    // ones: биты, встретившиеся 1 mod 3 раз
    // twos: биты, встретившиеся 2 mod 3 раз
    var ones = 0
    var twos = 0

    for (num in nums) {
        // Добавляем num к ones, но только если его нет в twos
        ones = (ones xor num) and twos.inv()
        // Добавляем num к twos, но только если его нет в (новых) ones
        twos = (twos xor num) and ones.inv()
    }

    // После обработки: троичные элементы обнулились,
    // уникальный остался в ones
    return ones
}
```

### Single Number III — два уникальных элемента (Kotlin)

```kotlin
/**
 * Найти ДВА уникальных элемента (остальные встречаются по 2 раза)
 *
 * ИДЕЯ: Разделить массив на две группы, в каждой один уникальный
 *
 * АЛГОРИТМ:
 * 1. XOR всех чисел даёт a XOR b (пары обнуляются)
 * 2. Поскольку a ≠ b, в a XOR b есть хотя бы один бит = 1
 * 3. Этот бит различает a и b (в одном = 1, в другом = 0)
 * 4. Разделяем все числа по этому биту на 2 группы
 * 5. В каждой группе применяем обычный Single Number
 *
 * ПОШАГОВЫЙ ПРИМЕР (nums = [1, 2, 1, 3, 2, 5]):
 * Уникальные: 3 и 5
 *
 * Шаг 1: XOR всех = 1^2^1^3^2^5 = 3^5 = 011^101 = 110 = 6
 *
 * Шаг 2: Найти различающийся бит
 * diffBit = 6 & -6 = 110 & 010 = 010 = 2 (бит в позиции 1)
 *
 * Шаг 3: Разделить по этому биту
 * - Бит 1 = 1: [2, 3, 2] → 2^3^2 = 3 ✓
 * - Бит 1 = 0: [1, 1, 5] → 1^1^5 = 5 ✓
 *
 * ПОЧЕМУ ЭТО РАБОТАЕТ:
 * - Каждая пара (например, обе 2) попадёт в одну группу
 * - a и b гарантированно в разных группах (бит различается)
 * - В каждой группе пары обнуляются, остаётся уникальный
 */
fun singleNumber3(nums: IntArray): IntArray {
    // Шаг 1: XOR всех даёт a XOR b
    var xorResult = 0
    for (num in nums) {
        xorResult = xorResult xor num
    }

    // Шаг 2: Находим любой различающийся бит между a и b
    // Младший установленный бит — самый простой способ
    val diffBit = xorResult and -xorResult

    // Шаг 3: Разделяем числа на две группы по этому биту
    var group1 = 0  // Группа с битом = 1
    var group2 = 0  // Группа с битом = 0
    for (num in nums) {
        if (num and diffBit != 0) {
            group1 = group1 xor num
        } else {
            group2 = group2 xor num
        }
    }

    // В каждой группе пары обнулились, остался уникальный
    return intArrayOf(group1, group2)
}
```

### Subsets via Bitmask (Kotlin)

```kotlin
/**
 * Генерация всех подмножеств через битовые маски
 *
 * КЛЮЧЕВАЯ ИДЕЯ:
 * - Для n элементов есть 2^n подмножеств
 * - Каждое подмножество кодируется числом от 0 до 2^n-1
 * - Бит i = 1 означает "i-й элемент включён"
 * - Бит i = 0 означает "i-й элемент не включён"
 *
 * ПОШАГОВЫЙ ПРИМЕР (nums = [a, b, c], n = 3):
 *
 * mask = 0 (000): {} — пустое множество
 * mask = 1 (001): {a} — только элемент 0
 * mask = 2 (010): {b} — только элемент 1
 * mask = 3 (011): {a, b} — элементы 0 и 1
 * mask = 4 (100): {c} — только элемент 2
 * mask = 5 (101): {a, c} — элементы 0 и 2
 * mask = 6 (110): {b, c} — элементы 1 и 2
 * mask = 7 (111): {a, b, c} — все элементы
 *
 * ПРОВЕРКА БИТА:
 * (mask shr i) and 1 == 1
 * → Сдвигаем маску вправо на i позиций
 * → Проверяем младший бит
 *
 * СЛОЖНОСТЬ: O(n × 2^n) — перебираем 2^n масок, для каждой n битов
 */
fun subsets(nums: IntArray): List<List<Int>> {
    val n = nums.size
    val result = mutableListOf<List<Int>>()

    // Перебираем все маски от 0 до 2^n - 1
    for (mask in 0 until (1 shl n)) {
        val subset = mutableListOf<Int>()

        for (i in 0 until n) {
            // Если i-й бит установлен, включаем i-й элемент
            if ((mask shr i) and 1 == 1) {
                subset.add(nums[i])
            }
        }

        result.add(subset)
    }

    return result
}
```

### Counting Bits DP (Java)

```java
/**
 * Подсчёт единичных битов для всех чисел от 0 до n
 *
 * РЕКУРРЕНТНОЕ СООТНОШЕНИЕ:
 * dp[i] = dp[i >> 1] + (i & 1)
 *
 * ПОЧЕМУ ЭТО РАБОТАЕТ:
 * - i >> 1 — это число без последнего бита
 * - i & 1 — это последний бит (0 или 1)
 * - Количество единиц в i = единицы в (i без последнего бита) + последний бит
 *
 * ПОШАГОВЫЙ ПРИМЕР (n = 5):
 *
 * i=0: dp[0] = 0 (база, ноль единиц)
 * i=1: dp[1] = dp[0] + 1 = 0 + 1 = 1     (1 = 1)
 * i=2: dp[2] = dp[1] + 0 = 1 + 0 = 1     (10 = 1)
 * i=3: dp[3] = dp[1] + 1 = 1 + 1 = 2     (11 = 2)
 * i=4: dp[4] = dp[2] + 0 = 1 + 0 = 1     (100 = 1)
 * i=5: dp[5] = dp[2] + 1 = 1 + 1 = 2     (101 = 2)
 *
 * Результат: [0, 1, 1, 2, 1, 2]
 *
 * ВИЗУАЛИЗАЦИЯ СВЯЗЕЙ:
 *        0 (0)
 *       / \
 *     1(1) 2(1)
 *     / \   \
 *   3(2) 5(2) 4(1)
 *
 * Каждое число ссылается на число в 2 раза меньше (i >> 1)
 *
 * СЛОЖНОСТЬ: O(n) время, O(n) память
 */
public int[] countBits(int n) {
    int[] dp = new int[n + 1];

    for (int i = 1; i <= n; i++) {
        // dp[i >> 1] — количество единиц без последнего бита
        // (i & 1) — добавляем 1, если последний бит = 1
        dp[i] = dp[i >> 1] + (i & 1);
    }

    return dp;
}
```

### Reverse Bits (Python)

```python
"""
Разворот битов 32-битного числа

ИДЕЯ:
Берём биты справа налево из n и добавляем их слева направо в result

МЕХАНИЗМ КАЖДОЙ ИТЕРАЦИИ:
1. result << 1 — освобождаем место справа
2. n & 1 — извлекаем младший бит n
3. result | (n & 1) — добавляем бит в result
4. n >>= 1 — переходим к следующему биту n

ПОШАГОВЫЙ ПРИМЕР (n = 13, упрощённо 4 бита для наглядности):
n = 1101 (13), хотим получить 1011 (11)

Итерация 1: result = (0 << 1) | (1101 & 1) = 0 | 1 = 1
            n = 1101 >> 1 = 110
Итерация 2: result = (1 << 1) | (110 & 1) = 10 | 0 = 10
            n = 110 >> 1 = 11
Итерация 3: result = (10 << 1) | (11 & 1) = 100 | 1 = 101
            n = 11 >> 1 = 1
Итерация 4: result = (101 << 1) | (1 & 1) = 1010 | 1 = 1011
            n = 1 >> 1 = 0

Результат: 1011 (11) — биты развёрнуты!

СЛОЖНОСТЬ: O(32) = O(1), так как всегда 32 итерации
"""
def reverseBits(n: int) -> int:
    result = 0
    for _ in range(32):
        # Сдвигаем result влево и добавляем младший бит n
        result = (result << 1) | (n & 1)
        # Сдвигаем n вправо для следующего бита
        n >>= 1
    return result
```

### Bitmask DP — Traveling Salesman (Kotlin)

```kotlin
/**
 * Задача коммивояжёра (Traveling Salesman Problem) через Bitmask DP
 *
 * ЗАДАЧА:
 * Посетить все n городов ровно по одному разу и вернуться в начало
 * с минимальной суммарной стоимостью переходов.
 *
 * ИДЕЯ BITMASK DP:
 * - Состояние: (какие города посетили, где находимся)
 * - Маска кодирует множество посещённых городов
 * - dp[mask][i] = минимальная стоимость посетить города в mask,
 *                 закончив в городе i
 *
 * ПОШАГОВЫЙ ПРИМЕР (4 города, граф на картинке):
 *
 *     10      15
 *   0 ─── 1 ─── 2
 *   │    / \    │
 *  25  20   35  30
 *   │ /     \ │
 *   3 ──────── 2
 *       30
 *
 * База: dp[0001][0] = 0 (начинаем в городе 0, стоимость 0)
 *
 * Переходы:
 * - Из dp[0001][0]=0: можем пойти в 1,2,3
 *   dp[0011][1] = 0 + dist[0][1] = 10
 *   dp[0101][2] = 0 + dist[0][2] = ...
 *   dp[1001][3] = 0 + dist[0][3] = 25
 *
 * - Продолжаем, пока не заполним dp[1111][*]
 *
 * Ответ: min(dp[1111][i] + dist[i][0]) для всех i ≠ 0
 *
 * СЛОЖНОСТЬ:
 * - Время: O(2^n × n²) — 2^n масок, n последних городов, n переходов
 * - Память: O(2^n × n)
 * - Работает для n ≤ 20
 */
fun tsp(dist: Array<IntArray>): Int {
    val n = dist.size
    // dp[mask][i] = минимальная стоимость посетить города в mask, закончив в i
    val dp = Array(1 shl n) { IntArray(n) { Int.MAX_VALUE / 2 } }

    // База: начинаем из города 0, посетили только его
    // mask = 1 = 0001 означает "посетили город 0"
    dp[1][0] = 0

    for (mask in 1 until (1 shl n)) {
        for (last in 0 until n) {
            // last должен быть в mask (мы там закончили)
            // Проверка: бит last в маске = 1
            if ((mask shr last) and 1 == 0) continue
            if (dp[mask][last] == Int.MAX_VALUE / 2) continue

            for (next in 0 until n) {
                // next НЕ должен быть в mask (ещё не посещён)
                // Проверка: бит next в маске = 0
                if ((mask shr next) and 1 == 1) continue

                // Добавляем next к маске и обновляем dp
                val newMask = mask or (1 shl next)
                dp[newMask][next] = minOf(
                    dp[newMask][next],
                    dp[mask][last] + dist[last][next]
                )
            }
        }
    }

    // Финал: посетили все города (fullMask = 1111...1)
    // Нужно вернуться в город 0
    val fullMask = (1 shl n) - 1
    var result = Int.MAX_VALUE
    for (last in 1 until n) {
        result = minOf(result, dp[fullMask][last] + dist[last][0])
    }
    return result
}
```

---

## Распространённые ошибки

### 1. Приоритет операторов

```kotlin
// ❌ НЕПРАВИЛЬНО: & имеет меньший приоритет чем ==
if (n & 1 == 0)  // парсится как n & (1 == 0) = n & false

// ✅ ПРАВИЛЬНО: явные скобки
if ((n and 1) == 0)
```

### 2. Знаковый сдвиг vs беззнаковый

```kotlin
// ❌ НЕПРАВИЛЬНО для отрицательных чисел
val n = -8
n shr 1  // = -4 (знаковый сдвиг, сохраняет знак)

// ✅ ПРАВИЛЬНО для беззнакового поведения
n ushr 1  // = 2147483644 (беззнаковый сдвиг)
```

### 3. Overflow при сдвиге

```kotlin
// ❌ НЕПРАВИЛЬНО: 1 << 32 = 1 (overflow для Int!)
val mask = 1 shl 32

// ✅ ПРАВИЛЬНО: используем Long
val mask = 1L shl 32
```

### 4. Забыть про отрицательные числа

```kotlin
// ❌ НЕПРАВИЛЬНО: не работает для отрицательных
fun isPowerOfTwo(n: Int) = (n and (n - 1)) == 0  // 0 тоже пройдёт!

// ✅ ПРАВИЛЬНО: проверяем n > 0
fun isPowerOfTwo(n: Int) = n > 0 && (n and (n - 1)) == 0
```

### 5. XOR с самим собой в цикле

```kotlin
// ❌ НЕПРАВИЛЬНО: инициализация в цикле
for (num in nums) {
    var result = 0  // каждую итерацию сбрасывается!
    result = result xor num
}

// ✅ ПРАВИЛЬНО: инициализация до цикла
var result = 0
for (num in nums) {
    result = result xor num
}
```

---

## Когда использовать

### Decision Tree

```
Задача подходит для bit manipulation?
│
├─ Поиск уникального элемента?
│   └─ XOR pattern (Single Number)
│
├─ Подсчёт битов / степень двойки?
│   └─ n & (n-1), popcount
│
├─ Перебор подмножеств (n ≤ 20)?
│   └─ Bitmask enumeration
│
├─ Compact state (n ≤ 20-30)?
│   └─ Bitmask DP
│
├─ Математические трюки?
│   └─ XOR, shifts для умножения/деления
│
└─ Hardware-level операции?
    └─ Flags, masks, registers
```

### Сравнение подходов

| Задача | Bit Manipulation | Alternative |
|--------|------------------|-------------|
| Single Number | O(n), O(1) space | HashMap O(n), O(n) |
| Is Power of 2 | O(1) | Loop O(log n) |
| Count Bits | O(k) where k = bits | O(log n) loop |
| All Subsets | O(2^n) bitmask | Backtracking O(2^n) |
| TSP | O(n² × 2^n) | Brute force O(n!) |

---

## Практика

### Концептуальные вопросы

1. **Почему n & (n-1) очищает младший бит?**
   - n-1 меняет младший бит на 0 и все биты правее на 1
   - AND с n обнуляет эти изменённые биты
   - Пример: 1010 & 1001 = 1000

2. **Почему -n = ~n + 1?**
   - Two's complement representation
   - ~n инвертирует все биты
   - +1 даёт отрицательное значение

3. **Когда bitmask DP лучше backtracking?**
   - Когда нужна мемоизация состояний подмножеств
   - Когда есть overlapping subproblems
   - Ограничение: n ≤ 20-25 (2^n помещается в память)

### LeetCode задачи

| # | Название | Сложность | Паттерн | Ключевая идея |
|---|----------|-----------|---------|---------------|
| 136 | Single Number | Easy | XOR all | a^a=0 |
| 137 | Single Number II | Medium | Bit counting | mod 3 |
| 260 | Single Number III | Medium | XOR + split | diff bit |
| 191 | Number of 1 Bits | Easy | n & (n-1) | Brian Kernighan |
| 231 | Power of Two | Easy | n & (n-1) == 0 | Single bit |
| 338 | Counting Bits | Easy | DP + bits | dp[i>>1] + (i&1) |
| 78 | Subsets | Medium | Bitmask | 2^n enumeration |
| 1284 | Minimum Flips | Hard | Bitmask DP | State compression |

### Порядок изучения

```
1. 191. Number of 1 Bits (Easy) — базовый popcount
2. 231. Power of Two (Easy) — n & (n-1)
3. 136. Single Number (Easy) — XOR basics
4. 338. Counting Bits (Easy) — bit DP
5. 78. Subsets (Medium) — bitmask enumeration
6. 260. Single Number III (Medium) — advanced XOR
7. 137. Single Number II (Medium) — bit counting mod k
```

---

## Связанные темы

### Prerequisites (изучить до)
- **Binary Numbers** — понимание двоичной системы
- **Bitwise Operations** — AND, OR, XOR, NOT, shifts
- **Two's Complement** — представление отрицательных чисел

### Unlocks (откроет путь к)
- **Bitmask DP** — TSP, Hamiltonian path
- **Bloom Filters** — probabilistic data structures
- **Bit-parallel algorithms** — SIMD оптимизации

---

## Мифы и заблуждения

| Миф | Реальность |
|-----|-----------|
| "Bit manipulation — только для low-level" | **Используется везде!** XOR для unique elements, bitmask для subsets, bit flags для permissions. Интервью-классика |
| "XOR сложно понять" | **Три правила:** a^a=0, a^0=a, XOR коммутативен и ассоциативен. Этого достаточно для большинства задач |
| "n & (n-1) — magic trick" | **Простая логика!** n-1 переворачивает все биты после rightmost 1. AND очищает именно этот бит. Визуализируй! |
| "Bitmask только для малых n" | **До n=20-25!** 2^20 ≈ 10^6 операций — приемлемо. 2^30 ≈ 10^9 — TLE. Это ограничение NP задач |
| "Сдвиги медленнее умножения" | **Наоборот!** << и >> компилируются в одну инструкцию CPU. Часто быстрее * и / для степеней 2 |
| "XOR всех элементов всегда полезен" | **Только при дубликатах!** XOR находит unique element когда все остальные парные. Для k-дубликатов нужны другие техники |
| "Bit manipulation не нужен в реальной работе" | **Нужен!** Feature flags, permission systems, compact state storage, low-level оптимизации, криптография |
| "Negative numbers ломают bit tricks" | **Two's complement предсказуем!** Но нужно понимать как работает. ~n = -n-1, arithmetic vs logical shift важно |

---

## CS-фундамент

| CS-концепция | Применение в Bit Manipulation |
|--------------|-------------------------------|
| **XOR Properties** | a^a=0 (самоинверсия), a^0=a (нейтральный элемент), коммутативность. Основа Single Number паттерна |
| **n & (n-1)** | Очищает rightmost set bit. Используется для: popcount (подсчёт единиц), power of 2 check, bit counting |
| **Bitmask Enumeration** | Перебор всех подмножеств: for mask in range(1<<n). Каждый бит = включён/исключён элемент |
| **Two's Complement** | Отрицательное число = ~n + 1. Позволяет выделить rightmost set bit: n & (-n) |
| **Bit Shifting** | << : умножение на 2, >> : деление на 2. Быстрее arithmetic операций для степеней 2 |
| **Bit Counting (Popcount)** | while(n) { count++; n &= n-1; } — O(k) где k = число единиц. Или встроенный __builtin_popcount() |

---

## Источники

| # | Источник | Тип | Вклад |
|---|----------|-----|-------|
| 1 | [GeeksforGeeks](https://www.geeksforgeeks.org/dsa/bits-manipulation-important-tactics/) | Tutorial | Bit tricks |
| 2 | [InterviewBit](https://www.interviewbit.com/courses/programming/bit-manipulation/) | Course | XOR patterns |
| 3 | [AlgoCademy](https://algocademy.com/blog/approaching-bit-manipulation-problems-a-comprehensive-guide-for-coding-interviews/) | Guide | Interview prep |
| 4 | [LeetCode Discuss](https://leetcode.com/discuss/post/3695233/all-types-of-patterns-for-bits-manipulat-qezp/) | Patterns | Classification |

---

## Куда дальше

→ **Advanced:** [[dp-patterns]] — Bitmask DP для NP задач
→ **Связанно:** Bloom Filters — probabilistic data structures
→ **Вернуться к:** [[patterns-overview|Обзор паттернов]]


---

## Проверь себя

> [!question]- Почему XOR идеален для поиска уникального элемента среди пар, и как расширить на два уникальных?
> XOR свойства: a^a=0, a^0=a, коммутативность. XOR всех элементов: пары обнуляются, остаётся уникальный. Для двух уникальных (x,y): XOR всех = x^y != 0. Находим бит, где x и y различаются (rightmost set bit). Разделяем числа по этому биту на две группы, XOR каждой = x или y.

> [!question]- Как n & (n-1) очищает младший установленный бит и где это применяется?
> n-1 инвертирует все биты от младшего set bit до конца. AND с n очищает этот бит. Пример: 12 (1100) & 11 (1011) = 8 (1000). Применение: 1) Power of Two: n & (n-1) == 0. 2) Count Set Bits: цикл n = n & (n-1), count++. 3) Brian Kernighan's algorithm. O(number of set bits).

> [!question]- Задача: даны все числа от 0 до n кроме одного. Как найти пропущенное за O(n) время и O(1) память?
> Два подхода: 1) XOR: XOR всех чисел 0..n XOR всех элементов массива = пропущенное (пары обнуляются). 2) Сумма: n*(n+1)/2 - sum(array). XOR безопаснее (нет overflow). Оба O(n) время, O(1) память. Cyclic Sort тоже работает, но модифицирует массив.

## Ключевые карточки

Какие основные битовые операции?
?
AND (&): оба 1 -> 1. OR (|): хотя бы один 1 -> 1. XOR (^): разные -> 1, одинаковые -> 0. NOT (~): инверсия. Left shift (<<): умножение на 2. Right shift (>>): деление на 2. Маски: 1<<k = бит на позиции k.

Как проверить/установить/очистить/инвертировать k-й бит?
?
Проверить: (n >> k) & 1. Установить: n | (1 << k). Очистить: n & ~(1 << k). Инвертировать: n ^ (1 << k). Все O(1). Нумерация: бит 0 = младший.

Что такое Bitmask DP?
?
Состояние DP включает bitmask — подмножество элементов. dp[mask] = ответ для подмножества, представленного mask. Переход: перебор подмножеств mask. Пример: TSP dp[mask][i] = мин. путь через города в mask, заканчивающийся в i. O(2^n * n).

Какие XOR трюки наиболее полезны?
?
a^a = 0 (обнуление). a^0 = a (идентичность). XOR коммутативен и ассоциативен. swap без temp: a^=b; b^=a; a^=b. Find unique: XOR всех элементов. XOR 0..n = паттерн по n%4: n,1,n+1,0.

Как перебрать все подмножества множества mask?
?
Цикл: submask = mask; while submask > 0: submask = (submask - 1) & mask. Это перебирает все подмножества в убывающем порядке. Для всех подмножеств всех масок: O(3^n) суммарно. Применение: Bitmask DP с разбиением на подмножества.

## Куда дальше

| Тип | Ссылка | Зачем |
|-----|--------|-------|
| Следующий шаг | [[patterns/meet-in-the-middle]] | Meet in the Middle для больших N |
| Углубиться | [[algorithms/number-theory]] | Теория чисел для бит-трюков |
| Смежная тема | [[patterns/dp-patterns]] | Bitmask DP |
| Обзор | [[patterns/patterns-overview]] | Вернуться к карте паттернов |


---

*Обновлено: 2026-01-08 — добавлены педагогические секции (интуиция битов: ластик/замок/подмножества, 6 типичных ошибок, 5 ментальных моделей)*
